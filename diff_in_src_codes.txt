Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/cable: cable_land
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/cable: interface
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/cable/shared: cable_fields_mod.F90
diff -r vn7.0copy1_c4/src/./control/cable/shared/cable_surface_types_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/cable/shared/cable_surface_types_mod.F90
0a1,11
> !******************************COPYRIGHT********************************************
> ! (c) CSIRO 2022.
> ! All rights reserved.
> !
> ! This routine has been licensed to the other JULES partners for use and
> ! distribution under the JULES collaboration agreement, subject to the terms and
> ! conditions set out therein.
> !
> ! [Met Office Ref SC0237]
> !******************************COPYRIGHT********************************************
> 
7a19,28
> ! This MODULE is USEd by:
> !      surf_couple_radiation_mod.F90,
> !      init_surface_types.F90
> !
> ! This MODULE contains public Subroutines:
> !      check_cable_surface_types,
> !      print_nlist_cable_surface_types,
> !      read_nml_cable_surface_types,
> !      set_derived_variables_cable_surface_types
> !
9a31,34
> !
> ! Code Description:
> !   Language: Fortran 90.
> !   This code is written to JULES coding standards v1.
89a115,117
> ! Description:
> !   Checks CABLE_SURFACE_TYPES namelist for consistency
> 
94,101d121
< !-----------------------------------------------------------------------------
< ! Description:
< !   Checks CABLE_SURFACE_TYPES namelist for consistency
< !
< ! Code Owner: Please refer to ModuleLeaders.txt
< ! This file belongs in CABLE SCIENCE
< !-----------------------------------------------------------------------------
< 
171a192,194
> ! Description:
> !   Nicely prints the namelist content to log file
> 
246,248d268
< ! Description:
< !  Read the CABLE_SURFACE_TYPES namelist
< 
255a276,278
> ! Description:
> !  Read the CABLE_SURFACE_TYPES namelist
> 
369a393,395
> ! Description:
> !   Derive ntype_cable and nnpft_cable from the namelist values
> 
372,374d397
< !-----------------------------------------------------------------------------
< ! Derive ntype_cable and nnpft_cable from the namelist values
< !-----------------------------------------------------------------------------
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/cable/shared: LAI_canopy_height_cbl.F90
diff -r vn7.0copy1_c4/src/./control/cable/shared/params_io_cbl.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/cable/shared/params_io_cbl.F90
0a1,10
> !******************************COPYRIGHT********************************************
> ! (c) CSIRO 2022.
> ! All rights reserved.
> !
> ! This routine has been licensed to the other JULES partners for use and
> ! distribution under the JULES collaboration agreement, subject to the terms and
> ! conditions set out therein.
> !
> ! [Met Office Ref SC0237]
> !******************************COPYRIGHT********************************************
2a13,37
> !-----------------------------------------------------------------------------
> ! Description:
> !   Defines variable types and variables for veg and soil parameters.
> !   We only define the pointer associations relevant to TYPES to be parssed
> !   around (following JULES params*_io). The allocation is unecessary as these
> !   input parameters are read in from namelist (following JULES params *_io),
> !   these are initialized in corresponding section
> !   Based on cable_def_types_mod.F90 from the CABLE trunk.
> !
> ! This MODULE is USEd by:
> !      cable_fields_mod.F90,
> !      init_vegin_cbl.inc
> !
> ! This MODULE contains 2 public Subroutines:
> !      params_io_assoc_cbl,
> !      params_io_nullify_cbl
> !
> ! Code Owner: Please refer to ModuleLeaders.txt
> ! This file belongs in CABLE SCIENCE
> !
> ! Code Description:
> !   Language: Fortran 90.
> !   This code is written to JULES coding standards v1.
> !-----------------------------------------------------------------------------
> 
12a48
> PUBLIC :: params_io_assoc_cbl
17,25d52
< !-----------------------------------------------------------------------------
< ! Description:
< !   Defines variable types and variables for CABLE standalone runs.
< !   Based on cable_def_types_mod.F90 from the CABLE trunk.
< !
< ! Code Owner: Please refer to ModuleLeaders.txt
< ! This file belongs in CABLE SCIENCE
< !-----------------------------------------------------------------------------
< 
154,156d180
< !Allocation unecessary as these input parameters are read in from namelist
< !(following JULES params *_io) these are initialized in corresponding section
< !Here we include the pointer association relevant to TYPES to be passed around
160c184,187
< !No USE statements other than Dr Hook
---
> ! Description:
> !   Associate veg. and soil parameters pointer types
> 
>   !No USE statements other than Dr Hook
242a270,272
> 
> ! Description:
> !   Nullify veg. and soil parameters pointer types
diff -r vn7.0copy1_c4/src/./control/cable/shared/progs_cbl_vars_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/cable/shared/progs_cbl_vars_mod.F90
0a1,10
> !******************************COPYRIGHT********************************************
> ! (c) CSIRO 2022.
> ! All rights reserved.
> !
> ! This routine has been licensed to the other JULES partners for use and
> ! distribution under the JULES collaboration agreement, subject to the terms and
> ! conditions set out therein.
> !
> ! [Met Office Ref SC0237]
> !******************************COPYRIGHT********************************************
5d14
< !
7a17,31
> ! This MODULE is USEd by:
> !      cable_fields_mod.F90,
> !      surf_couple_explicit_mod.F90,
> !      surf_couple_implicit_mod.F90,
> !      surf_couple_radiation_mod.F90,
> !      control.F90,
> !      init_cable_progs.F90,
> !      init.F90
> !
> ! This MODULE contains 4 public Subroutines:
> !      progs_cbl_vars_alloc,
> !      progs_cbl_vars_dealloc,
> !      progs_cbl_vars_assoc,
> !      progs_cbl_vars_nullify
> !
9a34,37
> !
> ! Code Description:
> !   Language: Fortran 90.
> !   This code is written to JULES coding standards v1.
60a89,91
> ! Description:
> !   Allocate the CABLE prognostic data variables in the derived type structure
> 
219a251,253
> ! Description:
> !   Deallocate the CABLE prognostic data variables in the derived type structure
> 
262a297,299
> ! Description:
> !   Associate the CABLE prognostic pointers in the derived type structure
> 
307a345,347
> 
> ! Description:
> !   Nullify the CABLE prognostic pointers in the derived type structure
diff -r vn7.0copy1_c4/src/./control/cable/shared/work_vars_mod_cbl.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/cable/shared/work_vars_mod_cbl.F90
0a1,10
> !******************************COPYRIGHT********************************************
> ! (c) CSIRO 2022.
> ! All rights reserved.
> !
> ! This routine has been licensed to the other JULES partners for use and
> ! distribution under the JULES collaboration agreement, subject to the terms and
> ! conditions set out therein.
> !
> ! [Met Office Ref SC0237]
> !******************************COPYRIGHT********************************************
5d14
< !
7,9c16,33
< !   These are vars req'd to be kept across the surf_couple* pathways
< !   and/or timesteps. Some will be elevated to rognostics, others will be
< !   removed via rewriting of the algorithm where req'd
---
> !   These are vars reqested to be kept across the surf_couple* pathways
> !   and/or timesteps. Some will be elevated to prognostics, others will be
> !   removed via rewriting of the algorithm where requested
> !
> ! This MODULE is USEd by:
> !      cable_fields_mod.F90,
> !      surf_couple_explicit_mod.F90,
> !      surf_couple_extra_mod.F90,
> !      surf_couple_implicit_mod.F90,
> !      control.F90,
> !      init_cable_working_vars.F90,
> !      init.F90
> !
> ! This MODULE contains 4 public Subroutines:
> !      alloc_work_vars_cbl,
> !      dealloc_work_vars_cbl,
> !      assoc_work_vars_cbl,
> !      nullify_assoc_work_vars_cbl
12a37,40
> !
> ! Code Description:
> !   Language: Fortran 90.
> !   This code is written to JULES coding standards v1.
54a83,85
> ! Description:
> !   Allocate the CABLE work data variables in the derived type structure
> 
145a177,179
> ! Description:
> !   Deallocate the CABLE work data variables in the derived type structure
> 
181a216,218
> ! Description:
> !   Associate the CABLE work pointers in the derived type structure
> 
215a253,255
> 
> ! Description:
> !   Nullify the CABLE work pointers in the derived type structure
Only in vn7.0copy1_c4/src/./control/cable: standalone
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/cable: util
Only in vn7.0copy1_c4/src/./control/imogen: cellarea_calc_mod.F90
diff -r vn7.0copy1_c4/src/./control/imogen/clim_calc.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/imogen/clim_calc.F90
12,15c12
< SUBROUTINE clim_calc(                                                          &
<   land_pts,wgen,mm,md,tmin_wg,tmax_wg,                                         &
<   swdown_wg,rh1p5m_wg,precip_wg,nsdmax,                                        &
<   seed_rain,lat,lon, imgn_drive, ainfo)
---
> SUBROUTINE clim_calc(land_pts, mm, md, nsdmax, seed_rain, imgn_drive, ainfo)
43c40
<            ! Number of days in (GCM) month
---
>            ! Number of days in month (in this case 30 expected)
51,53d47
< LOGICAL, INTENT(IN) ::                                                         &
<   wgen     ! Is the weather generator switched on.
< 
55d48
< 
58,76d50
< REAL, INTENT(IN) ::                                                            &
<   lat(land_pts),                                                               &
<            ! Latitudinal position of l
<   lon(land_pts)
<            ! Longitudinal position of
< 
< ! Output from the weather generator when called
< REAL, INTENT(IN OUT) ::                                                        &
<   precip_wg(land_pts,mm,md),                                                   &
<            ! Daily precipitation (mm/day)
<   tmin_wg(land_pts,mm,md),                                                     &
<            ! Daily minimum temperature (K)
<   tmax_wg(land_pts,mm,md),                                                     &
<            ! Daily maximum temperature (K)
<   swdown_wg(land_pts,mm,md),                                                   &
<            ! Daily shortwave radiation (W/m2)
<   rh1p5m_wg(land_pts,mm,md)
<            ! Daily relative humidity (%)
< 
79c53
<   t1p5m_subdaily(land_pts,nsdmax),                                             &
---
>   tl1_subdaily(land_pts,nsdmax),                                               &
87c61
<   q1p5m_subdaily(land_pts,nsdmax),                                             &
---
>   ql1_subdaily(land_pts,nsdmax),                                               &
100c74
<   t1p5m_daily(land_pts,mm,md),                                                 &
---
>   tl1_daily(land_pts,mm,md),                                                   &
104,107d77
<   uwind_daily(land_pts,mm,md),                                                 &
<            ! Calculated "u"-wind  (m/s)
<   vwind_daily(land_pts,mm,md),                                                 &
<            ! Calculated "v"-wind  (m/s)
110c80
<   diurnal_t1p5m_daily(land_pts,mm,md),                                         &
---
>   diurnal_tl1_daily(land_pts,mm,md),                                           &
118,119c88,89
<   rh1p5m_daily(land_pts,mm,md)
<            ! Calculated relative humidity (%)
---
>   ql1_daily(land_pts,mm,md)
>            ! Calculated specific humidity (kg/kg)
128,141d97
< ! Variables required to split rainfall up so that it rains roughly
< ! the correct no. of days/month when weather generator is switched off.
< !    INTEGER ::                                                    &
< !      NO_RAINDAY,                                                 &
<                ! WORK No. of rainy days in the month.
< !      INT_RAINDAY
<                ! WORK Rain day interval.
< !      IC_RAINDAY
<                ! WORK No. of rain days counter.
< !    REAL ::                                                       &
< !      TOT_RAIN ! WORK Total rain counter.
< !---------------------------------------------------------------------
< 
< 
143c99
< ! Anomalies will be zero, if anom=.false. and anlg=.false.
---
> ! Anomalies will be zero, if anom=.false.
152,206c108,118
<       IF (wgen) THEN
<         ! Temperature (K)
<         t1p5m_daily(l,im,id) = ( 0.5 * (tmin_wg(l,im,id) + tmax_wg(l,im,id)) ) &
<                           + imgn_drive%t1p5m_ij_anom(i,j,im)
<         diurnal_t1p5m_daily(l,im,id) = ( tmax_wg(l,im,id) - tmin_wg(l,im,id) ) &
<                            + imgn_drive%diurnal_t1p5m_ij_anom(i,j,im)
< 
<         ! Shortwave radiation (W/m2)
<         swdown_daily(l,im,id) = swdown_wg(l,im,id) +                           &
<                                imgn_drive%swdown_ij_anom(i,j,im)
< 
<         ! Relative humidity (kg/kg)
<         rh1p5m_daily(l,im,id) = rh1p5m_wg(l,im,id) +                           &
<                                imgn_drive%rh1p5m_ij_anom(i,j,im)
< 
<         ! Precip
<         precip_daily(l,im,id) = precip_wg(l,im,id) +                           &
<                                imgn_drive%precip_ij_anom(i,j,im)
<       ELSE
<         t1p5m_daily(l,im,id) = imgn_drive%t1p5m_ij_clim(i,j,im) +              &
<                                imgn_drive%t1p5m_ij_anom(i,j,im)
<         swdown_daily(l,im,id) = imgn_drive%swdown_ij_clim(i,j,im) +            &
<                                imgn_drive%swdown_ij_anom(i,j,im)
<         rh1p5m_daily(l,im,id) = imgn_drive%rh1p5m_ij_clim(i,j,im) +            &
<                                imgn_drive%rh1p5m_ij_anom(i,j,im)
<         diurnal_t1p5m_daily(l,im,id) =                                         &
<                                imgn_drive%diurnal_t1p5m_ij_clim(i,j,im) +      &
<                                imgn_drive%diurnal_t1p5m_ij_anom(i,j,im)
<         precip_daily(l,im,id) = imgn_drive%precip_ij_clim(i,j,im) +            &
<                                imgn_drive%precip_ij_anom(i,j,im)
< 
<         !CH-EDITTED OUT LINES BELOW BUT WILL BE RE_IMPLEMENTED WITH DOCUMENTATIO
<         ! To correct the no. of rain days per month if WGEN is off:
<         !                 IF (K == 1)THEN
<         !                    NO_RAINDAY=NINT(F_WET_CLIM(L,J)*MD)
<         !                    IF (NO_RAINDAY <  1)NO_RAINDAY=1
<         !                    IF (NO_RAINDAY >  MD)NO_RAINDAY=MD
<         !                    INT_RAINDAY=INT(FLOAT(MD)/FLOAT(NO_RAINDAY))
<         !                    IF (INT_RAINDAY >  MD)INT_RAINDAY=MD
<         !                    IC_RAINDAY=0
<         !                    TOT_RAIN=0.0
<         !                 END IF
<         !
<         !                 IF (MOD(K,INT_RAINDAY) == 0
<         !    &                 .AND.IC_RAINDAY <  NO_RAINDAY)THEN
<         !                    PRECIP_DAILY(L,J,K) = (RAINFALL_CLIM(L,J)+
<         !    &                 SNOWFALL_CLIM(L,J)+PRECIP_ANOM(L,J))
<         !    &                    *FLOAT(MD)/FLOAT(NO_RAINDAY)
<         !                    IC_RAINDAY=IC_RAINDAY+1
<         !                 ELSE
<         !                    PRECIP_DAILY(L,J,K) = 0.0
<         !                 END IF
<         !                 TOT_RAIN=TOT_RAIN+PRECIP_DAILY(L,J,K)
<         !CH-END OF EDITTING OUT
<       END IF
---
>       tl1_daily(l,im,id) = imgn_drive%tl1_ij_clim(i,j,im) +                    &
>                               imgn_drive%tl1_ij_anom(i,j,im)
>       swdown_daily(l,im,id) = imgn_drive%swdown_ij_clim(i,j,im) +              &
>                               imgn_drive%swdown_ij_anom(i,j,im)
>       ql1_daily(l,im,id) = imgn_drive%ql1_ij_clim(i,j,im) +                    &
>                            imgn_drive%ql1_ij_anom(i,j,im)
>       diurnal_tl1_daily(l,im,id) =                                             &
>                               imgn_drive%diurnal_tl1_ij_clim(i,j,im) +         &
>                               imgn_drive%diurnal_tl1_ij_anom(i,j,im)
>       precip_daily(l,im,id) = imgn_drive%precip_ij_clim(i,j,im) +              &
>                               imgn_drive%precip_ij_anom(i,j,im)
209c121,122
<       ! Convert input files to kg/m2/s when read in from netcdf in next ticket
---
>       ! Convert input precipitation from kg/m2/s to kg/m2/day
>       precip_daily(l,im,id) = precip_daily(l,im,id) * 86400
212,220d124
<       ! Pressure (Pa)
<       ! currently converts from hPa to Pa - will read in Pa in the future
<       pstar_daily(l,im,id) =                                                   &
<                100.0 * ( imgn_drive%pstar_ij_clim(i,j,im) +                    &
<                imgn_drive%pstar_ij_anom(i,j,im) )
< 
<       ! Check on humidity bounds
<       rh1p5m_daily(l,im,id) = MIN(rh1p5m_daily(l,im,id), 100.0)
<       rh1p5m_daily(l,im,id) = MAX(rh1p5m_daily(l,im,id), 0.0)
223c127,132
<       diurnal_t1p5m_daily(l,im,id) = MAX(diurnal_t1p5m_daily(l,im,id), 0.0)
---
>       swdown_daily(l,im,id) = MAX(swdown_daily(l,im,id), 0.0)
>       diurnal_tl1_daily(l,im,id) = MAX(diurnal_tl1_daily(l,im,id), 0.0)
> 
>       ! Pressure (Pa)
>       pstar_daily(l,im,id) = imgn_drive%pstar_ij_clim(i,j,im) +                &
>                                        imgn_drive%pstar_ij_anom(i,j,im)
230,235c139,140
<       uwind_daily(l,im,id) = imgn_drive%uwind_ij_clim(i,j,im) +                &
<                                       imgn_drive%uwind_ij_anom(i,j,im)
<       vwind_daily(l,im,id) = imgn_drive%vwind_ij_clim(i,j,im) +                &
<                                       imgn_drive%vwind_ij_anom(i,j,im)
<       wind_daily(l,im,id)  = SQRT(                                             &
<                     (uwind_daily(l,im,id)**2) + (vwind_daily(l,im,id)**2) )
---
>       wind_daily(l,im,id) = imgn_drive%wind_ij_clim(i,j,im) +                  &
>                                       imgn_drive%wind_ij_anom(i,j,im)
244,245c149,150
< ! Variables going in (with units) are SWdown (W/m2), Precip (mm/day), t1p5m
< ! (K), diurnal_t1p5m (K), LWdown (W/m2), pstar(Pa), Wind (m/2) and rh1p5m (%)
---
> ! Variables going in (with units) are SWdown (W/m2), Precip (mm/day), tl1
> ! (K), diurnal_tl1 (K), LWdown (W/m2), pstar(Pa), Wind (m/2) and ql1 (kg/kg)
248c153
< ! for diurnal_t1p5m (which no longer has meaning), and the temperature dependent
---
> ! for diurnal_tl1 (which no longer has meaning), and the temperature dependent
257,259c162,164
<       t1p5m_daily(:,im,id),diurnal_t1p5m_daily(:,im,id),lwdown_daily(:,im,id), &
<       pstar_daily(:,im,id),wind_daily(:,im,id),rh1p5m_daily(:,im,id),          &
<       swdown_subdaily,t1p5m_subdaily,lwdown_subdaily,                          &
---
>       tl1_daily(:,im,id),diurnal_tl1_daily(:,im,id),lwdown_daily(:,im,id),     &
>       pstar_daily(:,im,id),wind_daily(:,im,id),ql1_daily(:,im,id),             &
>       swdown_subdaily,tl1_subdaily,lwdown_subdaily,                            &
262c167
<       q1p5m_subdaily,im,id,lat,lon,nsdmax,seed_rain)
---
>       ql1_subdaily,im,id,nsdmax,seed_rain)
273,274c178,179
<         imgn_drive%t1p5m_ij_drive(i,j,im,id,istep) =                           &
<                                  t1p5m_subdaily(l,istep)
---
>         imgn_drive%tl1_ij_drive(i,j,im,id,istep) =                             &
>                                  tl1_subdaily(l,istep)
288,289c193,194
<         imgn_drive%q1p5m_ij_drive(i,j,im,id,istep) =                           &
<                                  q1p5m_subdaily(l,istep)
---
>         imgn_drive%ql1_ij_drive(i,j,im,id,istep) =                             &
>                                  ql1_subdaily(l,istep)
294c199
<         imgn_drive%t1p5m_ij_drive(i,j,im,id,istep)     = rmdi
---
>         imgn_drive%tl1_ij_drive(i,j,im,id,istep)       = rmdi
302c207
<         imgn_drive%q1p5m_ij_drive(i,j,im,id,istep)     = rmdi
---
>         imgn_drive%ql1_ij_drive(i,j,im,id,istep)       = rmdi
diff -r vn7.0copy1_c4/src/./control/imogen/day_calc.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/imogen/day_calc.F90
12,17c12,16
<   land_pts,swdown_daily,precip_daily,t1p5m_daily,diurnal_t1p5m_daily,          &
<   lwdown_daily, pstar_daily,wind_daily,rh1p5m_daily,swdown_subdaily,           &
<   t1p5m_subdaily, lwdown_subdaily,conv_rain_subdaily,ls_rain_subdaily,         &
<   ls_snow_subdaily, pstar_subdaily,wind_subdaily,q1p5m_subdaily,               &
<   imonth,iday, lat,lon,nsdmax,seed_rain                                        &
< )
---
>   land_pts, swdown_daily, precip_daily, tl1_daily, diurnal_tl1_daily,          &
>   lwdown_daily, pstar_daily, wind_daily, ql1_daily, swdown_subdaily,           &
>   tl1_subdaily, lwdown_subdaily, conv_rain_subdaily, ls_rain_subdaily,         &
>   ls_snow_subdaily, pstar_subdaily, wind_subdaily, ql1_subdaily,               &
>   imonth, iday, nsdmax, seed_rain)
20c19,20
< USE update_mod, ONLY: dur_ls_rain,dur_conv_rain,dur_ls_snow
---
> USE update_mod, ONLY: dur_ls_rain, dur_conv_rain, dur_ls_snow
> ! ejb these above are fixed in init_drive and not read in
23a24,29
> USE model_grid_mod, ONLY: latitude, longitude
> USE theta_field_sizes, ONLY: t_i_length, t_j_length
> USE jules_fields_mod, ONLY: ainfo
> ! USE update_mod, ONLY: t_for_snow, t_for_con_rain
> ! ejb add trap in imogen nml to ensure they are read
> ! not activated in #1322 because metadata is a nightmare
64c70
<   t1p5m_daily(land_pts),                                                       &
---
>   tl1_daily(land_pts),                                                         &
66c72
<   diurnal_t1p5m_daily(land_pts),                                               &
---
>   diurnal_tl1_daily(land_pts),                                                 &
74,75c80,81
<   rh1p5m_daily(land_pts)
<           ! Relative humidity (%)
---
>   ql1_daily(land_pts)
>           ! Daily values of specific humidity (kg/kg)
79,80c85,86
< ! periods. NOTE: diurnal_t1p5m_subdaily does not exist as t1p5m_subdaily
< ! combines t1p5m_daily and diurnal_t1p5m_daily
---
> ! periods. NOTE: diurnal_tl1_subdaily does not exist as tl1_subdaily
> ! combines tl1_daily and diurnal_tl1_daily
86c92
<   t1p5m_subdaily(land_pts,nsdmax),                                             &
---
>   tl1_subdaily(land_pts,nsdmax),                                               &
94,95c100,101
<   q1p5m_subdaily(land_pts,nsdmax),                                             &
<           ! Sub_daily humidity calculated from rh1p5m (kg/kg)
---
>   ql1_subdaily(land_pts,nsdmax),                                               &
>           ! Sub_daily humidity calculated from rhl1 (kg/kg)
103,108d108
< REAL, INTENT(IN) ::                                                            &
<   lat(land_pts),                                                               &
<           ! Latitude (degrees)
<   lon(land_pts)
<           ! Longitude (degrees)
< 
121,122c121,126
<   qs_subdaily(land_pts)
<           ! Saturated humidity deficit from t1p5m_subdaily and pstar_subdaily
---
>   rhl1_daily(land_pts),                                                        &
>           ! Relative humidity (%)
>   qs_subdaily(land_pts),                                                       &
>           ! Saturated humidity from tl1_subdaily and pstar_subdaily
>   qs_daily(land_pts)
>           ! Saturated humidity from tl1_daily and pstar_daily
148,149c152,153
< PARAMETER(temp_conv = 293.15) !ejb these need sorting in next ticket
< PARAMETER(temp_snow = 275.15) !ejb these need sorting in next ticket
---
> PARAMETER(temp_conv = 293.15) ! these need sorting in next ticket
> PARAMETER(temp_snow = 275.15) ! these need sorting in next ticket
173,175d176
<   max_precip_rate,                                                             &
<           ! Maximum precip. rate allowed within  each sub-daily timestep
<           ! (mm/day). Only applies when timesteps_in_day >= 2
177,178c178
<           !WORK Length of period (hr)
< 
---
>           ! Length of period (hr)
185a186,188
> REAL, PARAMETER :: max_precip_rate = 350.0
>           ! Maximum precip. rate allowed within  each sub-daily timestep
>           ! (mm/day). Only applies when timesteps_in_day >= 2
187d189
< PARAMETER(max_precip_rate = 350.0)
220,222c222,236
<   CALL sunny(                                                                  &
<     daynumber,timesteps_in_day,land_pts,current_time%year,lat,lon,             &
<     sun,time_max)
---
>   CALL sunny(daynumber, timesteps_in_day, t_i_length * t_j_length,             &
>                     current_time%year,                                         &
>                     RESHAPE(latitude(:,:),  [ t_i_length * t_j_length ]),      &
>                     RESHAPE(longitude(:,:), [ t_i_length * t_j_length ]),      &
>                     sun, time_max)
> 
>   !-----------------------------------------------------------------------
>   ! derive daily relative humidity and check it is between 0 and 100 %
>   !-----------------------------------------------------------------------
>   CALL qsat(qs_daily, tl1_daily, pstar_daily, land_pts)
>   rhl1_daily = ql1_daily / qs_daily * 100.0
>   DO l = 1,land_pts
>     rhl1_daily(l) = MIN(rhl1_daily(l), 100.0)
>     rhl1_daily(l) = MAX(rhl1_daily(l), 0.0)
>   END DO
235,236c249,250
<       t1p5m_subdaily(l,istep) = t1p5m_daily(l) + 0.5 * diurnal_t1p5m_daily(l) *&
<                     COS(2.0 * pi * (time_day - rsec_per_hour * time_max(l))    &
---
>       tl1_subdaily(l,istep) = tl1_daily(l) + 0.5 * diurnal_tl1_daily(l) *      &
>               COS(2.0 * pi * (time_day - rsec_per_hour * time_max(l))          &
239c253
<                      * (4.0 * t1p5m_subdaily(l,istep) / t1p5m_daily(l) - 3.0)
---
>                      * (4.0 * tl1_subdaily(l,istep) / tl1_daily(l) - 3.0)
253,254c267,268
<     ! Check that humidity value is not greater than qsat (but otherwise, q1p5m
<     ! is not split up into diurnal behaviour).
---
>     ! Get subdaily humidity from daily relative humidity and subdaily
>     ! saturated specific humidity
256c270
<     CALL qsat(qs_subdaily, t1p5m_subdaily(:,istep),                            &
---
>     CALL qsat(qs_subdaily, tl1_subdaily(:,istep),                              &
260c274,275
<       q1p5m_subdaily(l,istep) = 0.01 * rh1p5m_daily(l) * qs_subdaily(l)
---
>       ! same rhl1_daily all day
>       ql1_subdaily(l,istep) = 0.01 * rhl1_daily(l) * qs_subdaily(l)
279c294
<     ! mean daily temperature, t1p5m_daily. The cutoffs are:
---
>     ! mean daily temperature, tl1_daily. The cutoffs are:
281,283c296,299
<     ! Convective scale rain (duration conv_rain_dur): t1p5m_daily > 20.0oC
<     ! Large scale rain (duration ls_rain_dur) : 20.0oC > t1p5m_daily > 2oC
<     ! Large scale snow (duration ls_snow_dur) : t1p5m_daily < 2oC
---
>     ! Convective scale rain (duration conv_rain_dur): tl1_daily > t_for_con_rain
>     ! Large scale rain (duration ls_rain_dur) :
>     !                             t_for_snow > tl1_daily > t_for_con_rain
>     ! Large scale snow (duration ls_snow_dur) : tl1_daily < t_for_snow
302c318
<     IF (t1p5m_daily(l) >= temp_conv) THEN
---
>     IF (tl1_daily(l) >= temp_conv) THEN
344c360,361
<     ELSE IF (t1p5m_daily(l) < temp_conv .AND. t1p5m_daily(l) >= temp_snow) THEN
---
>     ELSE IF (tl1_daily(l) < temp_conv .AND. tl1_daily(l) >= temp_snow)         &
>                                                                           THEN
428,430d444
<   CALL qsat(qs_subdaily, t1p5m_subdaily(:,istep),                              &
<                                         pstar_subdaily(:,istep), land_pts)
< 
433c447
<     t1p5m_subdaily(l,1) = t1p5m_daily(l)
---
>     tl1_subdaily(l,1) = tl1_daily(l)
437c451,452
<     q1p5m_subdaily(l,1) = 0.01 * rh1p5m_daily(l) * qs_subdaily(l)
---
>     ql1_subdaily(l,1) = ql1_daily(l)
>   END DO
439c454,455
<     IF (t1p5m_daily(l) >= temp_conv) THEN
---
>   DO l = 1,land_pts
>     IF (tl1_daily(l) >= temp_conv) THEN
441c457,458
<     ELSE IF (t1p5m_daily(l) < temp_conv .AND. t1p5m_daily(l) >= temp_snow) THEN
---
>     ELSE IF (tl1_daily(l) < temp_conv .AND. tl1_daily(l) >= temp_snow)         &
>                                                                           THEN
diff -r vn7.0copy1_c4/src/./control/imogen/delta_temp.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/imogen/delta_temp.F90
12,13c12,16
<   n_olevs,f_ocean,kappa,lambda_l,lambda_o,mu,q,dtemp_l,dtemp_o                 &
< )
---
>   n_olevs,f_ocean,kappa,lambda_l,lambda_o,mu,dqradf,dtemp_l,dtemp_o, dtemp_g)
> 
> USE veg_param, ONLY: secs_per_360days
> 
> USE jules_print_mgr, ONLY: jules_message, jules_print
15,17d17
< USE jules_print_mgr, ONLY:                                                     &
<   jules_message,                                                               &
<   jules_print
35,36c35,36
< INTEGER ::                                                                     &
<   n_olevs  !IN Number of ocean thermal layers
---
> INTEGER, INTENT(IN) ::                                                         &
>   n_olevs  ! Number of ocean thermal layers
38,40c38,40
< REAL ::                                                                        &
<   q,                                                                           &
<            !IN Increase in global radiative forcing (W/m2)
---
> REAL, INTENT(IN) ::                                                            &
>   dqradf,                                                                      &
>            ! Change in global radiative forcing (W/m2)
42c42
<            !IN Inverse climate sensitivity over land (W/K/m2)
---
>            ! Inverse climate sensitivity over land (W/K/m2)
44c44
<            !IN Inverse climate sensitivity over ocean (W/K/m2)
---
>            ! Inverse climate sensitivity over ocean (W/K/m2)
46c46
<            !IN Ratio of land-to-ocean temperature anomalies (.)
---
>            ! Ratio of land-to-ocean temperature anomalies (.)
48,49c48,49
<            !IN Fractional coverage of planet with ocean
<   kappa    !IN Ocean eddy diffusivity (W/m/K)
---
>            ! Fractional coverage of planet with ocean
>   kappa    ! Ocean eddy diffusivity (W/m/K)
51,57c51,53
< INTEGER ::                                                                     &
<   iter_per_year,                                                               &
<            !WORK Iterations per year
<   timesteps,                                                                   &
<            !WORK Number of iterations per call to DELTA_TEMP
<   i,j      !WORK Looping parameter
< PARAMETER(iter_per_year = 20)
---
> REAL, INTENT(IN OUT) ::                                                        &
>   dtemp_o(n_olevs)
>            ! Ocean temperature anomalies (K)
59c55
< REAL ::                                                                        &
---
> REAL, INTENT(OUT) ::                                                           &
61,63c57,59
<            !OUT Land mean temperature anomaly
<   dtemp_o(n_olevs)
<            !IN/OUT Land mean temperature anomaly
---
>            ! Land mean temperature anomaly
>   dtemp_g
>            ! Global mean temperature anomaly
66,67d61
<   rhocp,                                                                       &
<            !WORK Rho times cp for the ocean (J/K/m3)
69,78c63,69
<            !WORK Flux into the top of the ocean (W/m2)
<   flux_bottom
<            !WORK Flux into the top of the ocean (W/m2)
< 
< REAL ::                                                                        &
<   DTIME,                                                                       &
<            !WORK Timestep (s)
<   dz(1:n_olevs),                                                               &
<            !WORK Distance step (m)
<   sec_year !WORK Seconds in a year (s)
---
>            ! Flux into the top of the ocean (W/m2)
>   flux_bottom,                                                                 &
>            ! Flux into the top of the ocean (W/m2)&
>   timestep_local,                                                              &
>            ! Timestep (s)
>   dz(1:n_olevs)
>            ! Distance step (m)
82c73
<            !WORK Mesh ratio
---
>            ! Mesh ratio
84c75
<            !WORK Mesh ratio
---
>            ! Mesh ratio
86c77
<            !WORK Inhomogenous component in implicit scheme (/s)
---
>            ! Inhomogenous component in implicit scheme (/s)
88,98c79,85
<            !WORK Inhomogenous component in implicit scheme (/s)
<   p        !WORK ``Dirchlet'' part of mixed boundary
<            !     condition at ocean surface (/m)
< 
< REAL ::                                                                        &
<   u_old(1:n_olevs),                                                            &
<            !WORK Old ocean temperature anomalies
<   u_new(1:n_olevs)
<            !WORK New ocean temperature anomalies
< 
< REAL ::                                                                        &
---
>            ! Inhomogenous component in implicit scheme (/s)
>   pdirchlet,                                                                   &
>            ! ``Dirchlet'' part of mixed boundary condition ocean surface (/m)
>   dtemp_o_old(1:n_olevs),                                                      &
>            ! Old ocean temperature anomalies
>   dtemp_o_new(1:n_olevs),                                                      &
>            ! New ocean temperature anomalies
100c87
<            !WORK Factor by which layers are changed
---
>            ! Factor by which layers are changed
102,103c89,90
<            !WORK Cumulated depth of layers (m)
<   dz_top   !WORK Depth of the top layer (m)
---
>            ! Cumulated depth of layers (m)
>   dz_top   ! Depth of the top layer (m)
105,106c92,93
< PARAMETER(rhocp = 4.04e6)
< PARAMETER(sec_year = 3.1536e7)
---
> REAL, PARAMETER :: rhocp = 4.04e6
>            ! Rho times cp for the ocean (J/K/m3)
107a95,101
> INTEGER ::                                                                     &
>   timesteps,                                                                   &
>            ! Number of iterations per call to delta_temp
>   i,j      ! Looping parameter
> 
> INTEGER, PARAMETER :: iter_per_year = 20
>            ! Iterations per year
113c107
< DTIME = sec_year / REAL(iter_per_year)
---
> timestep_local = secs_per_360days / REAL(iter_per_year)
145c139
< ! Now arrange that the lowest depth (here DEPTH = U(N_OLEVS+1)) is at 5000m
---
> ! Now arrange that the lowest depth (here depth = u(n_olevs+1)) is at 5000m
151c145
< r1(1) = (kappa / rhocp) * (DTIME / (dz_top * dz_top))
---
> r1(1) = (kappa / rhocp) * (timestep_local / (dz_top * dz_top))
154,155c148,149
<   r1(i) = (kappa / rhocp) * (DTIME / (dz(i-1) * (dz(i) + dz(i-1))))
<   r2(i) = (kappa / rhocp) * (DTIME / (dz(i) * (dz(i) + dz(i-1))))
---
>   r1(i) = (kappa / rhocp) * (timestep_local / (dz(i-1) * (dz(i) + dz(i-1))))
>   r2(i) = (kappa / rhocp) * (timestep_local / (dz(i) * (dz(i) + dz(i-1))))
158c152
< ! Reset the new values of U_OLD for the start of this run.
---
> ! Reset the new values of dtemp_o_old for the start of this run.
160c154
<   u_old(i) = dtemp_o(i)
---
>   dtemp_o_old(i) = dtemp_o(i)
165,166c159,160
<   lambda_old = -q / (kappa * f_ocean)
<   lambda_new = -q / (kappa * f_ocean)
---
>   lambda_old = -dqradf / (kappa * f_ocean)
>   lambda_new = -dqradf / (kappa * f_ocean)
168c162
<   p = ((1.0 - f_ocean) * lambda_l * mu) / (f_ocean * kappa)                    &
---
>   pdirchlet = ((1.0 - f_ocean) * lambda_l * mu) / (f_ocean * kappa)            &
172,173c166,167
<     u_old,u_new,p,lambda_old,lambda_new,r1,r2,dz_top,n_olevs                   &
<   )
---
>     dtemp_o_old,dtemp_o_new,pdirchlet,lambda_old,lambda_new,                   &
>     r1,r2,dz_top,n_olevs)
176,181c170,175
<   flux_top =  - 0.5 * (kappa * lambda_old * DTIME)                             &
<               - 0.5 * (kappa * lambda_new * DTIME)                             &
<               - 0.5 * (p * kappa * u_old(1) * DTIME)                           &
<               - 0.5 * (p * kappa * u_new(1) * DTIME)
<   flux_bottom = (DTIME / (2.0 * dz(n_olevs))) * kappa                          &
<               * (u_old(n_olevs) + u_new(n_olevs))
---
>   flux_top =  - 0.5 * (kappa * lambda_old * timestep_local)                    &
>               - 0.5 * (kappa * lambda_new * timestep_local)                    &
>               - 0.5 * (pdirchlet * kappa * dtemp_o_old(1) * timestep_local)    &
>               - 0.5 * (pdirchlet * kappa * dtemp_o_new(1) * timestep_local)
>   flux_bottom = (timestep_local / (2.0 * dz(n_olevs))) * kappa                 &
>               * (dtemp_o_old(n_olevs) + dtemp_o_new(n_olevs))
192c186
<     u_old(j) = u_new(j)
---
>     dtemp_o_old(j) = dtemp_o_new(j)
197c191
< ! At end of this model run, reset values of LAMBDA_L and LAMBDA_O
---
> ! At end of this model run, reset values of lambda_l and lambda_o
200c194
<   dtemp_o(j) = u_new(j)
---
>   dtemp_o(j) = dtemp_o_new(j)
201a196,197
> 
> ! land temperature change
202a199,202
> 
> ! global temperature change
> ! t_global  = (1-f) * t_land + f*t_ocean.
> dtemp_g = mu * dtemp_o(1) * (1.0 - f_ocean) + f_ocean * dtemp_o(1)
diff -r vn7.0copy1_c4/src/./control/imogen/diff_atmos_ch4.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/imogen/diff_atmos_ch4.F90
11c11
< SUBROUTINE diff_atmos_ch4(d_land_atmos_ch4, conv)
---
> SUBROUTINE diff_atmos_ch4(d_land_atmos_ch4, ch4_ppbv)
14,15c14
< USE imogen_constants, ONLY: nyr_max
< USE imogen_progs, ONLY: ch4_ppbv
---
> USE imogen_constants, ONLY: nyr_max, conv_gtc_to_ppm
28,30c27,31
<   d_land_atmos_ch4,                                                            &
<         ! Additional methane ACCUMULATED flux (kgC/year)
<   conv  ! Converts global emission of C (Gt) into change in atmospheric C (ppm)
---
>   d_land_atmos_ch4
>         ! Additional methane accumulated flux (kgC/year)
> 
> REAL, INTENT(IN OUT) :: ch4_ppbv
>         ! ch4 concentration in ppbv
41c42
<         ! Additional methane ACCUMULATED flux (ppbv)
---
>         ! Additional methane accumulated flux (ppbv)
90c91,92
< d_land_atmos_ch4_ppbv = d_land_atmos_ch4 * conv * ppm_to_ppb / pg_to_kg
---
> d_land_atmos_ch4_ppbv = d_land_atmos_ch4 *                                     &
>                         conv_gtc_to_ppm * ppm_to_ppb / pg_to_kg
diff -r vn7.0copy1_c4/src/./control/imogen/diffcarb_land_ch4.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/imogen/diffcarb_land_ch4.F90
5,7c5
< SUBROUTINE diffcarb_land_ch4(land_pts, d_land_atmos_ch4, lat, dctot_ch4)
< 
< USE cellarea_calc_mod, ONLY: cellarea_calc
---
> SUBROUTINE diffcarb_land_ch4(land_pts, d_land_atmos_ch4, darea, dctot_ch4)
36,37c34,35
<   lat(land_pts),                                                               &
<                    ! Latitute (degrees)
---
>   darea(land_pts),                                                             &
>                    ! Gridbox area (m2)
48,49d45
<   darea(land_pts),                                                             &
<                    ! Gridbox area (m2)
61d56
< CALL cellarea_calc(land_pts, lat, darea)
diff -r vn7.0copy1_c4/src/./control/imogen/diffcarb_land_co2.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/imogen/diffcarb_land_co2.F90
12c12
< SUBROUTINE diffcarb_land_co2(land_pts, d_land_atmos_co2, lat, dctot_co2, conv)
---
> SUBROUTINE diffcarb_land_co2(land_pts, d_land_atmos_co2, darea, dctot_co2)
14c14
< USE cellarea_calc_mod, ONLY: cellarea_calc
---
> USE imogen_constants, ONLY: conv_gtc_to_ppm
35c35
<                ! IN Number of land points
---
>                ! Number of land points
38,39d37
<   lat(land_pts),                                                               &
<                ! IN Latitute (degrees)
41,46c39,42
<                ! IN Change in total surface gridbox CO2
<                !    content during a period "YEAR_CO2" (kg C/m2)
<   conv
<                ! IN Converts global emission of C (Gt/yr)
<                !    into atmospheric CO2 (ppm/GtC)
< 
---
>                ! Change in total surface gridbox co2 content
>                ! between a calling period (here years) (kg C/m2)
>   darea(land_pts)
>                ! Gridbox area (m2)
48c44
< REAL, INTENT(IN OUT) ::                                                        &
---
> REAL, INTENT(OUT) ::                                                           &
50,53c46,48
<                ! OUT Change in atmospheric CO2 concentration
<                !     as a result of land-atmosphere feedbacks
<                !     between calls to SCENARIO (ppm/"YEAR_CO2")
< 
---
>                ! Change in atmospheric CO2 concentration
>                ! as a result of land-atmosphere feedbacks
>                ! between calling periods (here years) (ppm/year)
56c51
<   land_gain,                                                                   &
---
>   land_gain
58,59d52
<   darea(land_pts)
<                ! WORK Gridbox area (m2)
67,69d59
< 
< CALL cellarea_calc(land_pts, lat, darea)
< 
74c64
< d_land_atmos_co2 = -(land_gain / 1.0e12) * conv
---
> d_land_atmos_co2 = -(land_gain / 1.0e12) * conv_gtc_to_ppm
diff -r vn7.0copy1_c4/src/./control/imogen/drdat.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/imogen/drdat.F90
12,22c12,16
< SUBROUTINE drdat(                                                              &
<   iyear,land_pts,dir_anom,                                                     &
<   longmin_dat,latmin_dat,longmax_dat,latmax_dat,mm,drive_month,                &
<   imgn_drive, ainfo)
< 
< USE io_constants, ONLY: imogen_unit, max_file_name_len
< USE imogen_map, ONLY: sgindinv
< USE imogen_constants, ONLY: n_imogen_land
< USE imgn_drive_mod, ONLY: imgn_drive_type
< USE ancil_info, ONLY: ainfo_type
< USE theta_field_sizes, ONLY: t_i_length
---
> SUBROUTINE drdat(iyear)
> 
> USE fill_variables_from_file_mod, ONLY: fill_variables_from_file
> USE imogen_anlg_vals, ONLY: file_base_anom
> USE io_constants, ONLY: max_file_name_len
39,41d32
< TYPE(imgn_drive_type), INTENT(IN OUT) :: imgn_drive
< TYPE(ainfo_type), INTENT(IN) :: ainfo
< 
43c34
<   iyear,                                                                       &
---
>   iyear
45,61d35
<   land_pts,                                                                    &
<               ! IN Number of land points.
<   mm
<               ! IN Number months in year.
< 
< REAL, INTENT(OUT) ::                                                           &
<   latmin_dat,latmax_dat,                                                       &
<              ! Latitudinal limits of the area
<   longmin_dat,longmax_dat
<              ! Longitudinal limits of the area
< 
< REAL ::                                                                        &
<   lat(land_pts),                                                               &
<              ! Latitude (degrees).
<   lon(land_pts)
<              ! Longitude (degrees).
< 
64,89c38,62
<   drive_year,                                                                  &
<               ! IN Label for year of driving data.
<   drive_month(12)
<               ! Labels for month of driving data.
< 
< CHARACTER(LEN=max_file_name_len), INTENT(IN OUT) ::                            &
<   dir_anom
<               ! Directory containing anomalies.
< CHARACTER(LEN=180) ::                                                          &
<   driver_anom
<               ! Base filename containing anomalies.
< 
< !-----------------------------------------------------------------------
< ! Climatological forcing variables.
< !-----------------------------------------------------------------------
< REAL ::                                                                        &
<   blank_imogen_anomaly_input,                                                  &
<   rainfall_anom_dat(land_pts,mm),                                              &
<              ! WORK Rainfall rate (mm/day).
<   snowfall_anom_dat(land_pts,mm)
<              ! WORK Snowfall rate (mm/day).
< 
< !-----------------------------------------------------------------------
< ! Loop counters.
< !-----------------------------------------------------------------------
< INTEGER :: l, i, j, im, ijk ! Loop counters
---
>   drive_year
>               ! Label for year of driving data.
> CHARACTER(LEN=max_file_name_len) ::                                            &
>   file_year
>               ! File containing anomalies for the year of interest.
> 
> CHARACTER(LEN=24), DIMENSION(8) ::                                             &
>   imgn_name = ['tl1_ij_anom_imgn        ',                                     &
>                'ql1_ij_anom_imgn        ',                                     &
>                'wind_ij_anom_imgn       ',                                     &
>                'lwdown_ij_anom_imgn     ',                                     &
>                'swdown_ij_anom_imgn     ',                                     &
>                'precip_ij_anom_imgn     ',                                     &
>                'pstar_ij_anom_imgn      ',                                     &
>                'diurnal_tl1_ij_anom_imgn']
> 
> CHARACTER(LEN=14), DIMENSION(8) ::                                             &
>   nc_name = ['tl1_anom      ',                                                 &
>              'ql1_anom      ',                                                 &
>              'wind_anom     ',                                                 &
>              'lwdown_anom   ',                                                 &
>              'swdown_anom   ',                                                 &
>              'precip_anom   ',                                                 &
>              'pstar_anom    ',                                                 &
>              'range_tl1_anom' ]
96,100c69,70
< DO im = 1,mm
<   driver_anom = TRIM(dir_anom) // drive_year // drive_month(im)
< 
<   OPEN(imogen_unit, FILE=driver_anom,                                          &
<                     STATUS='old', POSITION='rewind', ACTION='read')
---
> file_year = TRIM(file_base_anom) // "_" // drive_year //".nc"
> ! curently need to be as a separate netcdf file for each year
102,133c72
<   READ(imogen_unit,*) longmin_dat,latmin_dat,longmax_dat,latmax_dat
<   DO ijk = 1,n_imogen_land
<     ! index of grid locations with index from get_imogen_map (see also gcm_anlg)
<     IF (sgindinv(ijk) > 0) THEN
<       l = sgindinv(ijk)
< 
<       j = (ainfo%land_index(l) - 1) / t_i_length + 1
<       i = ainfo%land_index(l) - (j-1) * t_i_length
< 
<       READ(imogen_unit,*) lon(l), lat(l),                                      &
<                         imgn_drive%t1p5m_ij_anom(i,j,im),                      &
<                         imgn_drive%rh1p5m_ij_anom(i,j,im),                     &
<                         imgn_drive%uwind_ij_anom(i,j,im),                      &
<                         imgn_drive%vwind_ij_anom(i,j,im),                      &
<                         imgn_drive%lwdown_ij_anom(i,j,im),                     &
<                         imgn_drive%swdown_ij_anom(i,j,im),                     &
<                         imgn_drive%diurnal_t1p5m_ij_anom(i,j,im),              &
<                         rainfall_anom_dat(l,im),                               &
<                         snowfall_anom_dat(l,im),                               &
<                         imgn_drive%pstar_ij_anom(i,j,im),                      &
<                         blank_imogen_anomaly_input
< 
< 
<       imgn_drive%precip_ij_anom(i,j,im) = rainfall_anom_dat(l,im) +            &
<                                           snowfall_anom_dat(l,im)
< 
<     ELSE
<       READ(imogen_unit,*)
<     END IF
<   END DO
< END DO
< CLOSE(imogen_unit)
---
> CALL fill_variables_from_file(file_year, imgn_name, nc_name)
diff -r vn7.0copy1_c4/src/./control/imogen/gcm_anlg.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/imogen/gcm_anlg.F90
13,15c13,14
<   q,land_pts,n_olevs,dir_patt,f_ocean,kappa_o,                                 &
<   lambda_l,lambda_o,mu,dtemp_o,longmin_am,latmin_am,longmax_am,                &
<   latmax_am,mm,imgn_drive, ainfo)
---
>   dqradf, land_pts, n_olevs, f_ocean, kappa_o,                                 &
>   lambda_l, lambda_o, mu, dtemp_o, dtemp_g, mm, imgn_drive, ainfo)
17,21c16
< USE io_constants, ONLY: imogen_unit, max_file_name_len
< 
< USE imogen_map, ONLY: sgindinv
< 
< USE imogen_constants, ONLY: drive_month,n_imogen_land
---
> USE imogen_run, ONLY: l_drive_with_global_temps
53,61d47
< CHARACTER(LEN=max_file_name_len), INTENT(IN) ::                                &
<   dir_patt
<                  ! IN Directory containing anomaly patterns.
< 
< 
< CHARACTER(LEN=max_file_name_len) ::                                            &
<   driver_patt
<                  ! File containing anomaly patterns from analogue model.
< 
73c59
<   q
---
>   dqradf
80,87d65
< REAL ::                                                                        &
<   lat_am(land_pts),                                                            &
<                   ! Latitude read from file.
<   long_am(land_pts),                                                           &
<                   !Longitude read from file.
<   dtemp_l
<                  ! Land mean temperature anomaly (K).
< 
89,94c67,68
<   latmin_am,latmax_am,                                                         &
<                  ! WORK Latitudinal limits of the area
<                  !      (degrees).
<   longmin_am,longmax_am
<                  ! WORK Longitudinal limits of the area
<                  !      (degrees).
---
>   dtemp_g
>                  ! Global mean temperature anomaly (K).
96,98d69
< !-----------------------------------------------------------------
< ! Anomaly patterns scaled to land mean temperature anomalies.
< !-----------------------------------------------------------------
100,104c71,75
<   drainfall_pat,                                                               &
<                  ! WORK Rainfall rate (mm/day/K).
<   dsnowfall_pat
<                  ! WORK Snowfall rate (mm/day/K).
< 
---
>   dtemp_l,                                                                     &
>                  ! Land mean temperature anomaly (K).
>   dtemp
>                  ! Mean temperature change either land or global
>                  ! depends on switch (K).
106c77
<   l, im, i, j, id, ijk
---
>   l, im, i, j
110c81
< ! Calculate new area mean temperature anomalies
---
> ! Calculate area mean temperature changes on both land & globally
112,113c83,88
< CALL delta_temp(n_olevs,f_ocean,kappa_o,lambda_l,lambda_o,mu,q,                &
<       dtemp_l,dtemp_o)
---
> IF ( .NOT. l_drive_with_global_temps ) THEN
>   CALL delta_temp(n_olevs, f_ocean, kappa_o, lambda_l, lambda_o, mu, dqradf,   &
>       dtemp_l, dtemp_o, dtemp_g)
>   dtemp = dtemp_l
>   ! ejb land temperature not global temperature - should be an option
> END IF
116,117c91,92
< ! Read in spatial patterns (/K) and convert to anomalies
< ! use to define the new climate data.
---
> ! Loop over months and calculate climate anomalies from patterns (/K)
> ! and global or land temperature change
120,174c95,98
<   !-----------------------------------------------------------------
<   ! Define the anomaly patterns and read the header
<   !-----------------------------------------------------------------
<   driver_patt = TRIM(dir_patt) // drive_month(im)
< 
<   OPEN(imogen_unit, FILE=driver_patt,                                          &
<                     STATUS='old', POSITION='rewind', ACTION='read')
< 
<   READ(imogen_unit,*) longmin_am,latmin_am,longmax_am,latmax_am
< 
<   !-----------------------------------------------------------------
<   ! Read in initial climatology and then define the new climate data.
<   !-----------------------------------------------------------------
<   DO ijk = 1,n_imogen_land
<     IF (sgindinv(ijk) > 0) THEN
<       l = sgindinv(ijk)
<       j = (ainfo%land_index(l) - 1) / t_i_length + 1
<       i = ainfo%land_index(l) - (j-1) * t_i_length
< 
<       READ(imogen_unit,*)                                                      &
<         long_am(l),lat_am(l),imgn_drive%t1p5m_ij_patt(i,j,im),                 &
<         imgn_drive%rh1p5m_ij_patt(i,j,im),                                     &
<         imgn_drive%uwind_ij_patt(i,j,im),                                      &
<         imgn_drive%vwind_ij_patt(i,j,im),                                      &
<         imgn_drive%lwdown_ij_patt(i,j,im),                                     &
<         imgn_drive%swdown_ij_patt(i,j,im),                                     &
<         imgn_drive%diurnal_t1p5m_ij_patt(i,j,im),                              &
<         drainfall_pat,dsnowfall_pat,                                           &
<         imgn_drive%pstar_ij_patt(i,j,im)
< 
<       imgn_drive%precip_ij_patt(i,j,im) = drainfall_pat + dsnowfall_pat
< 
<       imgn_drive%t1p5m_ij_anom(i,j,im) =                                       &
<                      imgn_drive%t1p5m_ij_patt(i,j,im) * dtemp_l
<       imgn_drive%rh1p5m_ij_anom(i,j,im) =                                      &
<                      imgn_drive%rh1p5m_ij_patt(i,j,im) * dtemp_l
<       imgn_drive%uwind_ij_anom(i,j,im) =                                       &
<                      imgn_drive%uwind_ij_patt(i,j,im) * dtemp_l
<       imgn_drive%vwind_ij_anom(i,j,im) =                                       &
<                      imgn_drive%vwind_ij_patt(i,j,im) * dtemp_l
<       imgn_drive%precip_ij_anom(i,j,im) =                                      &
<                      imgn_drive%precip_ij_patt(i,j,im) * dtemp_l
<       imgn_drive%diurnal_t1p5m_ij_anom(i,j,im) =                               &
<                      imgn_drive%diurnal_t1p5m_ij_patt(i,j,im) * dtemp_l
<       imgn_drive%lwdown_ij_anom(i,j,im) =                                      &
<                      imgn_drive%lwdown_ij_patt(i,j,im) * dtemp_l
<       imgn_drive%swdown_ij_anom(i,j,im) =                                      &
<                      imgn_drive%swdown_ij_patt(i,j,im) * dtemp_l
<       imgn_drive%pstar_ij_anom(i,j,im) =                                       &
<                      imgn_drive%pstar_ij_patt(i,j,im) * dtemp_l
< 
<     ELSE
<       READ(imogen_unit,*)
<     END IF
<   END DO     !End of loop over land points
---
>   DO l = 1,land_pts
> 
>     j = (ainfo%land_index(l) - 1) / t_i_length + 1
>     i = ainfo%land_index(l) - (j-1) * t_i_length
176c100,116
<   CLOSE(imogen_unit)
---
>     imgn_drive%tl1_ij_anom(i,j,im) =                                           &
>                       imgn_drive%tl1_ij_patt(i,j,im) * dtemp
>     imgn_drive%ql1_ij_anom(i,j,im) =                                           &
>                      imgn_drive%ql1_ij_patt(i,j,im) * dtemp
>     imgn_drive%wind_ij_anom(i,j,im) =                                          &
>                      imgn_drive%wind_ij_patt(i,j,im) * dtemp
>     imgn_drive%precip_ij_anom(i,j,im) =                                        &
>                      imgn_drive%precip_ij_patt(i,j,im) * dtemp
>     imgn_drive%diurnal_tl1_ij_anom(i,j,im) =                                   &
>                      imgn_drive%diurnal_tl1_ij_patt(i,j,im) * dtemp
>     imgn_drive%lwdown_ij_anom(i,j,im) =                                        &
>                      imgn_drive%lwdown_ij_patt(i,j,im) * dtemp
>     imgn_drive%swdown_ij_anom(i,j,im) =                                        &
>                      imgn_drive%swdown_ij_patt(i,j,im) * dtemp
>     imgn_drive%pstar_ij_anom(i,j,im) =                                         &
>                      imgn_drive%pstar_ij_patt(i,j,im) * dtemp
>   END DO     !End of loop over land points
diff -r vn7.0copy1_c4/src/./control/imogen/imgn_drive_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/imogen/imgn_drive_mod.F90
44,47c44,46
<   REAL, ALLOCATABLE :: t1p5m_ij_clim(:,:,:)
<   REAL, ALLOCATABLE :: rh1p5m_ij_clim(:,:,:)
<   REAL, ALLOCATABLE :: uwind_ij_clim(:,:,:)
<   REAL, ALLOCATABLE :: vwind_ij_clim(:,:,:)
---
>   REAL, ALLOCATABLE :: tl1_ij_clim(:,:,:)
>   REAL, ALLOCATABLE :: ql1_ij_clim(:,:,:)
>   REAL, ALLOCATABLE :: wind_ij_clim(:,:,:)
50c49
<   REAL, ALLOCATABLE :: diurnal_t1p5m_ij_clim(:,:,:)
---
>   REAL, ALLOCATABLE :: diurnal_tl1_ij_clim(:,:,:)
54,57c53,55
<   REAL, ALLOCATABLE :: t1p5m_ij_anom(:,:,:)
<   REAL, ALLOCATABLE :: rh1p5m_ij_anom(:,:,:)
<   REAL, ALLOCATABLE :: uwind_ij_anom(:,:,:)
<   REAL, ALLOCATABLE :: vwind_ij_anom(:,:,:)
---
>   REAL, ALLOCATABLE :: tl1_ij_anom(:,:,:)
>   REAL, ALLOCATABLE :: ql1_ij_anom(:,:,:)
>   REAL, ALLOCATABLE :: wind_ij_anom(:,:,:)
60c58
<   REAL, ALLOCATABLE :: diurnal_t1p5m_ij_anom(:,:,:)
---
>   REAL, ALLOCATABLE :: diurnal_tl1_ij_anom(:,:,:)
64,67c62,64
<   REAL, ALLOCATABLE :: t1p5m_ij_patt(:,:,:)
<   REAL, ALLOCATABLE :: rh1p5m_ij_patt(:,:,:)
<   REAL, ALLOCATABLE :: uwind_ij_patt(:,:,:)
<   REAL, ALLOCATABLE :: vwind_ij_patt(:,:,:)
---
>   REAL, ALLOCATABLE :: tl1_ij_patt(:,:,:)
>   REAL, ALLOCATABLE :: ql1_ij_patt(:,:,:)
>   REAL, ALLOCATABLE :: wind_ij_patt(:,:,:)
70c67
<   REAL, ALLOCATABLE :: diurnal_t1p5m_ij_patt(:,:,:)
---
>   REAL, ALLOCATABLE :: diurnal_tl1_ij_patt(:,:,:)
76c73
<   REAL, ALLOCATABLE :: t1p5m_ij_drive(:,:,:,:,:)
---
>   REAL, ALLOCATABLE :: tl1_ij_drive(:,:,:,:,:)
81c78
<   REAL, ALLOCATABLE :: q1p5m_ij_drive(:,:,:,:,:)
---
>   REAL, ALLOCATABLE :: ql1_ij_drive(:,:,:,:,:)
87,90d83
<   ! whar is this?
<   REAL, ALLOCATABLE :: dctot_co2(:)
<   REAL, ALLOCATABLE :: dctot_ch4(:)
< 
96,99c89,91
<   REAL, POINTER :: t1p5m_ij_clim(:,:,:)
<   REAL, POINTER :: rh1p5m_ij_clim(:,:,:)
<   REAL, POINTER :: uwind_ij_clim(:,:,:)
<   REAL, POINTER :: vwind_ij_clim(:,:,:)
---
>   REAL, POINTER :: tl1_ij_clim(:,:,:)
>   REAL, POINTER :: ql1_ij_clim(:,:,:)
>   REAL, POINTER :: wind_ij_clim(:,:,:)
102c94
<   REAL, POINTER :: diurnal_t1p5m_ij_clim(:,:,:)
---
>   REAL, POINTER :: diurnal_tl1_ij_clim(:,:,:)
105,108c97,99
<   REAL, POINTER :: t1p5m_ij_anom(:,:,:)
<   REAL, POINTER :: rh1p5m_ij_anom(:,:,:)
<   REAL, POINTER :: uwind_ij_anom(:,:,:)
<   REAL, POINTER :: vwind_ij_anom(:,:,:)
---
>   REAL, POINTER :: tl1_ij_anom(:,:,:)
>   REAL, POINTER :: ql1_ij_anom(:,:,:)
>   REAL, POINTER :: wind_ij_anom(:,:,:)
111c102
<   REAL, POINTER :: diurnal_t1p5m_ij_anom(:,:,:)
---
>   REAL, POINTER :: diurnal_tl1_ij_anom(:,:,:)
115,118c106,108
<   REAL, POINTER :: t1p5m_ij_patt(:,:,:)
<   REAL, POINTER :: rh1p5m_ij_patt(:,:,:)
<   REAL, POINTER :: uwind_ij_patt(:,:,:)
<   REAL, POINTER :: vwind_ij_patt(:,:,:)
---
>   REAL, POINTER :: tl1_ij_patt(:,:,:)
>   REAL, POINTER :: ql1_ij_patt(:,:,:)
>   REAL, POINTER :: wind_ij_patt(:,:,:)
121c111
<   REAL, POINTER :: diurnal_t1p5m_ij_patt(:,:,:)
---
>   REAL, POINTER :: diurnal_tl1_ij_patt(:,:,:)
125c115
<   REAL, POINTER :: t1p5m_ij_drive(:,:,:,:,:)
---
>   REAL, POINTER :: tl1_ij_drive(:,:,:,:,:)
130c120
<   REAL, POINTER :: q1p5m_ij_drive(:,:,:,:,:)
---
>   REAL, POINTER :: ql1_ij_drive(:,:,:,:,:)
135,136d124
<   REAL, POINTER :: dctot_co2(:)
<   REAL, POINTER :: dctot_ch4(:)
175,178c163,165
< ALLOCATE( imgn_drive_data%t1p5m_ij_clim(t_i_length,t_j_length,mm))
< ALLOCATE( imgn_drive_data%rh1p5m_ij_clim(t_i_length,t_j_length,mm))
< ALLOCATE( imgn_drive_data%uwind_ij_clim(t_i_length,t_j_length,mm))
< ALLOCATE( imgn_drive_data%vwind_ij_clim(t_i_length,t_j_length,mm))
---
> ALLOCATE( imgn_drive_data%tl1_ij_clim(t_i_length,t_j_length,mm))
> ALLOCATE( imgn_drive_data%ql1_ij_clim(t_i_length,t_j_length,mm))
> ALLOCATE( imgn_drive_data%wind_ij_clim(t_i_length,t_j_length,mm))
181c168
< ALLOCATE( imgn_drive_data%diurnal_t1p5m_ij_clim(t_i_length,t_j_length,mm))
---
> ALLOCATE( imgn_drive_data%diurnal_tl1_ij_clim(t_i_length,t_j_length,mm))
184,187c171,173
< ALLOCATE( imgn_drive_data%t1p5m_ij_anom(t_i_length,t_j_length,mm))
< ALLOCATE( imgn_drive_data%rh1p5m_ij_anom(t_i_length,t_j_length,mm))
< ALLOCATE( imgn_drive_data%uwind_ij_anom(t_i_length,t_j_length,mm))
< ALLOCATE( imgn_drive_data%vwind_ij_anom(t_i_length,t_j_length,mm))
---
> ALLOCATE( imgn_drive_data%tl1_ij_anom(t_i_length,t_j_length,mm))
> ALLOCATE( imgn_drive_data%ql1_ij_anom(t_i_length,t_j_length,mm))
> ALLOCATE( imgn_drive_data%wind_ij_anom(t_i_length,t_j_length,mm))
190c176
< ALLOCATE( imgn_drive_data%diurnal_t1p5m_ij_anom(t_i_length,t_j_length,mm))
---
> ALLOCATE( imgn_drive_data%diurnal_tl1_ij_anom(t_i_length,t_j_length,mm))
193,196c179,181
< ALLOCATE( imgn_drive_data%t1p5m_ij_patt(t_i_length,t_j_length,mm))
< ALLOCATE( imgn_drive_data%rh1p5m_ij_patt(t_i_length,t_j_length,mm))
< ALLOCATE( imgn_drive_data%uwind_ij_patt(t_i_length,t_j_length,mm))
< ALLOCATE( imgn_drive_data%vwind_ij_patt(t_i_length,t_j_length,mm))
---
> ALLOCATE( imgn_drive_data%tl1_ij_patt(t_i_length,t_j_length,mm))
> ALLOCATE( imgn_drive_data%ql1_ij_patt(t_i_length,t_j_length,mm))
> ALLOCATE( imgn_drive_data%wind_ij_patt(t_i_length,t_j_length,mm))
199c184
< ALLOCATE( imgn_drive_data%diurnal_t1p5m_ij_patt(t_i_length,t_j_length,mm))
---
> ALLOCATE( imgn_drive_data%diurnal_tl1_ij_patt(t_i_length,t_j_length,mm))
202c187
< ALLOCATE( imgn_drive_data%t1p5m_ij_drive(t_i_length,t_j_length,mm,md,nsdmax))
---
> ALLOCATE( imgn_drive_data%tl1_ij_drive(t_i_length,t_j_length,mm,md,nsdmax))
207c192
< ALLOCATE( imgn_drive_data%q1p5m_ij_drive(t_i_length,t_j_length,mm,md,nsdmax))
---
> ALLOCATE( imgn_drive_data%ql1_ij_drive(t_i_length,t_j_length,mm,md,nsdmax))
212,213d196
< ALLOCATE( imgn_drive_data%dctot_co2(land_pts))
< ALLOCATE( imgn_drive_data%dctot_ch4(land_pts))
215,218c198,200
< imgn_drive_data%t1p5m_ij_clim(:,:,:) = rmdi
< imgn_drive_data%rh1p5m_ij_clim(:,:,:) = rmdi
< imgn_drive_data%uwind_ij_clim(:,:,:) = rmdi
< imgn_drive_data%vwind_ij_clim(:,:,:) = rmdi
---
> imgn_drive_data%tl1_ij_clim(:,:,:) = rmdi
> imgn_drive_data%ql1_ij_clim(:,:,:) = rmdi
> imgn_drive_data%wind_ij_clim(:,:,:) = rmdi
221c203
< imgn_drive_data%diurnal_t1p5m_ij_clim(:,:,:) = rmdi
---
> imgn_drive_data%diurnal_tl1_ij_clim(:,:,:) = rmdi
224,227c206,208
< imgn_drive_data%t1p5m_ij_anom(:,:,:) = 0.0
< imgn_drive_data%rh1p5m_ij_anom(:,:,:) = 0.0
< imgn_drive_data%uwind_ij_anom(:,:,:) = 0.0
< imgn_drive_data%vwind_ij_anom(:,:,:) = 0.0
---
> imgn_drive_data%tl1_ij_anom(:,:,:) = 0.0
> imgn_drive_data%ql1_ij_anom(:,:,:) = 0.0
> imgn_drive_data%wind_ij_anom(:,:,:) = 0.0
230c211
< imgn_drive_data%diurnal_t1p5m_ij_anom(:,:,:) = 0.0
---
> imgn_drive_data%diurnal_tl1_ij_anom(:,:,:) = 0.0
233,236c214,216
< imgn_drive_data%t1p5m_ij_patt(:,:,:) = 0.0
< imgn_drive_data%rh1p5m_ij_patt(:,:,:) = 0.0
< imgn_drive_data%uwind_ij_patt(:,:,:) = 0.0
< imgn_drive_data%vwind_ij_patt(:,:,:) = 0.0
---
> imgn_drive_data%tl1_ij_patt(:,:,:) = 0.0
> imgn_drive_data%ql1_ij_patt(:,:,:) = 0.0
> imgn_drive_data%wind_ij_patt(:,:,:) = 0.0
239c219
< imgn_drive_data%diurnal_t1p5m_ij_patt(:,:,:) = 0.0
---
> imgn_drive_data%diurnal_tl1_ij_patt(:,:,:) = 0.0
242c222
< imgn_drive_data%t1p5m_ij_drive(:,:,:,:,:) = rmdi
---
> imgn_drive_data%tl1_ij_drive(:,:,:,:,:) = rmdi
247c227
< imgn_drive_data%q1p5m_ij_drive(:,:,:,:,:) = rmdi
---
> imgn_drive_data%ql1_ij_drive(:,:,:,:,:) = rmdi
252,253d231
< imgn_drive_data%dctot_co2(:) = rmdi
< imgn_drive_data%dctot_ch4(:) = rmdi
280,283c258,260
< DEALLOCATE( imgn_drive_data%t1p5m_ij_clim)
< DEALLOCATE( imgn_drive_data%rh1p5m_ij_clim)
< DEALLOCATE( imgn_drive_data%uwind_ij_clim)
< DEALLOCATE( imgn_drive_data%vwind_ij_clim)
---
> DEALLOCATE( imgn_drive_data%tl1_ij_clim)
> DEALLOCATE( imgn_drive_data%ql1_ij_clim)
> DEALLOCATE( imgn_drive_data%wind_ij_clim)
286c263
< DEALLOCATE( imgn_drive_data%diurnal_t1p5m_ij_clim)
---
> DEALLOCATE( imgn_drive_data%diurnal_tl1_ij_clim)
289,292c266,268
< DEALLOCATE( imgn_drive_data%t1p5m_ij_anom)
< DEALLOCATE( imgn_drive_data%rh1p5m_ij_anom)
< DEALLOCATE( imgn_drive_data%uwind_ij_anom)
< DEALLOCATE( imgn_drive_data%vwind_ij_anom)
---
> DEALLOCATE( imgn_drive_data%tl1_ij_anom)
> DEALLOCATE( imgn_drive_data%ql1_ij_anom)
> DEALLOCATE( imgn_drive_data%wind_ij_anom)
295c271
< DEALLOCATE( imgn_drive_data%diurnal_t1p5m_ij_anom)
---
> DEALLOCATE( imgn_drive_data%diurnal_tl1_ij_anom)
298,301c274,276
< DEALLOCATE( imgn_drive_data%t1p5m_ij_patt)
< DEALLOCATE( imgn_drive_data%rh1p5m_ij_patt)
< DEALLOCATE( imgn_drive_data%uwind_ij_patt)
< DEALLOCATE( imgn_drive_data%vwind_ij_patt)
---
> DEALLOCATE( imgn_drive_data%tl1_ij_patt)
> DEALLOCATE( imgn_drive_data%ql1_ij_patt)
> DEALLOCATE( imgn_drive_data%wind_ij_patt)
304c279
< DEALLOCATE( imgn_drive_data%diurnal_t1p5m_ij_patt)
---
> DEALLOCATE( imgn_drive_data%diurnal_tl1_ij_patt)
307c282
< DEALLOCATE( imgn_drive_data%t1p5m_ij_drive)
---
> DEALLOCATE( imgn_drive_data%tl1_ij_drive)
312c287
< DEALLOCATE( imgn_drive_data%q1p5m_ij_drive)
---
> DEALLOCATE( imgn_drive_data%ql1_ij_drive)
317,318d291
< DEALLOCATE( imgn_drive_data%dctot_co2)
< DEALLOCATE( imgn_drive_data%dctot_ch4)
348,351c321,323
< imgn_drive%t1p5m_ij_clim => imgn_drive_data%t1p5m_ij_clim
< imgn_drive%rh1p5m_ij_clim => imgn_drive_data%rh1p5m_ij_clim
< imgn_drive%uwind_ij_clim => imgn_drive_data%uwind_ij_clim
< imgn_drive%vwind_ij_clim => imgn_drive_data%vwind_ij_clim
---
> imgn_drive%tl1_ij_clim => imgn_drive_data%tl1_ij_clim
> imgn_drive%ql1_ij_clim => imgn_drive_data%ql1_ij_clim
> imgn_drive%wind_ij_clim => imgn_drive_data%wind_ij_clim
354c326
< imgn_drive%diurnal_t1p5m_ij_clim => imgn_drive_data%diurnal_t1p5m_ij_clim
---
> imgn_drive%diurnal_tl1_ij_clim => imgn_drive_data%diurnal_tl1_ij_clim
357,360c329,331
< imgn_drive%t1p5m_ij_anom => imgn_drive_data%t1p5m_ij_anom
< imgn_drive%rh1p5m_ij_anom => imgn_drive_data%rh1p5m_ij_anom
< imgn_drive%uwind_ij_anom => imgn_drive_data%uwind_ij_anom
< imgn_drive%vwind_ij_anom => imgn_drive_data%vwind_ij_anom
---
> imgn_drive%tl1_ij_anom => imgn_drive_data%tl1_ij_anom
> imgn_drive%ql1_ij_anom => imgn_drive_data%ql1_ij_anom
> imgn_drive%wind_ij_anom => imgn_drive_data%wind_ij_anom
363c334
< imgn_drive%diurnal_t1p5m_ij_anom =>imgn_drive_data%diurnal_t1p5m_ij_anom
---
> imgn_drive%diurnal_tl1_ij_anom =>imgn_drive_data%diurnal_tl1_ij_anom
366,369c337,339
< imgn_drive%t1p5m_ij_patt => imgn_drive_data%t1p5m_ij_patt
< imgn_drive%rh1p5m_ij_patt => imgn_drive_data%rh1p5m_ij_patt
< imgn_drive%uwind_ij_patt => imgn_drive_data%uwind_ij_patt
< imgn_drive%vwind_ij_patt => imgn_drive_data%vwind_ij_patt
---
> imgn_drive%tl1_ij_patt => imgn_drive_data%tl1_ij_patt
> imgn_drive%ql1_ij_patt => imgn_drive_data%ql1_ij_patt
> imgn_drive%wind_ij_patt => imgn_drive_data%wind_ij_patt
372c342
< imgn_drive%diurnal_t1p5m_ij_patt =>imgn_drive_data%diurnal_t1p5m_ij_patt
---
> imgn_drive%diurnal_tl1_ij_patt =>imgn_drive_data%diurnal_tl1_ij_patt
375c345
< imgn_drive%t1p5m_ij_drive => imgn_drive_data%t1p5m_ij_drive
---
> imgn_drive%tl1_ij_drive => imgn_drive_data%tl1_ij_drive
380c350
< imgn_drive%q1p5m_ij_drive => imgn_drive_data%q1p5m_ij_drive
---
> imgn_drive%ql1_ij_drive => imgn_drive_data%ql1_ij_drive
385,386d354
< imgn_drive%dctot_co2 => imgn_drive_data%dctot_co2
< imgn_drive%dctot_ch4 => imgn_drive_data%dctot_ch4
413,416c381,383
< NULLIFY( imgn_drive%t1p5m_ij_clim)
< NULLIFY( imgn_drive%rh1p5m_ij_clim)
< NULLIFY( imgn_drive%uwind_ij_clim)
< NULLIFY( imgn_drive%vwind_ij_clim)
---
> NULLIFY( imgn_drive%tl1_ij_clim)
> NULLIFY( imgn_drive%ql1_ij_clim)
> NULLIFY( imgn_drive%wind_ij_clim)
419c386
< NULLIFY( imgn_drive%diurnal_t1p5m_ij_clim)
---
> NULLIFY( imgn_drive%diurnal_tl1_ij_clim)
422,425c389,391
< NULLIFY( imgn_drive%t1p5m_ij_anom)
< NULLIFY( imgn_drive%rh1p5m_ij_anom)
< NULLIFY( imgn_drive%uwind_ij_anom)
< NULLIFY( imgn_drive%vwind_ij_anom)
---
> NULLIFY( imgn_drive%tl1_ij_anom)
> NULLIFY( imgn_drive%ql1_ij_anom)
> NULLIFY( imgn_drive%wind_ij_anom)
428c394
< NULLIFY( imgn_drive%diurnal_t1p5m_ij_anom)
---
> NULLIFY( imgn_drive%diurnal_tl1_ij_anom)
431,434c397,399
< NULLIFY( imgn_drive%t1p5m_ij_patt)
< NULLIFY( imgn_drive%rh1p5m_ij_patt)
< NULLIFY( imgn_drive%uwind_ij_patt)
< NULLIFY( imgn_drive%vwind_ij_patt)
---
> NULLIFY( imgn_drive%tl1_ij_patt)
> NULLIFY( imgn_drive%ql1_ij_patt)
> NULLIFY( imgn_drive%wind_ij_patt)
437c402
< NULLIFY( imgn_drive%diurnal_t1p5m_ij_patt)
---
> NULLIFY( imgn_drive%diurnal_tl1_ij_patt)
440c405
< NULLIFY( imgn_drive%t1p5m_ij_drive)
---
> NULLIFY( imgn_drive%tl1_ij_drive)
445c410
< NULLIFY( imgn_drive%q1p5m_ij_drive)
---
> NULLIFY( imgn_drive%ql1_ij_drive)
450,451d414
< NULLIFY( imgn_drive%dctot_co2)
< NULLIFY( imgn_drive%dctot_ch4)
459c422
< #endif
\ No newline at end of file
---
> #endif
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/imogen: imgn_vars_mod.F90
diff -r vn7.0copy1_c4/src/./control/imogen/imogen_check.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/imogen/imogen_check.F90
12,14c12,13
<   c_emissions,include_co2,include_non_co2,land_feed_co2, land_feed_ch4,        &
<   ocean_feed,anlg,anom, wgen                                                   &
< )
---
>   c_emissions, include_co2, include_non_co2_radf, land_feed_co2,               &
>   land_feed_ch4, ocean_feed, anlg, anom, l_drive_with_global_temps)
42c41
<          !IN True: CO2 concentration is calculated from emissions read from
---
>          ! True: CO2 concentration is calculated from emissions read from
44c43
<          !   False: CO2 concentration read from file_scen_co2_ppmv
---
>          ! False: CO2 concentration read from file_scen_co2_ppmv
46,48c45,47
<          !IN Are adjustments to CO2 values allowed?
<   include_non_co2,                                                             &
<          !IN Are adjustments to non-CO2 values allowed?
---
>          ! Are adjustments to CO2 concentrations allowed?
>   include_non_co2_radf,                                                        &
>          ! Are adjustments to non-CO2 radiative forcings allowed?
50c49
<          !IN Are land CO2 feedbacks allowed on atmospheric C
---
>          ! Are land CO2 feedbacks allowed on atmospheric C
52c51
<          !IN Are land CH4 feedbacks allowed on atmospheric C
---
>          ! Are land CH4 feedbacks allowed on atmospheric C
54c53
<          !IN Are ocean feedbacks allowed on atmospheric C
---
>          ! Are ocean feedbacks allowed on atmospheric C
56c55
<          !IN True if the analogue model is used
---
>          ! True if the analogue model is used
58,59c57,61
<          !IN True if the anomalies are used
<   wgen   !IN True if weather generator is used
---
>          ! True if the anomalies are used
>   l_drive_with_global_temps
>          ! True if driving with global temperature
>          ! also need co2 concentrations as input
>          ! no feedbacks currently included
66c68
<          !WORK Checks that configuration is Valid
---
>          ! Checks that configuration is valid
68c70
<          !WORK Confirms that configuration has been used before
---
>          ! Confirms that configuration has been used before
116,117c118,119
<         ( .NOT. include_non_co2) .AND. ( .NOT. land_feed_co2) .AND.            &
<         ( .NOT. ocean_feed) .AND. ( .NOT. wgen))                               &
---
>         ( .NOT. include_non_co2_radf) .AND. ( .NOT. land_feed_co2) .AND.       &
>         ( .NOT. ocean_feed))                                                   &
130c132
<   IF (( .NOT. include_co2) .AND. include_non_co2) THEN
---
>   IF (( .NOT. include_co2) .AND. include_non_co2_radf) THEN
142c144
<       WRITE(jules_message,*) 'Run is for prescribed CO2'
---
>       WRITE(jules_message,*) 'Run is for prescribed CO2 concentration'
149c151
<           ( .NOT. land_feed_ch4) .AND. ( .NOT. wgen)) THEN
---
>           ( .NOT. land_feed_ch4)) THEN
179,180c181
<       IF ( land_feed_co2 .AND. ocean_feed .AND. ( .NOT. land_feed_ch4) .AND.   &
<            ( .NOT. wgen) ) THEN
---
>       IF ( land_feed_co2 .AND. ocean_feed .AND. ( .NOT. land_feed_ch4)) THEN
188,189c189,190
<   IF (include_non_co2) THEN
<     WRITE(jules_message,*) 'Run is with non-CO2 radiative forcing'
---
>   IF (include_non_co2_radf) THEN
>     WRITE(jules_message,*) 'Run is with prescribed non-CO2 radiative forcing'
204,205c205
<     IF ( include_co2 .AND. ocean_feed .AND. ( land_feed_ch4) .AND.             &
<         ( .NOT. wgen) ) THEN
---
>     IF ( include_co2 .AND. ocean_feed .AND. ( land_feed_ch4)) THEN
220,222c220,221
< ! Write if weather generator is turned on
< IF ( .NOT. wgen) THEN
<   WRITE(jules_message,*) 'Weather generator is switched off'
---
> IF (l_drive_with_global_temps) THEN
>   WRITE(jules_message,*) 'JULES is driven with global mean temperature changes'
224,225c223
< ELSE
<   WRITE(jules_message,*) 'Weather generator is switched on'
---
>   WRITE(jules_message,*) 'there are no land or ocean feedbacks'
226a225,237
>   IF ( c_emissions ) THEN
>     WRITE(jules_message,*) 'Need co2 concentration not emissions'
>     CALL jules_print('imogen_check',jules_message)
>     check_flag = .FALSE.
>   ELSE
>     IF ( .NOT. include_co2) THEN
>       WRITE(jules_message,*) 'Need time series of co2 conc read from file'
>       CALL jules_print('imogen_check',jules_message)
>       check_flag = .FALSE.
>     ELSE
>       check_flag = .TRUE.
>     END IF
>   END IF
diff -r vn7.0copy1_c4/src/./control/imogen/imogen_update_carb.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/imogen/imogen_update_carb.F90
12c12,15
< SUBROUTINE imogen_update_carb(progs, imgn_drive)
---
> SUBROUTINE imogen_update_carb(progs, imgn_vars)
> 
> USE model_grid_mod, ONLY: grid_area_ij
> USE theta_field_sizes, ONLY: t_i_length, t_j_length
27,30c30,31
<   nyr_emiss, ocean_feed, initial_co2_ch4_year, land_feed_ch4
< 
< USE imogen_clim, ONLY:                                                         &
<   lat
---
>   nyr_emiss, ocean_feed, initial_co2_ch4_year, land_feed_ch4,                  &
>   l_drive_with_global_temps
35,39c36
<   conv,ocean_area,nfarray
< 
< USE imogen_progs, ONLY:                                                        &
<   co2_ppmv, co2_start_ppmv, dtemp_o, co2_change_ppmv, fa_ocean,                &
<   d_land_atmos_co2, d_land_atmos_ch4, d_ocean_atmos, c_emiss_out
---
>   conv_gtc_to_ppm, ocean_area, nfarray
51c48
< USE imgn_drive_mod, ONLY: imgn_drive_type
---
> USE imgn_vars_mod, ONLY: imgn_vars_type
74c71
< TYPE(imgn_drive_type), INTENT(IN OUT) :: imgn_drive
---
> TYPE(imgn_vars_type), INTENT(IN OUT) :: imgn_vars
83c80
<   d_land_atmos_field(land_pts)
---
>   d_land_atmos_field(land_pts),                                                &
84a82,83
>   darea(land_pts)
>               ! area of each grid cell on each processor
88,91c87,90
<               ! dctot on full grid
<   global_data_lat(:),                                                          &
<               !  lat on full grid
<   global_data_tmp(:)
---
>               ! imgn_vars%dctot_co2 on full grid
>   global_data_darea(:),                                                        &
>               ! area of each grid cell on full grid
>   global_data_land_atmos(:)
103,104c102,103
<     imgn_drive%dctot_co2(l) = trifctltype%cv_gb(l) -                           &
<                                            imgn_drive%dctot_co2(l)
---
>     imgn_vars%dctot_co2(l) = trifctltype%cv_gb(l) -                            &
>                                            imgn_vars%dctot_co2(l)
111c110
<           imgn_drive%dctot_co2(l) = imgn_drive%dctot_co2(l) +                  &
---
>           imgn_vars%dctot_co2(l) = imgn_vars%dctot_co2(l) +                    &
118c117
<   !need to gather dctot_co2 and lat to global grid
---
>   !need to gather dctot_co2 and darea to global grid
120,123c119,123
<   IF ( is_master_task() ) ALLOCATE(global_data_lat(global_land_pts))
<   IF ( is_master_task() ) ALLOCATE(global_data_tmp(global_land_pts))
<   CALL gather_land_field(imgn_drive%dctot_co2, global_data_dctot)
<   CALL gather_land_field(lat, global_data_lat)
---
>   IF ( is_master_task() ) ALLOCATE(global_data_darea(global_land_pts))
>   IF ( is_master_task() ) ALLOCATE(global_data_land_atmos(global_land_pts))
>   CALL gather_land_field(imgn_vars%dctot_co2, global_data_dctot)
>   darea = RESHAPE(grid_area_ij(:,:), [ t_i_length * t_j_length ])
>   CALL gather_land_field(darea, global_data_darea)
126,128c126,128
<     CALL diffcarb_land_co2(global_land_pts, d_land_atmos_co2,                  &
<               global_data_lat, global_data_dctot, conv)
<     global_data_tmp(:) = d_land_atmos_co2
---
>     CALL diffcarb_land_co2(global_land_pts, imgn_vars%d_land_atmos_co2(1),     &
>               global_data_darea, global_data_dctot)
>     global_data_land_atmos(:) = imgn_vars%d_land_atmos_co2(1)
131,137c131,137
<   ! need to scatter d_land_atmos_co2 to each processor
<   CALL scatter_land_field(global_data_tmp,d_land_atmos_field)
<   d_land_atmos_co2 = d_land_atmos_field(1)
< 
<   IF ( ALLOCATED(global_data_dctot) ) DEALLOCATE(global_data_dctot)
<   IF ( ALLOCATED(global_data_lat) ) DEALLOCATE(global_data_lat)
<   IF ( ALLOCATED(global_data_tmp) ) DEALLOCATE(global_data_tmp)
---
>   ! need to scatter imgn_vars%d_land_atmos_co2 to each processor
>   CALL scatter_land_field(global_data_land_atmos,d_land_atmos_field)
>   imgn_vars%d_land_atmos_co2 = d_land_atmos_field
> 
>   IF ( ALLOCATED(global_data_dctot) )      DEALLOCATE(global_data_dctot)
>   IF ( ALLOCATED(global_data_darea) )      DEALLOCATE(global_data_darea)
>   IF ( ALLOCATED(global_data_land_atmos) ) DEALLOCATE(global_data_land_atmos)
139c139
< END IF
---
> END IF  ! end co2 land feedbacks
144c144,145
< IF (include_co2 .AND. c_emissions .AND. anom .AND. anlg) THEN
---
> IF (include_co2 .AND. c_emissions .AND. anom .AND. anlg .AND. .NOT.            &
>                                            l_drive_with_global_temps) THEN
146c147
<   ! Include anthropogenic carbon emissions.
---
>   ! Include anthropogenic carbon emissions (c_emissions=true)
150,151c151,153
<       c_emiss_out = c_emiss(n)
<       co2_ppmv = co2_ppmv + conv * c_emiss_out
---
>       imgn_vars%c_emiss_data(1) = c_emiss(n)
>       imgn_vars%co2_ppmv(1) = imgn_vars%co2_ppmv(1) + conv_gtc_to_ppm *        &
>                                imgn_vars%c_emiss_data(1)
164c166
<     co2_ppmv = co2_ppmv + d_land_atmos_co2
---
>     imgn_vars%co2_ppmv(1) = imgn_vars%co2_ppmv(1) + imgn_vars%d_land_atmos_co2(1)
171,172c173,174
<       1,co2_ppmv,co2_init_ppmv,dtemp_o(1),                                     &
<       fa_ocean,ocean_area,co2_change_ppmv,                                     &
---
>       1,imgn_vars%co2_ppmv(1),co2_init_ppmv,imgn_vars%dtemp_o(1),              &
>       imgn_vars%fa_ocean,ocean_area,imgn_vars%co2_change_ppmv(1),              &
174c176
<       t_ocean_init,nfarray,d_ocean_atmos                                       &
---
>       t_ocean_init,nfarray,imgn_vars%d_ocean_atmos(1)                          &
176c178
<     co2_ppmv = co2_ppmv + d_ocean_atmos
---
>     imgn_vars%co2_ppmv(1) = imgn_vars%co2_ppmv(1) + imgn_vars%d_ocean_atmos(1)
180c182,186
< IF (include_co2) co2_change_ppmv = co2_ppmv - co2_start_ppmv
---
> IF (include_co2) THEN
>   ! if co2 concentration is allowed to change
>   imgn_vars%co2_change_ppmv(1) = imgn_vars%co2_ppmv(1) -                       &
>                         imgn_vars%co2_start_ppmv(1)
> END IF
183c189
< co2_mmr = co2_ppmv * 44.0 / 28.97 * 1.0e-6
---
> co2_mmr = imgn_vars%co2_ppmv(1) * 44.0 / 28.97 * 1.0e-6
197c203
<       imgn_drive%dctot_ch4(l) = SUM(toppdm%fch4_wetl_acc_soilt(l,:))
---
>       imgn_vars%dctot_ch4(l) = SUM(toppdm%fch4_wetl_acc_soilt(l,:))
206c212
<   ! Gather dctot_ch4 and lat to global grid
---
>   ! Gather dctot_ch4 and darea to global grid
208,211c214,218
<   IF ( is_master_task() ) ALLOCATE(global_data_lat(global_land_pts))
<   IF ( is_master_task() ) ALLOCATE(global_data_tmp(global_land_pts))
<   CALL gather_land_field(imgn_drive%dctot_ch4, global_data_dctot)
<   CALL gather_land_field(lat, global_data_lat)
---
>   IF ( is_master_task() ) ALLOCATE(global_data_darea(global_land_pts))
>   IF ( is_master_task() ) ALLOCATE(global_data_land_atmos(global_land_pts))
>   CALL gather_land_field(imgn_vars%dctot_ch4, global_data_dctot)
>   darea = RESHAPE(grid_area_ij(:,:), [ t_i_length * t_j_length ])
>   CALL gather_land_field(darea, global_data_darea)
217,219c224,226
<     CALL diffcarb_land_ch4(global_land_pts, d_land_atmos_ch4,                  &
<                 global_data_lat, global_data_dctot)
<     global_data_tmp(:) = d_land_atmos_ch4
---
>     CALL diffcarb_land_ch4(global_land_pts, imgn_vars%d_land_atmos_ch4(1),     &
>                 global_data_darea, global_data_dctot)
>     global_data_land_atmos(:) = imgn_vars%d_land_atmos_ch4(1)
223,224c230,231
<   CALL scatter_land_field(global_data_tmp, d_land_atmos_field)
<   d_land_atmos_ch4 = d_land_atmos_field(1)
---
>   CALL scatter_land_field(global_data_land_atmos, d_land_atmos_field)
>   imgn_vars%d_land_atmos_ch4(:) = d_land_atmos_field(1)
229c236
<   CALL diff_atmos_ch4(d_land_atmos_ch4, conv)
---
>   CALL diff_atmos_ch4(imgn_vars%d_land_atmos_ch4(1), imgn_vars%ch4_ppbv(1))
231,233c238,240
<   IF ( ALLOCATED(global_data_dctot) ) DEALLOCATE(global_data_dctot)
<   IF ( ALLOCATED(global_data_lat) )   DEALLOCATE(global_data_lat)
<   IF ( ALLOCATED(global_data_tmp) )   DEALLOCATE(global_data_tmp)
---
>   IF ( ALLOCATED(global_data_dctot) )      DEALLOCATE(global_data_dctot)
>   IF ( ALLOCATED(global_data_land_atmos) ) DEALLOCATE(global_data_land_atmos)
>   IF ( ALLOCATED(global_data_darea) )      DEALLOCATE(global_data_darea)
diff -r vn7.0copy1_c4/src/./control/imogen/imogen_update_clim.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/imogen/imogen_update_clim.F90
12c12
< SUBROUTINE imogen_update_clim(progs, imgn_drive, ainfo)
---
> SUBROUTINE imogen_update_clim(progs, imgn_drive, imgn_vars, ainfo)
20,23d19
< USE theta_field_sizes, ONLY: t_i_length
< 
< USE datetime_mod, ONLY: secs_in_day
< 
26,28d21
< USE imogen_progs, ONLY:                                                        &
<   co2_ppmv,co2_start_ppmv,dtemp_o
< 
31c24
<   co2_init_ppmv ,include_non_co2, wgen,                                        &
---
>   co2_init_ppmv, include_non_co2_radf,                                         &
33c26
<   nyr_non_co2, file_non_co2, file_non_co2_vals
---
>   nyr_non_co2, file_non_co2_radf, l_drive_with_global_temps
35,36c28
< USE imogen_time, ONLY:                                                         &
<   mm,md,nsdmax,step_day
---
> USE imogen_time, ONLY: mm, md, nsdmax
39,40c31
<   q2co2, dir_patt, f_ocean, kappa_o,                                           &
<   lambda_l, lambda_o,mu, dir_anom
---
>   q2co2, f_ocean, kappa_o, lambda_l, lambda_o, mu
42,55c33
< USE imogen_constants, ONLY:                                                    &
<   n_olevs, drive_month
< 
< USE imogen_clim, ONLY:                                                         &
< !   Scalars
<     latmin_clim,latmax_clim,longmin_clim,longmax_clim,                         &
< !   Arrays
<     t_clim,rainfall_clim,snowfall_clim,rh15m_clim,uwind_clim,                  &
<     vwind_clim,dtemp_clim,pstar_ha_clim,sw_clim,lw_clim,                       &
<     f_wet_clim, lat, LONG
< 
< USE imogen_drive_vars, ONLY:                                                   &
<   t_out,conv_rain_out,conv_snow_out,ls_rain_out,ls_snow_out,                   &
<   qhum_out,wind_out,pstar_out,sw_out,lw_out
---
> USE imogen_constants, ONLY: n_olevs
66a45
> USE imgn_vars_mod, ONLY: imgn_vars_type
90a70
> TYPE(imgn_vars_type), INTENT(IN OUT) :: imgn_vars
110c90
<                !WORK Radiative forcing due to CO2 (W/m2)
---
>                ! Radiative forcing due to CO2 (W/m2)
112c92
<                !WORK Radiative forcing due to changes in CH4 concentration
---
>                ! Radiative forcing due to changes in CH4 concentration
114,127c94
<   q_non_co2,                                                                   &
<                !WORK Radiative forcing due to non-CO2 (W/m2)
<   q            !WORK Total radiative forcing, both CO2 and NON CO2
< 
< REAL :: latmin,latmax,longmin,longmax
<                !WORK Max and min lat and long for files
< 
< ! Dummy variables for weather generator which is not available in this version
< REAL ::                                                                        &
<   precip_wg(land_pts,mm,md),                                                   &
<   tmin_wg(land_pts,mm,md),                                                     &
<   tmax_wg(land_pts,mm,md),                                                     &
<   swdown_wg(land_pts,mm,md),                                                   &
<   rh1p5m_wg(land_pts,mm,md)
---
>   q_total      ! Total radiative forcing
133,134c100,101
<   t1p5m_anom(land_pts,mm),                                                     &
<                 ! WORK Temperature anomalies (K)
---
>   tl1_anom(land_pts,mm),                                                       &
>                 ! Temperature anomalies (K)
136,144c103,109
<                 ! WORK Precip anomalies (mm/day)
<   rh1p5m_anom(land_pts,mm),                                                    &
<                 ! WORK Relative humidity anomalies
<   uwind_anom(land_pts,mm),                                                     &
<                 ! WORK u-wind anomalies (m/s)
<   vwind_anom(land_pts,mm),                                                     &
<                 ! WORK v-wind anomalies (m/s)
<   diurnal_t1p5m_anom(land_pts,mm),                                             &
<                 ! WORK Diurnal Temperature (K)
---
>                 ! Precip anomalies (mm/day)
>   ql1_anom(land_pts,mm),                                                       &
>                 ! Specific humidity anomalies
>   wind_anom(land_pts,mm),                                                      &
>                 ! wind anomalies (m/s)
>   diurnal_tl1_anom(land_pts,mm),                                               &
>                 ! Diurnal Temperature (K)
146c111
<                 ! WORK Pressure anomalies (hPa)
---
>                 ! Pressure anomalies (hPa)
148c113
<                 ! WORK Shortwave radiation anomalie
---
>                 ! Shortwave radiation anomalie
150c115
<                 ! WORK Longwave radiation anomalies
---
>                 ! Longwave radiation anomalies
155d119
< q_non_co2 = 0.0
156a121
> q_total   = 0.0
158,166c123,130
< t1p5m_anom(:,:)        = 0.0
< precip_anom(:,:)   = 0.0
< rh1p5m_anom(:,:)    = 0.0
< uwind_anom(:,:)    = 0.0
< vwind_anom(:,:)    = 0.0
< diurnal_t1p5m_anom(:,:)    = 0.0
< pstar_ha_anom(:,:) = 0.0
< swdown_anom(:,:)       = 0.0
< lwdown_anom(:,:)       = 0.0
---
> tl1_anom(:,:)         = 0.0
> precip_anom(:,:)      = 0.0
> ql1_anom(:,:)         = 0.0
> wind_anom(:,:)        = 0.0
> diurnal_tl1_anom(:,:) = 0.0
> pstar_ha_anom(:,:)    = 0.0
> swdown_anom(:,:)      = 0.0
> lwdown_anom(:,:)      = 0.0
174c138
<   co2_start_ppmv = co2_ppmv
---
>   imgn_vars%co2_start_ppmv(1) = imgn_vars%co2_ppmv(1)
179c143
< ! subroutine IMOGEN_CONFIRMED_RUN which includes more stringent checks)
---
> ! subroutine imogen_confirmed_run which includes more stringent checks)
181c145,146
< IF (( .NOT. c_emissions) .AND. include_co2) THEN
---
> IF ( ( ( .NOT. c_emissions) .AND. include_co2 ) .OR.                           &
>                                         l_drive_with_global_temps) THEN
198c163
<       co2_ppmv = co2_file_ppmv
---
>       imgn_vars%co2_ppmv(1) = co2_file_ppmv
217a183
>     ! anom = true and anlg = false
220c186
<     ! radiative forcing, Q. Recall that the AM has a "memory" through
---
>     ! radiative forcing, Q. Recall that the anlg model has a "memory" through
222c188
<     ! code, the AM is updated yearly.
---
>     ! code, the anlg model is updated yearly.
226c192
<       CALL radf_co2(co2_ppmv,co2_init_ppmv,q2co2,q_co2)
---
>       CALL radf_co2(imgn_vars%co2_ppmv(1), co2_init_ppmv, q2co2, q_co2)
230c196
<     IF (include_non_co2) THEN
---
>     IF (include_non_co2_radf) THEN
232,234c198
<         current_time%year,q_non_co2,nyr_non_co2,file_non_co2,                  &
<         file_non_co2_vals                                                      &
<       )
---
>         current_time%year,imgn_vars%q_non_co2(1),nyr_non_co2,file_non_co2_radf)
238c202
<       CALL radf_ch4(q_ch4)
---
>       CALL radf_ch4(imgn_vars%ch4_ppbv(1), q_ch4)
241c205
<     q = q_co2 + q_non_co2 + q_ch4
---
>     q_total = q_co2 + imgn_vars%q_non_co2(1) + q_ch4
244c208,209
<     IF (include_co2 .OR. include_non_co2) THEN
---
>     IF (include_co2 .OR. include_non_co2_radf .OR.                             &
>                                      l_drive_with_global_temps) THEN
246,257c211,214
<         q,land_pts,n_olevs,dir_patt,f_ocean,kappa_o,lambda_l,lambda_o,         &
<         mu,dtemp_o,longmin,latmin,longmax,latmax,mm,imgn_drive,ainfo           &
<       )
< 
<       ! Check driving files are compatible.
<       IF ((ABS(longmin_clim - longmin) >= 1.0e-6) .OR.                         &
<          (ABS(latmin_clim - latmin) >= 1.0e-6) .OR.                            &
<          (ABS(longmax_clim - longmax) >= 1.0e-6) .OR.                          &
<          (ABS(latmax_clim - latmax) >= 1.0e-6)) THEN
<         CALL log_fatal("imogen_update_clim",                                   &
<                        'Driving files are incompatible')
<       END IF
---
>         q_total, land_pts, n_olevs, f_ocean, kappa_o, lambda_l, lambda_o,      &
>         mu, imgn_vars%dtemp_o, imgn_vars%dtemp_g(1),                           &
>         mm, imgn_drive, ainfo)
> 
263,274c220,221
<     CALL drdat(                                                                &
<       current_time%year,land_pts,dir_anom,longmin,latmin,longmax,latmax,mm,    &
<       drive_month,imgn_drive,ainfo)
< 
<     ! Check driving files are compatible.
<     IF ((ABS(longmin_clim - longmin) >= 1.0e-6) .OR.                           &
<        (ABS(latmin_clim - latmin) >= 1.0e-6) .OR.                              &
<        (ABS(longmax_clim - longmax) >= 1.0e-6) .OR.                            &
<        (ABS(latmax_clim - latmax) >= 1.0e-6)) THEN
<       CALL log_fatal("imogen_update_clim",                                     &
<                      'Driving files are incompatible')
<     END IF
---
>     CALL drdat(current_time%year)
> 
276c223
< ELSE
---
> ELSE  ! anom=False
278,286c225,232
<   imgn_drive%t1p5m_ij_anom(:,:,:) = 0.0
<   imgn_drive%swdown_ij_anom(:,:,:) = 0.0
<   imgn_drive%lwdown_ij_anom(:,:,:) = 0.0
<   imgn_drive%pstar_ij_anom(:,:,:) = 0.0
<   imgn_drive%rh1p5m_ij_anom(:,:,:) = 0.0
<   imgn_drive%precip_ij_anom(:,:,:) = 0.0
<   imgn_drive%uwind_ij_anom(:,:,:) = 0.0
<   imgn_drive%vwind_ij_anom(:,:,:) = 0.0
<   imgn_drive%diurnal_t1p5m_ij_anom(:,:,:) = 0.0
---
>   imgn_drive%tl1_ij_anom(:,:,:)         = 0.0
>   imgn_drive%swdown_ij_anom(:,:,:)      = 0.0
>   imgn_drive%lwdown_ij_anom(:,:,:)      = 0.0
>   imgn_drive%pstar_ij_anom(:,:,:)       = 0.0
>   imgn_drive%ql1_ij_anom(:,:,:)         = 0.0
>   imgn_drive%precip_ij_anom(:,:,:)      = 0.0
>   imgn_drive%wind_ij_anom(:,:,:)        = 0.0
>   imgn_drive%diurnal_tl1_ij_anom(:,:,:) = 0.0
289,296c235,236
< ! Now incorporate anomalies with climate data.
< ! At this point, have climatology, wg if called and anomalies.
< ! Now calculate the daily values of the driving data.
< ! This is calculated using subroutine clim_calc
< CALL clim_calc(                                                                &
<   land_pts,wgen,mm,md,tmin_wg,                                                 &
<   tmax_wg,swdown_wg,rh1p5m_wg,precip_wg,                                       &
<   nsdmax,progs%seed_rain,lat,LONG, imgn_drive, ainfo)
---
> ! Now calculate the subdaily values of the driving data.
> CALL clim_calc(land_pts, mm, md, nsdmax, progs%seed_rain, imgn_drive, ainfo)
301c241
<     imgn_drive%dctot_co2(l) = trifctltype%cv_gb(l)
---
>     imgn_vars%dctot_co2(l) = trifctltype%cv_gb(l)
308c248
<           imgn_drive%dctot_co2(l) = imgn_drive%dctot_co2(l) +                  &
---
>           imgn_vars%dctot_co2(l) = imgn_vars%dctot_co2(l) +                    &
317,318c257,258
< co2_mmr = co2_ppmv * 44.0 / 28.97 * 1.0e-6
< 
---
> co2_mmr = imgn_vars%co2_ppmv(1) * 44.0 / 28.97 * 1.0e-6
> imgn_vars%imogen_radf(:) = q_total
diff -r vn7.0copy1_c4/src/./control/imogen/ocean_co2.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/imogen/ocean_co2.F90
59c59
<          !IN Array size for FA_OCEAN
---
>          !IN Array size for fa_ocean
diff -r vn7.0copy1_c4/src/./control/imogen/radf_ch4.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/imogen/radf_ch4.F90
11c11
< SUBROUTINE radf_ch4(q_ch4)
---
> SUBROUTINE radf_ch4(ch4_ppbv, q_ch4)
15d14
< USE imogen_progs, ONLY: ch4_ppbv
34a34,36
> REAL, INTENT(IN) ::                                                            &
>   ch4_ppbv              ! CH4 concetration (ppbv)
> 
36c38
<   q_ch4                 ! Forcing due to wetland/rice emissions.
---
>   q_ch4                 ! Forcing due to ch4 emissions (W/m2)
41c43
<                         ! years for which ch4 and N20 concentrations
---
>                         ! years for which ch4 and N2O concentrations
diff -r vn7.0copy1_c4/src/./control/imogen/radf_co2.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/imogen/radf_co2.F90
12c12
< SUBROUTINE radf_co2(co2,co2ref,q2co2,q_co2)
---
> SUBROUTINE radf_co2(co2, co2ref, q2co2, q_co2)
29c29
< REAL ::                                                                        &
---
> REAL, INTENT (IN) ::                                                           &
31c31
<             ! IN CO2 concentration (ppmv).
---
>             ! CO2 concentration (ppmv).
33,36c33,38
<             ! IN Reference CO2 concentration (ppmv).
<   q2co2,                                                                       &
<             ! IN Radiative forcing due to doubling CO2 (W/m2).
<   q_co2     ! OUT Radiative forcing due to CO2 (W/m2).
---
>             ! Reference CO2 concentration (ppmv).
>   q2co2
>             ! Radiative forcing due to doubling CO2 (W/m2).
> 
> REAL, INTENT (OUT) ::                                                          &
>   q_co2     ! Radiative forcing due to CO2 (W/m2).
diff -r vn7.0copy1_c4/src/./control/imogen/radf_non_co2.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/imogen/radf_non_co2.F90
13,14c13
<   year,q,nyr_non_co2,file_non_co2,file_non_co2_vals                            &
< )
---
>   year,q,nyr_non_co2,file_non_co2_radf)
46c45
<            ! IN Number of years for which NON_CO2
---
>            ! IN Number of years for which non_co2
50,54c49
<   file_non_co2_vals   ! IN File of non-co2 radiative forcings
< 
< LOGICAL ::                                                                     &
<   file_non_co2        ! .T. if non_co2 forcings are read in from
<                       ! a data file
---
>   file_non_co2_radf   ! IN File of non-co2 radiative forcings
73,90d67
< DATA years   / 1859,  1875,  1890,  1900,  1917,                               &
<                1935,  1950,  1960,  1970,  1980,                               &
<                1990,  2005,  2020,  2030,  2040,                               &
<                2050,  2060,  2070,  2080,  2090,                               &
<                2100,  679 * 2100 /
< 
< DATA q_non_co2 / 0.0344,0.0557,0.0754,0.0912,0.1176,                           &
<                 0.1483,0.1831,0.2387,0.3480,0.4987,                            &
<                 0.6627,0.8430,0.9225,0.9763,1.0575,                            &
<                 1.1486,1.2316,1.3025,1.3604,1.4102,                            &
<                 1.4602,679 * 1.4602 /
< 
< 
< 
< 
< IF ( .NOT. file_non_co2 .AND. nyr_non_co2 /= 21) THEN
<   CALL log_fatal("RADF_NON_CO2", 'Reset value of nyr_non_co2')
< END IF
100,101c77
< IF (file_non_co2) THEN
<   OPEN(imogen_unit, FILE=file_non_co2_vals,                                    &
---
> OPEN(imogen_unit, FILE=file_non_co2_radf,                                      &
103,107c79,82
<   DO i = 1,nyr_non_co2
<     READ(imogen_unit,*) years(i),q_non_co2(i)
<   END DO
<   CLOSE(imogen_unit)
< END IF
---
> DO i = 1,nyr_non_co2
>   READ(imogen_unit,*) years(i),q_non_co2(i)
> END DO
> CLOSE(imogen_unit)
diff -r vn7.0copy1_c4/src/./control/imogen/solpos.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/imogen/solpos.F90
70c70
<              ! Gamma
---
>              ! Supplement of the longitude of the perihelion
72c72
<              ! e
---
>              ! Eccentricity of the orbit
76c76
<              ! Sin (obliquity)
---
>              ! Sin (obliquity of the orbit)
78a79
>              !
84c85
<       twopi  ! 2pi
---
>       twopi  ! 2 * pi
98a100,102
> 
> ! Calculate the coefficients in the equation of the centre and
> ! thence derive the true anomaly.
118a123,129
> 
> ! sin(solar declination) (UMDP23 Eq 3.1.5)
> ! Solar declination is related to true longitude of earth (lambda) by:
> !  sindec = sin(obliquity) * sin(lambda)
> ! Lambda is counted counterclockwise from vernal equinox
> !  and is related to v (the true anomaly) through
> !  lambda = v + (longitude of perihelion)
Only in vn7.0copy1_c4/src/./control/imogen/var: imogen_clim.F90
Only in vn7.0copy1_c4/src/./control/imogen/var: imogen_map.F90
Only in vn7.0copy1_c4/src/./control/imogen/var: imogen_progs.F90
diff -r vn7.0copy1_c4/src/./control/rivers-standalone/control_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/rivers-standalone/control_mod.F90
1d0
< #if !defined(UM_JULES)
25,26d23
< !   Scalar arguments (INTENT IN)
<     timestep,                                                                  &
28c25
<     psparms, ainfo, progs, fluxes, river )
---
>     psparms, ainfo, progs, fluxes, river, wtrac_jls )
36,39c33,37
< USE p_s_parms,   ONLY: psparms_type
< USE ancil_info,  ONLY: ainfo_type
< USE prognostics, ONLY: progs_type
< USE fluxes_mod,  ONLY: fluxes_type
---
> USE p_s_parms,            ONLY: psparms_type
> USE ancil_info,           ONLY: ainfo_type
> USE prognostics,          ONLY: progs_type
> USE fluxes_mod,           ONLY: fluxes_type
> USE jules_wtrac_type_mod, ONLY: jls_wtrac_type
58a57,58
> USE jules_water_tracers_mod,     ONLY: n_wtrac_jls
> 
64,68d63
< ! Scalar arguments with intent(in)
< !-------------------------------------------------------------------------------
< INTEGER, INTENT(IN) :: timestep    ! IN Atmospheric timestep number.
< 
< !-------------------------------------------------------------------------------
71,75c66,71
< TYPE(psparms_type), INTENT(IN OUT) :: psparms
< TYPE(ainfo_type),   INTENT(IN OUT) :: ainfo
< TYPE(progs_type),   INTENT(IN OUT) :: progs
< TYPE(fluxes_type),  INTENT(IN OUT) :: fluxes
< TYPE(rivers_type),  INTENT(IN OUT) :: river
---
> TYPE(psparms_type),   INTENT(IN OUT) :: psparms
> TYPE(ainfo_type),     INTENT(IN OUT) :: ainfo
> TYPE(progs_type),     INTENT(IN OUT) :: progs
> TYPE(fluxes_type),    INTENT(IN OUT) :: fluxes
> TYPE(rivers_type),    INTENT(IN OUT) :: river
> TYPE(jls_wtrac_type), INTENT(IN OUT) :: wtrac_jls
146c142
<      land_pts,                                                                 &
---
>      land_pts, n_wtrac_jls,                                                    &
148a145
>      wtrac_jls%sub_surf_roff_gb,  wtrac_jls%surf_roff_gb,                      &
153a151,152
>      wtrac_jls%tot_surf_runoff_gb, wtrac_jls%tot_sub_runoff_gb,                &
>      wtrac_jls%acc_lake_evap_gb,                                               &
161c160
<      global_river_rows, nsurft,                                                &
---
>      global_river_rows,                                                        &
163c162
<      fluxes%fqw_surft, delta_lambda, delta_phi, xx_cos_theta_latitude,         &
---
>      fluxes%lake_evap, delta_lambda, delta_phi, xx_cos_theta_latitude,         &
166a166
>      wtrac_jls%lake_evap,                                                      &
169a170
>      wtrac_jls%twatstor, wtrac_jls%smcl_soilt, wtrac_jls%sthu_soilt,           &
172c173
<      riverout_rgrid,                                                           &
---
>      riverout_rgrid, wtrac_jls%inlandout_atm_gb,                               &
185d185
< #endif
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/rivers-standalone: oasis_rivers_control_mod.F90
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/rivers-standalone: oasis_rivers_mod.F90
diff -r vn7.0copy1_c4/src/./control/rivers-standalone/river.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/rivers-standalone/river.F90
1d0
< #if !defined(UM_JULES)
18a18,24
> USE jules_vars_mod, ONLY: mpi_local_comm
> USE mpi, ONLY: mpi_comm_world
> 
> USE jules_model_environment_mod, ONLY: l_oasis_rivers
> USE oasis_rivers_control_mod, ONLY: oasis_init, oasis_finalise,                &
>                                     oasis_send, oasis_receive
> USE oasis_rivers_mod, ONLY: cpl_freq
26c32
< USE model_time_mod, ONLY: timestep, end_of_run
---
> USE model_time_mod, ONLY: end_of_run, oasis_time
39c45,46
<                             rivers_data, rivers
---
>                             rivers_data, rivers,                               &
>                             wtrac_jls_data, wtrac_jls
66,68c73,79
< ! We don't check the error since most (all?) MPI implementations will just
< ! fail if a call is unsuccessful
< CALL mpi_init(ERROR)
---
> CALL oasis_init()
> IF (.NOT. l_oasis_rivers) THEN
>   ! We don't check the error since most (all?) MPI implementations will just
>   ! fail if a call is unsuccessful
>   CALL mpi_init(ERROR)
>   mpi_local_comm = mpi_comm_world
> END IF
98,99c109,111
<           rivers_data, rivers                                                  &
<           )
---
>           rivers_data, rivers,                                                 &
>           wtrac_jls_data, wtrac_jls                                            &
> )
108,112c120,134
<   !-----------------------------------------------------------------------------
<   ! The update of prescribed data is done in two phases
<   !  - Update variables provided by files
<   !-----------------------------------------------------------------------------
<   CALL update_prescribed_variables()
---
>   ! Drive the river model either via forcing files or via coupling exchanges
>   IF (l_oasis_rivers) THEN
>     !  - Update variables by OASIS coupling
>     IF (MOD(oasis_time, cpl_freq) == 0) THEN
>       ! Call first OASIS send and then receive to try to avoid deadlocks
>       CALL oasis_send(rivers,oasis_time)
>       CALL oasis_receive(rivers,oasis_time)
>     END IF
>   ELSE
>     !---------------------------------------------------------------------------
>     ! The update of prescribed data is done in two phases
>     !  - Update variables provided by files
>     !---------------------------------------------------------------------------
>     CALL update_prescribed_variables()
>   END IF
125,126d146
<   !   Scalar arguments (INTENT IN)
<      timestep,                                                                 &
128c148
<      psparms, ainfo, progs, fluxes, rivers )
---
>      psparms, ainfo, progs, fluxes, rivers, wtrac_jls )
152c172
< CALL input_close_all()
---
> IF (.NOT. l_oasis_rivers) CALL input_close_all()
158,159c178,182
< CALL mpi_finalize(ERROR)
< 
---
> IF (l_oasis_rivers) THEN
>   CALL oasis_finalise()
> ELSE
>   CALL mpi_finalize(ERROR)
> END IF
162d184
< #endif
diff -r vn7.0copy1_c4/src/./control/shared/ancil_info.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared/ancil_info.F90
82,83c82,83
<                     !  size of depth dimension in soil carbon (cs)
<                     !  and related respiration variables
---
>                     !  size of depth dimension in soil carbon (cs),
>                     !  nitrogen and related respiration variables
87,90d86
<  ,dim_cs2                                                                      &
<                     !  size used for some variables that are only
<                     !  used with TRIFFID. If not using TRIFFID these
<                     !  variables are set to be smaller to save some space
99,112d94
< !Allocatables not for the TYPE because they do not vary with gridbox
< LOGICAL, ALLOCATABLE ::                                                        &
<   l_lice_surft(:)
<     !  TRUE if a land ice (surface) tile, FALSE otherwise
< 
< INTEGER, ALLOCATABLE ::                                                        &
<   soilt_pts(:),                                                                &
<     !  Number of points for each soil tile
<   surft_pts(:),                                                                &
<     !  Number of land points which include the nth surface type
<   sice_pts_ncat(:)
<     !  Number of points for each sea-ice category
< 
< 
126a109,110
>   LOGICAL, ALLOCATABLE :: l_lice_surft(:)
>     !  TRUE if a land ice (surface) tile, FALSE otherwise
137c121,126
< 
---
>   INTEGER, ALLOCATABLE :: soilt_pts(:)
>     !  Number of points for each soil tile
>   INTEGER, ALLOCATABLE :: surft_pts(:)
>     !  Number of land points which include the nth surface type
>   INTEGER, ALLOCATABLE :: sice_pts_ncat(:)
>     !  Number of points for each sea-ice category
190a180
>   LOGICAL, POINTER :: l_lice_surft(:)
194a185,187
>   INTEGER, POINTER :: soilt_pts(:)
>   INTEGER, POINTER :: surft_pts(:)
>   INTEGER, POINTER :: sice_pts_ncat(:)
251,260c244,247
< !Allocatables not for the TYPE because they do not vary with gridbox
< ALLOCATE( soilt_pts(nsoilt))
< ALLOCATE( l_lice_surft(ntype))
< ALLOCATE( surft_pts(ntype))
< ALLOCATE( sice_pts_ncat(nice))
< soilt_pts(:)     = 0
< l_lice_surft(:)  = .FALSE.
< surft_pts(:)     = 0
< sice_pts_ncat(:) = 0
< 
---
> ALLOCATE(ainfo_data%l_lice_surft(ntype))
> ALLOCATE(ainfo_data%soilt_pts(nsoilt))
> ALLOCATE(ainfo_data%surft_pts(ntype))
> ALLOCATE(ainfo_data%sice_pts_ncat(nice))
288a276,279
> ainfo_data%l_lice_surft(:)             = .FALSE.
> ainfo_data%soilt_pts(:)                = 0
> ainfo_data%surft_pts(:)                = 0
> ainfo_data%sice_pts_ncat(:)            = 0
340,345d330
< !Allocatables not for the TYPE because they do not vary with gridbox
< DEALLOCATE(soilt_pts)
< DEALLOCATE(l_lice_surft)
< DEALLOCATE(surft_pts)
< DEALLOCATE(sice_pts_ncat)
< 
346a332,335
> DEALLOCATE(ainfo_data%l_lice_surft)
> DEALLOCATE(ainfo_data%soilt_pts)
> DEALLOCATE(ainfo_data%surft_pts)
> DEALLOCATE(ainfo_data%sice_pts_ncat)
405a395,398
> ainfo%l_lice_surft => ainfo_data%l_lice_surft
> ainfo%soilt_pts => ainfo_data%soilt_pts
> ainfo%surft_pts => ainfo_data%surft_pts
> ainfo%sice_pts_ncat => ainfo_data%sice_pts_ncat
461a455,458
> NULLIFY(ainfo%l_lice_surft)
> NULLIFY(ainfo%soilt_pts)
> NULLIFY(ainfo%surft_pts)
> NULLIFY(ainfo%sice_pts_ncat)
diff -r vn7.0copy1_c4/src/./control/shared/crop_vars_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared/crop_vars_mod.F90
145c145
<           ! fraction 1-FRACA
---
>           ! fraction 1-fracaero
diff -r vn7.0copy1_c4/src/./control/shared/fluxes.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared/fluxes.F90
43a44
> USE missing_data_mod, ONLY: rmdi
48a50,51
>   ! T if varying grey emissivity is used for surface tile type
>   LOGICAL, ALLOCATABLE :: l_emis_surft_set(:)
49a53
> 
111a116,118
>   REAL(KIND=real_jlslsm), ALLOCATABLE :: snowinc_surft(:,:)
>   !   Increment to snow from sublimation and melting on
>   !   surface tiles (kg m-2 TS-1)
156a164,165
>   REAL(KIND=real_jlslsm), ALLOCATABLE :: lake_evap(:)
>   !   Evaporation from lakes (kg m-2 s-1).
160a170,172
>   ! T if varying grey emissivity is used for surface tile type
>   LOGICAL, POINTER :: l_emis_surft_set(:)
> 
223a236,238
>   REAL(KIND=real_jlslsm), POINTER :: snowinc_surft(:,:)
>   !   Increment to snow from sublimation and melting on
>   !   surface tiles (kg m-2 TS-1)
268c283,285
<   !   Tile roughness lengths for heat and moisture (m).
---
>   !   Tile roughness lengths for heat and moisture (m)
>   REAL(KIND=real_jlslsm), POINTER :: lake_evap(:)
>   !   Evaporation from lakes (kg m-2 s-1).
304a322,325
> ALLOCATE(fluxes_data%l_emis_surft_set(nsurft))
> 
> fluxes_data%l_emis_surft_set(:) = .FALSE.
> 
351a373
> ALLOCATE(fluxes_data%snowinc_surft(land_pts,nsurft))
358a381
> ALLOCATE(fluxes_data%lake_evap(land_pts))
392a416
> fluxes_data%snowinc_surft(:,:)           = 0.0
399a424
> fluxes_data%lake_evap(:)                 = rmdi
426a452
> DEALLOCATE(fluxes_data%l_emis_surft_set)
465a492
> DEALLOCATE(fluxes_data%snowinc_surft)
472a500
> DEALLOCATE(fluxes_data%lake_evap)
505a534
> fluxes%l_emis_surft_set => fluxes_data%l_emis_surft_set
544a574
> fluxes%snowinc_surft => fluxes_data%snowinc_surft
551a582
> fluxes%lake_evap => fluxes_data%lake_evap
580a612
> NULLIFY(fluxes%l_emis_surft_set)
619a652
> NULLIFY(fluxes%snowinc_surft)
626a660
> NULLIFY(fluxes%lake_evap)
diff -r vn7.0copy1_c4/src/./control/shared/jules_chemvars_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared/jules_chemvars_mod.F90
43,44c43,77
< 
< 
---
>   ! Atmospheric deposition variables
>   REAL(KIND=real_jlslsm), ALLOCATABLE :: gc_corr(:,:)
>       ! Stomatal conductance without bare soil evaporation
>   REAL(KIND=real_jlslsm), ALLOCATABLE :: dep_ftl_1_ij(:,:)
>       ! Sensible heat flux (W m-2)
>   REAL(KIND=real_jlslsm), ALLOCATABLE :: dep_sinlat_ij(:,:)
>       ! Sine of latitude
>   REAL(KIND=real_jlslsm), ALLOCATABLE :: dep_surfconc_ij(:,:,:)
>       ! Concentration of chemical tracers in the atmosphere, for the
>       ! calculation of deposition, as mass mixing ratio (kg kg-1).
>   REAL(KIND=real_jlslsm), ALLOCATABLE :: dep_ustar_ij(:,:)
>       ! Friction velocity (m s-1)
>   ! Atmospheric deposition diagnostics
>   REAL(KIND=real_jlslsm), ALLOCATABLE :: dep_ra_ij(:,:,:)
>       ! Aerodynamic resistance, Ra (s m-1)
>   REAL(KIND=real_jlslsm), ALLOCATABLE :: dep_rb_ij(:,:,:)
>       ! Quasi-laminar resistance, Rb (s m-1)
>   REAL(KIND=real_jlslsm), ALLOCATABLE :: dep_rc_ij(:,:,:,:)
>       ! Surface resistance, Rc (s m-1)
>   REAL(KIND=real_jlslsm), ALLOCATABLE :: dep_rc_stom_ij(:,:,:,:)
>       ! Surface resistance, Rc (s m-1)
>       ! stomatal component
>   REAL(KIND=real_jlslsm), ALLOCATABLE :: dep_rc_nonstom_ij(:,:,:,:)
>       ! Surface resistance, Rc (s m-1)
>       ! non-stomatal component
>   REAL(KIND=real_jlslsm), ALLOCATABLE :: dep_vd_ij(:,:,:,:)
>       ! Surface deposition velocity term for trace gases (m s-1)
>   REAL(KIND=real_jlslsm), ALLOCATABLE :: dep_loss_rate_ij(:,:,:)
>       ! First-order loss rate for trace gases (s-1)
>   REAL(KIND=real_jlslsm), ALLOCATABLE :: dep_flux_ij(:,:,:)
>       ! Depostion flux for trace gases (kg m-3 s-1)
>   REAL(KIND=real_jlslsm), ALLOCATABLE :: dep_vd_so4_ij(:,:)
>       ! Surface deposition velocity term for sulphate particles (m s-1)
>   INTEGER,                ALLOCATABLE :: nlev_with_ddep(:,:)
>       ! From UKCA, no of levels over which dry deposition acts
60a94,108
>   REAL(KIND=real_jlslsm), POINTER :: gc_corr(:,:)
>   REAL(KIND=real_jlslsm), POINTER :: dep_ftl_1_ij(:,:)
>   REAL(KIND=real_jlslsm), POINTER :: dep_sinlat_ij(:,:)
>   REAL(KIND=real_jlslsm), POINTER :: dep_surfconc_ij(:,:,:)
>   REAL(KIND=real_jlslsm), POINTER :: dep_ustar_ij(:,:)
>   REAL(KIND=real_jlslsm), POINTER :: dep_ra_ij(:,:,:)
>   REAL(KIND=real_jlslsm), POINTER :: dep_rb_ij(:,:,:)
>   REAL(KIND=real_jlslsm), POINTER :: dep_rc_ij(:,:,:,:)
>   REAL(KIND=real_jlslsm), POINTER :: dep_rc_stom_ij(:,:,:,:)
>   REAL(KIND=real_jlslsm), POINTER :: dep_rc_nonstom_ij(:,:,:,:)
>   REAL(KIND=real_jlslsm), POINTER :: dep_vd_ij(:,:,:,:)
>   REAL(KIND=real_jlslsm), POINTER :: dep_loss_rate_ij(:,:,:)
>   REAL(KIND=real_jlslsm), POINTER :: dep_flux_ij(:,:,:)
>   REAL(KIND=real_jlslsm), POINTER :: dep_vd_so4_ij(:,:)
>   INTEGER               , POINTER :: nlev_with_ddep(:,:)
67c115,116
< SUBROUTINE chemvars_alloc(land_pts,npft, chemvars_data)
---
> SUBROUTINE chemvars_alloc(land_pts, t_i_length, t_j_length, npft, ntype,       &
>                           l_deposition, ndry_dep_species, chemvars_data)
76c125,127
< INTEGER, INTENT(IN) :: land_pts,npft
---
> INTEGER, INTENT(IN) :: land_pts, t_j_length, t_i_length, npft, ntype,          &
>                        ndry_dep_species
> LOGICAL, INTENT(IN) :: l_deposition
78a130
> !Local variables
103d154
< 
105,116c156,211
< chemvars_data%isoprene_gb(:)    = 0.0
< chemvars_data%isoprene_pft(:,:) = 0.0
< chemvars_data%terpene_gb(:)     = 0.0
< chemvars_data%terpene_pft(:,:)  = 0.0
< chemvars_data%methanol_gb(:)    = 0.0
< chemvars_data%methanol_pft(:,:) = 0.0
< chemvars_data%acetone_gb(:)     = 0.0
< chemvars_data%acetone_pft(:,:)  = 0.0
< !  ==== from ozone_vars module ====
< chemvars_data%o3_gb(:)          = 0.0
< chemvars_data%flux_o3_pft(:,:)  = 0.0
< chemvars_data%fo3_pft(:,:)      = 0.0
---
> chemvars_data%isoprene_gb(:)             = 0.0
> chemvars_data%isoprene_pft(:,:)          = 0.0
> chemvars_data%terpene_gb(:)              = 0.0
> chemvars_data%terpene_pft(:,:)           = 0.0
> chemvars_data%methanol_gb(:)             = 0.0
> chemvars_data%methanol_pft(:,:)          = 0.0
> chemvars_data%acetone_gb(:)              = 0.0
> chemvars_data%acetone_pft(:,:)           = 0.0
> !           ==== from ozone_vars module ====
> chemvars_data%o3_gb(:)                   = 0.0
> chemvars_data%flux_o3_pft(:,:)           = 0.0
> chemvars_data%fo3_pft(:,:)               = 0.0
> 
> ! ==== for atmospheric deposition ====
> ALLOCATE(chemvars_data%gc_corr(land_pts,npft))
> ALLOCATE(chemvars_data%dep_ftl_1_ij(t_i_length,t_j_length))
> ALLOCATE(chemvars_data%dep_sinlat_ij(t_i_length,t_j_length))
> ALLOCATE(chemvars_data%dep_ustar_ij(t_i_length,t_j_length))
> 
> chemvars_data%gc_corr(:,:)               = 0.0
> chemvars_data%dep_ftl_1_ij(:,:)          = 0.0
> chemvars_data%dep_sinlat_ij(:,:)         = 0.0
> chemvars_data%dep_ustar_ij(:,:)          = 0.0
> 
> IF (l_deposition) THEN
>   ALLOCATE(chemvars_data%dep_surfconc_ij(t_i_length,t_j_length,                &
>     ndry_dep_species))
>   ALLOCATE(chemvars_data%nlev_with_ddep(t_i_length,t_j_length))
>   ALLOCATE(chemvars_data%dep_ra_ij(t_i_length,t_j_length,ntype))
>   ALLOCATE(chemvars_data%dep_rb_ij(t_i_length,t_j_length,ndry_dep_species))
>   ALLOCATE(chemvars_data%dep_rc_ij(t_i_length,t_j_length,ntype,                &
>     ndry_dep_species))
>   ALLOCATE(chemvars_data%dep_rc_stom_ij(t_i_length,t_j_length,ntype,           &
>     ndry_dep_species))
>   ALLOCATE(chemvars_data%dep_rc_nonstom_ij(t_i_length,t_j_length,ntype,        &
>     ndry_dep_species))
>   ALLOCATE(chemvars_data%dep_vd_ij(t_i_length,t_j_length,ntype,                &
>     ndry_dep_species))
>   ALLOCATE(chemvars_data%dep_loss_rate_ij(t_i_length,t_j_length,               &
>     ndry_dep_species))
>   ALLOCATE(chemvars_data%dep_vd_so4_ij(t_i_length,t_j_length))
>   ALLOCATE(chemvars_data%dep_flux_ij(t_i_length,t_j_length,ndry_dep_species))
> 
>   chemvars_data%nlev_with_ddep(:,:)        = 0
>   chemvars_data%dep_ra_ij(:,:,:)           = 0.0
>   chemvars_data%dep_rb_ij(:,:,:)           = 0.0
>   chemvars_data%dep_rc_ij(:,:,:,:)         = 0.0
>   chemvars_data%dep_rc_stom_ij(:,:,:,:)    = 0.0
>   chemvars_data%dep_rc_nonstom_ij(:,:,:,:) = 0.0
>   chemvars_data%dep_vd_ij(:,:,:,:)         = 0.0
>   chemvars_data%dep_loss_rate_ij(:,:,:)    = 0.0
>   chemvars_data%dep_vd_so4_ij(:,:)         = 0.0
>   chemvars_data%dep_surfconc_ij(:,:,:)     = 0.0
>   chemvars_data%dep_flux_ij(:,:,:)         = 0.0
> END IF
> 
159a255,276
> ! ==== for atmospheric deposition ====
> DEALLOCATE(chemvars_data%gc_corr)
> DEALLOCATE(chemvars_data%dep_ftl_1_ij)
> DEALLOCATE(chemvars_data%dep_sinlat_ij)
> DEALLOCATE(chemvars_data%dep_ustar_ij)
> 
> ! Following prognostics TYPE, use chemvars_data%dep_ra_ij
> ! to DEALLOCATE deposition diagnostics
> IF ( ALLOCATED(chemvars_data%dep_ra_ij) ) THEN
>   DEALLOCATE(chemvars_data%nlev_with_ddep)
>   DEALLOCATE(chemvars_data%dep_ra_ij)
>   DEALLOCATE(chemvars_data%dep_rb_ij)
>   DEALLOCATE(chemvars_data%dep_rc_ij)
>   DEALLOCATE(chemvars_data%dep_rc_stom_ij)
>   DEALLOCATE(chemvars_data%dep_rc_nonstom_ij)
>   DEALLOCATE(chemvars_data%dep_vd_ij)
>   DEALLOCATE(chemvars_data%dep_loss_rate_ij)
>   DEALLOCATE(chemvars_data%dep_vd_so4_ij)
>   DEALLOCATE(chemvars_data%dep_surfconc_ij)
>   DEALLOCATE(chemvars_data%dep_flux_ij)
> END IF
> 
196,206c313,345
< chemvars%isoprene_gb  => chemvars_data%isoprene_gb
< chemvars%isoprene_pft => chemvars_data%isoprene_pft
< chemvars%terpene_gb   => chemvars_data%terpene_gb
< chemvars%terpene_pft  => chemvars_data%terpene_pft
< chemvars%methanol_gb  => chemvars_data%methanol_gb
< chemvars%methanol_pft => chemvars_data%methanol_pft
< chemvars%acetone_gb   => chemvars_data%acetone_gb
< chemvars%acetone_pft  => chemvars_data%acetone_pft
< chemvars%o3_gb        => chemvars_data%o3_gb
< chemvars%flux_o3_pft  => chemvars_data%flux_o3_pft
< chemvars%fo3_pft      => chemvars_data%fo3_pft
---
> chemvars%isoprene_gb       => chemvars_data%isoprene_gb
> chemvars%isoprene_pft      => chemvars_data%isoprene_pft
> chemvars%terpene_gb        => chemvars_data%terpene_gb
> chemvars%terpene_pft       => chemvars_data%terpene_pft
> chemvars%methanol_gb       => chemvars_data%methanol_gb
> chemvars%methanol_pft      => chemvars_data%methanol_pft
> chemvars%acetone_gb        => chemvars_data%acetone_gb
> chemvars%acetone_pft       => chemvars_data%acetone_pft
> chemvars%o3_gb             => chemvars_data%o3_gb
> chemvars%flux_o3_pft       => chemvars_data%flux_o3_pft
> chemvars%fo3_pft           => chemvars_data%fo3_pft
> 
> !      ==== for atmospheric deposition ====
> chemvars%gc_corr           => chemvars_data%gc_corr
> chemvars%dep_ftl_1_ij      => chemvars_data%dep_ftl_1_ij
> chemvars%dep_sinlat_ij     => chemvars_data%dep_sinlat_ij
> chemvars%dep_ustar_ij      => chemvars_data%dep_ustar_ij
> 
> ! Following prognostics TYPE, use chemvars_data%dep_ra_ij
> ! to associate pointers to deposition diagnostics
> IF ( ALLOCATED(chemvars_data%dep_ra_ij) ) THEN
>   chemvars%nlev_with_ddep    => chemvars_data%nlev_with_ddep
>   chemvars%dep_ra_ij         => chemvars_data%dep_ra_ij
>   chemvars%dep_rb_ij         => chemvars_data%dep_rb_ij
>   chemvars%dep_rc_ij         => chemvars_data%dep_rc_ij
>   chemvars%dep_rc_stom_ij    => chemvars_data%dep_rc_stom_ij
>   chemvars%dep_rc_nonstom_ij => chemvars_data%dep_rc_nonstom_ij
>   chemvars%dep_vd_ij         => chemvars_data%dep_vd_ij
>   chemvars%dep_loss_rate_ij  => chemvars_data%dep_loss_rate_ij
>   chemvars%dep_vd_so4_ij     => chemvars_data%dep_vd_so4_ij
>   chemvars%dep_surfconc_ij   => chemvars_data%dep_surfconc_ij
>   chemvars%dep_flux_ij       => chemvars_data%dep_flux_ij
> END IF
248a388,408
> 
> ! ==== for atmospheric deposition ====
> ! Deposition diagnostics
> NULLIFY(chemvars%nlev_with_ddep)
> NULLIFY(chemvars%dep_flux_ij)
> NULLIFY(chemvars%dep_ra_ij)
> NULLIFY(chemvars%dep_rb_ij)
> NULLIFY(chemvars%dep_rc_ij)
> NULLIFY(chemvars%dep_rc_stom_ij)
> NULLIFY(chemvars%dep_rc_nonstom_ij)
> NULLIFY(chemvars%dep_vd_ij)
> NULLIFY(chemvars%dep_loss_rate_ij)
> NULLIFY(chemvars%dep_vd_so4_ij)
> ! Deposition variables
> NULLIFY(chemvars%dep_surfconc_ij)
> 
> ! Deposition variables
> NULLIFY(chemvars%gc_corr)
> NULLIFY(chemvars%dep_ftl_1_ij)
> NULLIFY(chemvars%dep_sinlat_ij)
> NULLIFY(chemvars%dep_ustar_ij)
diff -r vn7.0copy1_c4/src/./control/shared/jules_deposition_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared/jules_deposition_mod.F90
9a10,11
> MODULE jules_deposition_mod
> 
23c25
< MODULE jules_deposition_mod
---
> USE max_dimensions,          ONLY: ndep_species_max
27c29,33
< USE um_types, ONLY: real_jlslsm
---
> USE ereport_mod,             ONLY: ereport
> 
> USE jules_print_mgr,         ONLY: jules_message, jules_print
> 
> USE um_types,                ONLY: real_jlslsm
42,43c48,52
<   dry_dep_ukca_jules = 1
<     ! Deposition is calculated in JULES using code modelled on UKCA.
---
>   dry_dep_model_ukca  = 1,                                                     &
>     ! Deposition is calculated in JULES using UKCA routines.
>   dry_dep_model_jules = 2
>     ! Deposition is calculated in JULES using code modelled on UKCA and
>     ! with restrictions on pft configuations and ordering removed.
67c76
<   l_deposition = .FALSE.,                                                      &
---
>   l_deposition = .FALSE. ,                                                     &
69c78
<   l_deposition_flux = .FALSE.
---
>   l_deposition_flux = .FALSE. ,                                                &
73a83,89
>   l_deposition_from_ukca = .FALSE. ,                                           &
>     ! Switch to call JULES deposition routines from ukca_chemistry_ctl
>   l_deposition_gc_corr = .FALSE.
>     ! Switch to use stomatal conductance corrected for bare soil evaporation
>     ! Only used if deposition is requested.
>     ! T means stomatal conductance corrected for bare soil evaporation
>     ! F means uses current incorrect treatment of stomatal conductance
81a98,107
> REAL(KIND=real_jlslsm), PARAMETER ::                                           &
>   dep_rnull = 1.0e+30,                                                         &
>     ! Infinite resistance to deposition (1/dep_rnull~0)
>   dep_rzero =  0.0,                                                            &
>     ! Zero resistance to deposition
>   dep_rten  = 10.0,                                                            &
>     ! Resistance of 10 s m-1
>   glmin     =  1.0e-6
>     ! Minimum leaf conductance (m s-1)
> 
83c109
<   l_ukca_ddep_lev1  = .FALSE.
---
>   l_ukca_ddep_lev1  = .FALSE. ,                                                &
96a123,130
>   l_ukca_dry_dep_so2wet = .FALSE. ,                                            &
>     ! True if considering the impact of surface wetness on dry deposition
>   l_ukca_ddepo3_ocean =.FALSE. ,                                               &
>     ! when true using oceanic O3 dry-deposition scheme
>     ! of Luhar et al. (2018)
>   l_ukca_emsdrvn_ch4 =.FALSE.
>     ! when true using emission-driven CH4 scheme
> 
101,110c135,138
<   dzl_const, dry_dep_model, l_deposition, l_deposition_flux,                   &
<   l_ukca_ddep_lev1, ndry_dep_species, tundra_s_limit
< 
< !-----------------------------------------------------------------------------
< ! Variables for the dry deposition scheme(s).
< !-----------------------------------------------------------------------------
< REAL(KIND=real_jlslsm), ALLOCATABLE ::                                         &
<   tracer_field(:,:)
<     ! Concentration of chemical tracers in the atmosphere, for the
<     ! calculation of deposition, as mass mixing ratio (kg kg-1).
---
>   dry_dep_model, dzl_const, l_deposition, l_deposition_flux,                   &
>   l_deposition_from_ukca, l_deposition_gc_corr, l_ukca_ddep_lev1,              &
>   l_ukca_ddepo3_ocean, l_ukca_dry_dep_so2wet, l_ukca_emsdrvn_ch4,              &
>   ndry_dep_species, tundra_s_limit
115,166d142
< 
< SUBROUTINE jules_deposition_alloc(land_pts)
< 
< !No USE statements other than Dr Hook
< USE parkind1,    ONLY: jprb, jpim
< USE yomhook,     ONLY: lhook, dr_hook
< 
< USE ereport_mod, ONLY: ereport
< 
< IMPLICIT NONE
< 
< !Arguments
< INTEGER, INTENT(IN) :: land_pts
< 
< INTEGER :: errcode
< 
< INTEGER(KIND=jpim), PARAMETER :: zhook_in  = 0
< INTEGER(KIND=jpim), PARAMETER :: zhook_out = 1
< REAL(KIND=jprb)               :: zhook_handle
< 
< CHARACTER(LEN=*), PARAMETER :: RoutineName='JULES_DEPOSITION_ALLOC'
< 
< !End of header
< 
< IF (lhook) CALL dr_hook(ModuleName//':'//RoutineName,zhook_in,zhook_handle)
< 
< errcode = 101
< 
< IF ( l_deposition ) THEN
< 
<   ! Model-dependent variables.
<   SELECT CASE ( dry_dep_model )
<   CASE ( dry_dep_ukca_jules )
<     ! Deposition variables.
<     IF ( l_deposition_flux ) THEN
<       ALLOCATE( tracer_field(land_pts,ndry_dep_species))
< 
<       tracer_field(:,:) = 0.0
< 
<     END IF  !  l_deposition_flux
<   CASE DEFAULT
<     CALL ereport ("Invalid value for dry_dep_model. ", errcode,                &
<                    "Please check jules_deposition_alloc")
<   END SELECT
< END IF  !  l_deposition
< 
< 
< IF (lhook) CALL dr_hook(ModuleName//':'//RoutineName,zhook_out,zhook_handle)
< RETURN
< END SUBROUTINE jules_deposition_alloc
< 
< #if !defined(RIVERS_ONLY)
174,180d149
< USE max_dimensions,          ONLY: ndep_species_max
< 
< USE jules_surface_mod, ONLY:                                                   &
<   l_aggregate
< 
< USE ereport_mod, ONLY: ereport
< 
190a160
> ! Checks on l_deposition = FALSE
191a162,170
>   ! l_deposition_flux cannot be TRUE
>   IF ( l_deposition_flux ) THEN
>     errorstatus = 100 !  a hard error
>     WRITE(jules_message,'(A,L1)') "Deposition switch l_deposition_flux is " // &
>        "not available if l_deposition = FALSE. l_deposition_flux = ",          &
>        l_deposition_flux
>     CALL ereport( TRIM(routineName), errorstatus, jules_message)
>   END IF
> 
200,201c179,180
< CASE ( dry_dep_ukca_jules )
<   !  Acceptable values.
---
> CASE ( dry_dep_model_ukca, dry_dep_model_jules )
>   ! Acceptable values.
203,205c182,185
<   errorstatus = 100
<   CALL ereport( TRIM(routineName), errorstatus,                                &
<                 "Invalid value for dry_dep_model." )
---
>   errorstatus = 100 !  a hard error
>   WRITE(jules_message,'(A,I2)') "Valid values for dry_dep_model: 1-2. Used ",  &
>         dry_dep_model
>   CALL ereport( TRIM(routineName), errorstatus, jules_message)
209,217d188
< ! Deposition requires a tiled model.
< !-----------------------------------------------------------------------------
< IF ( l_aggregate ) THEN
<   errorstatus = 100
<   CALL ereport( TRIM(routineName), errorstatus,                                &
<                 "Deposition cannot use aggregate tiles." )
< END IF
< 
< !-----------------------------------------------------------------------------
221,224c192,196
<   errorstatus = 100  !  a hard error
<   CALL ereport( TRIM(routineName), errorstatus,                                &
<                 "Number of species must be in range 1 to " //                  &
<                 "ndep_species_max." )
---
>   errorstatus = 100 !  a hard error
>   WRITE(jules_message,'(A,I3,A,I3)')                                           &
>         "Number of species must be in range 1 to ", ndep_species_max,          &
>         ". Used ", ndry_dep_species
>   CALL ereport( TRIM(routineName), errorstatus, jules_message)
239c211
< IF ( ABS( tundra_s_limit - rmdi ) < EPSILON(tundra_s_limit) ) THEN
---
> IF ( tundra_s_limit < -1.0 .OR. tundra_s_limit > 1.0 ) THEN
242c214,215
<                 "tundra_s_limit must be provided." )
---
>                 "tundra_s_limit (as sine of latitude) must lie between -1 " // &
>                 "and +1." )
246d218
< #endif
252,253d223
< USE jules_print_mgr,         ONLY: jules_print
< 
264c234
< WRITE(lineBuffer,"(A,L1)") '  l_deposition      = ', l_deposition
---
> WRITE(lineBuffer,"(A,L1)") '  l_deposition          = ', l_deposition
267c237
< WRITE(lineBuffer,"(A,L1)") '  l_deposition_flux = ', l_deposition_flux
---
> WRITE(lineBuffer,"(A,L1)") '  l_deposition_flux     = ', l_deposition_flux
270c240
< WRITE(lineBuffer,"(A,I0)") '  dry_dep_model     = ', dry_dep_model
---
> WRITE(lineBuffer,"(A,I0)") '  dry_dep_model         = ', dry_dep_model
273c243
< WRITE(lineBuffer,"(A,L1)") '  l_ukca_ddep_lev1  = ', l_ukca_ddep_lev1
---
> WRITE(lineBuffer,"(A,L1)") '  l_deposition_gc_corr  = ', l_deposition_gc_corr
276c246
< WRITE(lineBuffer,"(A,I0)") '  ndry_dep_species  = ', ndry_dep_species
---
> WRITE(lineBuffer,"(A,L1)") '  l_deposition_from_ukca= ', l_deposition_from_ukca
279c249,264
< WRITE(lineBuffer,"(A,G11.4E2)") '  tundra_s_limit    = ', tundra_s_limit
---
> WRITE(lineBuffer,"(A,L1)") '  l_ukca_ddep_lev1      = ', l_ukca_ddep_lev1
> CALL jules_print(RoutineName, lineBuffer)
> 
> WRITE(lineBuffer,"(A,L1)") '  l_ukca_dry_dep_so2wet = ', l_ukca_dry_dep_so2wet
> CALL jules_print(RoutineName, lineBuffer)
> 
> WRITE(lineBuffer,"(A,L1)") '  l_ukca_ddepo3_ocean   = ', l_ukca_ddepo3_ocean
> CALL jules_print(RoutineName, lineBuffer)
> 
> WRITE(lineBuffer,"(A,L1)") '  l_ukca_emsdrvn_ch4    = ', l_ukca_emsdrvn_ch4
> CALL jules_print(RoutineName, lineBuffer)
> 
> WRITE(lineBuffer,"(A,I0)") '  ndry_dep_species      = ', ndry_dep_species
> CALL jules_print(RoutineName, lineBuffer)
> 
> WRITE(lineBuffer,"(A,G11.4E2)") '  tundra_s_limit        = ', tundra_s_limit
286a272,391
> 
> #if defined(UM_JULES) && !defined(LFRIC)
> SUBROUTINE read_nml_jules_deposition (unitnumber)
> 
> ! Description:
> !  Read the JULES_DEPOSITION namelist
> 
> USE setup_namelist,   ONLY: setup_nml_type
> USE check_iostat_mod, ONLY: check_iostat
> USE UM_parcore,       ONLY: mype
> 
> USE parkind1,         ONLY: jprb, jpim
> USE yomhook,          ONLY: lhook, dr_hook
> 
> USE errormessagelength_mod, ONLY: errormessagelength
> 
> IMPLICIT NONE
> 
> ! Subroutine arguments
> INTEGER, INTENT(IN) :: unitnumber
> 
> INTEGER :: my_comm
> INTEGER :: mpl_nml_type
> INTEGER :: ErrorStatus
> INTEGER :: icode
> REAL(KIND=jprb) :: zhook_handle
> 
> CHARACTER(LEN=*), PARAMETER :: RoutineName='READ_NML_JULES_DEPOSITION'
> 
> CHARACTER(LEN=errormessagelength) :: iomessage
> 
> INTEGER(KIND=jpim), PARAMETER :: zhook_in  = 0
> INTEGER(KIND=jpim), PARAMETER :: zhook_out = 1
> 
> ! set number of each type of variable in my_namelist type
> INTEGER, PARAMETER :: no_of_types = 3
> INTEGER, PARAMETER :: n_int  = 2
> INTEGER, PARAMETER :: n_real = 2
> INTEGER, PARAMETER :: n_log  = 8
> 
> TYPE :: my_namelist
>   SEQUENCE
>   INTEGER :: dry_dep_model
>   INTEGER :: ndry_dep_species
>   REAL(KIND=real_jlslsm) :: dzl_const
>   REAL(KIND=real_jlslsm) :: tundra_s_limit
>   LOGICAL :: l_deposition
>   LOGICAL :: l_deposition_flux
>   LOGICAL :: l_deposition_from_ukca
>   LOGICAL :: l_deposition_gc_corr
>   LOGICAL :: l_ukca_ddep_lev1
>   LOGICAL :: l_ukca_ddepo3_ocean
>   LOGICAL :: l_ukca_dry_dep_so2wet
>   LOGICAL :: l_ukca_emsdrvn_ch4
> END TYPE my_namelist
> 
> TYPE (my_namelist) :: my_nml
> 
> IF (lhook) CALL dr_hook(ModuleName//':'//RoutineName,zhook_in,zhook_handle)
> 
> CALL gc_get_communicator(my_comm, icode)
> 
> CALL setup_nml_type(no_of_types, mpl_nml_type, n_int_in = n_int,               &
>                     n_real_in = n_real, n_log_in = n_log)
> 
> IF (mype == 0) THEN
> 
>   READ (UNIT = unitnumber, NML = jules_deposition, IOSTAT = errorstatus,       &
>         IOMSG = iomessage)
>   CALL check_iostat(errorstatus, "namelist jules_deposition", iomessage)
> 
>   my_nml % l_deposition          = l_deposition
>   my_nml % l_deposition_flux     = l_deposition_flux
>   my_nml % l_deposition_gc_corr  = l_deposition_gc_corr
>   my_nml % l_deposition_from_ukca= l_deposition_from_ukca
>   my_nml % l_ukca_ddep_lev1      = l_ukca_ddep_lev1
>   my_nml % l_ukca_dry_dep_so2wet = l_ukca_dry_dep_so2wet
>   my_nml % l_ukca_ddepo3_ocean   = l_ukca_ddepo3_ocean
>   my_nml % l_ukca_emsdrvn_ch4    = l_ukca_emsdrvn_ch4
>     ! end of logicals
>   my_nml % dry_dep_model         = dry_dep_model
>   my_nml % ndry_dep_species      = ndry_dep_species
>     ! end of integers
>   my_nml % dzl_const             = dzl_const
>   my_nml % tundra_s_limit        = tundra_s_limit
> 
> END IF
> 
> CALL mpl_bcast(my_nml,1,mpl_nml_type,0,my_comm,icode)
> 
> IF (mype /= 0) THEN
> 
>   l_deposition                   = my_nml % l_deposition
>   l_deposition_flux              = my_nml % l_deposition_flux
>   l_deposition_gc_corr           = my_nml % l_deposition_gc_corr
>   l_deposition_from_ukca         = my_nml % l_deposition_from_ukca
>   l_ukca_ddep_lev1               = my_nml % l_ukca_ddep_lev1
>   l_ukca_dry_dep_so2wet          = my_nml % l_ukca_dry_dep_so2wet
>   l_ukca_ddepo3_ocean            = my_nml % l_ukca_ddepo3_ocean
>   l_ukca_emsdrvn_ch4             = my_nml % l_ukca_emsdrvn_ch4
>     ! end of logicals
>   dry_dep_model                  = my_nml % dry_dep_model
>   ndry_dep_species               = my_nml % ndry_dep_species
>     ! end of integers
>   dzl_const                      = my_nml % dzl_const
>   tundra_s_limit                 = my_nml % tundra_s_limit
>     ! end of reals
> 
> END IF
> 
> CALL mpl_type_free(mpl_nml_type,icode)
> 
> IF (lhook) CALL dr_hook(ModuleName//':'//RoutineName,zhook_out,zhook_handle)
> 
> RETURN
> END SUBROUTINE read_nml_jules_deposition
> 
> #endif
> 
> ! ------------------------------------------------------------------------------
diff -r vn7.0copy1_c4/src/./control/shared/jules_hydrology_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared/jules_hydrology_mod.F90
20a21
> USE missing_data_mod, ONLY: rmdi, imdi
36c37
<       ! Switch for slope dependent s_pdm in PDM hydrology
---
>       ! Switch for slope-dependent s_pdm in PDM hydrology
54c55
<   dz_pdm = 1.0,                                                                &
---
>   dz_pdm = rmdi,                                                               &
56c57
<   b_pdm  = 1.0,                                                                &
---
>   b_pdm  = rmdi,                                                               &
58,62c59,64
<   s_pdm = 0.0,                                                                 &
< ! So/Smax factor for PDM
<    slope_pdm_max = 6.0
< ! Maximum topographic slope (deg) in the slope dependent s_pdm
< ! linear function
---
>   s_pdm = rmdi,                                                                &
>       ! So/Smax factor for PDM
>   slope_pdm_max = rmdi
>       ! Maximum topographic slope (deg) in the slope dependent s_pdm
>       ! linear function
> 
67c69
<   nfita = 20
---
>   nfita = imdi
68a71
> 
70c73
<   ti_max = 10.0,                                                               &
---
>   ti_max = rmdi,                                                               &
72c75
<   ti_wetl = 1.5,                                                               &
---
>   ti_wetl = rmdi,                                                              &
75c78
<   zw_max = 6.0
---
>   zw_max = rmdi
76a80
> 
89a94,95
> !#############################################################################
> 
107a114,115
> CHARACTER(LEN=*), PARAMETER :: RoutineName = 'CHECK_JULES_HYDROLOGY'
> 
113c121
<   CALL ereport("check_jules_hydrology", errorstatus,                           &
---
>   CALL ereport(RoutineName, errorstatus,                                       &
116a125,197
> !-----------------------------------------------------------------------------
> ! Check that values required with PDM have been provided.
> !-----------------------------------------------------------------------------
> IF ( l_pdm ) THEN
> 
>   IF ( ABS( b_pdm - rmdi ) < EPSILON(1.0) ) THEN
>     errorstatus = 101  !  a hard error
>     CALL ereport(RoutineName, errorstatus,                                     &
>                  "No value for b_pdm")
>   END IF
> 
>   IF ( ABS( dz_pdm - rmdi ) < EPSILON(1.0) ) THEN
>     errorstatus = 101  !  a hard error
>     CALL ereport(RoutineName, errorstatus,                                     &
>                  "No value for dz_pdm")
>   END IF
> 
>   IF ( l_spdmvar ) THEN
>     IF ( ABS( slope_pdm_max - rmdi ) < EPSILON(1.0) ) THEN
>       errorstatus = 101  !  a hard error
>       CALL ereport(RoutineName, errorstatus,                                   &
>                    "No value for slope_pdm_max")
>     END IF
>   ELSE
>     IF ( ABS( s_pdm - rmdi ) < EPSILON(1.0) ) THEN
>       errorstatus = 101  !  a hard error
>       CALL ereport(RoutineName, errorstatus,                                   &
>                    "No value for s_pdm")
>     END IF
>   END IF  !  l_spdmvar
> 
> ELSE
> 
>   ! PDM is not selected. Check that a related switch is consistent.
>   IF ( l_spdmvar ) THEN
>     errorstatus = 101  !  a hard error
>     CALL ereport(RoutineName, errorstatus,                                     &
>                  "l_spdmvar must be FALSE if l_pdm is FALSE.")
>   END IF
> 
> END IF  !  l_pdm
> 
> !-----------------------------------------------------------------------------
> ! Check that values required with TOPMODEL have been provided.
> !-----------------------------------------------------------------------------
> IF ( l_top ) THEN
> 
>   IF ( nfita == imdi ) THEN
>     errorstatus = 101  !  a hard error
>     CALL ereport(RoutineName, errorstatus,                                     &
>                  "No value for nfita")
>   END IF
> 
>   IF ( ABS( ti_max - rmdi ) < EPSILON(1.0) ) THEN
>     errorstatus = 101  !  a hard error
>     CALL ereport(RoutineName, errorstatus,                                     &
>                  "No value for ti_max")
>   END IF
> 
>   IF ( ABS( ti_wetl - rmdi ) < EPSILON(1.0) ) THEN
>     errorstatus = 101  !  a hard error
>     CALL ereport(RoutineName, errorstatus,                                     &
>                  "No value for ti_wetl")
>   END IF
> 
>   IF ( ABS( zw_max - rmdi ) < EPSILON(1.0) ) THEN
>     errorstatus = 101  !  a hard error
>     CALL ereport(RoutineName, errorstatus,                                     &
>                  "No value for zw_max")
>   END IF
> 
> END IF  !  l_top
> 
118a200
> !#############################################################################
diff -r vn7.0copy1_c4/src/./control/shared/jules_model_environment_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared/jules_model_environment_mod.F90
40a41,43
> LOGICAL, PUBLIC :: l_oasis_rivers  = .FALSE.
>                              ! Internal switch to indicate OASIS-Rivers coupling
> 
73c76,77
<   um_jules         = 1
---
>   um_jules         = 1,                                                        &
>   oasis_coupler    = 2
89a94,101
> #elif defined(RIVER_CPL)
> IF ( l_jules_parent /= oasis_coupler ) THEN
>   errcode = 20
>   WRITE(jules_message,'(A,I0)')                                                &
>      "l_jules_parent should be 2 for OASIS coupler. l_jules_parent = ",        &
>      l_jules_parent
>   CALL ereport(RoutineName, errcode, jules_message )
> END IF
92c104
<   errcode = 20
---
>   errcode = 30
101c113
<   errcode = 30
---
>   errcode = 40
114a127,139
>   IF ( l_jules_parent == oasis_coupler ) THEN
>     IF ( lsm_id /= rivers ) THEN
>       errcode = 50
>       WRITE(jules_message,'(A)')                                               &
>          "OASIS coupler can only be used with Rivers-only."
>       CALL ereport(RoutineName, errcode, jules_message )
>     ELSE IF ( .NOT. l_oasis_rivers ) THEN
>       errcode = 60
>       WRITE(jules_message,'(A)')                                               &
>          "Internal switch l_oasis_rivers has been set incorrectly"
>       CALL ereport(RoutineName, errcode, jules_message )
>     END IF
>   END IF
116c141
<   errcode = 40
---
>   errcode = 70
diff -r vn7.0copy1_c4/src/./control/shared/jules_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared/jules_mod.F90
205a206,208
> ! MPI communicator for river coupled jobs
> INTEGER :: mpi_local_comm
> 
diff -r vn7.0copy1_c4/src/./control/shared/jules_print_mgr.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared/jules_print_mgr.F90
38c38
< CHARACTER(LEN=1)              :: newline
---
> CHARACTER(LEN=1)   :: newline = NEW_LINE('a')
50,52d49
< 
< ! Set newline character
< newline = NEW_LINE('a')
diff -r vn7.0copy1_c4/src/./control/shared/jules_rivers_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared/jules_rivers_mod.F90
9c9
< !-----------------------------------------------------------------------------
---
> !------------------------------------------------------------------------------
20c20
< !-----------------------------------------------------------------------------
---
> !------------------------------------------------------------------------------
26,27d25
< USE jules_irrig_mod, ONLY: l_irrig_limit
< 
32c30
< !-----------------------------------------------------------------------------
---
> !------------------------------------------------------------------------------
34c32
< !-----------------------------------------------------------------------------
---
> !------------------------------------------------------------------------------
36c34
< !-----------------------------------------------------------------------------
---
> !------------------------------------------------------------------------------
51,58c49,58
< ! The values of river_mouth and inland_drainage should differ and should not
< ! be in the range 1:SIZE(flow_dir_delta,1), i.e. not in the range of values
< ! used to encode the flow directions.
< INTEGER, PARAMETER :: river_mouth = 9
<   ! The value of the flow direction field that indicates a river mouth.
< INTEGER, PARAMETER :: inland_drainage = 10
<   ! The value of the flow direction field that indicates an inland drainage
<   ! point, i.e. an endorheic catchment.
---
> INTEGER, PARAMETER :: inland_drainage = -10
>     ! The value of nextx_grid that indicates an inland drainage point, i.e. an
>     ! endorheic catchment. This should be <0 and should not be either of sea or
>     ! river_mouth, nor should it appear in flow_dir_river_edge.
> 
> INTEGER, PARAMETER :: river_mouth = -9
>   ! The value of nextx_grid that indicates a river mouth. This should be <0 and
>   ! should not be either of sea or inland_drainage, nor should it appear in
>   ! flow_dir_river_edge.
> 
60,63c60,65
<     ! Value used to indicate that a river point is sea, for the UM.
<     ! This should be <1, should not equal -1*river_mouth nor
<     ! -1*inland_drainage, nor should it be in the range
<     ! -1:-SIZE(flow_dir_delta,1).
---
>     ! The value of flow direction that is used to indicate a sea point.
>     ! This value is used to set the flow direction variable in this code, but
>     ! it need not be the value used to indicate sea in the input ancillary
>     ! file. This value should be <1 and must not be any of flow_dir_river(1:8),
>     ! dir_mouth or dir_inland_drainage.
>     ! This value is also used to indicate sea in river_mask.
73c75
< !-----------------------------------------------------------------------------
---
> !------------------------------------------------------------------------------
76c78
< ! The values in the flow direction ancillary layer must be consistent with the
---
> ! The values in any flow direction ancillary layer must be consistent with the
97c99
< !-----------------------------------------------------------------------------
---
> !------------------------------------------------------------------------------
99c101
< !-----------------------------------------------------------------------------
---
> !------------------------------------------------------------------------------
104c106
<    ,l_inland = .FALSE.
---
>    ,l_inland = .FALSE.                                                         &
105a108,121
>    ,l_riv_overbank = .FALSE.                                                   &
>                             ! Logical to control overbank inundation
>    ,l_outflow_per_river = .FALSE.
>                  ! Internal flag where exact usage depends on the parent model
>                  ! as a result of the order of namelist reading:
>                  !   oasis_rivers, jules_rivers_props, jules_output.
>                  ! When TRUE:
>                  ! - OASIS-Rivers: OASIS send field contains
>                  !   outflow_per_river so river number ancillary should be
>                  !   specified in jules_rivers_props.
>                  ! - Standalone: The river number ancillary has been specified
>                  !   so outflow_per_river should be present in jules_output.
>                  ! Both cases are checked once the latter namelist is read.
>                  ! Additionally, rivers_outflow_rp is added to the dump.
116c132
<    ,a_thresh = 1
---
>    ,a_thresh = imdi
118a135,139
> ! Select shape of Earth used in TRIP river routing scheme
> INTEGER :: trip_globe_shape = imdi
> INTEGER, PARAMETER :: globe_spherical = 1
> INTEGER, PARAMETER :: globe_ellipsoidal = 2
> 
120c141
<    rivers_meander = 1.4                                                        &
---
>    rivers_meander = rmdi                                                       &
123c144
<    ,rivers_speed = 0.4                                                         &
---
>    ,rivers_speed = rmdi                                                        &
125c146
<    ,runoff_factor = 1.0                                                        &
---
>    ,runoff_factor = rmdi                                                       &
127c148
<    ,cland  = 0.2                                                               &
---
>    ,cland  = rmdi                                                              &
129,135c150,156
<    ,criver = 0.62                                                              &
<                             ! subsurf river wave speed (m/s)
<    ,cbland  = 0.1                                                              &
<                             ! subsurf land wave speed (m/s)
<    ,cbriver = 0.15                                                             &
<                             ! subsurf river wave speed (m/s)
<    ,retl = 0.0                                                                 &
---
>    ,criver = rmdi                                                              &
>                             ! subsurface river wave speed (m/s)
>    ,cbland  = rmdi                                                             &
>                             ! subsurface land wave speed (m/s)
>    ,cbriver = rmdi                                                             &
>                             ! subsurface river wave speed (m/s)
>    ,retl = rmdi                                                                &
137c158
<    ,retr = 0.005
---
>    ,retr = rmdi
140,142c161,165
< !-----------------------------------------------------------------------------
< ! Rivers parameters
< !-----------------------------------------------------------------------------
---
> ! Selects different fields for use in water conservation of lake evaporation
> ! JULES ticket #1360
> INTEGER :: lake_water_conserve_method = imdi
> INTEGER, PARAMETER :: use_fqw_surft  = 1
> INTEGER, PARAMETER :: use_elake_surft = 2
144c167,183
< ! Scalar variables (general)
---
> !------------------------------------------------------------------------------
> ! Single namelist definition for UM and standalone
> !------------------------------------------------------------------------------
> NAMELIST  /jules_rivers/                                                       &
>   l_rivers, l_inland, l_riv_overbank, i_river_vn, nstep_rivers,                &
>   trip_globe_shape,                                                            &
>   cland, criver, cbland, cbriver, runoff_factor, retl, retr,                   &
>   a_thresh, rivers_meander, rivers_speed, lake_water_conserve_method
> 
> !------------------------------------------------------------------------------
> ! Note that items declared below here are not in the jules_rivers namelist.
> !------------------------------------------------------------------------------
> 
> !------------------------------------------------------------------------------
> ! Definitions and characteristics of the river routing grid
> !------------------------------------------------------------------------------
> ! Scalar variables
146,149c185
<    np_rivers = 0                                                               &
<                             ! number of points in the rivers grid at which
<                             ! routing is calculated
<    ,nx_rivers = 0                                                              &
---
>     nx_rivers = 0                                                              &
151c187
<    ,ny_rivers = 0
---
>    ,ny_rivers = 0                                                              &
152a189,192
>    ,n_rivers = 0
>                             ! number of rivers in the River number ancillary
>                             ! - identifies the River an outflow gridbox belongs
>                             !   to by assigning a river number [1:n_rivers]
154,156d193
< !-----------------------------------------------------------------------------
< ! Definition of the river routing grid
< !-----------------------------------------------------------------------------
159,174c196,226
<    rivers_dlat  = rmdi                                                         &
<                             ! size of gridbox of (regular) rivers grid
<                             ! in latitude (degrees)
<    ,rivers_dlon = rmdi                                                         &
<                             ! size of gridbox of (regular) rivers grid
<                             ! in longitude (degrees)
<    ,rivers_lat1 = rmdi                                                         &
<                             ! latitude of southernmost row of gridpoints
<                             ! on a regular rivers grid (degrees)
<    ,rivers_lon1 = rmdi                                                         &
<                             !  longitude of westernmost (first) column of
<                             ! gridpoints on a regular rivers grid (degrees)
<    ,rivers_dx   = rmdi
<                             ! size of gridbox of rivers grid in m (for
<                             ! non-regular lat/lon grids)
< 
---
>    rivers_dx = rmdi                                                            &
>                             ! Size of gridbox of regular rivers grid
>                             ! in x direction. If l_coord_latlon=T, the units
>                             ! are degrees of longitude, otherwise units are
>                             ! unknown.
>    ,rivers_dy = rmdi                                                           &
>                             ! Size of gridbox of regular rivers grid
>                             ! in y direction. If l_coord_latlon=T, the units
>                             ! are degrees of latitude, otherwise units are
>                             ! unknown.
>    ,rivers_x1 = rmdi                                                           &
>                             ! x coordinate of of westernmost (first) column of
>                             ! gridpoints on the regular rivers grid.
>    ,rivers_y1 = rmdi                                                           &
>                             ! y coordinate of "southernmost" (first) row of
>                             ! gridpoints on the regular rivers grid.
>    ,rivers_length = rmdi
>                             ! Size of gridbox of rivers grid (m).
>       ! This is used:
>       !   to calculate gridbox areas (if l_coord_latlon=F);
>       !   as a length scale for RFM;
>       !   as a length scale for overbank inundation with l_riv_hypsometry=F.
> 
> !------------------------------------------------------------------------------
> ! Variables that describe the land grid (not the river grid).
> ! If the model grid is 1-D, this is the notional 2-D grid across which the
> ! land points can be scattered. In many cases we expect this grid to
> ! be identical to the full JULES model grid (where that is 2D), but as these
> ! grid descriptors are input via a namelist this grid can in principle be
> ! larger than the model grid.
> !------------------------------------------------------------------------------
176,183c228,231
<    nx_grid      = imdi                                                         &
<                             ! row length of full land model grid
<                             ! (only needed for river routing)
<    ,ny_grid     = imdi                                                         &
<                             ! column length of model grid
<                             ! (only needed for river routing)
<    ,nseqmax     = imdi
<                             ! maximum value of routing grid sequence
---
>    nx_land_grid  = imdi                                                        &
>                             ! Row length of land grid.
>    ,ny_land_grid = imdi
>                             ! Column length of land grid.
186,197c234,263
<    reg_lon1     = rmdi                                                         &
<                             ! longitude of westernnmost row of gridpoints
<                             ! on a regular full model grid (degrees)
<    ,reg_lat1    = rmdi                                                         &
<                             ! latitude of southernnmost row of gridpoints
<                             ! on a regular full model grid (degrees)
<    ,reg_dlon    = rmdi                                                         &
<                             ! size of gridbox of (regular) full model grid
<                             ! in longitude (degrees)
<    ,reg_dlat    = rmdi
<                             ! size of gridbox of (regular) full model grid
<                             ! in latitude (degrees)
---
>    land_dx = rmdi                                                              &
>                             ! Size in x direction of gridbox of (regular) full
>                             ! land grid. If l_coord_latlon=T, this is
>                             ! longitude in degrees, otherwise units are
>                             ! unknown.
>    ,land_dy = rmdi                                                             &
>                             ! Size in y direction of gridbox of (regular) full
>                             ! land grid. If l_coord_latlon=T, this is
>                             ! latitude in degrees, otherwise units are
>                             ! unknown.
>    ,x1_land_grid  = rmdi                                                       &
>                             ! x coordinate of "western-most" (i.e. first)
>                             ! column of gridpoints on a regular full land
>                             ! grid. If l_coord_latlon=T, this is longitude in
>                             ! degrees, otherwise units are unknown.
>    ,y1_land_grid  = rmdi
>                             ! y coordinate of "southern-most" (i.e. first)
>                             ! row of gridpoints on a regular full land
>                             ! grid. If l_coord_latlon=T, this is latitude in
>                             ! degrees, otherwise units are unknown.
> 
> !------------------------------------------------------------------------------
> ! Further river variables.
> !------------------------------------------------------------------------------
> INTEGER ::                                                                     &
>     np_rivers = 0                                                              &
>                             ! Number of river points, i.e. the number of points
>                             ! in the rivers grid at which routing is calculated
>    ,nseqmax   = imdi
>                             ! Maximum value of routing grid sequence.
200,202c266,273
<    rivers_reglatlon = .TRUE.                                                   &
<                             ! flag indicating if rivers grid is regular in
<                             ! latitude and longitude See above for
---
>    l_trivial_mapping = .FALSE.                                                 &
>                             ! Flag indicating if the land and river points
>                             ! are identical (and in the same order) and hence
>                             ! fields can be moved between grids simply by
>                             ! copying.
>    ,rivers_reglatlon = .TRUE.                                                  &
>                             ! Flag indicating if rivers grid is regular in
>                             ! latitude and longitude. See above for
204,208c275,290
<    ,rivers_regrid   = .TRUE.                                                   &
<                             ! flag indicating if model and rivers grids
<                             ! are identical
<                             !     FALSE grids are identical
<                             !     TRUE grids differ and regridding required
---
>    ,rivers_regrid   = .FALSE.                                                  &
>                             ! Flag indicating if variables on the land grid
>                             ! need to be regridded (interpolated) to the river
>                             ! routing grid.
>                             ! Grids are considered consistent (and therefore
>                             ! regridding is not required) if they are of the
>                             ! same resolution and points on one coincide with
>                             ! points on the other. These grids can be handled
>                             ! by a 1:1 mapping. We do not require that all
>                             ! locations have to be in both grids (though that
>                             ! is desirable), nor do the points need to be
>                             ! presented in the same order in both grids.
>                             !   FALSE grids are consistent and fields can be
>                             !     transferred between grids through a simple
>                             !     mapping
>                             !   TRUE grids differ and regridding is required.
212,221c294,295
< 
< 
< !-----------------------------------------------------------------------------
< ! Single namelist definition for UM and standalone
< !-----------------------------------------------------------------------------
< 
< NAMELIST  / jules_rivers/                                                      &
<   l_rivers, l_inland, i_river_vn, nstep_rivers,                                &
<   cland, criver, cbland, cbriver, runoff_factor, retl, retr,                   &
<   a_thresh, rivers_meander, rivers_speed
---
>                             ! Flag that is TRUE on timesteps when rivers are
>                             ! called, otherwise FALSE.
225c299
< !-----------------------------------------------------------------------------
---
> !------------------------------------------------------------------------------
240,243c314,324
<   INTEGER, ALLOCATABLE :: il_river_grid(:)
<                            ! map of land point index on river routing grid
<   INTEGER, ALLOCATABLE :: ir_land_grid(:)
<                            ! map of river point index on land model grid
---
>   INTEGER, ALLOCATABLE :: map_river_to_land_points(:)
>                            ! List of coincident land point numbers, on
>                            ! river points.
>                            ! For every river point, this is the matching land
>                            ! point. Only used when rivers_regrid=F.
>   INTEGER, ALLOCATABLE :: global_land_index(:)
>                            ! List of indices for the land grid.
>                            ! For every land point, this gives the location in a
>                            ! 2-D grid. Only used after initialisation when
>                            ! rivers_regrid=T.
> 
250,251d330
<   INTEGER, ALLOCATABLE :: rivers_dir_rp(:)
<                             ! River routing direction index
253c332,333
<                             ! Index of points where routing is calculated
---
>                             ! Index of points where routing is calculated.
>                             ! This index refers to position in the river grid.
255c335,336
<                             ! Index of the next downstream point.
---
>                             ! Index (river point number) of the next downstream
>                             ! point.
257a339,342
>   INTEGER, ALLOCATABLE :: rivers_outflow_number_rp(:)
>                             ! Maps ocean outflow gridboxes to the river they
>                             !    belong to (on river points)
>                             ! Used for coupling to ocean model
260,262d344
<   REAL(KIND=real_jlslsm), ALLOCATABLE :: rivers_dra_rp(:)
<                             ! Catchment area draining to a grid cell
<                             !    (no. of grid cells)
266a349,358
>   REAL(KIND=real_jlslsm), ALLOCATABLE :: rivers_ilat_rp(:)
>                             ! River routing index in latitude direction
>   REAL(KIND=real_jlslsm), ALLOCATABLE :: rivers_ilon_rp(:)
>                             ! River routing index in longitude direction
>   REAL(KIND=real_jlslsm), ALLOCATABLE :: rivers_x_coord_rp(:)
>                             ! River routing point projection x coordinate.
>                             ! Units can differ between input datasets.
>   REAL(KIND=real_jlslsm), ALLOCATABLE :: rivers_y_coord_rp(:)
>                             ! River routing point projection y coordinate.
>                             ! Units can differ between input datasets.
277a370,374
>   REAL(KIND=real_jlslsm), ALLOCATABLE :: sub_surf_roff_rp(:)
>     ! OASIS-Rivers: Sub-surface runoff on river vector (kg m-2 s-1)
>   REAL(KIND=real_jlslsm), ALLOCATABLE :: surf_roff_rp(:)
>     ! OASIS-Rivers: Surface runoff on river vector (kg m-2 s-1)
> 
288d384
<                             ! (enables non-regular lat-lon river grids)
291c387,390
<                             ! (enables non-regular lat-lon river grids)
---
>   REAL(KIND=real_jlslsm), ALLOCATABLE :: rivers_outflow_number(:,:)
>                             ! Maps ocean outflow gridboxes to the river they
>                             !    belong to (on rivers grid)
>                             ! Used for coupling to ocean model
293c392
<                             ! 1D x-dimension of rivers grid
---
>                             ! Coordinate values for x-dimension of rivers grid
295c394,395
<                             ! 1D y-dimension of rivers grid
---
>                             ! Coordinate values for y-dimension of rivers grid
> 
312a413,414
>   REAL(KIND=real_jlslsm), ALLOCATABLE :: rivers_outflow_rp(:)
>                             ! River outflow into the ocean (kg s-1)
321,322c423,424
<   INTEGER, POINTER :: il_river_grid(:)
<   INTEGER, POINTER :: ir_land_grid(:)
---
>   INTEGER, POINTER :: map_river_to_land_points(:)
>   INTEGER, POINTER :: global_land_index(:)
325d426
<   INTEGER, POINTER :: rivers_dir_rp(:)
328a430
>   INTEGER, POINTER :: rivers_outflow_number_rp(:)
330d431
<   REAL(KIND=real_jlslsm), POINTER :: rivers_dra_rp(:)
332a434,437
>   REAL(KIND=real_jlslsm), POINTER :: rivers_ilat_rp(:)
>   REAL(KIND=real_jlslsm), POINTER :: rivers_ilon_rp(:)
>   REAL(KIND=real_jlslsm), POINTER :: rivers_x_coord_rp(:)
>   REAL(KIND=real_jlslsm), POINTER :: rivers_y_coord_rp(:)
336a442,443
>   REAL(KIND=real_jlslsm), POINTER :: sub_surf_roff_rp(:)
>   REAL(KIND=real_jlslsm), POINTER :: surf_roff_rp(:)
343a451
>   REAL(KIND=real_jlslsm), POINTER :: rivers_outflow_number(:,:)
351a460
>   REAL(KIND=real_jlslsm), POINTER :: rivers_outflow_rp(:)
369d477
< INTEGER :: temp_size
392,393c500,501
< !!!ALLOCATE(rivers_data%il_river_grid(np_rivers))
< !!!ALLOCATE(rivers_data%ir_land_grid(np_rivers))
---
> !!!ALLOCATE(rivers_data%map_river_to_land_points(np_rivers))
> !!!ALLOCATE(rivers_data%global_land_index(np_rivers))
396d503
< !!!ALLOCATE(rivers_data%rivers_dir_rp(np_rivers))
401d507
< !!!ALLOCATE(rivers_data%rivers_dra_rp(np_rivers))
403a510,513
> !!!ALLOCATE(rivers_data%rivers_ilat_rp(np_rivers))
> !!!ALLOCATE(rivers_data%rivers_ilon_rp(np_rivers))
> !!!ALLOCATE(rivers_data%rivers_x_coord_rp(np_rivers))
> !!!ALLOCATE(rivers_data%rivers_y_coord_rp(np_rivers))
413,414c523,524
< !!!ALLOCATE(rivers_data%rivers_xgrid(np_rivers))
< !!!ALLOCATE(rivers_data%rivers_ygrid(np_rivers))
---
> !!!ALLOCATE(rivers_data%rivers_xgrid(nx_rivers))
> !!!ALLOCATE(rivers_data%rivers_ygrid(ny_rivers))
429,430c539,540
< !!!rivers_data%il_river_grid(:) = 0
< !!!rivers_data%ir_land_grid(:) = 0
---
> !!!rivers_data%map_river_to_land_points(:) = 0
> !!!rivers_data%global_land_index(:) = 0
433d542
< !!!rivers_data%rivers_dir_rp(:) = 0
438d546
< !!!rivers_data%rivers_dra_rp(:) = 0.0
440a549,552
> !!!rivers_data%rivers_ilat_rp(:) = 0.0
> !!!rivers_data%rivers_ilon_rp(:) = 0.0
> !!!rivers_data%rivers_x_coord_rp(:) = 0.0
> !!!rivers_data%rivers_y_coord_rp(:) = 0.0
472c584
< !-----------------------------------------------------------------------------
---
> !------------------------------------------------------------------------------
482c594
< !-----------------------------------------------------------------------------
---
> !------------------------------------------------------------------------------
485a598,599
> CHARACTER(LEN=*), PARAMETER :: RoutineName = 'CHECK_JULES_RIVERS'
> 
491c605
<     CALL ereport("check_jules_rivers", errcode,                                &
---
>     CALL ereport(RoutineName, errcode,                                         &
502c616
<   CALL ereport("check_jules_rivers", errcode, 'nstep_rivers must be > 0')
---
>   CALL ereport(RoutineName, errcode, 'nstep_rivers must be > 0')
505,506c619,621
< ! Check that parameter values are appropriate for the selected algorithm
< ! This also serves as a check that we have a recognised rivers type
---
> ! Check that the required parameter values have been provided and are
> ! appropriate for the selected algorithm.
> ! This also serves as a check that we have a recognised rivers type.
507a623
> 
509c625,679
<   IF ( cland <= 0.0 .OR. criver <= 0.0 ) THEN
---
>   !---------------------------------------------------------------------------
>   ! RFM parameters.
>   !---------------------------------------------------------------------------
> 
>   IF ( a_thresh == imdi ) THEN
>     errcode = 101  !  a hard error
>     CALL ereport(RoutineName, errcode,                                         &
>                  "No value for a_thresh")
>   END IF
> 
>   IF ( ABS( cbland - rmdi ) < EPSILON(1.0) ) THEN
>     errcode = 101  !  a hard error
>     CALL ereport(RoutineName, errcode,                                         &
>                  "No value for cbland")
>   ELSE IF ( cbland <= 0.0 ) THEN
>     errcode = 101
>     CALL ereport(RoutineName, errcode,                                         &
>                  "Sub surface land wave speed must be > 0")
>   END IF
> 
>   IF ( ABS( cbriver - rmdi ) < EPSILON(1.0) ) THEN
>     errcode = 101  !  a hard error
>     CALL ereport(RoutineName, errcode,                                         &
>                  "No value for cbriver")
>   ELSE IF ( cbriver <= 0.0 ) THEN
>     errcode = 101
>     CALL ereport(RoutineName, errcode,                                         &
>                  "Sub surface river wave speed must be > 0")
>   END IF
> 
>   IF ( ABS( cland - rmdi ) < EPSILON(1.0) ) THEN
>     errcode = 101  !  a hard error
>     CALL ereport(RoutineName, errcode,                                         &
>                  "No value for cland")
>   ELSE IF ( cland <= 0.0 ) THEN
>     errcode = 101
>     CALL ereport(RoutineName, errcode,                                         &
>                  "Surface wave land speed must be > 0")
>   END IF
> 
>   IF ( ABS( criver - rmdi ) < EPSILON(1.0) ) THEN
>     errcode = 101  !  a hard error
>     CALL ereport(RoutineName, errcode,                                         &
>                  "No value for criver")
>   ELSE IF ( criver <= 0.0 ) THEN
>     errcode = 101
>     CALL ereport(RoutineName, errcode,                                         &
>                  "Surface wave river speed must be > 0")
>   END IF
> 
>   IF ( ABS( retl - rmdi ) < EPSILON(1.0) ) THEN
>     errcode = 101  !  a hard error
>     CALL ereport(RoutineName, errcode,                                         &
>                  "No value for retl")
>   ELSE IF ( retl < -1.0 .OR. retl > 1.0 ) THEN
511,512c681,682
<     CALL ereport("check_jules_rivers", errcode,                                &
<                  "Surface wave speeds must be > 0")
---
>     CALL ereport(RoutineName, errcode,                                         &
>                  "retl must be in the range -1 to 1")
514,521c684,701
<   IF ( cbland <= 0.0 .OR. cbriver <= 0.0) THEN
<     errcode = 102
<     CALL ereport("check_jules_rivers", errcode,                                &
<                  "Sub surface wave speeds must be > 0")
<   END IF
<   IF ( runoff_factor <= 0.0 ) THEN
<     errcode = 103
<     CALL ereport("check_jules_rivers", errcode,                                &
---
> 
>   IF ( ABS( retr - rmdi ) < EPSILON(1.0) ) THEN
>     errcode = 101  !  a hard error
>     CALL ereport(RoutineName, errcode,                                         &
>                  "No value for retr")
>   ELSE IF ( retr < -1.0 .OR. retr > 1.0 ) THEN
>     errcode = 101
>     CALL ereport(RoutineName, errcode,                                         &
>                  "retr must be in the range -1 to 1")
>   END IF
> 
>   IF ( ABS( runoff_factor - rmdi ) < EPSILON(1.0) ) THEN
>     errcode = 101  !  a hard error
>     CALL ereport(RoutineName, errcode,                                         &
>                  "No value for runoff_factor")
>   ELSE IF ( runoff_factor <= 0.0 ) THEN
>     errcode = 101
>     CALL ereport(RoutineName, errcode,                                         &
525,535c705,717
< CASE ( rivers_trip )
<   IF ( rivers_speed <= 0.0 .OR. rivers_meander <= 0.0 ) THEN
<     errcode = 104
<     CALL ereport("check_jules_rivers", errcode,                                &
<                  "River speed and meander ratio must be > 0")
<   END IF
< CASE ( rivers_um_trip )
<   IF ( rivers_speed <= 0.0 .OR. rivers_meander <= 0.0 ) THEN
<     errcode = 104
<     CALL ereport("check_jules_rivers", errcode,                                &
<                  "River speed and meander ratio must be > 0")
---
> CASE ( rivers_trip, rivers_um_trip )
>   !---------------------------------------------------------------------------
>   ! TRIP and UM TRIP parameters.
>   !---------------------------------------------------------------------------
> 
>   IF ( ABS( rivers_meander - rmdi ) < EPSILON(1.0) ) THEN
>     errcode = 101  !  a hard error
>     CALL ereport(RoutineName, errcode,                                         &
>                  "No value for rivers_meander")
>   ELSE IF ( rivers_meander <= 0.0 ) THEN
>     errcode = 101
>     CALL ereport(RoutineName, errcode,                                         &
>                  "Meander ratio must be > 0")
536a719,766
> 
>   IF ( ABS( rivers_speed - rmdi ) < EPSILON(1.0) ) THEN
>     errcode = 101  !  a hard error
>     CALL ereport(RoutineName, errcode,                                         &
>                  "No value for rivers_speed")
>   ELSE IF ( rivers_speed <= 0.0 ) THEN
>     errcode = 101
>     CALL ereport(RoutineName, errcode,                                         &
>                  "River speed must be > 0")
>   END IF
> 
>   SELECT CASE ( i_river_vn )
> 
>   CASE ( rivers_um_trip )
>     !---------------------------------------------------------------------------
>     ! UM TRIP only parameters.
>     !---------------------------------------------------------------------------
>     IF ( lake_water_conserve_method < 1 .OR.                                   &
>          lake_water_conserve_method > 2 ) THEN
>       errcode = 101
>       CALL ereport(RoutineName, errcode,                                       &
>                    "lake_water_conserve_method must be 1 or 2")
>     END IF
> 
>     IF ( trip_globe_shape < 1 .OR.                                             &
>          trip_globe_shape > 2 ) THEN
>       errcode = 101
>       CALL ereport(RoutineName, errcode,                                       &
>                    "trip_globe_shape must be 1 or 2")
>     END IF
> 
>   CASE ( rivers_trip )
>     !---------------------------------------------------------------------------
>     ! Standalone TRIP only parameters.
>     !---------------------------------------------------------------------------
>     IF ( lake_water_conserve_method /= imdi ) THEN
>       errcode = 101
>       CALL ereport(RoutineName, errcode,                                       &
>                    "lake_water_conserve_method is not used in standalone")
>     END IF
> 
>     IF ( trip_globe_shape /= imdi ) THEN
>       errcode = 101
>       CALL ereport(RoutineName, errcode,                                       &
>                    "trip_globe_shape is not used in standalone")
>     END IF
>   END SELECT
> 
539c769
<   CALL ereport("check_jules_rivers", errcode,                                  &
---
>   CALL ereport(RoutineName, errcode,                                           &
545c775
<   CALL ereport("check_jules_rivers", errcode,                                  &
---
>   CALL ereport(RoutineName, errcode,                                           &
567a798,801
> WRITE(lineBuffer,*)' l_riv_overbank = ',l_riv_overbank
> CALL jules_print('jules_rivers',lineBuffer)
> WRITE(lineBuffer,*)' trip_globe_shape = ',trip_globe_shape
> CALL jules_print('jules_rivers',lineBuffer)
571a806,808
> WRITE(lineBuffer,'(A,I0)') ' lake_water_conserve_method = ',                   &
>                            lake_water_conserve_method
> CALL jules_print(ModuleName,lineBuffer)
605a843,891
> #if !defined(UM_JULES) && !defined(LFRIC)
> SUBROUTINE read_nml_jules_rivers(nml_dir)
> 
> USE io_constants, ONLY: namelist_unit
> 
> USE string_utils_mod, ONLY: to_string
> 
> USE logging_mod, ONLY: log_info, log_fatal
> 
> IMPLICIT NONE
> 
> ! Arguments
> CHARACTER(LEN=*), INTENT(IN) :: nml_dir  ! The directory containing the
>                                          ! namelists
> ! Work variables
> INTEGER :: ERROR  ! Error indicator
> 
> CHARACTER(LEN=*), PARAMETER :: RoutineName='READ_NML_JULES_RIVERS'
> 
> !-----------------------------------------------------------------------------
> ! Read river routing namelist
> !----------------------------------------------------------------------------
> CALL log_info(RoutineName, "Reading JULES_RIVERS namelist...")
> 
> ! Open the river routing parameters namelist file
> OPEN(namelist_unit, FILE=(TRIM(nml_dir) // '/' // 'jules_rivers.nml'),         &
>                STATUS='old', POSITION='rewind', ACTION='read', IOSTAT = ERROR)
> IF ( ERROR /= 0 ) THEN
>   CALL log_fatal(RoutineName,                                                  &
>                  "Error opening namelist file jules_rivers.nml " //            &
>                  "(IOSTAT=" // TRIM(to_string(ERROR)) // ")")
> END IF
> 
> READ(namelist_unit, NML = jules_rivers, IOSTAT = ERROR)
> IF ( ERROR /= 0 ) THEN
>   CALL log_fatal(RoutineName,                                                  &
>                  "Error reading namelist JULES_RIVERS " //                     &
>                  "(IOSTAT=" // TRIM(to_string(ERROR)) // ")")
> END IF
> 
> CLOSE(namelist_unit, IOSTAT = ERROR)
> IF ( ERROR /= 0 ) THEN
>   CALL log_fatal(RoutineName,                                                  &
>                  "Error closing namelist file jules_rivers.nml " //            &
>                  "(IOSTAT=" // TRIM(to_string(ERROR)) // ")")
> END IF
> 
> END SUBROUTINE read_nml_jules_rivers
> #endif
633c919
< INTEGER, PARAMETER :: n_int = 3
---
> INTEGER, PARAMETER :: n_int = 5
635c921
< INTEGER, PARAMETER :: n_log = 2
---
> INTEGER, PARAMETER :: n_log = 3
639a926
>   INTEGER :: trip_globe_shape
641a929
>   INTEGER :: lake_water_conserve_method
652a941
>   LOGICAL :: l_riv_overbank
676a966
>   my_nml % trip_globe_shape = trip_globe_shape
682a973,974
>   my_nml % l_riv_overbank = l_riv_overbank
>   my_nml % lake_water_conserve_method = lake_water_conserve_method
695a988
>   trip_globe_shape = my_nml % trip_globe_shape
702a996,997
>   l_riv_overbank = my_nml % l_riv_overbank
>   lake_water_conserve_method = my_nml % lake_water_conserve_method
741,742c1036,1037
< !!!DEALLOCATE(rivers_data%il_river_grid)
< !!!DEALLOCATE(rivers_data%ir_land_grid)
---
> !!!DEALLOCATE(rivers_data%map_river_to_land_points)
> !!!DEALLOCATE(rivers_data%global_land_index)
745d1039
< !!!DEALLOCATE(rivers_data%rivers_dir_rp)
750d1043
< !!!DEALLOCATE(rivers_data%rivers_dra_rp)
752a1046,1049
> !!!DEALLOCATE(rivers_data%rivers_ilat_rp)
> !!!DEALLOCATE(rivers_data%rivers_ilon_rp)
> !!!DEALLOCATE(rivers_data%rivers_x_coord_rp)
> !!!DEALLOCATE(rivers_data%rivers_y_coord_rp)
808,809c1105,1106
< !!!rivers%il_river_grid => rivers_data%il_river_grid
< !!!rivers%ir_land_grid => rivers_data%ir_land_grid
---
> !!!rivers%map_river_to_land_points => rivers_data%map_river_to_land_points
> !!!rivers%global_land_index => rivers_data%global_land_index
812d1108
< !!!rivers%rivers_dir_rp => rivers_data%rivers_dir_rp
817d1112
< !!!rivers%rivers_dra_rp => rivers_data%rivers_dra_rp
819a1115,1118
> !!!rivers%rivers_ilat_rp => rivers_data%rivers_ilat_rp
> !!!rivers%rivers_ilon_rp => rivers_data%rivers_ilon_rp
> !!!rivers%rivers_x_coord_rp => rivers_data%rivers_x_coord_rp
> !!!rivers%rivers_y_coord_rp => rivers_data%rivers_y_coord_rp
874,875c1173,1174
< !!!NULLIFY(rivers%il_river_grid)
< !!!NULLIFY(rivers%ir_land_grid)
---
> !!!NULLIFY(rivers%map_river_to_land_points)
> !!!NULLIFY(rivers%global_land_index)
878d1176
< !!!NULLIFY(rivers_dir_rp)
883d1180
< !!!NULLIFY(rivers_dra_rp)
885a1183,1186
> !!!NULLIFY(rivers_ilat_rp)
> !!!NULLIFY(rivers_ilon_rp)
> !!!NULLIFY(rivers_x_coord_rp)
> !!!NULLIFY(rivers_y_coord_rp)
910c1211,1215
< END MODULE jules_rivers_mod
---
> FUNCTION calc_outflow_per_river(rivers) RESULT(outflow_per_river)
> 
> USE jules_print_mgr, ONLY: jules_print, jules_message
> 
> IMPLICIT NONE
912a1218,1254
> ! Description:
> !   Calculates river outflow for each river.
> !
> ! Code Owner: Please refer to ModuleLeaders.txt
> ! This file belongs in TECHNICAL
> !
> ! Code Description:
> !   Language: Fortran 90.
> !   This code is written to JULES coding standards v1.
> !-----------------------------------------------------------------------------
> ! Arguments with intent(in)
> TYPE(rivers_type), INTENT(IN) :: rivers
> 
> ! Return type
> REAL :: outflow_per_river(n_rivers)
>   ! River outflow into the ocean for each river (kg s-1)
>   ! Used in coupling to ocean model
> 
> ! Local variables
> INTEGER :: ip
> 
> CHARACTER(LEN=*), PARAMETER :: RoutineName='CALC_OUTFLOW_PER_RIVER'
> 
> outflow_per_river(:) = 0.0
> DO ip = 1, np_rivers
>   IF (rivers%rivers_outflow_number_rp(ip) > 0) THEN
>     outflow_per_river(rivers%rivers_outflow_number_rp(ip)) =                   &
>        outflow_per_river(rivers%rivers_outflow_number_rp(ip)) +                &
>        rivers%rivers_outflow_rp(ip)
>   END IF
> END DO
> 
> END FUNCTION calc_outflow_per_river
> 
> END MODULE jules_rivers_mod
> 
> !------------------------------------------------------------------------------
diff -r vn7.0copy1_c4/src/./control/shared/jules_science_fixes_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared/jules_science_fixes_mod.F90
80a81,93
> ! ticket # (Jules:#1396)
> LOGICAL :: l_fix_neg_snow = .FALSE.       ! Review in April 2025
> 
> ! ticket #931 (um:#6885): Atmospheric deposition fixes used in UKCA
> LOGICAL :: l_fix_drydep_so2_water = .FALSE. ,                                  &
>              ! True to use correct surface resistance of water when calculating
>              ! dry deposition of SO2
>            l_fix_improve_drydep = .FALSE. ,                                    &
>              ! True to fix dry deposition velocities
>            l_fix_ukca_h2dd_x = .FALSE.
>              ! True to fix H2 deposition to shrub/soil
> 
> 
85c98,99
<          l_fix_snow_frac
---
>          l_fix_snow_frac, l_fix_drydep_so2_water, l_fix_improve_drydep,        &
>          l_fix_ukca_h2dd_x, l_fix_neg_snow
119a134,142
> CALL jules_print(ModuleName,lineBuffer)
> WRITE(lineBuffer,'(A,L1)') ' l_fix_neg_snow = ',      l_fix_neg_snow
> CALL jules_print(ModuleName,lineBuffer)
> WRITE(lineBuffer,'(A,L1)') ' l_fix_improve_drydep = ', l_fix_improve_drydep
> CALL jules_print(ModuleName,lineBuffer)
> WRITE(lineBuffer,'(A,L1)') ' l_fix_ukca_h2dd_x = ',   l_fix_ukca_h2dd_x
> CALL jules_print(ModuleName,lineBuffer)
> WRITE(lineBuffer,'(A,L1)') ' l_fix_drydep_so2_water = ', l_fix_drydep_so2_water
> CALL jules_print(ModuleName,lineBuffer)
235c258
< INTEGER, PARAMETER :: n_log = 10
---
> INTEGER, PARAMETER :: n_log = 14
249a273,276
>   LOGICAL :: l_fix_neg_snow
>   LOGICAL :: l_fix_drydep_so2_water
>   LOGICAL :: l_fix_improve_drydep
>   LOGICAL :: l_fix_ukca_h2dd_x
276a304,307
>   my_nml % l_fix_neg_snow                  = l_fix_neg_snow
>   my_nml % l_fix_drydep_so2_water          = l_fix_drydep_so2_water
>   my_nml % l_fix_improve_drydep            = l_fix_improve_drydep
>   my_nml % l_fix_ukca_h2dd_x               = l_fix_ukca_h2dd_x
292a324,327
>   l_fix_neg_snow                  = my_nml % l_fix_neg_snow
>   l_fix_drydep_so2_water          = my_nml % l_fix_drydep_so2_water
>   l_fix_improve_drydep            = my_nml % l_fix_improve_drydep
>   l_fix_ukca_h2dd_x               = my_nml % l_fix_ukca_h2dd_x
412a448,456
> IF ( .NOT. l_fix_neg_snow ) THEN
>   errorstatus = -100
>   cmessage    =                                                     newline // &
>   'jules:#1396 fix to remove correct the melting calculation'     //newline // &
>   ' that can result in negative snow amounts is not enabled: '    //newline // &
>   'l_fix_neg_snow = .FALSE.'
>   CALL ereport(RoutineName, errorstatus, cmessage)
> END IF
> 
423a468,499
> ! JULES and atmospheric deposition
> ! Copied from um/src/control/misc/science_fixes_mod.F90
> IF (.NOT. l_fix_improve_drydep) THEN
>   ErrorStatus = -100
>   cmessage    =                                                       newline//&
>   'Model run excludes a change from ticket um:#1250 as'//             newline//&
>   ' l_fix_improve_drydep=.FALSE.'//                                   newline//&
>   ' This will mean that dry deposition velocities are set to null'//  newline//&
>   ' for HCl, HOCl, HBr, HOBr, H2SO4, MeOH and Sec_Org and that dry'// newline//&
>   ' deposition velocities for 9 tiles are inconsistent with 13/17/27 tiles.'
>   CALL ereport(RoutineName, ErrorStatus, Cmessage)
> END IF
> 
> IF (.NOT. l_fix_drydep_so2_water) THEN
>   ErrorStatus = -100
>   cmessage    =                                                       newline//&
>   ' Model run excludes a change from ticket um:#5651, '//             newline//&
>   ' l_fix_drydep_so2_water=.FALSE.'//                                 newline//&
>   ' This will mean that the surface resistance of water when '//      newline//&
>   ' calculating the dry deposition of SO2 is too high for 13, 17 '//  newline//&
>   ' and 27 tiles.'
>   CALL ereport(RoutineName, ErrorStatus, Cmessage)
> END IF
> 
> IF (.NOT.  l_fix_ukca_h2dd_x) THEN
>   ErrorStatus = -100
>   cmessage    =                                                       newline//&
>   'Model run excludes a change from ticket um:#4157 as'//             newline//&
>   ' l_fix_ukca_h2dd_x=.FALSE. .'//                                    newline//&
>   ' This will mean that the wrong element is used for h2dd_c & h2dd_m.'
>   CALL ereport(RoutineName, ErrorStatus, Cmessage)
> END IF
diff -r vn7.0copy1_c4/src/./control/shared/jules_sea_seaice_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared/jules_sea_seaice_mod.F90
122a123,126
> ! The following setting is needed for setting up (UM-JULES) pseudo level IDs
> ! for water tracer fields on multiple sea ice categories.  It is not used
> ! anywhere else in the code.
> INTEGER, PARAMETER :: nice_max=25 ! maximum number of sea ice categories
diff -r vn7.0copy1_c4/src/./control/shared/jules_snow_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared/jules_snow_mod.F90
354a355
> CHARACTER(LEN=*), PARAMETER :: RoutineName='CHECK_JULES_SNOW'
362c363
<   CALL ereport("check_jules_snow", errorstatus,                                &
---
>   CALL ereport(RoutineName, errorstatus,                                       &
373a375,389
> 
> ! If variables are set check that they are in the correct range
> IF ( ANY( ABS( aicemax(:) - rmdi ) > EPSILON(1.0) ) ) THEN
>   IF ( ANY( aicemax(:) < 0.01 ) .OR. ANY( aicemax(:) > 0.99 ) ) THEN
>     CALL ereport(RoutineName, errorstatus,                                     &
>        'aicemax must lie in the range 0.01 to 0.99')
>   END IF
> END IF
> 
> IF ( ABS( rho_firn_albedo - rmdi ) > EPSILON(1.0) ) THEN
>   IF ( rho_firn_albedo < 0.01 .OR. rho_firn_albedo > 1000.0 ) THEN
>     CALL ereport(RoutineName, errorstatus,                                     &
>        'rho_firn_albedo must lie in the range 0.01 to 1000.0')
>   END IF
> END IF
diff -r vn7.0copy1_c4/src/./control/shared/jules_soil_biogeochem_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared/jules_soil_biogeochem_mod.F90
47,48c47,48
<   soil_model_rothc = 2,                                                        &
<     ! The RothC (4 pool) model of soil carbon. Historically this was
---
>   soil_model_4pool = 2,                                                        &
>     ! The 4 pool model of soil carbon. Historically this was
50c50
<     ! effectively implying RothC was used.
---
>     ! effectively implying 4-pools were used.
79c79
< ! Namelist variables used by both 1pool and RothC models.
---
> ! Namelist variables used by both 1-pool and 4-pool models.
94c94
<     ! .FALSE. = use RothC formulation
---
>     ! .FALSE. = use 4-pool specific formulation
138c138
< ! Namelist variables used only by the RothC model.
---
> ! Namelist variables used only by the 4-pool soil C model.
156,158c156,158
<   kaps_roth(4) = rmdi
<     ! Specific soil respiration rate for RothC (s-1).
<     ! in check_jules_soil_biogeochemistry we comfirm that kaps_roth is
---
>   kaps_4pool(4) = rmdi
>     ! Specific soil respiration rate for 4-pool soil C model (s-1).
>     ! in check_jules_soil_biogeochemistry we comfirm that kaps_4pool is
167a168,171
> REAL(KIND=real_jlslsm) ::                                                      &
>   z_burn_max = rmdi
>     ! Parameter setting maximum depth of burn
> 
233c237
<     soil_bgc_model, ch4_substrate, kaps, kaps_roth, q10_soil, sorp,            &
---
>     soil_bgc_model, ch4_substrate, kaps, kaps_4pool, q10_soil, sorp,           &
239c243
<     l_label_frac_cs
---
>     l_label_frac_cs, z_burn_max
250a255,257
> USE jules_soil_mod, ONLY: sm_levels, dzsoil
> USE ancil_info, ONLY: dim_cslayer
> 
257c264
<   l_triffid, l_trif_fire, l_nitrogen
---
>   l_triffid, l_trif_fire, l_nitrogen, l_inferno
280c287
< CASE ( soil_model_1pool, soil_model_rothc, soil_model_ecosse )
---
> CASE ( soil_model_1pool, soil_model_4pool, soil_model_ecosse )
290c297
<   CASE ( soil_model_ecosse, soil_model_rothc )
---
>   CASE ( soil_model_ecosse, soil_model_4pool )
294c301
<                  'TRIFFID needs a prognostic soil model - use RothC.')
---
>                  'TRIFFID needs a prognostic soil model - use 4-pool C model.')
314c321
< CASE ( soil_model_ecosse, soil_model_rothc )
---
> CASE ( soil_model_ecosse, soil_model_4pool )
317c324
<                   'RothC and ECOSSE soil models need a veg model ' //          &
---
>                   '4-pool and ECOSSE soil models need a veg model ' //         &
325c332
< CASE ( soil_model_ecosse, soil_model_rothc )
---
> CASE ( soil_model_ecosse, soil_model_4pool )
328c335
<                   'RothC and ECOSSE soil models cannot be used with ' //       &
---
>                   '4-pool and ECOSSE soil models cannot be used with ' //      &
338c345,346
< ! Check that l_layeredC=T is only used with 1-pool and RothC models.
---
> ! Check that l_layeredC=T is only used with 1-pool and 4-pool models.
> ! In addition modify value of dim_cslayer
342c350,351
<   CASE ( soil_model_1pool, soil_model_rothc )
---
>   CASE ( soil_model_1pool, soil_model_4pool )
>     dim_cslayer = sm_levels
356c365
< ! Can't trace soil carbon unless using roth C model
---
> ! Can't trace soil carbon unless using 4-pool C model
359c368
<   CASE ( soil_model_rothc )
---
>   CASE ( soil_model_4pool )
363c372
<                  'need Roth C to be true to trace a fraction of soil C')
---
>                  'need 4-pool C to be true to trace a fraction of soil C')
392,396c401,405
< ! check kaps_rothc, n_inorg_turnoverand bio_hum_cn are set for soil_model_rothc
< IF ( soil_bgc_model == soil_model_rothc ) THEN
<   IF ( ANY( ABS( kaps_roth(:) - rmdi ) < EPSILON(1.0) ) ) THEN
<     CALL ereport(RoutineName, errorstatus, "kaps_roth not found")
<   ELSE IF ( ANY(kaps_roth(:) < 1.0e-12) .OR. ANY(kaps_roth(:) > 1.0e-4) ) THEN
---
> ! check kaps_4pool, n_inorg_turnover and bio_hum_cn are set for soil_model_4pool
> IF ( soil_bgc_model == soil_model_4pool ) THEN
>   IF ( ANY( ABS( kaps_4pool(:) - rmdi ) < EPSILON(1.0) ) ) THEN
>     CALL ereport(RoutineName, errorstatus, "kaps_4pool not found")
>   ELSE IF ( ANY(kaps_4pool(:) < 1.0e-12) .OR. ANY(kaps_4pool(:) > 1.0e-4) ) THEN
398c407
<                  "kaps_roth must lie in the range 1.0e-12 to 1.0e-4")
---
>                  "kaps_4pool must lie in the range 1.0e-12 to 1.0e-4")
414c423
< END IF  ! end if soil_model_rothc
---
> END IF  ! end if soil_model_4pool
417,418c426,427
< ! check sorp is set for l_nitrogen and soil_model_rothc
< IF ( l_nitrogen .AND. soil_bgc_model == soil_model_rothc ) THEN  ! sorp
---
> ! check sorp is set for l_nitrogen and soil_model_4pool
> IF ( l_nitrogen .AND. soil_bgc_model == soil_model_4pool ) THEN  ! sorp
456a466,475
> ! check value of z_burn_max with l_layeredc
> IF ( l_layeredc ) THEN
>   IF ( ABS( z_burn_max - rmdi ) > EPSILON(1.0) ) THEN
>     IF ( z_burn_max <= 0.0 .OR. z_burn_max > SUM(dzsoil(:)) ) THEN
>       CALL ereport(RoutineName, errorstatus,                                   &
>                    "z_burn_max must be positive & less than total soil depth")
>     END IF
>   END IF
> END IF
> 
649c668
< WRITE(lineBuffer, *) ' kaps_roth = ', kaps_roth
---
> WRITE(lineBuffer, *) ' kaps_4pool = ', kaps_4pool
666a686,688
> WRITE(lineBuffer, *) ' z_burn_max = ', z_burn_max
> CALL jules_print('jules_soil_biogeochem_mod', lineBuffer)
> 
783c805
< INTEGER, PARAMETER :: n_real = 27 + 4
---
> INTEGER, PARAMETER :: n_real = 28 + 4
792c814
<   REAL(KIND=real_jlslsm) :: kaps_roth(4)
---
>   REAL(KIND=real_jlslsm) :: kaps_4pool(4)
817a840
>   REAL(KIND=real_jlslsm) :: z_burn_max
848c871
<   my_nml % kaps_roth         = kaps_roth
---
>   my_nml % kaps_4pool         = kaps_4pool
880a904
>   my_nml % z_burn_max       = z_burn_max
891c915
<   kaps_roth         = my_nml % kaps_roth
---
>   kaps_4pool         = my_nml % kaps_4pool
923a948
>   z_burn_max       = my_nml % z_burn_max
diff -r vn7.0copy1_c4/src/./control/shared/jules_soil_ecosse_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared/jules_soil_ecosse_mod.F90
21,22c21,22
<     decomp_rate, decomp_wrate_min_rothc, decomp_wrate_min_jules,               &
<     decomp_temp_coeff_rothc, decomp_ph_min, decomp_ph_max,                     &
---
>     decomp_rate, decomp_wrate_min_smith, decomp_wrate_min_clark,               &
>     decomp_temp_coeff_smith, decomp_ph_min, decomp_ph_max,                     &
82,83c82,83
<   temp_mod_rothc = 2,                                                          &
<     ! Value of temp_modifier that indicates the RothC form of the
---
>   temp_mod_smith = 2,                                                          &
>     ! Value of temp_modifier that indicates Smith et al. (2010) form of the
85,86c85,86
<   water_mod_jules = 1,                                                         &
<     ! Value of water_modifier that indicates the JULES form of the
---
>   water_mod_clark = 1,                                                         &
>     ! Value of water_modifier that indicates Clark et al. (2011) form of the
88,89c88,89
<   water_mod_rothc = 2
<     ! Value of water_modifier that indicates the RothC form of the
---
>   water_mod_smith = 2
>     ! Value of water_modifier that indicates Smith et al. (2010) form of the
148c148
<   temp_modifier = temp_mod_rothc,                                              &
---
>   temp_modifier = temp_mod_smith,                                              &
150c150
<   water_modifier = water_mod_rothc
---
>   water_modifier = water_mod_smith
180,181c180,181
<     decomp_rate, decomp_wrate_min_rothc, decomp_wrate_min_jules,               &
<     decomp_temp_coeff_rothc, decomp_ph_min, decomp_ph_max,                     &
---
>     decomp_rate, decomp_wrate_min_smith, decomp_wrate_min_clark,               &
>     decomp_temp_coeff_smith, decomp_ph_min, decomp_ph_max,                     &
214c214
<   timestep_len_real=>timestep
---
>   timestep
365c365
< IF ( dt_soilc <= 0.0 ) dt_soilc = timestep_len_real
---
> IF ( dt_soilc <= 0.0 ) dt_soilc = timestep
369c369
< IF ( MOD( dt_soilc, timestep_len_real ) > EPSILON(dt_soilc) ) THEN
---
> IF ( MOD( dt_soilc, timestep ) > EPSILON(dt_soilc) ) THEN
393c393
< CASE ( temp_mod_q10, temp_mod_rothc )
---
> CASE ( temp_mod_q10, temp_mod_smith )
402c402
< CASE ( water_mod_jules, water_mod_rothc )
---
> CASE ( water_mod_clark, water_mod_smith )
413c413
< IF ( ABS( dt_soilc - timestep_len_real ) < EPSILON(dt_soilc) ) THEN
---
> IF ( ABS( dt_soilc - timestep ) < EPSILON(dt_soilc) ) THEN
diff -r vn7.0copy1_c4/src/./control/shared/jules_soil_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared/jules_soil_mod.F90
32,34d31
< INTEGER, PARAMETER ::                                                          &
<   sm_levels_default = 4
< 
36,40c33
<   sm_levels = sm_levels_default
<       ! Number of soil layers (standalone only - this variable is not used
<       ! when run in the UM)
<       ! When running in the UM, its value is checked against the default and
<       ! a warning is issued if it has changed
---
>   sm_levels = imdi
175c168
< ! Levels - not used in the UM
---
> ! Soil levels
191c184
< SUBROUTINE check_jules_soil(sm_levels_in)
---
> SUBROUTINE check_jules_soil()
214,219d206
< INTEGER, INTENT(IN) :: sm_levels_in
<     ! The number of soil levels
<     ! This is passed in because the value in the namelist is not used when
<     ! running in the UM
<     ! This is due to complications with reading it from dump etc.
< 
225,239c212,216
< !-----------------------------------------------------------------------------
< ! Verify that a suitable sm_levels was given in the namelist
< !
< !   * If we are running in the UM and the user tried to specify sm_levels
< !     using the namelist, emit an error as it is probably something that
< !     needs looking at
< !     We use the passed in value instead
< !   * If we are running standalone, we ignore the passed in value and use the
< !     value from the namelist
< !-----------------------------------------------------------------------------
< #if defined(UM_JULES)
< IF ( sm_levels /= sm_levels_default ) THEN
<   CALL ereport(RoutineName, errorstatus,                                       &
<                "sm_levels cannot be set using the JULES_SOIL namelist " //     &
<                "when running as part of the UM")
---
> ! Check that sm_levels has been set
> IF ( sm_levels < 1 ) THEN
>   errorstatus = 101
>   CALL ereport("check_jules_soil", errorstatus,                                &
>                "sm_levels must be between 1 and sm_levels_max")
241,243d217
< 
< sm_levels = sm_levels_in
< #endif
diff -r vn7.0copy1_c4/src/./control/shared/jules_surface_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared/jules_surface_mod.F90
89a90,92
>   l_anthrop_heat_use_wrr = .FALSE.,                                            &
>       ! Internal switch for anthropogenic heat to use W/R if it exists to
>       ! maintain bit comparability
153c156
<    o2= 0.23,                                                                   &
---
>   o2 = 0.23,                                                                   &
441c444
<   IF ( ANY ( [ urban_roof, urban_canyon ] < 0 ) ) THEN
---
>   IF ( ANY ( [ urban_roof, urban_canyon ] <= 0 ) ) THEN
diff -r vn7.0copy1_c4/src/./control/shared/jules_urban_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared/jules_urban_mod.F90
18a19
> USE missing_data_mod,  ONLY: rmdi
23,26c24,27
<    anthrop_heat_scale = 1.0 ! Scales anthropogenic heat source of roof
<                             ! canyon from being equally distributed (= 1.0)
<                             ! to all being released in the canyon (= 0.0).
<                             ! Takes a value between 0.0 - 1.0
---
>    anthrop_heat_scale = rmdi ! Scales anthropogenic heat source of roof
>                              ! canyon from being equally distributed (= 1.0)
>                              ! to all being released in the canyon (= 0.0).
>                              ! Takes a value between 0.0 - 1.0
72,73c73,74
< USE jules_print_mgr, ONLY: jules_print
< USE jules_surface_mod, ONLY: l_urban2t, l_aggregate
---
> USE jules_print_mgr, ONLY: jules_print, jules_message
> USE jules_surface_mod, ONLY: l_urban2t, l_aggregate, l_anthrop_heat_src
134a136,145
> IF ( l_urban2t .AND. l_anthrop_heat_src ) THEN
>   IF ( anthrop_heat_scale < 0.0 .OR. anthrop_heat_scale > 1.0 ) THEN
>     errcode = 50
>     WRITE(jules_message,*)                                                     &
>        "anthrop_heat_scale is out of range: anthrop_heat_scale = ",            &
>        anthrop_heat_scale
>     CALL ereport(RoutineName, errcode, jules_message)
>   END IF
> END IF
> 
138c149
<     errcode = 50
---
>     errcode = 60
diff -r vn7.0copy1_c4/src/./control/shared/jules_vegetation_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared/jules_vegetation_mod.F90
47,49c47,49
<   photo_pmodel =3
<     ! plants use the model of Prentice et al., 2014, Ecology
<     ! letter,10.1111/ele.12211
---
>   photo_sox_collatz = 3
>     ! C3 plants use the model of Collatz et al.as derived for use with the
>     ! SOX stomata model.
63c63
<   photo_adapt_acclim = 3,                                                      &
---
>   photo_adapt_acclim = 3
65d64
<   photo_pmodel_acclim = 4
102c101
<   stomata_medlyn = 2
---
>   stomata_medlyn = 2,                                                          &
104a104,120
>   stomata_sox = 3
>     ! Use the semi-analytical version of the SOX model (Eller et al 2020)
>     ! doi: 10.1111/nph.16419 - Eqns. 4 & 5
> 
> ! Parameters identifying alternative leaf dark respiration models.
> ! These should have unique values.
> INTEGER, PARAMETER ::                                                          &
>   rd_classic = 1,                                                              &
>     ! Use the original model where Rd is a fixed fraction of Vcmax.
>     ! Eqn.13 of Clark et al (2011), doi:10.5194/gmd-4-701-2011.
>   rd_pftq10 = 2,                                                               &
>     ! Use explicitly a PFT-dependent Q10 with temperature adjustment,
>     ! regardless of how Vcmax is calculated.  This is analogous to Eqns.4 & 5
>     ! of Clark et al (2011), but for respiration.
>   rd_tdq10 = 3
>     ! Use a Q10 function in which Q10 depends linearly on temperature, as per
>     ! Eqn.1 of Atkin et al (2015) doi:10.1111/nph.13253.
138a155,156
>   l_vcmax_jmax_diurnal = .FALSE.,                                              &
>       !***rfu Switch to enable diurnal cycle of Vcmax and Jmax
178a197,198
>    l_sugar = .FALSE.,                                                          &
>        ! Switch fo the non-structural carbohydrate model
249,250c269,272
<   stomata_model = stomata_jacobs
<       ! Stomatal conductance model.
---
>   rd_model = imdi,                                                             &
>       ! Chosen model of leaf dark respiration.
>   stomata_model = imdi
>       ! Chosen model of stomatal conductance.
322c344
<   n_day_photo_acclim = rmdi
---
>   n_day_photo_acclim = rmdi,                                                   &
326a349,356
>   !---------------------------------------------------------------------------
>   ! Parameters used with the leaf dark respiration temperature-dependent Q10
>   ! model.
>   !---------------------------------------------------------------------------
>   tdq10_int = rmdi,                                                            &
>       ! Intercept in Q10 linear temperature dependence (unitless).
>   tdq10_slope = rmdi
>       ! Slope in Q10 linear temperature dependence (/degC).
345,346c375,377
<     photo_model, stomata_model, l_spec_veg_z0, l_limit_canhc,                  &
< ! Not used in the UM yet
---
>     photo_model, rd_model, tdq10_int, tdq10_slope, stomata_model,              &
>     l_spec_veg_z0, l_limit_canhc,                                              &
> ! Not used in the UM yet  !***rfu
349c380
<     l_trif_biocrop, l_ag_expand
---
>     l_trif_biocrop, l_ag_expand, l_sugar, l_vcmax_jmax_diurnal
358,361d388
< REAL :: alpha_acclim
<     ! Smoothing factor of exponential filter used with temperature acclmation.
<     ! Small values give large amounts of smoothing.
< 
386,387d412
< USE conversions_mod, ONLY:  rsec_per_day
< 
392,393d416
< USE timestep_mod, ONLY: timestep
< 
479c502
< CASE ( photo_collatz, photo_farquhar,photo_pmodel )
---
> CASE ( photo_collatz, photo_farquhar, photo_sox_collatz )
511,512d533
<   CASE (photo_pmodel_acclim)
<    l_acclim = .TRUE.
676,677c697
<   CASE (photo_pmodel_acclim)
<     ! NO checks necessary
---
> 
684,685c704
<        photo_acclim_model == photo_adapt_acclim  .OR.                          &
<        photo_acclim_model == photo_pmodel_acclim ) THEN
---
>        photo_acclim_model == photo_adapt_acclim ) THEN
692,696c711,714
<     ! Check that the timescale is not too short (to avoid problems when it
<     ! appears in the denominator). Here we compare with a timescale of 0.01
<     ! timesteps, which would anyway mean effectively instantaneous
<     ! acclimation.
<     IF ( n_day_photo_acclim < 0.01 * timestep / rsec_per_day ) THEN
---
>     ! Check that the acclimation timescale is long enough to avoid problems
>     ! when it appears in the denominator.  This timescale is typically tens of
>     ! days, so set 1 day as a hard lower bound.
>     IF ( n_day_photo_acclim < 1.0 ) THEN
699c717
<                    "n_day_photo_acclim is too small.")
---
>                    "n_day_photo_acclim must not be less than 1.0 days.")
701,704d718
<     ! Calculate the smoothing coefficient, assuming values will be sampled
<     ! every timestep.
<     alpha_acclim = 1.0 - EXP( -1.0 * timestep                                  &
<                               / ( n_day_photo_acclim * rsec_per_day ) )
705a720
> 
708,725c723,752
< !---------------------------------------------------------------------------
< ! check options for photo_pmodel
< !---------------------------------------------------------------------------
< IF (  photo_model == photo_pmodel ) THEN
<    SELECT CASE ( photo_acclim_model )
<     CASE ( 0 )
<     ! This is valid, nothing more to do.
<     CASE ( photo_adapt, photo_acclim, photo_adapt_acclim )
<     ! Set a switch to indicate to the UM that extra input fields are needed.
<     l_acclim = .TRUE.
<     CASE (photo_pmodel_acclim)
<     l_acclim = .TRUE.
<     CASE DEFAULT
<       errcode = 101  !  a fatal error
<       CALL ereport("check_jules_vegetation", errcode,                          &
<                  "Invalid value given for photo_acclim_model.")
<   END SELECT
< END IF ! photo_model ==photo_pmodel
---
> 
> ! Check that the leaf dark respiration model is reasonable.
> SELECT CASE ( rd_model )
> CASE ( rd_classic, rd_pftq10 )
>   ! These are valid, so nothing to do.
> CASE ( rd_tdq10 )
>   IF ( ANY(ABS([tdq10_slope, tdq10_int] - rmdi) < EPSILON(rmdi)) ) THEN
>     errcode = 101  !  a fatal error
>     CALL ereport("check_jules_vegetation", errcode,                            &
>                  "Both tdq10_slope and tdq10_int must be specified with " //   &
>                  "the TDQ10 leaf dark respiration model.")
>   END IF
> CASE DEFAULT
>   errcode = 101
>   CALL ereport("check_jules_vegetation", errcode,                              &
>                "Invalid value for rd_model" )
> END SELECT
> 
> IF ( (photo_model == photo_collatz) .AND. (rd_model == rd_pftq10) ) THEN
>   errcode = -101  ! Warning
>   CALL ereport("check_jules_vegetation", errcode,                              &
>                "rd_model=1 is recommended over rd_model=2 when " //            &
>                "Collatz photosynthesis is enabled." )
> END IF
> 
> IF ( (photo_model == photo_sox_collatz) .AND. (rd_model /= rd_classic) ) THEN
>   errcode = 101  ! Fatal error
>   CALL ereport("check_jules_vegetation", errcode,                              &
>                "rd_model=1 is required when SOX is enabled." )
> END IF
729c756
< CASE ( stomata_jacobs, stomata_medlyn )
---
> CASE ( stomata_jacobs, stomata_medlyn, stomata_sox )
908a936,938
> WRITE(lineBuffer,*) ' l_vcmax_jmax_diurnal = ',l_vcmax_jmax_diurnal
> CALL jules_print('jules_vegetation_mod',lineBuffer)
> 
986a1017,1028
> WRITE(lineBuffer,*)' l_sugar = ',l_sugar
> CALL jules_print('jules_vegetation_mod',lineBuffer)
> 
> WRITE(lineBuffer,*) ' rd_model = ',rd_model
> CALL jules_print('jules_vegetation_mod',lineBuffer)
> 
> WRITE(lineBuffer,*) ' tdq10_slope = ',tdq10_slope
> CALL jules_print('jules_vegetation_mod',lineBuffer)
> 
> WRITE(lineBuffer,*) ' tdq10_int = ',tdq10_int
> CALL jules_print('jules_vegetation_mod',lineBuffer)
> 
1027,1029c1069,1071
< INTEGER, PARAMETER :: n_int = 11
< INTEGER, PARAMETER :: n_real = 11 + (n_photo_coef * 5)
< INTEGER, PARAMETER :: n_log = 27 + npft_max
---
> INTEGER, PARAMETER :: n_int = 12
> INTEGER, PARAMETER :: n_real = 13 + (n_photo_coef * 5)
> INTEGER, PARAMETER :: n_log = 28 + npft_max
1043a1086
>   INTEGER :: rd_model
1059a1103,1104
>   REAL(KIND=real_jlslsm) :: tdq10_slope
>   REAL(KIND=real_jlslsm) :: tdq10_int
1067a1113
>   LOGICAL :: l_vcmax_jmax_diurnal  
1087a1134
>   LOGICAL :: l_sugar
1115a1163
>   my_nml % rd_model        = rd_model
1131a1180,1181
>   my_nml % tdq10_slope     = tdq10_slope
>   my_nml % tdq10_int       = tdq10_int
1139a1190
>   my_nml % l_vcmax_jmax_diurnal     = l_vcmax_jmax_diurnal  
1159a1211
>   my_nml % l_sugar         = l_sugar
1176a1229
>   rd_model        = my_nml % rd_model
1192a1246,1247
>   tdq10_slope     = my_nml % tdq10_slope
>   tdq10_int       = my_nml % tdq10_int
1200a1256
>   l_vcmax_jmax_diurnal  = my_nml % l_vcmax_jmax_diurnal
1220a1277
>   l_sugar         = my_nml % l_sugar
diff -r vn7.0copy1_c4/src/./control/shared/jules_water_resources_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared/jules_water_resources_mod.F90
153c153
<   nwater_use,                                                                  &
---
>   nwater_use = imdi,                                                           &
154a155,158
>   !----------------------------------------------------------------------------
>   ! The following indices should be initialised to zero, to indicate that a
>   ! water use is not considered.
>   !----------------------------------------------------------------------------
170,205d173
< ! Array variables.
< INTEGER, ALLOCATABLE ::                                                        &
<   priority_order(:,:)
<     ! Priorities of water demands at each gridpoint, in order of decreasing
<     ! priority. Values are the index in multi-sector arrays.
<     ! e.g. priority_order(l,1) = 3 indicates that the first priority use is
<     !      in slice 3 of multi-sector arrays.
< 
< REAL(KIND=real_jlslsm), ALLOCATABLE ::                                         &
<   demand_accum(:,:),                                                           &
<     ! Demands for water accumulated over the water resource timestep (kg).
<     ! Note that in general this should be written to restart files (dumps)
<     ! but this is not done yet.
<   !---------------------------------------------------------------------------
<   ! Demands that can be prescribed.
<   !---------------------------------------------------------------------------
<   demand_rate_domestic(:),                                                     &
<     ! Demand for water for domestic use (kg s-1).
<   demand_rate_industry(:),                                                     &
<     ! Demand for water for industrial use (kg s-1).
<   demand_rate_livestock(:),                                                    &
<     ! Demand for water for livestock (kg s-1).
<   demand_rate_transfers(:),                                                    &
<     ! Demand for water for (explicit) transfers (kg s-1).
<   !---------------------------------------------------------------------------
<   ! Ancillary fields.
<   !---------------------------------------------------------------------------
<   conveyance_loss(:),                                                          &
<     ! Fraction of water that is lost during conveyance from source to user.
<   irrig_eff(:),                                                                &
<     ! Irrigation efficiency i.e. the fraction of the water withdrawn for
<     ! irrigation that is demanded by the crop scheme.
<   sfc_water_frac(:)
<     ! Target for the fraction of demand that will be met from surface water
<     ! (as opposed to groundwater).
< 
745,837d712
< !#############################################################################
< !#############################################################################
< 
< SUBROUTINE water_resources_alloc( land_pts )
< 
< ! Allocate arrays.
< ! No USE statements other than error reporting and Dr Hook (if required).
< 
< IMPLICIT NONE
< 
< ! Arguments.
< INTEGER, INTENT(IN) :: land_pts
<   ! Number of land points.
< 
< ! Local parameters.
< CHARACTER(LEN=*), PARAMETER :: RoutineName = 'WATER_RESOURCES_ALLOC'
< 
< ! Local scalar variables.
< INTEGER :: land_pts_dim, nwater_use_dim
< 
< !-----------------------------------------------------------------------------
< ! Arrays are always allocated, but with minimal size if the science is not
< ! selected. Decide on sizes.
< !-----------------------------------------------------------------------------
< IF ( l_water_resources ) THEN
<   land_pts_dim   = land_pts
<   nwater_use_dim = nwater_use
< ELSE
<   land_pts_dim   = 1
<   nwater_use_dim = 1
< END IF
< 
< !-----------------------------------------------------------------------------
< ! Individual demands (which can be prescibed).
< ! We allocate a minimum size if a sector is not being used.
< !-----------------------------------------------------------------------------
< IF ( l_water_domestic ) THEN
<   ALLOCATE( demand_rate_domestic(land_pts_dim) )
< ELSE
<   ALLOCATE( demand_rate_domestic(1) )
< END IF
< 
< IF ( l_water_industry ) THEN
<   ALLOCATE( demand_rate_industry(land_pts_dim) )
< ELSE
<   ALLOCATE( demand_rate_industry(1) )
< END IF
< 
< IF ( l_water_livestock ) THEN
<   ALLOCATE( demand_rate_livestock(land_pts_dim) )
< ELSE
<   ALLOCATE( demand_rate_livestock(1) )
< END IF
< 
< IF ( l_water_transfers ) THEN
<   ALLOCATE( demand_rate_transfers(land_pts_dim) )
< ELSE
<   ALLOCATE( demand_rate_transfers(1) )
< END IF
< 
< demand_rate_domestic(:)  = 0.0
< demand_rate_industry(:)  = 0.0
< demand_rate_livestock(:) = 0.0
< demand_rate_transfers(:) = 0.0
< 
< !-----------------------------------------------------------------------------
< ! Accumulated demands.
< !-----------------------------------------------------------------------------
< ALLOCATE( demand_accum(land_pts_dim,nwater_use_dim) )
< demand_accum(:,:) = 0.0
< 
< !-----------------------------------------------------------------------------
< ! Ancillary fields.
< !-----------------------------------------------------------------------------
< ALLOCATE( conveyance_loss(land_pts_dim) )
< IF ( l_water_irrigation ) THEN
<   ALLOCATE( irrig_eff(land_pts_dim) )
< ELSE
<   ALLOCATE( irrig_eff(1) )
< END IF
< ALLOCATE( sfc_water_frac(land_pts_dim) )
< conveyance_loss(:) = 0.0
< irrig_eff(:)       = 0.0
< sfc_water_frac(:)  = 0.0
< 
< !-----------------------------------------------------------------------------
< ! Other variables.
< !-----------------------------------------------------------------------------
< ALLOCATE( priority_order(land_pts_dim,nwater_use_dim) )
< priority_order(:,:) = 0
< 
< RETURN
< END SUBROUTINE water_resources_alloc
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared: jules_water_tracers_mod.F90
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared: jules_wtrac_type_mod.F90
diff -r vn7.0copy1_c4/src/./control/shared/land_tile_ids_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared/land_tile_ids_mod.F90
20a21,24
> USE free_tracers_inputs_mod, ONLY: max_wtrac
> 
> USE jules_sea_seaice_mod, ONLY: nice_max
> 
123c127
<                 ! Array which maps pseudo levels to tile types
---
>               ! Array which maps pseudo levels to tile types
126c130
<                 ! Array which maps pseudo levels to tile types
---
>               ! Array which maps pseudo levels to tile types
129c133,144
<                 ! Tile IDs in the input header
---
>               ! Tile IDs in the input header
> 
> INTEGER :: surface_type_wtrac_ids(ntype_max*max_wtrac) = imdi
>               ! Array which maps pseudo levels to tile types and water tracers
> 
> INTEGER :: ml_snow_type_wtrac_ids(ntype_max*snow_layers_max*max_wtrac) = imdi
>               ! Array which maps pseudo levels to tile types, snow layers and
>               !  water tracers
> 
> INTEGER :: seaice_wtrac_ids(nice_max*max_wtrac) = imdi
>               ! Array which maps pseudo levels to sea ice categories and
>               !  water tracers
294a310,379
> 
> ! ============================================================
> 
> SUBROUTINE set_surface_type_wtrac_ids ()
> 
> USE jules_surface_types_mod, ONLY: ntype
> USE jules_water_tracers_mod, ONLY: n_wtrac_jls
> 
> IMPLICIT NONE
> 
> INTEGER      :: i, i_wt ! Loop counter
> INTEGER      :: pseudo
> 
> ! Set up land tiles * water tracers type (pl_code = 23) ids array
> DO i = 1, ntype
>   DO i_wt = 1, n_wtrac_jls
>     pseudo = i + (i_wt-1) * ntype
>     surface_type_wtrac_ids(pseudo) = surface_type_ids(i) * 1000 + i_wt
>   END DO
> END DO
> 
> END SUBROUTINE set_surface_type_wtrac_ids
> 
> ! ======================================================================
> 
> SUBROUTINE set_ml_snow_type_wtrac_ids ( )
> 
> USE jules_surface_types_mod, ONLY: ntype
> USE jules_snow_mod,          ONLY: nsmax
> USE jules_water_tracers_mod, ONLY: n_wtrac_jls
> 
> IMPLICIT NONE
> 
> INTEGER      :: i, j, i_wt ! Loop counter
> INTEGER      :: pseudo
> 
> ! Set up multilayer snow * water tracer type (pl_code = 24) ids array
> DO i = 1, ntype
>   DO j = 1, nsmax
>     DO i_wt = 1, n_wtrac_jls
>       pseudo = i + (j-1) * ntype + (i_wt-1) * ntype*nsmax
>       ml_snow_type_wtrac_ids(pseudo) = surface_type_ids(i) * 1000000           &
>                                         + j*1000 + i_wt
>     END DO
>   END DO
> END DO
> 
> END SUBROUTINE set_ml_snow_type_wtrac_ids
> 
> ! ======================================================================
> 
> SUBROUTINE set_seaice_wtrac_ids ( )
> 
> USE jules_sea_seaice_mod,    ONLY: nice
> USE jules_water_tracers_mod, ONLY: n_wtrac_jls
> 
> IMPLICIT NONE
> 
> INTEGER      :: i, i_wt ! Loop counter
> INTEGER      :: pseudo
> 
> ! Set up sea ice category * water tracer type (pl_code = 25) ids array
> DO i = 1, nice
>   DO i_wt = 1, n_wtrac_jls
>     pseudo = i + (i_wt-1) * nice
>     seaice_wtrac_ids(pseudo) = i * 1000 + i_wt
>   END DO
> END DO
> 
> END SUBROUTINE set_seaice_wtrac_ids
diff -r vn7.0copy1_c4/src/./control/shared/max_dimensions.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared/max_dimensions.F90
45c45
<   ndep_species_max  = 50
---
>   ndep_species_max  = 200
diff -r vn7.0copy1_c4/src/./control/shared/overbank_inundation_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared/overbank_inundation_mod.F90
25c25
< USE missing_data_mod, ONLY: rmdi
---
> USE missing_data_mod, ONLY: imdi, rmdi
31a32,48
> ! Constants identifying overbank inundation models.
> !-----------------------------------------------------------------------------
> INTEGER, PARAMETER ::                                                          &
>   overbank_simple = 1,                                                         &
>     ! Constant indicating that the inundated area is calculated using an
>     ! allometric relationship to estimate river width, without use of
>     ! topographic data.
>   overbank_simple_rosgen = 2,                                                  &
>     ! Constant indicating that the inundated area is calculated using
>     ! allometric relationships to estimate river width and depth, and the
>     ! Rosgen entrenchment ratio, without use of topographic data,
>   overbank_hypsometric = 3
>     ! Constant indicating that the inundated area is calculated using a
>     ! hypsometric integral and an allometric relationship to estimate river
>     ! depth.
> 
> !-----------------------------------------------------------------------------
35a53,55
> INTEGER ::                                                                     &
>   overbank_model = imdi
>     ! Switch used to select the model of overbank inundation.
60,73d79
< LOGICAL ::                                                                     &
<    l_riv_overbank = .FALSE.,                                                   &
<                             ! Logical to control overbank inundation
<    l_riv_hypsometry = .TRUE.,                                                  &
<                             ! TRUE indicates to calculate inundated area
<                             ! using hypsometry, which requires additional
<                             ! ancillaries logn_mean and logn_stdev
<                             ! FALSE indicates to use a simpler width scaling
<                             ! method (generally only to be used for testing
<                             ! when those ancillaries are not available).
<    use_rosgen = .FALSE.
<                             ! Modify floodplain width using the Rosgen
<                             ! entrenchment ratio (n.b. only for local use)
< 
117,119c123,124
< NAMELIST  / jules_overbank/                                                    &
<   l_riv_overbank, l_riv_hypsometry, use_rosgen,                                &
<   riv_a, riv_b, riv_c, riv_f, coef_b, exp_c, ent_ratio
---
> NAMELIST  /jules_overbank/                                                     &
>   overbank_model, riv_a, riv_b, riv_c, riv_f, coef_b, exp_c, ent_ratio
131c136
< USE jules_rivers_mod, ONLY: l_rivers
---
> USE jules_rivers_mod, ONLY: l_rivers, l_riv_overbank
137c142,144
< ! Current Code Owner: Toby Marthews (CEH)
---
> ! Code Owner:
> !   Please refer to ModuleLeaders.txt
> !   This file belongs in section: Hydrology
150,151c157,169
< ! If overbank is not selected, there's nothing more to do here, so leave.
< IF ( .NOT. l_riv_overbank ) RETURN
---
> 
> IF ( .NOT. l_riv_overbank ) THEN
>   ! For clarity, raise an error if a model is specified but l_riv_overbank=F.
>   IF ( overbank_model /= imdi ) THEN
>     errcode = 101
>     CALL ereport(RoutineName, errcode,                                         &
>                  'overbank_model should not be specified if '               // &
>                  'l_riv_overbank = .FALSE')
>   ELSE
>     ! No model specified, nothing more to do here.
>     RETURN
>   END IF
> END IF
154c172
< IF ( ( .NOT. l_rivers) .AND. l_riv_overbank) THEN
---
> IF ( .NOT. l_rivers ) THEN
159a178,187
> ! Check that a valid overbank model is specified.
> SELECT CASE ( overbank_model )
> CASE ( overbank_simple, overbank_simple_rosgen, overbank_hypsometric )
>   ! Valid options, nothing to do.
> CASE DEFAULT
>   errcode = 101
>   CALL ereport(RoutineName, errcode,                                           &
>                'Invalid value for overbank_model')
> END SELECT
> 
166,167c194,195
< ! Check parameters that are required if l_riv_hypsometry = T or
< ! use_rosgen = T.
---
> ! Check values that are only required with overbank_model = simple or
> ! simple_rosgen.
169c197,198
< IF ( l_riv_hypsometry .OR. use_rosgen ) THEN
---
> SELECT CASE ( overbank_model )
> CASE ( overbank_simple, overbank_simple_rosgen )
171,186c200
<   IF ( ABS( riv_c - rmdi ) < EPSILON(1.0) ) THEN
<     errcode = 101
<     CALL ereport(RoutineName, errcode,'No value found for riv_c.')
<   END IF
< 
<   IF ( ABS( riv_f - rmdi ) < EPSILON(1.0) ) THEN
<     errcode = 101
<     CALL ereport(RoutineName, errcode,'No value found for riv_f.')
<   END IF
< 
< END IF
< 
< !-----------------------------------------------------------------------------
< ! Check values that are only required if l_riv_hypsometry = F.
< !-----------------------------------------------------------------------------
< IF ( .NOT. l_riv_hypsometry ) THEN
---
>   ! Parameters for river width allometry are required.
199c213
<   ! Check values that are only required if use_rosgen = T.
---
>   ! Check values that are only required with overbak_model = rosgen.
201c215,217
<   IF ( use_rosgen ) THEN
---
>   IF ( overbank_model == overbank_simple_rosgen ) THEN
> 
>     ! Parameters for bankfull discharge and entrenchment ratio are required.
218c234,255
<   END IF  !  use_rosgen
---
>   END IF  !  overbank_simple_rosgen
> 
> END SELECT
> 
> !-----------------------------------------------------------------------------
> ! Check parameters that are required with overbank_model = simple_rosgen or
> ! hypso.
> !-----------------------------------------------------------------------------
> SELECT CASE ( overbank_model )
> CASE ( overbank_simple_rosgen, overbank_hypsometric )
> 
>   ! Parameters for river depth allometry are required.
> 
>   IF ( ABS( riv_c - rmdi ) < EPSILON(1.0) ) THEN
>     errcode = 101
>     CALL ereport(RoutineName, errcode,'No value found for riv_c.')
>   END IF
> 
>   IF ( ABS( riv_f - rmdi ) < EPSILON(1.0) ) THEN
>     errcode = 101
>     CALL ereport(RoutineName, errcode,'No value found for riv_f.')
>   END IF
220c257
< END IF  !  .NOT. l_riv_hypsometry
---
> END SELECT
224c261,307
< !#############################################################################
---
> !##############################################################################
> 
> SUBROUTINE init_rosgen_vars( rivers )
> 
> USE jules_rivers_mod, ONLY: np_rivers, rivers_type
> 
> IMPLICIT NONE
> 
> !------------------------------------------------------------------------------
> ! Arguments with INTENT(IN)
> !------------------------------------------------------------------------------
> TYPE(rivers_type), INTENT(IN) :: rivers
> 
> !------------------------------------------------------------------------------
> ! Local parameters.
> !------------------------------------------------------------------------------
> REAL(KIND=real_jlslsm), PARAMETER :: m2tokm2 = 1.0e-6
>   ! Conversion from m2 to km2
> 
> !------------------------------------------------------------------------------
> ! Local scalar variables.
> !------------------------------------------------------------------------------
> INTEGER :: ip
> 
> REAL(KIND=real_jlslsm) :: contribarea
>   ! Upstream contributing drainage area (km2).
> 
> !------------------------------------------------------------------------------
> ! Define overbank inundation initial variables for bankfull on river points
> ! if using Rosgen entrenchment option.
> ! Bankfull discharge (qbf) from power-law relationship from
> ! "Flood Modeling, Prediction and Mitigation" by Sen 2018.
> ! Bankfull width and depth (wbf, dbf) from Leopold   & Maddock (1953).
> !------------------------------------------------------------------------------
> DO ip = 1,np_rivers
>   contribarea = (rivers%rivers_boxareas_rp(ip) * m2tokm2) *                    &
>                 ( 1.0 + MAX(0.0, REAL(rivers%rfm_iarea_rp(ip))) )
>   qbf(ip) = coef_b * ( contribarea**exp_c )
>   wbf(ip) = riv_a * ( qbf(ip)**riv_b )
>   dbf(ip) = riv_c * ( qbf(ip)**riv_f )
> END DO
> 
> RETURN
> END SUBROUTINE init_rosgen_vars
> 
> !##############################################################################
> !##############################################################################
238,242c321
< WRITE(lineBuffer,*)' l_riv_overbank = ',l_riv_overbank
< CALL jules_print('jules_overbank',lineBuffer)
< WRITE(lineBuffer,*)' l_riv_hypsometry = ',l_riv_hypsometry
< CALL jules_print('jules_overbank',lineBuffer)
< WRITE(lineBuffer,*)' use_rosgen = ',use_rosgen
---
> WRITE(lineBuffer,*)' overbank_model = ',overbank_model
265a345,396
> #if !defined(UM_JULES) && !defined(LFRIC)
> SUBROUTINE read_nml_jules_overbank(nml_dir)
> 
> USE io_constants, ONLY: namelist_unit
> 
> USE string_utils_mod, ONLY: to_string
> 
> USE logging_mod, ONLY: log_info, log_fatal
> 
> IMPLICIT NONE
> 
> ! Arguments
> CHARACTER(LEN=*), INTENT(IN) :: nml_dir  ! The directory containing the
>                                          ! namelists
> ! Work variables
> INTEGER :: ERROR  ! Error indicator
> 
> CHARACTER(LEN=*), PARAMETER :: RoutineName='READ_NML_JULES_OVERBANK'
> 
> !-----------------------------------------------------------------------------
> ! Read river routing namelist
> !----------------------------------------------------------------------------
> CALL log_info(RoutineName, "Reading JULES_OVERBANK namelist...")
> 
> ! Open the river routing parameters namelist file
> OPEN(namelist_unit, FILE=(TRIM(nml_dir) // '/' // 'jules_rivers.nml'),         &
>                STATUS='old', POSITION='rewind', ACTION='read', IOSTAT = ERROR)
> IF ( ERROR /= 0 ) THEN
>   CALL log_fatal(RoutineName,                                                  &
>                  "Error opening namelist file jules_rivers.nml " //            &
>                  "(IOSTAT=" // TRIM(to_string(ERROR)) // ")")
> END IF
> 
> READ(namelist_unit, NML = jules_overbank, IOSTAT = ERROR)
> IF ( ERROR /= 0 ) THEN
>   CALL log_fatal(RoutineName,                                                  &
>                  "Error reading namelist JULES_OVERBANK " //                   &
>                  "(IOSTAT=" // TRIM(to_string(ERROR)) // ")")
> END IF
> 
> CLOSE(namelist_unit, IOSTAT = ERROR)
> IF ( ERROR /= 0 ) THEN
>   CALL log_fatal(RoutineName,                                                  &
>                  "Error closing namelist file jules_rivers.nml " //            &
>                  "(IOSTAT=" // TRIM(to_string(ERROR)) // ")")
> END IF
> 
> END SUBROUTINE read_nml_jules_overbank
> #endif
> 
> !#############################################################################
> 
291a423
> INTEGER, PARAMETER :: n_int = 1
293d424
< INTEGER, PARAMETER :: n_log = 3
297,299c428
<   LOGICAL :: l_riv_overbank
<   LOGICAL :: l_riv_hypsometry
<   LOGICAL :: use_rosgen
---
>   INTEGER :: overbank_model
316c445
<                     n_real_in = n_real, n_log_in = n_log)
---
>                     n_int_in = n_int, n_real_in = n_real)
323,325c452
<   my_nml % l_riv_overbank   = l_riv_overbank
<   my_nml % l_riv_hypsometry = l_riv_hypsometry
<   my_nml % use_rosgen       = use_rosgen
---
>   my_nml % overbank_model   = overbank_model
340,342c467
<   l_riv_overbank = my_nml % l_riv_overbank
<   l_riv_hypsometry = my_nml % l_riv_hypsometry
<   use_rosgen = my_nml % use_rosgen
---
>   overbank_model = my_nml % overbank_model
diff -r vn7.0copy1_c4/src/./control/shared/prognostics.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared/prognostics.F90
188c188
<   REAL(KIND=real_jlslsm), ALLOCATABLE :: t_growth_gb(:,:)
---
>   REAL(KIND=real_jlslsm), ALLOCATABLE :: t_growth_gb(:)
191,229c191,192
<   REAL(KIND=real_jlslsm), ALLOCATABLE :: l_growth_gb(:,:)
<   ! Average light for thermal acclimation of
<   ! photosynthetic capacity (W m-2).
<   REAL(KIND=real_jlslsm), ALLOCATABLE :: vpd_growth_gb(:,:)
<   ! Average vapour pressure deficit for thermal acclimation of
<   ! photosynthetic capacity (Pa).
<   REAL(KIND=real_jlslsm), ALLOCATABLE :: co2_growth_gb(:,:)
<   ! Average co2 for thermal acclimation of
<   ! photosynthetic capacity (Pa).
<   REAL(KIND=real_jlslsm), ALLOCATABLE :: pstar_growth_gb(:,:)
<   ! Average surface pressure for thermal acclimation of
<   ! photosynthetic capacity (Pa).
<   REAL(KIND=real_jlslsm), ALLOCATABLE :: xipam_opt(:,:)
<   ! Sensitivity of ci/ca ratio to VPD at 
<   ! optimal condition (Pa^1/2)
<   REAL(KIND=real_jlslsm), ALLOCATABLE :: vcmax_opt(:,:)
<     ! Maximum rate of carboxylation at optimal
<   ! condition(mol CO2/m2s)
<   REAL(KIND=real_jlslsm), ALLOCATABLE :: jmax_opt(:,:)
<   ! Maximum rate of electon transportation at optimal
<   ! condition(mol CO2/m2s)
<  ! REAL(KIND=real_jlslsm), ALLOCATABLE :: Rd25New(:,:)
<   ! Rd25 adjusted to prior [15] night conditions
<   ! (umol co2/m2/s)
<   REAL(KIND=real_jlslsm), ALLOCATABLE :: t_sum(:,:)
<   ! Daily temperature, sum of noon condition
<   REAL(KIND=real_jlslsm), ALLOCATABLE :: l_sum(:,:)
<   ! Daily light, sum of noon condition
<     REAL(KIND=real_jlslsm), ALLOCATABLE :: co2_sum(:,:)
<   ! Daily co2, sum of noon condition
<    REAL(KIND=real_jlslsm), ALLOCATABLE :: vpd_sum(:,:)
<   ! Daily vpd, sum of noon condition
<    REAL(KIND=real_jlslsm), ALLOCATABLE :: t_night(:,:)
<   ! Average temperature (night temperature) for thermal acclimation of
<   ! dark respiration (K).
<   REAL(KIND=real_jlslsm), ALLOCATABLE :: nt_sum(:,:)
<   ! Daily light, sum of night condition
<   REAL(KIND=real_jlslsm), ALLOCATABLE :: pstar_sum(:,:)
<   ! Daily atmospheric pressure, sum of noon condition
---
>   REAL(KIND=real_jlslsm), ALLOCATABLE :: f_nsc_pft(:,:)
>     ! Non-structural carbohydrate mass fraction (kgC/kgC)
292,308c255,256
<   REAL(KIND=real_jlslsm), POINTER :: t_growth_gb(:,:)
<   REAL(KIND=real_jlslsm), POINTER :: l_growth_gb(:,:)
<   REAL(KIND=real_jlslsm), POINTER :: vpd_growth_gb(:,:)
<   REAL(KIND=real_jlslsm), POINTER :: co2_growth_gb(:,:)
<   REAL(KIND=real_jlslsm), POINTER :: pstar_growth_gb(:,:)
<   REAL(KIND=real_jlslsm), POINTER :: xipam_opt(:,:)
<   REAL(KIND=real_jlslsm), POINTER :: vcmax_opt(:,:)
<   REAL(KIND=real_jlslsm), POINTER :: jmax_opt(:,:)
<   !REAL(KIND=real_jlslsm), POINTER :: Rd25New(:,:)
<   REAL(KIND=real_jlslsm), POINTER :: t_sum(:,:)
<   REAL(KIND=real_jlslsm), POINTER :: l_sum(:,:)
<   REAL(KIND=real_jlslsm), POINTER :: co2_sum(:,:)
<   REAL(KIND=real_jlslsm), POINTER :: t_night(:,:)
<   REAL(KIND=real_jlslsm), POINTER :: nt_sum(:,:)
<   REAL(KIND=real_jlslsm), POINTER :: vpd_sum(:,:)
<   REAL(KIND=real_jlslsm), POINTER :: pstar_sum(:,:)
<   
---
>   REAL(KIND=real_jlslsm), POINTER :: t_growth_gb(:)
>   REAL(KIND=real_jlslsm), POINTER :: f_nsc_pft(:,:)
329c277
<                        nmasst, nnpft, l_acclim, progs_data)
---
>                        nmasst, nnpft, l_acclim, l_sugar, progs_data)
344c292
<                        l_acclim
---
>                        l_acclim, l_sugar
489,504c437
<   ALLOCATE(progs_data%t_growth_gb(land_pts,npft))
<   ALLOCATE(progs_data%l_growth_gb(land_pts,npft))
<   ALLOCATE(progs_data%vpd_growth_gb(land_pts,npft))
<   ALLOCATE(progs_data%co2_growth_gb(land_pts,npft))
<   ALLOCATE(progs_data%pstar_growth_gb(land_pts,npft))
<   ALLOCATE(progs_data%xipam_opt(land_pts,npft))
<   ALLOCATE(progs_data%vcmax_opt(land_pts,npft))
<   ALLOCATE(progs_data%jmax_opt(land_pts,npft))
<  ! ALLOCATE(progs_data%Rd25New(land_pts,npft))
<   ALLOCATE(progs_data%t_sum(land_pts,npft))
<   ALLOCATE(progs_data%l_sum(land_pts,npft))
<   ALLOCATE(progs_data%t_night(land_pts,npft))
<   ALLOCATE(progs_data%nt_sum(land_pts,npft))
<   ALLOCATE(progs_data%co2_sum(land_pts,npft))
<   ALLOCATE(progs_data%vpd_sum(land_pts,npft))
<   ALLOCATE(progs_data%pstar_sum(land_pts,npft))
---
>   ALLOCATE(progs_data%t_growth_gb(land_pts))
506,521c439
<   progs_data%t_growth_gb(:,:)         = 0.0
<   progs_data%l_growth_gb(:,:)         = 0.0
<   progs_data%vpd_growth_gb(:,:)       = 0.0
<   progs_data%co2_growth_gb(:,:)       = 0.0
<   progs_data%pstar_growth_gb(:,:)     = 0.0
<   progs_data%xipam_opt(:,:)           = 0.0
<   progs_data%vcmax_opt(:,:)           = 0.0
<   progs_data%jmax_opt(:,:)            = 0.0
<  ! progs_data%Rd25New(:,:)             = 0.0
<   progs_data%t_sum(:,:)               = 0.0
<   progs_data%l_sum(:,:)               = 0.0
<   progs_data%t_night(:,:)             = 0.0
<   progs_data%nt_sum(:,:)              = 0.0
<   progs_data%co2_sum(:,:)             = 0.0
<   progs_data%vpd_sum(:,:)             = 0.0
<   progs_data%pstar_sum(:,:)           = 0.0
---
>   progs_data%t_growth_gb(:)         = 0.0
524,539c442
<   ALLOCATE(progs_data%t_growth_gb(1,1))
<   ALLOCATE(progs_data%l_growth_gb(1,1))
<   ALLOCATE(progs_data%vpd_growth_gb(1,1))
<   ALLOCATE(progs_data%co2_growth_gb(1,1))
<   ALLOCATE(progs_data%pstar_growth_gb(1,1))
<   ALLOCATE(progs_data%xipam_opt(1,1))
<   ALLOCATE(progs_data%vcmax_opt(1,1))
<   ALLOCATE(progs_data%jmax_opt(1,1))
<   !ALLOCATE(progs_data%Rd25New(1,1))
<   ALLOCATE(progs_data%t_sum(1,1))
<   ALLOCATE(progs_data%l_sum(1,1))
<   ALLOCATE(progs_data%t_night(1,1))
<   ALLOCATE(progs_data%nt_sum(1,1))
<   ALLOCATE(progs_data%co2_sum(1,1))
<   ALLOCATE(progs_data%vpd_sum(1,1))
<   ALLOCATE(progs_data%pstar_sum(1,1))
---
>   ALLOCATE(progs_data%t_growth_gb(1))
541,555c444
<   progs_data%t_growth_gb(1,1)       = 0.0
<   progs_data%l_growth_gb(1,1)         = 0.0
<   progs_data%vpd_growth_gb(1,1)       = 0.0
<   progs_data%pstar_growth_gb(1,1)     = 0.0
<   progs_data%xipam_opt(1,1)           = 0.0
<   progs_data%vcmax_opt(1,1)           = 0.0
<   progs_data%jmax_opt(1,1)            = 0.0
<   !progs_data%Rd25New(1,1)             = 0.0
<   progs_data%t_sum(1,1)               = 0.0
<   progs_data%l_sum(1,1)               = 0.0
<   progs_data%t_night(1,1)             = 0.0
<   progs_data%nt_sum(1,1)              = 0.0
<   progs_data%co2_sum(1,1)              = 0.0
<   progs_data%vpd_sum(1,1)             = 0.0
<   progs_data%pstar_sum(1,1)           = 0.0
---
>   progs_data%t_growth_gb(1)         = 0.0
557a447,451
> ! Prognostics for SUGAR module
> ALLOCATE(progs_data%f_nsc_pft(land_pts,npft))
> progs_data%f_nsc_pft(:,:) = 0.0
> 
> 
679,693c573,576
<   DEALLOCATE(progs_data%l_growth_gb)
<   DEALLOCATE(progs_data%vpd_growth_gb)
<   DEALLOCATE(progs_data%co2_growth_gb)
<   DEALLOCATE(progs_data%pstar_growth_gb)
<   DEALLOCATE(progs_data%xipam_opt)
<   DEALLOCATE(progs_data%vcmax_opt)
<   DEALLOCATE(progs_data%jmax_opt)
<  ! DEALLOCATE(progs_data%Rd25New)
<   DEALLOCATE(progs_data%t_sum)
<   DEALLOCATE(progs_data%l_sum)
<   DEALLOCATE(progs_data%t_night)
<   DEALLOCATE(progs_data%nt_sum)
<   DEALLOCATE(progs_data%co2_sum)
<   DEALLOCATE(progs_data%vpd_sum)
<   DEALLOCATE(progs_data%pstar_sum)
---
> END IF
> 
> IF ( ALLOCATED(progs_data%f_nsc_pft) ) THEN
>   DEALLOCATE(progs_data%f_nsc_pft)
809,823c692
< progs%l_growth_gb => progs_data%l_growth_gb
< progs%vpd_growth_gb => progs_data%vpd_growth_gb
< progs%co2_growth_gb => progs_data%co2_growth_gb
< progs%pstar_growth_gb => progs_data%pstar_growth_gb
< progs%xipam_opt => progs_data%xipam_opt
< progs%vcmax_opt => progs_data%vcmax_opt
< progs%jmax_opt => progs_data%jmax_opt
< !progs%Rd25New => progs_data%Rd25New
< progs%t_sum => progs_data%t_sum
< progs%l_sum => progs_data%l_sum
< progs%t_night => progs_data%t_night
< progs%nt_sum => progs_data%nt_sum
< progs%vpd_sum => progs_data%vpd_sum
< progs%co2_sum => progs_data%co2_sum
< progs%pstar_sum => progs_data%pstar_sum
---
> progs%f_nsc_pft => progs_data%f_nsc_pft
914,928c783
< NULLIFY(progs%l_growth_gb)
< NULLIFY(progs%vpd_growth_gb)
< NULLIFY(progs%co2_growth_gb)
< NULLIFY(progs%pstar_growth_gb)
< NULLIFY(progs%xipam_opt)
< NULLIFY(progs%vcmax_opt)
< NULLIFY(progs%jmax_opt)
< !NULLIFY(progs%Rd25New)
< NULLIFY(progs%t_sum)
< NULLIFY(progs%l_sum)
< NULLIFY(progs%t_night)
< NULLIFY(progs%nt_sum)
< NULLIFY(progs%co2_sum)
< NULLIFY(progs%vpd_sum)
< NULLIFY(progs%pstar_sum)
---
> NULLIFY(progs%f_nsc_pft)
diff -r vn7.0copy1_c4/src/./control/shared/soil_biogeochem_control_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared/soil_biogeochem_control_mod.F90
117c117
<   timestep_number=>timestep
---
>   timestep_number
121c121
<   timestep_len_real=>timestep
---
>   timestep
258c258
< nstep = NINT( dt_soilc / timestep_len_real )
---
> nstep = NINT( dt_soilc / timestep )
diff -r vn7.0copy1_c4/src/./control/shared/surf_couple_explicit_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared/surf_couple_explicit_mod.F90
47c47,48
<     fraca, resfs, resft, rhokh, rhokh_surft, rhokh_sice, rhokh_sea,            &
---
>     fracaero_t, fracaero_s, resfs, resft,                                      &
>     rhokh, rhokh_surft, rhokh_sice, rhokh_sea,                                 &
59c60
<     land_pts, nsurft, surft_pts,                                               &
---
>     land_pts, ssi_pts, sea_pts, nsurft, surft_pts,                             &
67c68
<     asteps_since_triffid, resp_s_acc_gb_um,                                    &
---
>     asteps_since_triffid,                                                      &
73c74
<     numcycles, cycleno, z1_uv_top, z1_tq_top, ddmfx,                           &
---
>     numcycles, cycleno, z1_uv_top, z1_tq_top, sky, ddmfx,                      &
86a88
>     wtrac_jls,                                                                 &
109a112
> USE jules_wtrac_type_mod, ONLY: jls_wtrac_type
130a134,135
> USE jules_water_tracers_mod,  ONLY:                                            &
>   n_wtrac_jls, n_evap_srce
140c145
<     soil_model_rothc,                                                          &
---
>     soil_model_4pool,                                                          &
148c153
<   dim_cs1, dim_cs2, co2_dim_len,co2_dim_row
---
>   co2_dim_len,co2_dim_row
163c168
<   dim_cs1, dim_cs2, co2_dim_len,co2_dim_row, dim_cslayer
---
>   co2_dim_len,co2_dim_row, dim_cslayer
201c206
<   nsurft
---
>   nsurft, ssi_pts, sea_pts
219,220d223
< REAL(KIND=real_jlslsm), INTENT(IN OUT) ::                                      &
<   resp_s_acc_gb_um(land_pts,dim_cslayer,dim_cs1)
236a240,241
>   sky(tdims%i_start:tdims%i_end,tdims%j_start:tdims%j_end),                    &
>     ! Skyview correction factor for surface LW
268c273
<   resp_s_tot_soilt(dim_cs2,nsoilt),                                            &
---
>   resp_s_tot_soilt(land_pts,nsoilt),                                           &
323,325c328,332
<   fraca(land_pts,nsurft),                                                      &
<     !Fraction of surface moisture flux with only aerodynamic resistance for
<     !snow-free land tiles.
---
>   fracaero_t(land_pts,nsurft),                                                 &
>     !Total fraction of surface moisture flux with only aerodynamic resistance
>   fracaero_s(land_pts,nsurft),                                                 &
>     !Fraction of surface moisture flux with only aerodynamic resistance
>     !from the frozen part of the tile only
328c335
<     !(1-FRACA) of snow-free land tiles.
---
>     !(1-fracaero_t) of snow-free land tiles.
330,331c337,338
<     !Total resistance factor. FRACA+(1-FRACA)*RESFS for snow-free land, 1 for
<     !snow.
---
>     !Total resistance factor. fracaero_t+(1-fracaero_t)*resfs                  &
>     !for snow-free land, 1 for snow.
394a402
> TYPE(jls_wtrac_type), INTENT(IN OUT) :: wtrac_jls
487c495
<   IF ( soil_bgc_model == soil_model_rothc ) THEN
---
>   IF ( soil_bgc_model == soil_model_4pool ) THEN
496,501d503
< 
<   DO l = 1, land_pts
<     DO n = 1, dim_cs1
<       trifctltype%resp_s_acc_soilt(l,1,:,n) = resp_s_acc_gb_um(l,:,n)
<     END DO
<   END DO
533d534
< 
538a540,541
>     !IN values defining water tracer field dimensions
>     n_wtrac_jls, n_evap_srce,                                                  &
555,556c558,559
<     forcing%pstar_ij,forcing%lw_down_ij,fluxes%sw_surft,jules_vars%zh,ddmfx,   &
<     co2_mmr,co2_3d_ij,l_co2_interactive,l_phenol,                              &
---
>     forcing%pstar_ij,forcing%lw_down_ij,fluxes%sw_surft,sky,jules_vars%zh,     &
>     ddmfx, co2_mmr,co2_3d_ij,l_co2_interactive,l_phenol,                       &
564a568
>     fluxes%l_emis_surft_set,                                                   &
568,569c572,573
<     progs%gs_gb,trifctltype%g_leaf_acc_pft,trifctltype%npp_acc_pft,            &
<     trifctltype%resp_w_acc_pft,                                                &
---
>     fluxes%emis_surft,progs%gs_gb,chemvars%gc_corr,trifctltype%g_leaf_acc_pft, &
>     trifctltype%npp_acc_pft,trifctltype%resp_w_acc_pft,                        &
580c584,585
<     alpha1,ashtf_prime_surft,fluxes%fqw_surft,epot_surft,fraca,                &
---
>     alpha1,ashtf_prime_surft,fluxes%fqw_surft,epot_surft,fracaero_t,           &
>     fracaero_s(:,:),                                                           &
584,588c589
<     trifctltype%gpp_pft,trifctltype%gpp_pft_lay, trifctltype%apar_pft_lay,     &
<     trifctltype%cmpf_pft_lay, trifctltype%vcmax_pft_lay,                       &
<     trifctltype%vcmax25_pft_lay, trifctltype%wlite_pft_lay,                    &
<     trifctltype%wcarb_pft_lay,trifctltype%wmin_pft_lay, trifctltype%ej_pft_lay,&
<     trifctltype%npp_pft,trifctltype%resp_p_pft,                                &
---
>     trifctltype%gpp_pft,trifctltype%npp_pft,trifctltype%resp_p_pft,            &
594,595c595,597
<     ainfo%surft_index,surft_pts,tile_frac,fluxes%fsmc_pft,fluxes%emis_surft,   &
<     emis_soil,                                                                 &
---
>     ainfo%surft_index,surft_pts,tile_frac,fluxes%fsmc_pft,emis_soil,           &
>     trifctltype%growth_sug_pft,trifctltype%growth_sug_gb,progs%f_nsc_pft,      &
>     trifctltype%lwp_c_pft, trifctltype%psi_root_zone_pft,                      &
602,606c604
<     progs%t_home_gb, progs%t_growth_gb, progs%l_growth_gb,                     & 
<     progs%vpd_growth_gb,progs%co2_growth_gb,progs%pstar_growth_gb,             &
<     progs%xipam_opt, progs%vcmax_opt,progs%jmax_opt,                           &
<     progs%t_sum,progs%l_sum,progs%t_night,progs%nt_sum,                        &
<     progs%co2_sum,progs%vpd_sum,progs%pstar_sum,                               &
---
>     progs%t_home_gb, progs%t_growth_gb,                                        &
648c646
<     ainfo%l_lice_point, ainfo%l_soil_point,                                    &
---
>     ainfo%l_lice_point, ainfo%l_soil_point, ainfo%l_lice_surft,                &
652c650,656
<     chemvars%flux_o3_pft, chemvars%fo3_pft                                     &
---
>     chemvars%flux_o3_pft, chemvars%fo3_pft,                                    &
>     !Water tracers (IN)
>     wtrac_jls%snow_surft, wtrac_jls%canopy_surft,                              &
>     wtrac_jls%sthu_soilt, wtrac_jls%qw_1_ij,                                   &
>     !Water tracers (OUT)
>     wtrac_jls%fqw_1, wtrac_jls%fqw_surft, wtrac_jls%fqw_evapsrce,              &
>     wtrac_jls%smc_soilt                                                        &
655d658
< 
658c661
<     nice, nice_use,                                                            &
---
>     nice, nice_use, n_wtrac_jls,                                               &
676c679
<     ! IN calcualted in land code
---
>     ! IN calculated in land code
697c700,701
<     ainfo%sice_index_ncat, ainfo%sice_frac_ncat,                               &
---
>     ainfo%sice_index_ncat, ainfo%sice_frac_ncat, ainfo%sice_pts_ncat,          &
>     ssi_pts, sea_pts,                                                          &
699c703,709
<     fluxes%sw_sicat, fluxes%sw_sea                                             &
---
>     fluxes%sw_sicat, fluxes%sw_sea,                                            &
>     !Water tracers (IN)
>     wtrac_jls%qw_1_ij, wtrac_jls%r_sea, wtrac_jls%r_sice,                      &
>     !Water tracers (INOUT)
>     wtrac_jls%fqw_1,                                                           &
>     !Water tracers (OUT)
>     wtrac_jls%fqw_sea, wtrac_jls%fqw_sicat                                     &
743a754
>     ainfo%sice_pts_ncat,                                                       &
748,756d758
< #if defined(UM_JULES)
<   DO l = 1, land_pts
<     DO n = 1, dim_cs1
<       resp_s_acc_gb_um(l,:,n) = trifctltype%resp_s_acc_soilt(l,1,:,n)
<     END DO
<   END DO
< #endif
< 
< 
783c785,786
<   fraca(:,:) = 0.0
---
>   fracaero_t(:,:) = 0.0
>   fracaero_s(:,:) = 0.0
diff -r vn7.0copy1_c4/src/./control/shared/surf_couple_extra_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared/surf_couple_extra_mod.F90
84d83
<    resp_s_acc_gb_um,                                                           &
91c90
<    progs,trifctltype,jules_vars,                                               &
---
>    progs,trifctltype,coast,jules_vars,                                         &
98c97,98
<   !chemvars, &
---
>    chemvars, water_resources,                                                  &
>    wtrac_jls,                                                                  &
113a114
> USE coastal, ONLY: coastal_type
122c123,125
< ! USE jules_chemvars_mod, ONLY: chemvars_type
---
> USE jules_chemvars_mod, ONLY: chemvars_type
> USE water_resources_vars_mod, ONLY: water_resources_type
> USE jules_wtrac_type_mod, ONLY: jls_wtrac_type
182c185,193
< USE atm_fields_bounds_mod,    ONLY: tdims, tdims_s, pdims_s
---
> USE atm_fields_bounds_mod,    ONLY: tdims, tdims_s, pdims, pdims_s
> 
> USE conversions_mod,          ONLY: rsec_per_day
> 
> ! Used for atmospheric deposition
> USE jules_deposition_mod,     ONLY: l_deposition, l_deposition_from_ukca
> 
> USE deposition_from_surf_couple_extra_mod,                                     &
>                               ONLY: deposition_from_surf_couple_extra
193c204
<   soil_model_rothc, soil_bgc_model
---
>   soil_model_4pool, soil_bgc_model
207c218,219
<   ignition_vary_natural, ignition_vary_natural_human, l_acclim, alpha_acclim
---
>   ignition_vary_natural, ignition_vary_natural_human,                          &
>   l_acclim, n_day_photo_acclim
210a223,224
> USE jules_water_tracers_mod,  ONLY: n_wtrac_jls
> 
212,214d225
< #if !defined(UM_JULES)
<   irrig_eff,                                                                   &
< #endif
216a228,235
> USE jules_water_tracers_mod,  ONLY: l_wtrac_jls
> USE wtrac_extra_mod,          ONLY: wtrac_alloc_extra, wtrac_dealloc_extra,    &
>                                     wtrac_ex_type
> USE wtrac_checks_jls_mod,     ONLY: wtrac_checks_sno, wtrac_checks_hyd,        &
>                                     wtrac_checks_grid
> USE wtrac_correct_jls_mod,    ONLY: wtrac_correct_sno, wtrac_correct_hyd,      &
>                                     wtrac_correct_grid
> 
218a238,239
> USE timestep_mod,             ONLY: timestep
> 
240,241d260
< USE timestep_mod,             ONLY: timestep
< 
244,245d262
< USE conversions_mod,          ONLY: isec_per_day, rsec_per_day
< 
252c269
< USE model_time_mod,           ONLY: timestep_len, current_time
---
> USE model_time_mod,           ONLY: current_time
256,259d272
< USE jules_water_resources_mod, ONLY:                                           &
<   conveyance_loss, demand_accum, demand_rate_domestic, demand_rate_industry,   &
<   demand_rate_livestock, demand_rate_transfers, priority_order
< 
379d391
<   resp_s_acc_gb_um(land_pts,dim_cslayer,dim_cs1),                              &
392a405
> TYPE(coastal_type), INTENT(IN OUT) :: coast
400c413,415
< !TYPE(chemvars_type), INTENT(IN OUT) :: chemvars
---
> TYPE(chemvars_type), INTENT(IN OUT) :: chemvars
> TYPE(water_resources_type), INTENT(IN OUT) :: water_resources
> TYPE(jls_wtrac_type), INTENT(IN OUT) :: wtrac_jls
409c424
<    i,j,k,l,n,m,                                                                &
---
>    i,j,k,l,n,m,i_wt,                                                           &
422,423d436
< REAL(KIND=real_jlslsm) :: timestep_real ! Model timestep (s) in REAL
< 
463,464d475
<   dun_roff_soilt(land_pts,nsoilt),                                             &
<   drain_soilt(land_pts,nsoilt),                                                &
472a484,497
> ! Smoothing factor of exponential filter used with temperature acclimation.
> REAL(KIND=real_jlslsm) :: alpha_acclim
> 
> ! Water tracer local arrays
> TYPE(wtrac_ex_type) :: wtrac_ex
> 
> ! Compressed water tracer rain and snow fields on land points only
> REAL(KIND=real_jlslsm), ALLOCATABLE ::                                         &
>   con_snow_wtrac(:,:),                                                         &
>   con_rain_wtrac(:,:),                                                         &
>   ls_rain_wtrac(:,:),                                                          &
>   ls_snow_wtrac(:,:),                                                          &
>   ls_graup_wtrac(:,:)
> 
485,492d509
< !Care needed as the timestep is used in arithmetic to control the
< !timing of when various science schemes are called.
< #if defined(UM_JULES)
< timestep_real =  timestep
< #else
< timestep_real = REAL(timestep_len)
< #endif
< 
510c527
<   IF ( soil_bgc_model == soil_model_rothc ) THEN
---
>   IF ( soil_bgc_model == soil_model_4pool ) THEN
542a560,562
>   ! Set up water tracer working arrays
>   CALL wtrac_alloc_extra(land_pts, nsurft, n_wtrac_jls, wtrac_ex)
> 
565a586,611
>     IF (l_wtrac_jls) THEN
>       ! Repeat for water tracers
>       ALLOCATE(con_snow_wtrac(land_pts,n_wtrac_jls))
>       ALLOCATE(con_rain_wtrac(land_pts,n_wtrac_jls))
>       ALLOCATE(ls_snow_wtrac(land_pts,n_wtrac_jls))
>       ALLOCATE(ls_rain_wtrac(land_pts,n_wtrac_jls))
>       ALLOCATE(ls_graup_wtrac(land_pts,n_wtrac_jls))
>       DO i_wt = 1, n_wtrac_jls
>         DO l = 1, land_pts
>           j = (ainfo%land_index(l) - 1) / row_length + 1
>           i = ainfo%land_index(l) - (j-1) * row_length
>           con_snow_wtrac(l,i_wt) = wtrac_jls%con_snow_ij(i,j,i_wt)
>           con_rain_wtrac(l,i_wt) = wtrac_jls%con_rain_ij(i,j,i_wt)
>           ls_rain_wtrac(l,i_wt)  = wtrac_jls%ls_rain_ij(i,j,i_wt)
>           ls_snow_wtrac(l,i_wt)  = wtrac_jls%ls_snow_ij(i,j,i_wt)
>           ls_graup_wtrac(l,i_wt) = 0.0
>         END DO
>       END DO
>     ELSE
>       ALLOCATE(con_snow_wtrac(1,1))
>       ALLOCATE(con_rain_wtrac(1,1))
>       ALLOCATE(ls_snow_wtrac(1,1))
>       ALLOCATE(ls_rain_wtrac(1,1))
>       ALLOCATE(ls_graup_wtrac(1,1))
>     END IF
> 
605a652,694
>     !---------------------------------------------------------------------------
>     ! Calculation of atmospheric deposition parameters and fluxes
>     !---------------------------------------------------------------------------
> 
>     ! For JULES standalone applications, the JULES-based atmospheric deposition
>     ! routines are called here, by setting the switches l_deposition to true
>     ! and l_deposition_from_ukca to false.
> 
>     ! For coupled UM_JULES applications, the JULES-based atmospheric deposition
>     ! routines can only be called from the UKCA routine ukca_chemistry_ctl
>     ! (or its equivalents, ukca_chemistry_ctl_BE and ukca_chemistry_ctl_col),
>     ! setting the switch l_deposition_from_ukca to true. This is to demonstrate
>     ! that the JULES-based routines give outputs that bit compare with
>     ! UKCA known good outputs.
> 
>     ! The longer-term plan is for the UKCA to provide surface atmospheric
>     ! concentrations of the deposited species with JULES returning deposition
>     ! fluxes, with the call routed through here.
> 
>     IF (l_deposition .AND. (.NOT. l_deposition_from_ukca)) THEN
> 
>       CALL deposition_from_surf_couple_extra(                                  &
>            a_step, timestep,                                                   &
>              ! passed to calling routine, defined in module ainfo
>            row_length, rows, land_pts, ainfo%land_index,                       &
>              ! From TYPE ainfo, coast
>            surft_pts, ainfo%surft_index, ainfo%ice_fract_ij, coast%fland,      &
>              ! From TYPE forcing: pressure and surface water mixing ratio
>            forcing%pstar_ij, forcing%qw_1_ij,                                  &
>              ! From TYPE fluxes: temperature, SW radiation & surface roughness
>            fluxes%tstar_ij, fluxes%sw_surft, fluxes%z0h_surft,                 &
>              ! From TYPE progs
>            progs%gc_surft, progs%lai_pft, progs%canht_pft, progs%tstar_surft,  &
>            progs%canopy_surft, progs%smc_soilt,                                &
>              ! From TYPES jules_vars
>            jules_vars%zh, jules_vars%dzl,                                      &
>              ! passed From calling routine
>            tile_frac,                                                          &
>              ! From TYPE chemvars: atmospheric variables & diagnostics
>            chemvars)
> 
>     END IF
> 
607c696
<     CALL snow ( land_pts,timestep_real,smlt,nsurft,surft_pts,                  &
---
>     CALL snow ( land_pts,timestep,smlt,nsurft,n_wtrac_jls,surft_pts,           &
611c700
<                 fluxes%melt_surft,                                             &
---
>                 fluxes%melt_surft,fluxes%snowinc_surft,                        &
615c704,705
<                 psparms%smvcst_soilt(:,:,1),progs%rgrain_surft,                &
---
>                 psparms%smvcst_soilt(:,:,1), con_snow_wtrac,                   &
>                 wtrac_jls%ei_surft, progs%rgrain_surft,                        &
619c709,712
<                 progs%nsnow_surft,progs%ds_surft,                              &
---
>                 progs%nsnow_surft, con_rain_wtrac, ls_rain_wtrac,              &
>                 ls_snow_wtrac, ls_graup_wtrac, wtrac_ex%melt_surft,            &
>                 wtrac_jls%snow_grnd_surft, wtrac_jls%snow_surft,               &
>                 wtrac_jls%sice_surft, wtrac_jls%sliq_surft, progs%ds_surft,    &
623c716,717
<                 sf_diag, dhf_surf_minus_soil,                                  &
---
>                 sf_diag, dhf_surf_minus_soil, wtrac_ex%snow_melt,              &
>                 wtrac_ex%lake_snow_melt,                                       &
628c722
<                 ainfo%l_lice_point,                                            &
---
>                 ainfo%l_lice_point, ainfo%l_lice_surft,                        &
634a729,751
>     IF (l_wtrac_jls) THEN
> 
>       ! Check that the snow normal water tracer stores are not significantly
>       ! diverging from the water fields
>       CALL wtrac_checks_sno(land_pts, nsurft, nsmax, surft_pts,                &
>                             ainfo%surft_index,                                 &
>                             progs%snow_surft, progs%snow_grnd_surft,           &
>                             progs%sice_surft,progs%sliq_surft,                 &
>                             wtrac_jls%snow_surft(:,:,1),                       &
>                             wtrac_jls%snow_grnd_surft(:,:,1),                  &
>                             wtrac_jls%sice_surft(:,:,:,1),                     &
>                             wtrac_jls%sliq_surft(:,:,:,1))
> 
>       ! Correct snow water tracer stores to prevent build up of numerical error
>       CALL wtrac_correct_sno(land_pts, nsurft, nsmax, n_wtrac_jls,             &
>                             surft_pts, ainfo%surft_index,                      &
>                             progs%snow_surft, progs%snow_grnd_surft,           &
>                             progs%sice_surft,progs%sliq_surft,                 &
>                             wtrac_jls%snow_surft, wtrac_jls%snow_grnd_surft,   &
>                             wtrac_jls%sice_surft, wtrac_jls%sliq_surft)
> 
>     END IF  ! l_wtrac_jls
> 
638c755
<       asteps_since_triffid, timestep_real,                                     &
---
>       asteps_since_triffid, n_wtrac_jls, timestep, ainfo%l_lice_surft,         &
647a765
>       con_rain_wtrac, ls_rain_wtrac,                                           &
649a768
>       wtrac_jls%ecan_surft, wtrac_jls%ext_soilt,                               &
651c770
<       fluxes%snow_soil_htf,                                                    &
---
>       wtrac_ex%melt_surft, wtrac_ex%snow_melt, fluxes%snow_soil_htf,           &
654,655c773,775
<       npp_gb, inlandout_atm_gb,                                                &
<       progs%canopy_surft, progs%smcl_soilt, psparms%sthf_soilt,                &
---
>       npp_gb, inlandout_atm_gb, wtrac_jls%inlandout_atm_gb,                    &
>       progs%canopy_surft, wtrac_jls%canopy_surft,                              &
>       progs%smcl_soilt, psparms%sthf_soilt,                                    &
658c778,779
<       fsat_soilt, fwetl_soilt, sthzw_soilt, zw_soilt,                          &
---
>       wtrac_jls%smcl_soilt, wtrac_jls%sthf_soilt, wtrac_jls%sthu_soilt,        &
>       fsat_soilt, fwetl_soilt, sthzw_soilt, zw_soilt, wtrac_jls%sthzw_soilt,   &
665,668c786,790
<       drain_soilt, dun_roff_soilt, fluxes%sub_surf_roff_gb,                    &
<       fluxes%surf_roff_gb, fluxes%tot_tfall_gb,     fluxes%tot_tfall_surft,    &
<       w_flux_soilt, toppdm%qbase_soilt, qbase_l_soilt, toppdm%qbase_zw_soilt,  &
<       toppdm%fch4_wetl_soilt,  toppdm%fch4_wetl_cs_soilt,                      &
---
>       toppdm%drain_soilt, toppdm%dun_roff_soilt, fluxes%sub_surf_roff_gb,      &
>       fluxes%surf_roff_gb, fluxes%tot_tfall_gb, fluxes%tot_tfall_surft,        &
>       w_flux_soilt, wtrac_jls%surf_roff_gb,  wtrac_jls%sub_surf_roff_gb,       &
>       toppdm%qbase_soilt, qbase_l_soilt, toppdm%qbase_zw_soilt,                &
>       toppdm%fch4_wetl_soilt, toppdm%fch4_wetl_cs_soilt,                       &
671a794,827
> 
>     DEALLOCATE(ls_graup_wtrac)
>     DEALLOCATE(ls_rain_wtrac)
>     DEALLOCATE(ls_snow_wtrac)
>     DEALLOCATE(con_rain_wtrac)
>     DEALLOCATE(con_snow_wtrac)
> 
>     IF (l_wtrac_jls) THEN
> 
>       ! Check that the hydrological normal water tracer stores are not
>       ! significantly diverging from the water fields
>       CALL wtrac_checks_hyd(land_pts, nsurft, nsoilt, sm_levels, soil_pts,     &
>                             ainfo%soil_index, surft_pts, ainfo%surft_index,    &
>                             progs%canopy_surft, psparms%sthu_soilt,            &
>                             psparms%sthf_soilt, progs%smcl_soilt, sthzw_soilt, &
>                             wtrac_jls%canopy_surft(:,:,1),                     &
>                             wtrac_jls%sthu_soilt(:,:,:,1),                     &
>                             wtrac_jls%sthf_soilt(:,:,:,1),                     &
>                             wtrac_jls%smcl_soilt(:,:,:,1),                     &
>                             wtrac_jls%sthzw_soilt(:,:,1))
> 
>       ! Correct hydrological water tracer stores to prevent build up of
>       ! numerical errors
>       CALL wtrac_correct_hyd(land_pts, nsurft, nsoilt, sm_levels, n_wtrac_jls, &
>                             soil_pts, ainfo%soil_index,                        &
>                             surft_pts, ainfo%surft_index,                      &
>                             progs%canopy_surft, psparms%sthu_soilt,            &
>                             psparms%sthf_soilt, progs%smcl_soilt, sthzw_soilt, &
>                             wtrac_jls%canopy_surft, wtrac_jls%sthu_soilt,      &
>                             wtrac_jls%sthf_soilt,   wtrac_jls%smcl_soilt,      &
>                             wtrac_jls%sthzw_soilt)
> 
>     END IF ! l_wtrac_jls
> 
687,688c843,847
<            conveyance_loss, demand_rate_domestic, demand_rate_industry,        &
<            demand_rate_livestock, demand_rate_transfers, crop_vars%dvi_cpft,   &
---
>            water_resources%conveyance_loss,                                    &
>            water_resources%demand_rate_domestic,                               &
>            water_resources%demand_rate_industry,                               &
>            water_resources%demand_rate_livestock,                              &
>            water_resources%demand_rate_transfers, crop_vars%dvi_cpft,          &
690c849
<            ainfo%frac_surft, irrig_eff, grid_area_ij,                          &
---
>            ainfo%frac_surft, water_resources%irrig_eff, grid_area_ij,          &
694c853,854
<            crop_vars%icntmax_gb, crop_vars%plant_n_gb, demand_accum,           &
---
>            crop_vars%icntmax_gb, crop_vars%plant_n_gb,                         &
>            water_resources%demand_accum,                                       &
699c859
<            priority_order, crop_vars%irrig_water_gb )
---
>            water_resources%priority_order, crop_vars%irrig_water_gb )
706c866
<       land_pts,                                                                &
---
>       land_pts, n_wtrac_jls,                                                   &
708a869
>       wtrac_jls%sub_surf_roff_gb,  wtrac_jls%surf_roff_gb,                     &
712a874,875
>       wtrac_jls%tot_surf_runoff_gb, wtrac_jls%tot_sub_runoff_gb,               &
>       wtrac_jls%acc_lake_evap_gb,                                              &
720c883
<        global_river_rows, nsurft,                                              &
---
>        global_river_rows,                                                      &
722c885
<       fluxes%fqw_surft, delta_lambda, delta_phi, xx_cos_theta_latitude,        &
---
>       fluxes%lake_evap, delta_lambda, delta_phi, xx_cos_theta_latitude,        &
725a889
>       wtrac_jls%lake_evap,                                                     &
728a893
>       wtrac_jls%twatstor, wtrac_jls%smcl_soilt, wtrac_jls%sthu_soilt,          &
731c896
<       riverout_rgrid,                                                          &
---
>       riverout_rgrid, wtrac_jls%inlandout_atm_gb,                              &
735a901,925
>   IF (l_rivers .AND. l_wtrac_jls) THEN
> 
>     ! Check that the river normal water tracer store is not diverging
>     ! signifantly from the water field.
>     CALL wtrac_checks_grid(river_row_length, river_rows,                       &
>                            twatstor, wtrac_jls%twatstor(:,:,1),'twatstor')
> 
>     ! Correct river water tracer store to prevent build up of numerical errors
>     CALL wtrac_correct_grid(river_row_length, river_rows, n_wtrac_jls,         &
>                            twatstor, wtrac_jls%twatstor)
> 
>     ! Check that the hydrological normal water tracer stores are not
>     ! significantly diverging from the water fields
>     CALL wtrac_checks_hyd(land_pts, nsurft, nsoilt, sm_levels, soil_pts,       &
>                           ainfo%soil_index, surft_pts, ainfo%surft_index,      &
>                           progs%canopy_surft, psparms%sthu_soilt,              &
>                           psparms%sthf_soilt, progs%smcl_soilt, sthzw_soilt,   &
>                           wtrac_jls%canopy_surft(:,:,1),                       &
>                           wtrac_jls%sthu_soilt(:,:,:,1),                       &
>                           wtrac_jls%sthf_soilt(:,:,:,1),                       &
>                           wtrac_jls%smcl_soilt(:,:,:,1),                       &
>                           wtrac_jls%sthzw_soilt(:,:,1))
> 
>   END IF ! (l_rivers .AND. l_wtrac_jls)
> 
775c965
<                         REAL(crop_period) * rsec_per_day / timestep_real )
---
>                         REAL(crop_period) * rsec_per_day / timestep )
781c971
<                         + (trifctltype%npp_pft(l,nnpft + n) * timestep_real)
---
>                         + (trifctltype%npp_pft(l,nnpft + n) * timestep)
809c999
<                 ainfo%l_lice_point)
---
>                 ainfo%l_lice_point, ainfo%l_lice_surft)
821c1011
<                             current_time%TIME, timestep_real,land_pts)
---
>                             current_time%TIME, timestep,land_pts)
831c1021
<                         current_time%TIME, current_time%month, timestep_real,  &
---
>                         current_time%TIME, current_time%month, timestep,       &
912c1102
<           timestep_real, frac_agr_gb, trif_vars%frac_past_gb,                  &
---
>           timestep, frac_agr_gb, trif_vars%frac_past_gb,                       &
916c1106
<           resp_s_acc_gb_um, trifctltype%resp_w_acc_pft,                        &
---
>           trifctltype%resp_w_acc_pft,                                          &
962c1152
<           ainfo%l_lice_point, ainfo%soil_index,                                &
---
>           ainfo%l_lice_point, ainfo%l_lice_surft, ainfo%soil_index,            &
972c1162,1165
<       progs%t_growth_gb(:,:) = progs%t_growth_gb(:,:) 
---
>       alpha_acclim = 1.0 - EXP( -1.0 * timestep                                &
>                               / ( n_day_photo_acclim * rsec_per_day ) )
>       progs%t_growth_gb(:) = progs%t_growth_gb(:)                              &
>                      + alpha_acclim * ( tl_1_gb(:) - progs%t_growth_gb(:) )
1050c1243
<                            ,timestep_real                                      &
---
>                            ,timestep                                           &
1127c1320,1321
<         dun_roff_soilt(:,m), drain_soilt(:,m), toppdm%qbase_soilt(:,m),        &
---
>         toppdm%dun_roff_soilt(:,m), toppdm%drain_soilt(:,m),                   &
>         toppdm%qbase_soilt(:,m),                                               &
1134c1328
<         timestep_real,                                                         &
---
>         timestep,                                                              &
1156c1350
<         land_pts,                                                              &
---
>         land_pts, sm_levels,                                                   &
1170a1365
> 
1173a1369,1371
>   ! Deallocate water tracer working arrays
>   CALL wtrac_dealloc_extra(wtrac_ex)
> 
1181a1380
>   fluxes%snowinc_surft(:,:) = 0.0
diff -r vn7.0copy1_c4/src/./control/shared/surf_couple_implicit_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared/surf_couple_implicit_mod.F90
39,40c39,40
<   ashtf, ashtf_sea, ashtf_surft, du, dv, fraca, resfs, resft, rhokh,           &
<   rhokh_surft, rhokh_sice, rhokh_sea,                                          &
---
>   ashtf, ashtf_sea, ashtf_surft, du, dv, fracaero_t, fracaero_s, resfs, resft, &
>   rhokh, rhokh_surft, rhokh_sice, rhokh_sea,                                   &
56c56
<   nsurft, land_pts, surft_pts,                                                 &
---
>   nsurft, land_pts, ssi_pts, sice_pts, sea_pts, surft_pts,                     &
60a61,62
>   ! Water tracer switch (IN)
>   l_wtrac_bl,                                                                  &
67c69
<   rhokh_mix, ti_gb,                                                            &
---
>   rhokh_mix, ti_gb, sky,                                                       &
76a79
>   wtrac_jls,                                                                   &
96a100,102
> USE jules_wtrac_type_mod, ONLY: jls_wtrac_type
> 
> 
108c114,117
< USE jules_surface_types_mod, ONLY: ntype
---
> USE jules_surface_types_mod,  ONLY: ntype
> USE jules_water_tracers_mod,  ONLY: l_wtrac_imp_jls, l_wtrac_jls,              &
>                                     n_wtrac_jls, n_evap_srce
> 
150c159
<   nsurft, land_pts,                                                            &
---
>   nsurft, land_pts, ssi_pts, sice_pts, sea_pts,                                &
152a162,165
> !JULES water_tracer module
> LOGICAL, INTENT(IN) ::                                                         &
>   l_wtrac_bl      ! Logical to control the water tracer calculations in
>                   ! the implicit code
183a197,198
>   sky(tdims%i_start:tdims%i_end,tdims%j_start:tdims%j_end),                    &
>     ! Skyview correction factor for surface LW
242,244c257,261
<   fraca(land_pts,nsurft),                                                      &
<     !Fraction of surface moisture flux with only aerodynamic resistance for
<     !snow-free land tiles.
---
>   fracaero_t(land_pts,nsurft),                                                 &
>     !Total fraction of surface moisture flux with only aerodynamic resistance
>   fracaero_s(land_pts,nsurft),                                                 &
>     !Fraction of surface moisture flux with only aerodynamic resistance
>     !from the frozen portion of the tile
247c264
<     !(1-FRACA) of snow-free land tiles.
---
>     !(1-fracaero_t) of snow-free land tiles.
249,250c266,267
<     !Total resistance factor. FRACA+(1-FRACA)*RESFS for snow-free land, 1 for
<     !snow.
---
>     !Total resistance factor. fracaero_t+(1-fracaero_t)*resfs
>     !for snow-free land, 1 for snow.
323a341
> TYPE(jls_wtrac_type), INTENT(IN OUT) :: wtrac_jls
370d387
< 
386a404,407
> ! Set JULES logical to control water tracer calculations in the implicit
> ! scheme (they only need to be done on the final dynamics loop in UMJULES)
> l_wtrac_imp_jls = (l_wtrac_bl .AND. l_wtrac_jls)
> 
420a442,443
>     !IN values defining water tracer field dimensions
>             n_wtrac_jls, n_evap_srce,                                          &
422c445
<             forcing%lw_down_ij,fluxes%sw_surft,progs%t_soil_soilt,r_gamma,     &
---
>             forcing%lw_down_ij,fluxes%sw_surft,sky,progs%t_soil_soilt,r_gamma, &
424c447,448
<             jules_vars%dtrdz_charney_grid_1_ij,fraca,resfs,resft,rhokh_surft,  &
---
>             jules_vars%dtrdz_charney_grid_1_ij,fracaero_t,fracaero_s,          &
>             resfs,resft, rhokh_surft,                                          &
436c460
<             fluxes%ext_soilt,fluxes%melt_surft,                                &
---
>             fluxes%ext_soilt,fluxes%melt_surft,fluxes%snowinc_surft,           &
446a471
>             fluxes%lake_evap,                                                  &
454c479,491
<             crop_vars)
---
>             crop_vars,                                                         &
>             !Water tracers (IN)
>             wtrac_jls%snow_surft, wtrac_jls%smc_soilt,                         &
>             wtrac_jls%canopy_surft, wtrac_jls%fqw_evapsrce,                    &
>             !Water tracers (INOUT)
>             wtrac_jls%fqw_surft,                                               &
>             !Water tracers (OUT)
>             wtrac_jls%ei_surft, wtrac_jls%ei_ij,                               &
>             wtrac_jls%esoil_surft, wtrac_jls%esoil_ij_soilt,                   &
>             wtrac_jls%ext_soilt, wtrac_jls%ecan_surft,                         &
>             wtrac_jls%ecan_ij, wtrac_jls%lake_evap,                            &
>             wtrac_jls%fqw_1, wtrac_jls%dfqw_imp)
> 
459a497,498
>   !IN values defining water tracer field dimensions
>             n_wtrac_jls,                                                       &
482c521,522
<           ainfo%ocn_cpl_point,                                                 &
---
>           ainfo%ocn_cpl_point, ainfo%sice_pts_ncat, ainfo%sea_index,           &
>           ssi_pts, sice_pts, sea_pts,                                          &
484c524,530
<           fluxes%sw_sicat)
---
>           fluxes%sw_sicat,                                                     &
>   ! water tracers (IN)
>           wtrac_jls%fqw_sea, wtrac_jls%fqw_sicat,                              &
>   ! water tracers (INOUT)
>           wtrac_jls%fqw_1, wtrac_jls%dfqw_imp,                                 &
>   ! water tracers (OUT)
>           wtrac_jls%e_sea_ij, wtrac_jls%ei_sice_ij)
519d564
< 
537a583
>   fluxes%snowinc_surft(:,:) = 0.0
diff -r vn7.0copy1_c4/src/./control/shared/surf_couple_radiation_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared/surf_couple_radiation_mod.F90
34c34
<   nsurft, land_pts, surft_pts, row_length, rows,                               &
---
>   nsurft, land_pts, sea_pts, surft_pts, row_length, rows,                      &
72a73
> USE cable_land_albedo_mod,    ONLY: cable_land_albedo
99a101,110
> USE cable_fields_mod,   ONLY: pars_io_cbl         ! and veg/soil parameters
> !data: constants
> USE cable_other_constants_mod,  ONLY: z0surf_min, lai_thresh, coszen_tols,     &
>                                       gauss_w
> USE cable_math_constants_mod,   ONLY: pi, pi180
> USE grid_constants_mod_cbl,     ONLY: nsl, nsnl, mp, ICE_SoilType, nrb, nrs
> USE cable_surface_types_mod,    ONLY: ICE_cable, lakes_cable
> 
> USE jules_surface_types_mod,    ONLY: npft
> 
143c154
<   nsurft, land_pts, surft_pts(nsurft), row_length, rows
---
>   nsurft, land_pts, sea_pts, surft_pts(nsurft), row_length, rows
194,195c205,206
< !CABLE TYPES containing field data (IN OUT)
< TYPE(progs_cbl_vars_type), INTENT(IN OUT) :: progs_cbl
---
> !CABLE TYPES containing field data
> TYPE(progs_cbl_vars_type), INTENT(IN) :: progs_cbl
255c266
<     ainfo%l_lice_point,                                                        &
---
>     ainfo%l_lice_point, ainfo%l_lice_surft,                                    &
260,290d270
<   CALL jules_ssi_albedo (                                                      &
<     !INTENT(IN)
<     !input fields
<     flandg, ainfo%ice_fract_ij, fluxes%tstar_ij, coast%tstar_sice_sicat,       &
<     psparms%cosz_ij, ws10m, chloro,                                            &
<     progs%snow_mass_sea_sicat, progs%di_ncat_sicat,                            &
<     ainfo%pond_frac_cat_sicat, ainfo%pond_depth_cat_sicat,                     &
<     !max and min sea ice albedo specifications
<     alpham, alphac, alphab, dtice,                                             &
<     dt_bare, dalb_bare_wet, pen_rad_frac, sw_beta,                             &
<     ! parameters for CICE multi-band albedo scheme:
<     albicev_cice, albicei_cice, albsnowv_cice, albsnowi_cice,                  &
<     albpondv_cice, albpondi_cice,                                              &
<     ahmax, dalb_mlt_cice, dalb_mlts_v_cice, dalb_mlts_i_cice,                  &
<     dt_bare_cice, dt_snow_cice,                                                &
<     pen_rad_frac_cice, sw_beta_cice, snowpatch,                                &
<     !size and control variables
<     row_length * rows, max_n_swbands,                                          &
<     n_band, nice, nice_use,                                                    &
<     !spectral boundaries
<     wavelength_short,                                                          &
<     wavelength_long,                                                           &
<     !INTENT(OUT)
<     !output arguments
<     sea_ice_albedo,                                                            &
<     open_sea_albedo,                                                           &
<     !ancil_info (IN)
<     ainfo%sea_index, ainfo%ssi_index, ainfo%sice_index_ncat,                   &
<     ainfo%sice_frac_ncat,                                                      &
<     !Fluxes (OUT)
<     fluxes%alb_sicat, fluxes%penabs_rad_frac)
293,312d272
<   ! for testing LSM
<   WRITE(jules_message,'(A)') "CABLE not yet implemented"
<   CALL jules_print(RoutineName, jules_message)
< 
<   ! initialise all INTENT(OUT) fields for now until CABLE is implemented
<   sea_ice_albedo(:,:,:) = 0.0
<   fluxes%alb_surft(:,:,:) = 0.0
<   fluxes%land_albedo_ij(:,:,:) = 0.0
< 
<   progs_cbl%SoilTemp_CABLE(:,:,:) = 0.0
<   progs_cbl%SoilMoisture_CABLE(:,:,:) = 0.0
<   progs_cbl%FrozenSoilFrac_CABLE(:,:,:) = 0.0
<   progs_cbl%SnowDepth_CABLE(:,:,:) = 0.0
<   progs_cbl%SnowMass_CABLE(:,:,:) = 0.0
<   progs_cbl%SnowTemp_CABLE(:,:,:) = 0.0
<   progs_cbl%SnowDensity_CABLE(:,:,:) = 0.0
<   progs_cbl%ThreeLayerSnowFlag_CABLE(:,:) = 0.0
<   progs_cbl%OneLyrSnowDensity_CABLE(:,:) = 0.0
<   progs_cbl%SnowAge_CABLE(:,:) = 0.0
<   progs_cbl%snowOsurft(:,:) = 0.0
313a274,295
>   CALL cable_land_albedo (                                                     &
>     !OUT: (per rad band) albedos [GridBoxMean & per tile albedo]
>     fluxes%land_albedo_ij, fluxes%alb_surft,                                   &
>     !IN: JULES dimensions and associated
>     row_length, rows, land_pts, nsurft, npft,                                  &
>     surft_pts, ainfo%surft_index, ainfo%land_index,                            &
>     !IN: JULES Surface descriptions generally parametrized
>     ainfo%frac_surft, progs%LAI_pft, progs%canht_pft,                          &
>     psparms%albsoil_soilt(:,1),                                                &
>     !IN: JULES  timestep varying fields
>     psparms%cosz_ij, snow_surft,                                               &
>     !IN:CABLE dimensions from grid_constants_cbl (mp NOT constant)
>     nrb, nrs, mp,                                                              &
>     !IN: CABLE specific surface_type indexes
>     ICE_cable, lakes_cable, ICE_SoilType,                                      &
>     !IN: CABLE constants
>     z0surf_min, lai_thresh, coszen_tols, gauss_w, pi, pi180,                   &
>     !IN: CABLE Veg parameters. ICE surface_type index
>     pars_io_cbl%vegin_xfang, pars_io_cbl%vegin_taul, pars_io_cbl%vegin_refl,   &
>     !IN: CABLE prognostics. decl in progs_cbl_vars_mod.F90 [(:,:,1)= top layer]
>     progs_cbl%SoilTemp_CABLE(:,:,1), progs_cbl%OneLyrSnowDensity_CABLE,        &
>     progs_cbl%SnowAge_CABLE )
322a305,336
> 
> CALL jules_ssi_albedo (                                                        &
>   !INTENT(IN)
>   !input fields
>   flandg, ainfo%ice_fract_ij, fluxes%tstar_ij, coast%tstar_sice_sicat,         &
>   psparms%cosz_ij, ws10m, chloro,                                              &
>   progs%snow_mass_sea_sicat, progs%di_ncat_sicat,                              &
>   ainfo%pond_frac_cat_sicat, ainfo%pond_depth_cat_sicat,                       &
>   !max and min sea ice albedo specifications
>   alpham, alphac, alphab, dtice,                                               &
>   dt_bare, dalb_bare_wet, pen_rad_frac, sw_beta,                               &
>   ! parameters for CICE multi-band albedo scheme:
>   albicev_cice, albicei_cice, albsnowv_cice, albsnowi_cice,                    &
>   albpondv_cice, albpondi_cice,                                                &
>   ahmax, dalb_mlt_cice, dalb_mlts_v_cice, dalb_mlts_i_cice,                    &
>   dt_bare_cice, dt_snow_cice,                                                  &
>   pen_rad_frac_cice, sw_beta_cice, snowpatch,                                  &
>   !size and control variables
>   row_length * rows, max_n_swbands,                                            &
>   n_band, nice, nice_use,                                                      &
>   !spectral boundaries
>   wavelength_short,                                                            &
>   wavelength_long,                                                             &
>   !INTENT(OUT)
>   !output arguments
>   sea_ice_albedo,                                                              &
>   open_sea_albedo,                                                             &
>   !ancil_info (IN)
>   ainfo%sea_index, ainfo%ssi_index, ainfo%sice_index_ncat,                     &
>   ainfo%sice_frac_ncat, ainfo%sice_pts_ncat, sea_pts,                          &
>   !Fluxes (OUT)
>   fluxes%alb_sicat, fluxes%penabs_rad_frac)
diff -r vn7.0copy1_c4/src/./control/shared/surf_couple_rivers_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared/surf_couple_rivers_mod.F90
10a11,13
> 
> USE um_types, ONLY: real_jlslsm
> 
16c19
<    land_pts,                                                                   &
---
>    land_pts, n_wtrac_jls,                                                      &
18c21
<    sub_surf_roff, surf_roff,                                                   &
---
>    sub_surf_roff, surf_roff, sub_surf_roff_wtrac, surf_roff_wtrac,             &
22a26,27
>    tot_surf_runoff_gb_wtrac, tot_sub_runoff_gb_wtrac,                          &
>    acc_lake_evap_gb_wtrac,                                                     &
30c35
<    global_river_rows, nsurft,                                                  &
---
>    global_river_rows,                                                          &
32c37
<    fqw_surft, delta_lambda, delta_phi, xx_cos_theta_latitude,                  &
---
>    lake_evap, delta_lambda, delta_phi, xx_cos_theta_latitude,                  &
35c40
<    smvcst_soilt, smvcwt_soilt, frac_surft,                                     &
---
>    smvcst_soilt, smvcwt_soilt, frac_surft, lake_evap_wtrac,                    &
37a43
>    twatstor_wtrac, smcl_soilt_wtrac, sthu_soilt_wtrac,                         &
40c46
<    riverout_rgrid,                                                             &
---
>    riverout_rgrid, inlandout_atm_gb_wtrac,                                     &
47c53
< USE rivers_route_mod,         ONLY: rivers_drive, scatter_land_from_riv_field
---
> USE rivers_route_mod,         ONLY: scatter_land_from_riv_field, rivers_route_rp
50c56
<                                     rivers_type,                               &
---
>                                     rivers_type, l_riv_overbank,               &
52,53c58,59
<                                     l_inland, rivers_um_trip, rivers_speed,    &
<                                     rivers_meander
---
>                                     l_inland, rivers_um_trip
> USE jules_model_environment_mod, ONLY:  l_oasis_rivers
70c76,78
< USE overbank_inundation_mod,  ONLY: l_riv_overbank
---
> USE rivers_regrid_mod,        ONLY: landpts_to_rivpts, rivpts_to_landpts
> 
> USE jules_water_tracers_mod,  ONLY: l_wtrac_jls
96,97d103
< USE um_types, ONLY: real_jlslsm
< 
102c108,109
< !   Control routine for rivers
---
> !   Control routine for rivers. If OASIS rivers is used, regridding between
> !   the land and river grids is done automatically by the coupler.
130c137
<   nsurft
---
>   n_wtrac_jls
140c147,152
<   fqw_surft(land_pts,nsurft),                                                  &
---
>   lake_evap(land_pts),                                                         &
>   surf_roff_wtrac(land_pts,n_wtrac_jls),                                       &
>   ! Water tracer surface runoff (kg m-2 s-1)
>   sub_surf_roff_wtrac(land_pts,n_wtrac_jls),                                   &
>   ! Water tracer sub-surface runoff (kg m-2 s-1)
>   lake_evap_wtrac(land_pts,n_wtrac_jls),                                       &
167a180,182
>   tot_surf_runoff_gb_wtrac(land_pts,n_wtrac_jls),                              &
>   tot_sub_runoff_gb_wtrac(land_pts,n_wtrac_jls),                               &
>   acc_lake_evap_gb_wtrac(row_length,rows,n_wtrac_jls),                         &
170a186,188
>   twatstor_wtrac(river_row_length, river_rows,n_wtrac_jls),                    &
>   smcl_soilt_wtrac(land_pts,nsoilt,sm_levels,n_wtrac_jls),                     &
>   sthu_soilt_wtrac(land_pts,nsoilt,sm_levels,n_wtrac_jls),                     &
189a208,210
> REAL(KIND=real_jlslsm), INTENT(OUT) ::                                         &
>    inlandout_atm_gb_wtrac(land_pts,n_wtrac_jls)
> 
196,199d216
< REAL(KIND=real_jlslsm) :: riverout_rgrid_1d(np_rivers)
<                           ! River outflow into the ocean on river points
<                           ! (kg s-1). This is calculated, but not used
<                           ! further.
205,209d221
< REAL(KIND=real_jlslsm), ALLOCATABLE :: global_tot_sub_runoff(:)
< REAL(KIND=real_jlslsm), ALLOCATABLE :: global_tot_surf_runoff(:)
< REAL(KIND=real_jlslsm), ALLOCATABLE :: global_rrun(:)
< REAL(KIND=real_jlslsm), ALLOCATABLE :: global_rflow(:)
< 
215a228,235
> REAL(KIND=real_jlslsm), ALLOCATABLE :: global_tot_sub_runoff(:)
> REAL(KIND=real_jlslsm), ALLOCATABLE :: global_tot_surf_runoff(:)
> REAL(KIND=real_jlslsm), ALLOCATABLE :: global_rrun(:)
> REAL(KIND=real_jlslsm), ALLOCATABLE :: global_rflow(:)
> 
> REAL(KIND=real_jlslsm), ALLOCATABLE :: inlandout_atmos_wtrac(:,:,:)
>                            ! inlandout_atmos_gb_wtrac on (i,j) grid
> 
222,227c242
<   gather_pe_rivers,                                                            &
<   l,i,j
< 
< #if !defined(UM_JULES)
< INTEGER :: ip
< #endif
---
>   l,i,j,ip,i_wt
235d249
<    first_routing,                                                              &
253a268,274
> ! Allocate water tracer fields
> IF (l_wtrac_jls) THEN
>   ALLOCATE(inlandout_atmos_wtrac(row_length,rows,n_wtrac_jls))
> ELSE
>   ALLOCATE(inlandout_atmos_wtrac(1,1,1))
> END IF
> 
254a276
> 
259a282,285
>     END DO
>   END DO
>   DO j = 1, river_rows
>     DO i = 1, river_row_length
262a289,298
> 
>   IF (l_wtrac_jls) THEN
>     DO i_wt = 1, n_wtrac_jls
>       DO j = 1, rows
>         DO i = 1, row_length
>           inlandout_atmos_wtrac(i,j,i_wt) = 0.0
>         END DO
>       END DO
>     END DO
>   END IF
271,272d306
< !Set the river routing to run on the 'last' PE as PE0 is very busy
< gather_pe_rivers = n_proc - 1
280a315,333
> 
>   IF (l_wtrac_jls) THEN
>     DO i_wt = 1, n_wtrac_jls
>       DO l = 1, land_pts
>         tot_surf_runoff_gb_wtrac(l,i_wt) = 0.0
>         tot_sub_runoff_gb_wtrac(l,i_wt)  = 0.0
>       END DO
>       DO j = 1, rows
>         DO i = 1, row_length
>           acc_lake_evap_gb_wtrac(i,j,i_wt)   = 0.0
>         END DO
>       END DO
>     END DO
>   END IF
> 
>   IF (l_oasis_rivers) THEN
>     rivers%rrun_sub_surf_rp = 0.0
>     rivers%rrun_surf_rp = 0.0
>   END IF
293,308c346,366
< DO l = 1, land_pts
<   IF (surf_roff(l) <  0.0) THEN
<     !      WRITE(umMessage,*)'surf_roff(',l,')= ',surf_roff(l)
<     !      CALL umPrint(umMessage,src='surf_couple_rivers')
<   ELSE
<     tot_surf_runoff_gb(l) = tot_surf_runoff_gb(l) +                            &
<                          (surf_roff(l) / REAL(nstep_rivers))
<   END IF
<   IF (sub_surf_roff(l) <  0.0) THEN
<     !      WRITE(umMessage,*)'sub_surf_roff(',l,')= ',sub_surf_roff(L)
<     !      CALL umPrint(umMessage,src='surf_couple_rivers')
<   ELSE
<     tot_sub_runoff_gb(l) = tot_sub_runoff_gb(l) +                              &
<                         (sub_surf_roff(l) / REAL(nstep_rivers))
<   END IF
< END DO
---
> IF (l_oasis_rivers) THEN
> 
>   CALL accumulate_runoff(np_rivers,                                            &
>                          rivers%surf_roff_rp, rivers%sub_surf_roff_rp,         &
>                          rivers%rrun_surf_rp, rivers%rrun_sub_surf_rp)
> ELSE
> 
>   CALL accumulate_runoff(land_pts,                                             &
>                          surf_roff, sub_surf_roff,                             &
>                          tot_surf_runoff_gb, tot_sub_runoff_gb)
> 
>   ! Repeat for water tracers
>   IF (l_wtrac_jls) THEN
>     DO i_wt = 1, n_wtrac_jls
>       CALL accumulate_runoff(land_pts,                                         &
>                        surf_roff_wtrac(:,i_wt), sub_surf_roff_wtrac(:,i_wt),   &
>                        tot_surf_runoff_gb_wtrac(:,i_wt),                       &
>                        tot_sub_runoff_gb_wtrac(:,i_wt))
>     END DO
>   END IF  ! l_wtrac_jls
> END IF
311a370
> ! Accumulate the GBM lake evaporation over river routing period
316c375
<      frac_surft(l,lake) * fqw_surft(l,lake) * timestep
---
>      frac_surft(l,lake) * lake_evap(l) * timestep
319,320c378,390
< !Detect first entry into river routing and initialise diagnostics
< first_routing = .FALSE.
---
> ! Repeat for water tracers
> IF (l_wtrac_jls) THEN
>   DO i_wt = 1, n_wtrac_jls
>     DO l = 1, land_pts
>       j = (land_index(l) - 1) / row_length +1
>       i = land_index(l) - (j-1) * row_length
>       acc_lake_evap_gb_wtrac(i,j,i_wt) = acc_lake_evap_gb_wtrac(i,j,i_wt) +    &
>               frac_surft(l,lake) * lake_evap_wtrac(l,i_wt) * timestep
>     END DO
>   END DO
> END IF
> 
> ! initialise diagnostics
322d391
<   first_routing = .TRUE.
331a401
> 
353a424
> 
356a428
> 
362,363c434,435
<         g_p_field, g_r_field, n_proc,                                          &
<         gather_pe_rivers,land_pts,land_index,                                  &
---
>         g_p_field, g_r_field,                                                  &
>         land_pts,n_wtrac_jls, land_index,                                      &
369c441
<         riv_step, rivers_speed, rivers_meander,                                &
---
>         riv_step,                                                              &
371c443,445
<         delta_phi,first_routing,                                               &
---
>         twatstor_wtrac,                                                        &
>         ! Fields used for UM-RFM implementation
>         delta_phi,                                                             &
374c448
<         !in/out accumulated runoff
---
>         !in accumulated runoff
375a450
>         tot_surf_runoff_gb_wtrac, tot_sub_runoff_gb_wtrac,                     &
378d452
<         !add inland basin arguments in call to rivctl
379a454
>         inlandout_atmos_wtrac,                                                 &
382c457,458
<         smcl_soilt(1:,1,sm_levels),sthu_soilt(1:,1,sm_levels)                  &
---
>         smcl_soilt(1:,1,sm_levels),sthu_soilt(1:,1,sm_levels),                 &
>         acc_lake_evap_gb_wtrac, smcl_soilt_wtrac, sthu_soilt_wtrac             &
391a468
> 
404c481
<     IF ( is_master_task() ) THEN
---
>     IF (.NOT. l_oasis_rivers .AND. is_master_task()) THEN
430,431c507,510
<     CALL gather_land_field(tot_sub_runoff_gb, global_tot_sub_runoff)
<     CALL gather_land_field(tot_surf_runoff_gb, global_tot_surf_runoff)
---
>     IF (.NOT. l_oasis_rivers) THEN
>       CALL gather_land_field(tot_sub_runoff_gb, global_tot_sub_runoff)
>       CALL gather_land_field(tot_surf_runoff_gb, global_tot_surf_runoff)
>     END IF
438,443c517,563
<       CALL rivers_drive( global_land_pts,                                      &
<                          global_tot_sub_runoff,                                &
<                          global_tot_surf_runoff,                               &
<                          global_rrun, global_rflow, riverout_rgrid_1d,         &
<                        !  imported rivers arrays
<                          rivers )
---
>       IF (l_oasis_rivers) THEN
>         ! No regridding is required between the land and river grids as this
>         ! is done by the OASIS coupler. Only the science routine needs calling.
>         CALL rivers_route_rp( rivers )
>       ELSE
>         ! Initialisation
>         DO ip = 1, np_rivers
>           rivers%rrun_sub_surf_rp(ip) = 0.0
>           rivers%rrun_surf_rp(ip) = 0.0
>         END DO
> 
>         DO l = 1, global_land_pts
>           global_rflow(l)= 0.0
>           global_rrun(l) = 0.0
>         END DO
> 
>         ! Regrid surface and subsurface runoff from land points to rivers
>         ! points.
>         CALL landpts_to_rivpts( global_land_pts, np_rivers,                    &
>                                 rivers%map_river_to_land_points,               &
>                                 rivers%global_land_index,                      &
>                                 rivers%rivers_index_rp,                        &
>                                 global_tot_sub_runoff,                         &
>                                 rivers%rrun_sub_surf_rp )
> 
>         CALL landpts_to_rivpts( global_land_pts, np_rivers,                    &
>                                 rivers%map_river_to_land_points,               &
>                                 rivers%global_land_index,                      &
>                                 rivers%rivers_index_rp,                        &
>                                 global_tot_surf_runoff, rivers%rrun_surf_rp )
> 
>         ! Call the routing science routine.
>         CALL rivers_route_rp( rivers )
> 
>         ! Regrid from rivers to land grid
>         CALL rivpts_to_landpts( global_land_pts, np_rivers,                    &
>                                 rivers%map_river_to_land_points,               &
>                                 rivers%global_land_index,                      &
>                                 rivers%rivers_index_rp,                        &
>                                 rivers%rflow_rp, global_rflow )
> 
>         CALL rivpts_to_landpts( global_land_pts, np_rivers,                    &
>                                 rivers%map_river_to_land_points ,              &
>                                 rivers%global_land_index,                      &
>                                 rivers%rivers_index_rp,                        &
>                                 rivers%rrun_rp, global_rrun )
>       END IF
463,477c583,599
<     IF (srflow .OR. srrun) THEN
<       CALL scatter_land_field(global_rrun, rrun)
<       CALL scatter_land_field(global_rflow, rflow)
< 
<       !-------------------------------------------------------------------------
<       ! Update riv storage on land points used to calculate water for irrigation
<       !-------------------------------------------------------------------------
<       IF ( l_irrig_limit ) THEN
<         DO ip = 1, np_rivers
<           rivers_sto_per_m2_rgrid(ip) = rivers%rivers_sto_rp(ip) /             &
<                                         rivers%rivers_boxareas_rp(ip)
<         END DO
<         CALL scatter_land_from_riv_field(rivers_sto_per_m2_rgrid,              &
<                                          rivers_sto_per_m2_on_landpts,         &
<                                          rivers)
---
>     IF (.NOT. l_oasis_rivers) THEN
>       IF (srflow .OR. srrun) THEN
>         CALL scatter_land_field(global_rrun, rrun)
>         CALL scatter_land_field(global_rflow, rflow)
> 
>         !-------------------------------------------------------------------------
>         ! Update riv storage on land points used to calculate water for irrigation
>         !-------------------------------------------------------------------------
>         IF ( l_irrig_limit ) THEN
>           DO ip = 1, np_rivers
>             rivers_sto_per_m2_rgrid(ip) = rivers%rivers_sto_rp(ip) /           &
>                                           rivers%rivers_boxareas_rp(ip)
>           END DO
>           CALL scatter_land_from_riv_field(rivers_sto_per_m2_rgrid,            &
>                                            rivers_sto_per_m2_on_landpts,       &
>                                            rivers)
>         END IF
479d600
<     END IF
481,487c602,609
<     !-------------------------------------------------------------------------
<     ! Update fraction of inundated floodplain from overbank inundation routine
<     !-------------------------------------------------------------------------
<     IF ( l_riv_overbank ) THEN
<       CALL scatter_land_from_riv_field( frac_fplain_rp, frac_fplain_lp,        &
<                                         rivers )
<     END IF
---
>       !------------------------------------------------------------------------
>       ! Update fraction of inundated floodplain from overbank inundation.
>       !------------------------------------------------------------------------
>       IF ( l_riv_overbank ) THEN
>         CALL scatter_land_from_riv_field( frac_fplain_rp, frac_fplain_lp,      &
>                                           rivers )
>       END IF
>     END IF  !  .NOT. l_oasis_rivers
511a634,643
> 
>     IF (l_wtrac_jls) THEN
>       DO i_wt = 1, n_wtrac_jls
>         DO l = 1,land_pts
>           j = (land_index(l) - 1) / row_length +1
>           i = land_index(l) - (j-1) * row_length
>           inlandout_atm_gb_wtrac(l,i_wt) = inlandout_atmos_wtrac(i,j,i_wt)
>         END DO
>       END DO
>     END IF
524a657,659
> ! Deallocate water tracer field
> DEALLOCATE(inlandout_atmos_wtrac)
> 
527a663,722
> 
> !---------------------------------------------------------------------------
> 
> SUBROUTINE accumulate_runoff(npoints, surf_runoff, sub_runoff,                 &
>                              surf_runoff_accum, sub_runoff_accum)
> 
> ! Accumulate the surface and subsurface runoff over the river routing period.
> ! This is a generic routine used for normal water and water tracers
> 
> USE jules_rivers_mod,         ONLY: nstep_rivers
> 
> USE parkind1, ONLY: jprb, jpim
> USE yomhook, ONLY: lhook, dr_hook
> 
> IMPLICIT NONE
> 
> INTEGER, INTENT(IN) :: npoints   ! No. of points
> 
> REAL(KIND=real_jlslsm), INTENT(IN) ::                                          &
>   surf_runoff(npoints),                                                        &
>                                  ! Surface runoff (kg m-2 s-1)
>   sub_runoff(npoints)
>                                  ! Sub-surface runoff (kg m-2 s-1)
> 
> REAL(KIND=real_jlslsm), INTENT(IN OUT) ::                                      &
>   surf_runoff_accum(npoints),                                                  &
>                                  ! Accumulated surface runoff
>   sub_runoff_accum(npoints)
>                                  ! Accumulated sub-surface runoff
> 
> ! Local variables
> 
> INTEGER :: ip                    ! Loop counter
> 
> CHARACTER(LEN=*), PARAMETER  :: RoutineName = 'ACCUMULATE_RUNOFF'
> 
> !Dr Hook variables
> INTEGER(KIND=jpim), PARAMETER :: zhook_in  = 0
> INTEGER(KIND=jpim), PARAMETER :: zhook_out = 1
> REAL(KIND=jprb)               :: zhook_handle
> !end of header
> 
> IF (lhook) CALL dr_hook(ModuleName//':'//RoutineName,zhook_in,zhook_handle)
> 
> 
> DO ip = 1, npoints
>   IF (surf_runoff(ip) >=  0.0) THEN
>     surf_runoff_accum(ip) = surf_runoff_accum(ip) +                            &
>                             (surf_runoff(ip) / REAL(nstep_rivers))
>   END IF
> 
>   IF (sub_runoff(ip) >=  0.0) THEN
>     sub_runoff_accum(ip) = sub_runoff_accum(ip) +                              &
>                             (sub_runoff(ip) / REAL(nstep_rivers))
>   END IF
> END DO
> 
> IF (lhook) CALL dr_hook(ModuleName//':'//RoutineName,zhook_out,zhook_handle)
> RETURN
> END SUBROUTINE accumulate_runoff
diff -r vn7.0copy1_c4/src/./control/shared/tilepts_jls.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared/tilepts_jls.F90
16c16,17
< SUBROUTINE tilepts(land_pts,frac,surft_pts,surft_index,l_lice_point)
---
> SUBROUTINE tilepts(land_pts,frac,surft_pts,surft_index,l_lice_point,           &
>                    l_lice_surft)
22,23d22
< USE ancil_info, ONLY: l_lice_surft
< 
42a42
> LOGICAL, INTENT(OUT) :: l_lice_surft(ntype)
diff -r vn7.0copy1_c4/src/./control/shared/time_info_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared/time_info_mod.F90
15c15
< USE datetime_mod, ONLY: l_360, l_leap
---
> USE datetime_mod, ONLY: l_360, l_leap, l_local_solar_time
35a36,37
> LOGICAL :: l_local_solar_time = .FALSE.
>   ! In the UM, time is always UTC.
diff -r vn7.0copy1_c4/src/./control/shared/trifctl.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared/trifctl.F90
57,74d56
<   REAL(KIND=real_jlslsm), ALLOCATABLE :: gpp_pft_lay(:,:,:)  
<       ! Gross primary productivity on PFTs per canopy layer (kg C/m2/s)
<   REAL(KIND=real_jlslsm), ALLOCATABLE :: apar_pft_lay(:,:,:)  
<       ! Absorbed PAR on PFTs per canopy layer (W/m2)
<   REAL(KIND=real_jlslsm), ALLOCATABLE :: cmpf_pft_lay(:,:,:)  
<       ! CO2 compensation point correction factor per canopy layer (unitless)
<   REAL(KIND=real_jlslsm), ALLOCATABLE :: vcmax_pft_lay(:,:,:)  
<       ! Vcmax on PFTs per canopy layer (mol CO2/m2/s)
<   REAL(KIND=real_jlslsm), ALLOCATABLE :: vcmax25_pft_lay(:,:,:)  
<       ! Vcmax25 on PFTs per canopy layer (mol CO2/m2/s)
<   REAL(KIND=real_jlslsm), ALLOCATABLE :: wlite_pft_lay(:,:,:)  
<       ! Light-limited photosynthesis rate per canopy layer (mol CO2/m2/s)
<   REAL(KIND=real_jlslsm), ALLOCATABLE :: wcarb_pft_lay(:,:,:)  
<       ! Carbon-limited photosynthesis rate per canopy layer (mol CO2/m2/s)
<   REAL(KIND=real_jlslsm), ALLOCATABLE :: wmin_pft_lay(:,:,:)  
<       ! Minimum of light- and carbon-limited photosynthesis per layer (mol CO2/m2/s)
<   REAL(KIND=real_jlslsm), ALLOCATABLE :: ej_pft_lay(:,:,:)  
<       ! Electron transport rate per canopy layer (mol/m2/s)
106a89,97
>   REAL(KIND=real_jlslsm), ALLOCATABLE :: growth_sug_gb(:)
>     ! Structural carbon growth rate (kg C/m2/s)
>   REAL(KIND=real_jlslsm), ALLOCATABLE :: growth_sug_pft(:,:)
>     ! Structural carbon growth rate on PFT (kg C/m2/s)
>   REAL(KIND=real_jlslsm), ALLOCATABLE :: lwp_c_pft(:,:)
>     ! Diagnostic for canopy leaf water potential
>     ! in the SOX stomatal model (MPa)
>   REAL(KIND=real_jlslsm), ALLOCATABLE :: psi_root_zone_pft(:,:)
>     ! (Negative) soil water potential in the root zone (Pa)
124,132d114
<   REAL(KIND=real_jlslsm), POINTER :: gpp_pft_lay(:,:,:)
<   REAL(KIND=real_jlslsm), POINTER :: apar_pft_lay(:,:,:)
<   REAL(KIND=real_jlslsm), POINTER :: cmpf_pft_lay(:,:,:)
<   REAL(KIND=real_jlslsm), POINTER :: vcmax_pft_lay(:,:,:)
<   REAL(KIND=real_jlslsm), POINTER :: vcmax25_pft_lay(:,:,:)
<   REAL(KIND=real_jlslsm), POINTER :: wlite_pft_lay(:,:,:)
<   REAL(KIND=real_jlslsm), POINTER :: wcarb_pft_lay(:,:,:)
<   REAL(KIND=real_jlslsm), POINTER :: wmin_pft_lay(:,:,:)
<   REAL(KIND=real_jlslsm), POINTER :: ej_pft_lay(:,:,:)
147a130,133
>   REAL(KIND=real_jlslsm), POINTER :: growth_sug_gb(:)
>   REAL(KIND=real_jlslsm), POINTER :: growth_sug_pft(:,:)
>   REAL(KIND=real_jlslsm), POINTER :: lwp_c_pft(:,:)
>   REAL(KIND=real_jlslsm), POINTER :: psi_root_zone_pft(:,:)
157d142
< USE jules_vegetation_mod,     ONLY: ilayers       
189,197d173
< ALLOCATE(trifctl_data%gpp_pft_lay(land_pts, npft, ilayers))
< ALLOCATE(trifctl_data%apar_pft_lay(land_pts, npft, ilayers))
< ALLOCATE(trifctl_data%cmpf_pft_lay(land_pts, npft, ilayers))
< ALLOCATE(trifctl_data%vcmax_pft_lay(land_pts, npft, ilayers))
< ALLOCATE(trifctl_data%vcmax25_pft_lay(land_pts, npft, ilayers))
< ALLOCATE(trifctl_data%wlite_pft_lay(land_pts, npft, ilayers))
< ALLOCATE(trifctl_data%wcarb_pft_lay(land_pts, npft, ilayers))
< ALLOCATE(trifctl_data%wmin_pft_lay(land_pts, npft, ilayers))
< ALLOCATE(trifctl_data%ej_pft_lay(land_pts, npft, ilayers))
212a189,192
> ALLOCATE(trifctl_data%growth_sug_gb(land_pts))
> ALLOCATE(trifctl_data%growth_sug_pft(land_pts,npft))
> ALLOCATE(trifctl_data%lwp_c_pft(land_pts,npft))
> ALLOCATE(trifctl_data%psi_root_zone_pft(land_pts,npft))
225,233d204
< trifctl_data%gpp_pft_lay(:,:,:)        = 0.0
< trifctl_data%apar_pft_lay(:,:,:)       = 0.0
< trifctl_data%cmpf_pft_lay(:,:,:)       = 0.0
< trifctl_data%vcmax_pft_lay(:,:,:)      = 0.0
< trifctl_data%vcmax25_pft_lay(:,:,:)    = 0.0
< trifctl_data%wlite_pft_lay(:,:,:)      = 0.0
< trifctl_data%wcarb_pft_lay(:,:,:)      = 0.0
< trifctl_data%wmin_pft_lay(:,:,:)       = 0.0
< trifctl_data%ej_pft_lay(:,:,:)         = 0.0
248a220,223
> trifctl_data%growth_sug_gb(:)          = 0.0
> trifctl_data%growth_sug_pft(:,:)       = 0.0
> trifctl_data%lwp_c_pft(:,:)            = 0.0
> trifctl_data%psi_root_zone_pft(:,:)    = 0.0
290,298d264
< DEALLOCATE(trifctl_data%gpp_pft_lay)
< DEALLOCATE(trifctl_data%apar_pft_lay)
< DEALLOCATE(trifctl_data%cmpf_pft_lay)
< DEALLOCATE(trifctl_data%vcmax_pft_lay)
< DEALLOCATE(trifctl_data%vcmax25_pft_lay)
< DEALLOCATE(trifctl_data%wlite_pft_lay)
< DEALLOCATE(trifctl_data%wcarb_pft_lay)
< DEALLOCATE(trifctl_data%wmin_pft_lay)
< DEALLOCATE(trifctl_data%ej_pft_lay)
313a280,283
> DEALLOCATE(trifctl_data%growth_sug_gb)
> DEALLOCATE(trifctl_data%growth_sug_pft)
> DEALLOCATE(trifctl_data%lwp_c_pft)
> DEALLOCATE(trifctl_data%psi_root_zone_pft)
361,369d330
< trifctl%gpp_pft_lay      => trifctl_data%gpp_pft_lay
< trifctl%apar_pft_lay     => trifctl_data%apar_pft_lay
< trifctl%cmpf_pft_lay     => trifctl_data%cmpf_pft_lay
< trifctl%vcmax_pft_lay    => trifctl_data%vcmax_pft_lay
< trifctl%vcmax25_pft_lay  => trifctl_data%vcmax25_pft_lay
< trifctl%wlite_pft_lay    => trifctl_data%wlite_pft_lay
< trifctl%wcarb_pft_lay    => trifctl_data%wcarb_pft_lay
< trifctl%wmin_pft_lay     => trifctl_data%wmin_pft_lay
< trifctl%ej_pft_lay       => trifctl_data%ej_pft_lay
384a346,349
> trifctl%growth_sug_gb        => trifctl_data%growth_sug_gb
> trifctl%growth_sug_pft       => trifctl_data%growth_sug_pft
> trifctl%lwp_c_pft            => trifctl_data%lwp_c_pft
> trifctl%psi_root_zone_pft    => trifctl_data%psi_root_zone_pft
427,435d391
< NULLIFY(trifctl%gpp_pft_lay)
< NULLIFY(trifctl%apar_pft_lay)
< NULLIFY(trifctl%cmpf_pft_lay)
< NULLIFY(trifctl%vcmax_pft_lay)
< NULLIFY(trifctl%vcmax25_pft_lay)
< NULLIFY(trifctl%wlite_pft_lay)
< NULLIFY(trifctl%wcarb_pft_lay)
< NULLIFY(trifctl%wmin_pft_lay)
< NULLIFY(trifctl%ej_pft_lay)
450a407,410
> NULLIFY(trifctl%growth_sug_gb)
> NULLIFY(trifctl%growth_sug_pft)
> NULLIFY(trifctl%lwp_c_pft)
> NULLIFY(trifctl%psi_root_zone_pft)
diff -r vn7.0copy1_c4/src/./control/shared/trif_vars_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared/trif_vars_mod.F90
348,365d347
<   REAL(KIND=real_jlslsm), ALLOCATABLE :: gpp_pft_lay(:,:,:)     
<                         ! Gross primary productivity on PFTs per canopy layer (kg C/m2/s)
<   REAL(KIND=real_jlslsm), ALLOCATABLE :: apar_pft_lay(:,:,:)    
<                         ! Absorbed PAR on PFTs per canopy layer (W/m2)
<   REAL(KIND=real_jlslsm), ALLOCATABLE :: cmpf_pft_lay(:,:,:)    
<                         ! CO2 compensation point correction factor per canopy layer (unitless)
<   REAL(KIND=real_jlslsm), ALLOCATABLE :: vcmax_pft_lay(:,:,:) 
<                         ! Vcmax on PFTs per canopy layer (mol CO2/m2/s)
<   REAL(KIND=real_jlslsm), ALLOCATABLE :: vcmax25_pft_lay(:,:,:)
<                         ! Vcmax25 on PFTs per canopy layer (mol CO2/m2/s)
<   REAL(KIND=real_jlslsm), ALLOCATABLE :: wlite_pft_lay(:,:,:)    
<                         ! Light-limited photosynthesis rate per canopy layer (mol CO2/m2/s)
<   REAL(KIND=real_jlslsm), ALLOCATABLE :: wcarb_pft_lay(:,:,:) 
<                         ! Carbon-limited photosynthesis rate per canopy layer (mol CO2/m2/s)
<   REAL(KIND=real_jlslsm), ALLOCATABLE :: wmin_pft_lay(:,:,:) 
<                         ! Minimum of light- and carbon-limited photosynthesis per layer (mol CO2/m2/s)
<   REAL(KIND=real_jlslsm), ALLOCATABLE :: ej_pft_lay(:,:,:)      
<                         ! Electron transport rate per canopy layer (mol/m2/s)
555,563d536
<   REAL(KIND=real_jlslsm), POINTER :: gpp_pft_lay(:,:,:)      
<   REAL(KIND=real_jlslsm), POINTER :: apar_pft_lay(:,:,:)     
<   REAL(KIND=real_jlslsm), POINTER :: cmpf_pft_lay(:,:,:)     
<   REAL(KIND=real_jlslsm), POINTER :: vcmax_pft_lay(:,:,:)    
<   REAL(KIND=real_jlslsm), POINTER :: vcmax25_pft_lay(:,:,:)  
<   REAL(KIND=real_jlslsm), POINTER :: wlite_pft_lay(:,:,:)    
<   REAL(KIND=real_jlslsm), POINTER :: wcarb_pft_lay(:,:,:)    
<   REAL(KIND=real_jlslsm), POINTER :: wmin_pft_lay(:,:,:)     
<   REAL(KIND=real_jlslsm), POINTER :: ej_pft_lay(:,:,:)
606c579
< USE jules_vegetation_mod,     ONLY: ilayers            
---
> 
738,746d710
< ALLOCATE(trif_vars_data%gpp_pft_lay(land_pts_dim, npft_dim, ilayers))
< ALLOCATE(trif_vars_data%apar_pft_lay(land_pts_dim, npft_dim, ilayers))
< ALLOCATE(trif_vars_data%cmpf_pft_lay(land_pts_dim, npft_dim, ilayers))
< ALLOCATE(trif_vars_data%vcmax_pft_lay(land_pts_dim, npft_dim, ilayers))
< ALLOCATE(trif_vars_data%vcmax25_pft_lay(land_pts_dim, npft_dim, ilayers))
< ALLOCATE(trif_vars_data%wlite_pft_lay(land_pts_dim, npft_dim, ilayers))
< ALLOCATE(trif_vars_data%wcarb_pft_lay(land_pts_dim, npft_dim, ilayers))
< ALLOCATE(trif_vars_data%wmin_pft_lay(land_pts_dim, npft_dim, ilayers))
< ALLOCATE(trif_vars_data%ej_pft_lay(land_pts_dim, npft_dim, ilayers))
789,797d752
< trif_vars_data%gpp_pft_lay(:,:,:)           = 0.0
< trif_vars_data%apar_pft_lay(:,:,:)          = 0.0
< trif_vars_data%cmpf_pft_lay(:,:,:)          = 0.0
< trif_vars_data%vcmax_pft_lay(:,:,:)         = 0.0
< trif_vars_data%vcmax25_pft_lay(:,:,:)       = 0.0
< trif_vars_data%wlite_pft_lay(:,:,:)         = 0.0
< trif_vars_data%wcarb_pft_lay(:,:,:)         = 0.0
< trif_vars_data%wmin_pft_lay(:,:,:)          = 0.0
< trif_vars_data%ej_pft_lay(:,:,:)            = 0.0
1027,1035d981
< DEALLOCATE(trif_vars_data%gpp_pft_lay)
< DEALLOCATE(trif_vars_data%apar_pft_lay)
< DEALLOCATE(trif_vars_data%cmpf_pft_lay)
< DEALLOCATE(trif_vars_data%vcmax_pft_lay)
< DEALLOCATE(trif_vars_data%vcmax25_pft_lay)
< DEALLOCATE(trif_vars_data%wlite_pft_lay)
< DEALLOCATE(trif_vars_data%wcarb_pft_lay)
< DEALLOCATE(trif_vars_data%wmin_pft_lay)
< DEALLOCATE(trif_vars_data%ej_pft_lay)
1203,1211d1148
< trif_vars%gpp_pft_lay      => trif_vars_data%gpp_pft_lay
< trif_vars%apar_pft_lay     => trif_vars_data%apar_pft_lay
< trif_vars%cmpf_pft_lay     => trif_vars_data%cmpf_pft_lay
< trif_vars%vcmax_pft_lay    => trif_vars_data%vcmax_pft_lay
< trif_vars%vcmax25_pft_lay  => trif_vars_data%vcmax25_pft_lay
< trif_vars%wlite_pft_lay    => trif_vars_data%wlite_pft_lay
< trif_vars%wcarb_pft_lay    => trif_vars_data%wcarb_pft_lay
< trif_vars%wmin_pft_lay     => trif_vars_data%wmin_pft_lay
< trif_vars%ej_pft_lay       => trif_vars_data%ej_pft_lay
1377,1385d1313
< NULLIFY(trif_vars%gpp_pft_lay)
< NULLIFY(trif_vars%apar_pft_lay)
< NULLIFY(trif_vars%cmpf_pft_lay)
< NULLIFY(trif_vars%vcmax_pft_lay)
< NULLIFY(trif_vars%vcmax25_pft_lay)
< NULLIFY(trif_vars%wlite_pft_lay)
< NULLIFY(trif_vars%wcarb_pft_lay)
< NULLIFY(trif_vars%wmin_pft_lay)
< NULLIFY(trif_vars%ej_pft_lay)
diff -r vn7.0copy1_c4/src/./control/shared/update_irrig_variables_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared/update_irrig_variables_mod.F90
35,36d34
< USE jules_print_mgr, ONLY: jules_print ! ifdef'ed usage
< 
48,51d45
< #if !defined(UM_JULES)
< CHARACTER(LEN=500) :: lineBuffer ! ifdef'ed usage
< #endif
< 
156,165d149
< 
< !------------------------------------------------------------------------------
< ! If running standalone JULES then write irrigation fraction range to stdout
< !-------------------------------------------------------------------------------
< #if !defined(UM_JULES)
< WRITE(lineBuffer,*) ' Range of frac irrigation (including ice points) = ',     &
<                       MINVAL(crop_vars%frac_irr_soilt),                        &
<                       MAXVAL(crop_vars%frac_irr_soilt)
< CALL jules_print('update_irrig_variables',lineBuffer)
< #endif
diff -r vn7.0copy1_c4/src/./control/shared/veg_control.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared/veg_control.F90
21c21
<   resp_s_acc_gb_um, resp_w_acc_pft,                                            &
---
>   resp_w_acc_pft,                                                              &
52c52
<   l_lice_point, soil_index,                                                    &
---
>   l_lice_point, l_lice_surft, soil_index,                                      &
139d138
<   resp_s_acc_gb_um(land_pts,dim_cslayer,dim_cs1),                              &
235a235
> LOGICAL, INTENT(IN OUT) :: l_lice_surft(ntype)
313,314d312
< trifctltype%resp_s_acc_soilt(:,1,:,:) = resp_s_acc_gb_um(:,:,:)
< 
335c333
<                trifctltype%resp_s_acc_soilt(:,1,1,:), resp_w_acc_pft,          &
---
>                trifctltype%resp_s_acc_soilt(:,1,:,:), resp_w_acc_pft,          &
359c357
<                l_lice_point,                                                   &
---
>                l_lice_point, l_lice_surft,                                     &
374c372
<                urban_param%ztm_gb)
---
>                l_lice_surft, urban_param%ztm_gb)
385,386d382
< resp_s_acc_gb_um(:,:,:)    = trifctltype%resp_s_acc_soilt(:,1,:,:)
< 
447c443
<             l_lice_point,                                                      &
---
>             l_lice_point, l_lice_surft,                                        &
463c459
<               ,urban_param%ztm_gb )
---
>               ,l_lice_surft,urban_param%ztm_gb )
diff -r vn7.0copy1_c4/src/./control/shared/water_resources_control_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared/water_resources_control_mod.F90
111c111
< USE model_time_mod, ONLY: timestep_number=>timestep
---
> USE model_time_mod, ONLY: timestep_number
506c506
< USE timestep_mod, ONLY: timestep_len=>timestep
---
> USE timestep_mod, ONLY: timestep
548c548
<                                  + demand_rate_domestic(:) * timestep_len      &
---
>                                  + demand_rate_domestic(:) * timestep          &
554c554
<                                  + demand_rate_industry(:) * timestep_len      &
---
>                                  + demand_rate_industry(:) * timestep          &
560c560
<                                   + demand_rate_livestock(:) * timestep_len    &
---
>                                   + demand_rate_livestock(:) * timestep        &
566c566
<                                   + demand_rate_transfers(:) * timestep_len
---
>                                   + demand_rate_transfers(:) * timestep
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared: water_resources_vars_mod.F90
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared: wtrac_checks_jls_mod.F90
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared: wtrac_correct_jls_mod.F90
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/shared: wtrac_extra_mod.F90
diff -r vn7.0copy1_c4/src/./control/standalone/check_unavailable_options_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/standalone/check_unavailable_options_mod.F90
22a23
> USE missing_data_mod, ONLY: imdi
29c30,31
< USE jules_rivers_mod,  ONLY: i_river_vn, l_inland, rivers_um_trip
---
> USE jules_rivers_mod,  ONLY: i_river_vn, l_inland, rivers_um_trip,             &
>                              trip_globe_shape
34a37,41
> USE jules_deposition_mod, ONLY: l_ukca_dry_dep_so2wet, l_ukca_ddepo3_ocean,    &
>                                 l_deposition_from_ukca
> 
> USE jules_water_tracers_mod, ONLY: l_wtrac_jls
> 
113a121,129
> IF ( trip_globe_shape /= imdi ) THEN
>   error_sum = error_sum + 1
>   WRITE(jules_message,'(I0,A,L1)') error_sum,                                  &
>      ": The shape of the TRIP globe can not be altered in standalone mode." // &
>      " trip_globe_shape must not be input. trip_globe_shape = ",               &
>      trip_globe_shape
>   CALL jules_print(RoutineName, jules_message, level = PrNorm)
> END IF
> 
137a154,187
>   CALL jules_print(RoutineName, jules_message, level = PrNorm)
> END IF
> 
> ! Deposition switches which are not available for use in JULES standalone
> IF ( l_deposition_from_ukca ) THEN
>   error_sum = error_sum + 1
>   WRITE(jules_message,'(I0,A,L1)') error_sum,                                  &
>      ": Deposition switch l_deposition_from_ukca_has to be false for " //      &
>      "standalone, as the calling UKCA routines are not available. " //         &
>      "l_deposition_from_ukca =", l_deposition_from_ukca
>   CALL jules_print(RoutineName, jules_message, level = PrNorm)
> END IF
> 
> IF ( l_ukca_ddepo3_ocean ) THEN
>   error_sum = error_sum + 1
>   WRITE(jules_message,'(I0,A,L1)') error_sum,                                  &
>      ": Deposition switch l_ukca_ddepo3_ocean is not applicable to " //        &
>      "standalone. l_ukca_ddepo3_ocean =", l_ukca_ddepo3_ocean
>   CALL jules_print(RoutineName, jules_message, level = PrNorm)
> END IF
> 
> IF ( l_ukca_dry_dep_so2wet ) THEN
>   error_sum = error_sum + 1
>   WRITE(jules_message,'(I0,A,L1)') error_sum,                                  &
>      ": Deposition switch l_ukca_dry_dep_so2wet is not applicable to " //      &
>      "standalone. l_ukca_dry_dep_so2wet =", l_ukca_dry_dep_so2wet
>   CALL jules_print(RoutineName, jules_message, level = PrNorm)
> END IF
> 
> IF ( l_wtrac_jls ) THEN
>   error_sum = error_sum + 1
>   WRITE(jules_message,'(I0,A,L1)') error_sum,                                  &
>      ": Water tracers cannot be run in standalone mode. " //                   &
>      "l_wtrac_jls =", l_wtrac_jls
diff -r vn7.0copy1_c4/src/./control/standalone/control.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/standalone/control.F90
4c4
<     timestep,                                                                  &
---
>     timestep_number,                                                           &
12c12
<     lake_vars ,                                                                &
---
>     lake_vars,                                                                 &
17c17,18
<     rivers,                                                                    &
---
>     rivers, water_resources,                                                   &
>     wtrac_jls,                                                                 &
46a48,49
> USE water_resources_vars_mod, ONLY: water_resources_type
> USE jules_wtrac_type_mod, ONLY: jls_wtrac_type
62,63c65,66
<   land_pts, nsurft, surft_pts, row_length, rows, dim_cs1, dim_cs2,             &
<   lice_pts, soil_pts, nsoilt, dim_cslayer
---
>   land_pts, nsurft, row_length, rows,                                          &
>   lice_pts, soil_pts, nsoilt, ssi_pts, sea_pts, sice_pts
104a108,114
> USE jules_water_tracers_mod,  ONLY: l_wtrac_jls
> 
> ! Used for atmospheric deposition
> USE jules_deposition_mod,     ONLY: l_deposition
> USE conversions_mod,          ONLY: pi_over_180
> USE model_grid_mod,           ONLY: latitude
> 
113c123
< INTEGER, INTENT(IN) :: timestep    ! IN Atmospheric timestep number.
---
> INTEGER, INTENT(IN) :: timestep_number    ! IN Atmospheric timestep number.
143a154,155
> TYPE(water_resources_type), INTENT(IN OUT) :: water_resources
> TYPE(jls_wtrac_type), INTENT(IN OUT) :: wtrac_jls
191,192d202
< !TYPES containing field data (IN OUT)
< 
252,254c262,266
<   fraca(land_pts,nsurft),                                                      &
<     !Fraction of surface moisture flux with only aerodynamic resistance for
<     !snow-free land tiles.
---
>   fracaero_t(land_pts,nsurft),                                                 &
>     !Total fractions of surface moisture flux with only aerodynamic resistance
>   fracaero_s(land_pts,nsurft),                                                 &
>     !Fractions of surface moisture flux with only aerodynamic resistance
>     !from the frozen part of the tile only
257c269
<     !(1-FRACA) of snow-free land tiles.
---
>     !(1-fracaero_t) of snow-free land tiles.
259,260c271,272
<     !Total resistance factor. FRACA+(1-FRACA)*RESFS for snow-free land, 1
<     !for snow.
---
>     !Total resistance factor, fracaero_t+(1-fracaero_t)*RESFS for snow-free
>     !land, 1 for snow.
355a368,369
>   sky(tdims%i_start:tdims%i_end,tdims%j_start:tdims%j_end),                    &
>     ! Skyview correction for surface LW
358d371
<   resp_s_acc_gb_um(land_pts,dim_cslayer,dim_cs1),                              &
387c400
<   resp_s_tot_soilt(dim_cs2,nsoilt),                                            &
---
>   resp_s_tot_soilt(land_pts,nsoilt),                                           &
462c475
<   IF (timestep == 1) THEN
---
>   IF (timestep_number == 1) THEN
477c490
<   nsurft, land_pts, surft_pts, row_length, rows,                               &
---
>   nsurft, land_pts, sea_pts, ainfo%surft_pts, row_length, rows,                &
535c548
<   DO point = 1, surft_pts(lake)
---
>   DO point = 1, ainfo%surft_pts(lake)
580c593,594
<   fraca, resfs, resft, rhokh, rhokh_surft, rhokh_sice, rhokh_sea_ij,           &
---
>   fracaero_t, fracaero_s, resfs, resft,                                        &
>   rhokh, rhokh_surft, rhokh_sice, rhokh_sea_ij,                                &
592,593c606,607
<   land_pts, nsurft,                                                            &
<   surft_pts,                                                                   &
---
>   land_pts, ssi_pts, sea_pts, nsurft,                                          &
>   ainfo%surft_pts,                                                             &
601c615
<   asteps_since_triffid, resp_s_acc_gb_um,                                      &
---
>   asteps_since_triffid,                                                        &
607c621
<   numcycles, cycleno, z1_uv_top, z1_tq_top, ddmfx,                             &
---
>   numcycles, cycleno, z1_uv_top, z1_tq_top, sky, ddmfx,                        &
620a635
>   wtrac_jls,                                                                   &
627c642,643
< !  epot_surft, fraca, rhokh, rhokh_surft, rhokh_sice, dtstar_ij_surft,
---
> !  epot_surft, fracaero_t, fracaero_s,
> !  rhokh, rhokh_surft, rhokh_sice, dtstar_ij_surft,
712,714c728,730
<   ashtf_prime, ashtf_prime_sea, ashtf_prime_surft, du, dv, fraca, resfs,       &
<   resft, rhokh, rhokh_surft, rhokh_sice, rhokh_sea_ij, z0hssi, z0mssi,         &
<   chr1p5m, chr1p5m_sice, canhc_surft, flake, tile_frac,                        &
---
>   ashtf_prime, ashtf_prime_sea, ashtf_prime_surft, du, dv, fracaero_t,         &
>   fracaero_s, resfs, resft, rhokh, rhokh_surft, rhokh_sice, rhokh_sea_ij,      &
>   z0hssi, z0mssi, chr1p5m, chr1p5m_sice, canhc_surft, flake, tile_frac,        &
729c745
<   nsurft, land_pts, surft_pts,                                                 &
---
>   nsurft, land_pts, ssi_pts, sice_pts, sea_pts, ainfo%surft_pts,               &
731a748,749
>   ! Water tracer switch (IN)
>   l_wtrac_jls,                                                                 &
738c756
<   rhokh_mix, ti_gb,                                                            &
---
>   rhokh_mix, ti_gb, sky,                                                       &
747a766
>   wtrac_jls,                                                                   &
775,776c794,796
<   ashtf_prime, ashtf_prime_sea, ashtf_prime_surft, du, dv, fraca, resfs,       &
<   resft, rhokh, rhokh_surft, rhokh_sice, rhokh_sea_ij, z0hssi, z0mssi,         &
---
>   ashtf_prime, ashtf_prime_sea, ashtf_prime_surft, du, dv,                     &
>   fracaero_t, fracaero_s, resfs, resft,                                        &
>   rhokh, rhokh_surft, rhokh_sice, rhokh_sea_ij, z0hssi, z0mssi,                &
792c812
<   nsurft, land_pts, surft_pts,                                                 &
---
>   nsurft, land_pts, ssi_pts, sice_pts, sea_pts, ainfo%surft_pts,               &
795a816,817
>   ! Water tracer switch (IN)
>   l_wtrac_jls,                                                                 &
802c824
<   rhokh_mix, ti_gb,                                                            &
---
>   rhokh_mix, ti_gb, sky,                                                       &
811a834
>   wtrac_jls,                                                                   &
833a857,863
> !For JULES with atmospheric deposition
> IF (l_deposition) THEN
>   chemvars%dep_sinlat_ij(:,:) = SIN(pi_over_180 * latitude(:,:))
>   chemvars%dep_ftl_1_ij(:,:)  = ftl_1_ij(:,:)
>   chemvars%dep_ustar_ij(:,:)  = u_s(:,:)
> END IF
> 
840c870
<   timestep, sf_diag%smlt, tile_frac, hcons_soilt, rhostar,                     &
---
>   timestep_number, sf_diag%smlt, tile_frac, hcons_soilt, rhostar,              &
845c875
<   cca_2d, nsurft, surft_pts,                                                   &
---
>   cca_2d, nsurft, ainfo%surft_pts,                                             &
866c896
<   twatstor, asteps_since_triffid, resp_s_acc_gb_um,                            &
---
>   twatstor, asteps_since_triffid,                                              &
872c902
<   progs,trifctltype, jules_vars,                                               &
---
>   progs,trifctltype,coast,jules_vars,                                          &
879c909,910
<   !chemvars, &
---
>   chemvars, water_resources,                                                   &
>   wtrac_jls,                                                                   &
diff -r vn7.0copy1_c4/src/./control/standalone/jules.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/standalone/jules.F90
15a16,17
> USE jules_vars_mod, ONLY: mpi_local_comm
> USE mpi, ONLY: mpi_comm_world
30c32
<                        output_close_all => close_all
---
>                       output_close_all => close_all
32c34,35
< USE model_time_mod, ONLY: timestep, start_of_year, end_of_year, end_of_run
---
> USE model_time_mod, ONLY: timestep_number, start_of_year, end_of_year,         &
>                           end_of_run
62c65,67
<                             rivers_data, rivers
---
>                             rivers_data, rivers,                               &
>                             water_resources_data, water_resources,             &
>                             wtrac_jls_data, wtrac_jls
68a74
> USE imgn_vars_mod, ONLY: imgn_vars_data, imgn_vars
97a104
> mpi_local_comm = mpi_comm_world
138c145,146
<                    !veg3_parm_(data), &
---
>                    imgn_vars_data, imgn_vars,                                  &
>                   !veg3_parm_(data), &
142c150,153
<                    !CABLE state vars, progs, params and miscellaneous requirements
---
>                    water_resources_data, water_resources,                      &
>                    wtrac_jls_data, wtrac_jls,                                  &
>                    ! CABLE state vars, progs, params and miscellaneous
>                    ! requirements
158c169
<     CALL imogen_update_clim(progs, imgn_drive, ainfo)
---
>     CALL imogen_update_clim(progs, imgn_drive, imgn_vars, ainfo)
182c193
<       timestep,                                                                &
---
>       timestep_number,                                                         &
196c207,208
<       rivers,                                                                  &
---
>       rivers, water_resources,                                                 &
>       wtrac_jls,                                                               &
204c216
<   IF ( l_imogen .AND. end_of_year ) CALL imogen_update_carb(progs, imgn_drive)
---
>   IF ( l_imogen .AND. end_of_year ) CALL imogen_update_carb(progs, imgn_vars)
diff -r vn7.0copy1_c4/src/./control/standalone/jules_fields_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/standalone/jules_fields_mod.F90
31a32,34
> USE water_resources_vars_mod, ONLY: water_resources_data_type,                 &
>                                     water_resources_type
> USE jules_wtrac_type_mod, ONLY: jls_wtrac_data_type, jls_wtrac_type
54a58,59
> TYPE(water_resources_data_type), TARGET :: water_resources_data
> TYPE(jls_wtrac_data_type), TARGET :: wtrac_jls_data
77a83,84
> TYPE(water_resources_type) :: water_resources
> TYPE(jls_wtrac_type) :: wtrac_jls
diff -r vn7.0copy1_c4/src/./control/standalone/jules_final_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/standalone/jules_final_mod.F90
76,77c76,78
<   CALL log_error(proc_name, 'The deposition code is not fully functional ' //  &
<                             'in this version. It should not be used!')
---
>   CALL log_warn(proc_name, 'The deposition code is available in this ' //      &
>                            'version but should be used with caution '  //      &
>                            'as it is still under development')
diff -r vn7.0copy1_c4/src/./control/standalone/jules_vectlib_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/standalone/jules_vectlib_mod.F90
34c34
< USE um_types, ONLY: REAL64, integer32
---
> USE um_types, ONLY: real_64, integer_32
39c39
< REAL (KIND=REAL64) :: y(n), x(n)
---
> REAL (KIND=real_64) :: y(n), x(n)
41c41
< INTEGER (KIND=integer32) :: l_n
---
> INTEGER (KIND=integer_32) :: l_n
77c77
< USE um_types, ONLY: REAL64, integer32
---
> USE um_types, ONLY: real_64, integer_32
82c82
< REAL (KIND=REAL64) :: z(n), x(n), y(n), power
---
> REAL (KIND=real_64) :: z(n), x(n), y(n), power
84c84
< INTEGER (KIND=integer32) :: l_n
---
> INTEGER (KIND=integer_32) :: l_n
123c123
< USE um_types, ONLY: REAL64, integer32
---
> USE um_types, ONLY: real_64, integer_32
128c128
< REAL (KIND=REAL64) :: z(n), x(n), y(n)
---
> REAL (KIND=real_64) :: z(n), x(n), y(n)
130c130
< INTEGER (KIND=integer32) :: l_n
---
> INTEGER (KIND=integer_32) :: l_n
166c166
< USE um_types, ONLY: REAL64, integer32
---
> USE um_types, ONLY: real_64, integer_32
171c171
< REAL (KIND=REAL64) :: x(n), y(n)
---
> REAL (KIND=real_64) :: x(n), y(n)
173c173
< INTEGER (KIND=integer32) :: l_n
---
> INTEGER (KIND=integer_32) :: l_n
210c210
< USE um_types, ONLY: REAL64, integer32
---
> USE um_types, ONLY: real_64, integer_32
215c215
< REAL (KIND=REAL64) :: x(n), y(n)
---
> REAL (KIND=real_64) :: x(n), y(n)
217c217
< INTEGER (KIND=integer32) :: l_n
---
> INTEGER (KIND=integer_32) :: l_n
244c244
< USE um_types, ONLY: REAL64, integer32
---
> USE um_types, ONLY: real_64, integer_32
249c249
< REAL (KIND=REAL64) :: x(n), y(n)
---
> REAL (KIND=real_64) :: x(n), y(n)
251c251
< INTEGER (KIND=integer32) :: l_n
---
> INTEGER (KIND=integer_32) :: l_n
287c287
< USE um_types, ONLY: REAL64, integer32
---
> USE um_types, ONLY: real_64, integer_32
292c292
< REAL (KIND=REAL64) :: y(n), x(n)
---
> REAL (KIND=real_64) :: y(n), x(n)
294c294
< INTEGER (KIND=integer32) :: l_n
---
> INTEGER (KIND=integer_32) :: l_n
330c330
< USE um_types, ONLY: REAL64, integer32
---
> USE um_types, ONLY: real_64, integer_32
335c335
< REAL (KIND=REAL64) :: y(n), x(n)
---
> REAL (KIND=real_64) :: y(n), x(n)
337c337
< INTEGER (KIND=integer32) :: l_n
---
> INTEGER (KIND=integer_32) :: l_n
372c372
< USE um_types, ONLY: REAL64, integer32
---
> USE um_types, ONLY: real_64, integer_32
377c377
< REAL (KIND=REAL64) :: y(n), x(n)
---
> REAL (KIND=real_64) :: y(n), x(n)
379c379
< INTEGER (KIND=integer32) :: l_n
---
> INTEGER (KIND=integer_32) :: l_n
406c406
< USE um_types, ONLY: REAL64, integer32
---
> USE um_types, ONLY: real_64, integer_32
411c411
< REAL (KIND=REAL64) :: y(n), x(n)
---
> REAL (KIND=real_64) :: y(n), x(n)
413c413
< INTEGER (KIND=integer32) :: l_n
---
> INTEGER (KIND=integer_32) :: l_n
diff -r vn7.0copy1_c4/src/./control/standalone/next_time_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/standalone/next_time_mod.F90
27c27
< USE spinup_mod, ONLY: spinup_check
---
> USE spinup_check_mod, ONLY: spinup_check
32,33c32,34
<                           timestep, start_of_year, current_time,end_of_year,   &
<                           print_step, max_spinup_cycles
---
>                           timestep_number, start_of_year, current_time,        &
>                           end_of_year, print_step, max_spinup_cycles,          &
>                           oasis_time
109c110
<     !-----------------------------------------------------------------------------
---
>     !---------------------------------------------------------------------------
111c112
<     !-----------------------------------------------------------------------------
---
>     !---------------------------------------------------------------------------
124c125
<     !-----------------------------------------------------------------------------
---
>     !---------------------------------------------------------------------------
127c128
<     !-----------------------------------------------------------------------------
---
>     !---------------------------------------------------------------------------
141,143c142,144
<       ! We use end_of_run rather than a fatal error to abort the run as we want a
<       ! final dump to be written, and output from the final spinup cycle to be written
<       ! correctly
---
>       ! We use end_of_run rather than a fatal error to abort the run as we want
>       ! a final dump to be written, and output from the final spinup cycle to
>       ! be written correctly
146c147,148
<       ! If the flag is not set, we will continue with the main run with a warning
---
>       ! If the flag is not set, we will continue with the main run with a
>       ! warning
154c156
<     !-----------------------------------------------------------------------------
---
>     !---------------------------------------------------------------------------
156c158
<     !-----------------------------------------------------------------------------
---
>     !---------------------------------------------------------------------------
166,168c168,170
<     ! A seek of the input files is not required for starting a new cycle of spinup
<     ! since advance_all handles ramping between spinup_end and spinup_start
<     ! smoothly
---
>     ! A seek of the input files is not required for starting a new cycle of
>     ! spinup since advance_all handles ramping between spinup_end and
>     ! spinup_start smoothly
186c188
< timestep = timestep + 1
---
> timestep_number = timestep_number + 1
188a191,193
> ! Update the time step in seconds: the first time step is 1, not 0
> oasis_time = (timestep_number-1)*timestep_len
> 
218c223
<   IF ( MOD(timestep, print_step) == 0 ) THEN
---
>   IF ( MOD(timestep_number, print_step) == 0 ) THEN
220c225
<                   "Timestep: " // TRIM(to_string(timestep)) // "; " //         &
---
>                   "Timestep: " // TRIM(to_string(timestep_number)) // "; " //  &
244,253c249,255
< ! Standalone Rivers: Ignore dumps for now
< IF ( lsm_id /= rivers ) THEN
<   IF ( current_time == spinup_start .OR. current_time == main_run_start .OR.   &
<      ( dump_period_unit == dump_period_year .AND.                              &
<      start_of_year .AND. MOD(current_time%year,dump_period) == 0 )  .OR.       &
<      ( dump_period_unit == dump_period_time .AND.                              &
<      MOD(current_time%TIME,dump_period) == 0 ) .OR.                            &
<      end_of_run ) THEN
<     CALL write_dump()
<   END IF
---
> IF ( current_time == spinup_start .OR. current_time == main_run_start .OR.     &
>    ( dump_period_unit == dump_period_year .AND.                                &
>    start_of_year .AND. MOD(current_time%year,dump_period) == 0 )  .OR.         &
>    ( dump_period_unit == dump_period_time .AND.                                &
>    MOD(current_time%TIME,dump_period) == 0 ) .OR.                              &
>    end_of_run ) THEN
>   CALL write_dump()
Only in vn7.0copy1_c4/src/./control/standalone/parallel: decompose_domain.inc
Only in vn7.0copy1_c4/src/./control/standalone/parallel: gather_land_field.inc
Only in vn7.0copy1_c4/src/./control/standalone/parallel: is_master_task.inc
diff -r vn7.0copy1_c4/src/./control/standalone/parallel/parallel_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/standalone/parallel/parallel_mod.F90
8,14d7
< 
< MODULE parallel_mod
< 
< USE logging_mod, ONLY: log_info, log_fatal
< 
< IMPLICIT NONE
< 
26a20,25
> MODULE parallel_mod
> 
> USE logging_mod, ONLY: log_info, log_fatal
> 
> IMPLICIT NONE
> 
56d54
< 
58a57,566
> !-----------------------------------------------------------------------------
> ! Description:
> !   Returns .TRUE. if the current task is the master task, .FALSE. otherwise
> !-----------------------------------------------------------------------------
> LOGICAL FUNCTION is_master_task()
> 
> USE jules_vars_mod, ONLY: mpi_local_comm
> 
> IMPLICIT NONE
> 
> ! Work variables
> INTEGER :: task_id  ! The id of this task
> 
> INTEGER :: ERROR  ! Error indicator for MPI calls
>                   ! This is ignored as (most) MPI implementations fail
>                   ! rather than returning actual error codes
> 
> 
> !-----------------------------------------------------------------------------
> 
> CALL mpi_comm_rank(mpi_local_comm, task_id, ERROR)
> 
> is_master_task = (task_id == master_task_id)
> 
> RETURN
> 
> END FUNCTION is_master_task
> 
> !-----------------------------------------------------------------------------
> ! Description:
> !   Decomposes the given grid across the available MPI tasks
> !   Returns a subgrid object representing the part of the grid that the
> !   current task will be responsible for
> !-----------------------------------------------------------------------------
> FUNCTION decompose_domain(grid) RESULT(task_subgrid)
> 
> USE mpi, ONLY: mpi_address_kind, mpi_real
> USE jules_vars_mod, ONLY: mpi_local_comm
> 
> USE grid_utils_mod, ONLY: grid_info, subgrid_info, subgrid_create
> 
> USE string_utils_mod, ONLY: to_string
> 
> IMPLICIT NONE
> 
> ! Argument types
> TYPE(grid_info), INTENT(IN) :: grid  ! The grid to decompose
> 
> ! Return type
> TYPE(subgrid_info) :: task_subgrid  ! The subgrid this task is responsible for
> 
> ! Work variables
> INTEGER :: ntasks_x, ntasks_y  ! The size of the "task grid" (i.e. the grid
>                                ! will be split into ntasks_x by ntasks_y
>                                ! blocks
> 
> INTEGER :: task_nx, task_ny    ! The size of the block for the current task
> 
> INTEGER :: task_x, task_y  ! The x and y coordinates in the "task grid"
>                            ! of the current task
> 
> INTEGER :: x_start, y_start  ! The x/y coordinates in the grid of the start
>                              ! of the task subgrid
> 
> LOGICAL :: found_decomposition  ! T - we found a usable decomposition
>                                 ! F - we did not find a usable decomposition
> 
> INTEGER :: leftover  ! The remainder when distributing columns along a task row
> 
> INTEGER :: mpi_type  ! Holds intermediate MPI datatype before the extent
>                      ! is adjusted
> INTEGER(KIND=mpi_address_kind) :: mpi_real_lb, mpi_real_extent
>                      ! The lower bound and extent for the mpi_real type
> 
> INTEGER(KIND=mpi_address_kind), PARAMETER :: mpi_zero = 0
>                      ! A 'zero' of the correct kind to be used as an MPI address
> 
> INTEGER, ALLOCATABLE :: counts_2d(:,:), offsets_2d(:,:)
>                      ! Used when calculating the counts and offsets on the
>                      ! task grid
> 
> INTEGER :: ERROR  ! Error indicator for MPI calls
>                   ! This is ignored as (most) MPI implementations fail
>                   ! rather than returning actual error codes
> 
> INTEGER :: i, j, n  ! Index variables
> 
> 
> !-----------------------------------------------------------------------------
> 
> 
> !-----------------------------------------------------------------------------
> ! This routine currently implements a very naive decomposition
> !
> ! The main concern when decomposing the grid is I/O, not MPI communication
> ! I.E. the grid must be split into contiguous regions that can be written to
> ! file in one write statement by specifying appropriate start and count
> !-----------------------------------------------------------------------------
> 
> ! First get the number of available tasks and the id of this task
> CALL mpi_comm_size(mpi_local_comm, ntasks, ERROR)
> CALL mpi_comm_rank(mpi_local_comm, task_id, ERROR)
> 
> CALL log_info("decompose_domain",                                              &
>               "Decomposing domain across " // TRIM(to_string(ntasks)) //       &
>               " available tasks")
> 
> ! We can only utilise at most 1 task per point
> IF ( ntasks > grid%nx * grid%ny )                                              &
>   CALL log_fatal("decompose_domain",                                           &
>                  "More tasks are available than points in the model grid")
> 
> !-----------------------------------------------------------------------------
> ! Work out the decomposition, subject to the following rules:
> !
> !   * Each task must have the same number of grid rows, but can have a
> !     varying number of columns
> !
> !   * Each row of the task grid must have at most grid%nx tasks
> !
> !   * Each row of the task grid must have the same number of tasks
> !
> !-----------------------------------------------------------------------------
> ! This is the minimum number of rows we need in the task grid to ensure that
> ! each row has <= grid%nx tasks
> ntasks_y = (ntasks-1) / grid%nx + 1
> 
> ! Loop until we find a suitable number of rows for the task grid
> ! Limited testing found that using as many rows of tasks as possible resulted
> ! in the most efficient decomposition more of the time (I realise that sounds
> ! a bit woolly!)
> DO n = grid%ny,ntasks_y,-1
>   found_decomposition =     ( MOD(grid%ny, n) == 0 ) & ! Each task gets the same number of grid rows
>                       .AND. ( MOD(ntasks, n) == 0 )     ! Each row of the task grid has the same number of tasks
> 
>   IF ( found_decomposition ) THEN
>     ntasks_x = ntasks / n
>     ntasks_y = n
>     EXIT
>   END IF
> END DO
> 
> ! If we could not find a suitable decomposition, suggest changing the number
> ! of available processes
> IF ( .NOT. found_decomposition )                                               &
>   CALL log_fatal("decompose_domain",                                           &
>                  "Unable to find a suitable decomposition - try " //           &
>                  "using a different number of tasks")
> 
> CALL log_info("decompose_domain",                                              &
>               "Tasks are arranged as a grid of size " //                       &
>               TRIM(to_string(ntasks_x)) // " x " // TRIM(to_string(ntasks_y)))
> 
> ! Each task has the same number of rows, which we can now calculate
> task_ny = grid%ny / ntasks_y
> 
> !-----------------------------------------------------------------------------
> ! Build the MPI datatype that allows us to scatter to and gather from
> ! global arrays in blocks of size 1 x task_ny
> !-----------------------------------------------------------------------------
> ! Get the lower bound and extent for the mpi_real type
> CALL mpi_type_get_extent(mpi_real, mpi_real_lb, mpi_real_extent, ERROR)
> 
> ! Define a MPI type that selects columns from the full grid
> CALL mpi_type_vector(task_ny, 1, grid%nx, mpi_real, mpi_type, ERROR)
> 
> ! Restrict the extent of the datatype to 1 real value for use in offset
> ! calculations
> CALL mpi_type_create_resized(                                                  &
>   mpi_type, mpi_zero, mpi_real_extent, mpi_type_global_col, ERROR              &
> )
> 
> ! Commit the datatype
> CALL mpi_type_commit(mpi_type_global_col, ERROR)
> 
> !-----------------------------------------------------------------------------
> ! Work out how many grid columns each task in the task grid will have
> !-----------------------------------------------------------------------------
> ALLOCATE(counts_2d(ntasks_x,ntasks_y))
> ! Work out how many columns (most of) the tasks will get
> counts_2d(:,:) = grid%nx / ntasks_x
> ! Distribute any leftover columns
> leftover = MOD(grid%nx, ntasks_x)
> IF ( leftover > 0 ) THEN
>   DO n = 1,leftover
>     counts_2d(n,:) = counts_2d(n,:) + 1
>   END DO
> END IF
> 
> ! The counts used in MPI calls are a flattened version of this
> ALLOCATE(counts(ntasks))
> counts(:) = RESHAPE(counts_2d, [ ntasks ])
> 
> !-----------------------------------------------------------------------------
> ! Calculate the offsets for each task
> !
> ! Because we adjusted the extent of the column type, our offsets are
> ! calculated in actual grid cells
> !-----------------------------------------------------------------------------
> ALLOCATE(offsets_2d(ntasks_x,ntasks_y))
> ! Note that MPI offsets must start from 0, not 1!
> DO j = 1,ntasks_y
>   DO i = 1,ntasks_x
>     ! First, sum along each row in the task grid to get the offsets within the row
>     offsets_2d(i,j) = SUM(counts_2d(1:i-1,j))
>   END DO
>   ! Then for each row of tasks, add the offset to the start of that row
>   offsets_2d(:,j) = offsets_2d(:,j) + (j-1) * grid%nx * task_ny
> END DO
> 
> ! The offsets used in MPI calls are a flattened version of this
> ALLOCATE(offsets(ntasks))
> offsets(:) = RESHAPE(offsets_2d, [ ntasks ])
> 
> !-----------------------------------------------------------------------------
> ! Construct the subgrid that this task is responsible for
> !-----------------------------------------------------------------------------
> ! Work out where the current task sits in the task grid
> ! Remember that task ids start from 0, not 1!
> task_y = task_id / ntasks_x + 1
> task_x = (task_id+1) - (task_y-1) * ntasks_x
> 
> ! From that, we can retrieve the number of columns the current task is
> ! reponsible for
> ! We already know how many rows the task is responsible for
> task_nx = counts_2d(task_x,task_y)
> 
> ! Now we work out the position of the start of our grid in the full grid
> ! Don't forget that these offsets start from 1, not 0!
> ! We can get our x_start by summing the counts for the previous columns
> x_start = SUM(counts_2d(1:task_x-1,task_y)) + 1
> ! Since each task has the same number of rows, getting y_start is easier
> y_start = (task_y-1) * task_ny + 1
> 
> task_subgrid = subgrid_create(grid, x_start, y_start, task_nx, task_ny)
> 
> !-----------------------------------------------------------------------------
> ! Now we know the size of the subgrid, we define a MPI datatype that selects
> ! columns in the subgrid for the current task
> !-----------------------------------------------------------------------------
> CALL mpi_type_vector(                                                          &
>   task_subgrid%ny, 1, task_subgrid%nx, mpi_real, mpi_type, ERROR               &
> )
> ! Again, we set the extent of the type to one real value for offset
> ! calculations
> CALL mpi_type_create_resized(                                                  &
>   mpi_type, mpi_zero, mpi_real_extent, mpi_type_local_col, ERROR               &
> )
> CALL mpi_type_commit(mpi_type_local_col, ERROR)
> 
> DEALLOCATE(counts_2d)
> DEALLOCATE(offsets_2d)
> 
> RETURN
> 
> END FUNCTION decompose_domain
> 
> !-----------------------------------------------------------------------------
> ! Description:
> !   Takes a field defined on the land points of the full model grid in the
> !   master task and scatters it onto the land points for each task, in
> !   accordance with the decomposition performed by decompose_domain
> !-----------------------------------------------------------------------------
> SUBROUTINE scatter_land_field(field_global_land, field_local_land)
> 
> USE jules_vars_mod, ONLY: mpi_local_comm
> 
> USE missing_data_mod, ONLY: rmdi
> 
> USE ancil_info, ONLY: land_pts
> 
> USE jules_fields_mod, ONLY: ainfo
> 
> USE theta_field_sizes, ONLY: t_i_length, t_j_length
> 
> USE model_grid_mod, ONLY: model_grid, global_land_pts, global_land_mask
> 
> IMPLICIT NONE
> 
> ! Interface definition is only required if using the dummy MPI library - it
> ! allows the mpi_scatterv implementation to use assumed-shape arrays (without
> ! being in a module), which it needs to as it doesn't track MPI type information
> ! and relies purely on the shape of the array
> #if defined(MPI_DUMMY)
> INTERFACE
>   SUBROUTINE mpi_scatterv(sendbuf, sendcnts, displs, sendtype,                 &
>                           recvbuf, recvcnt, recvtype,                          &
>                           root, comm, ERROR)
> 
>   REAL, INTENT(IN) :: sendbuf(:,:)
>   INTEGER, INTENT(IN) :: sendcnts(:)
>   INTEGER, INTENT(IN) :: displs(:)
>   INTEGER, INTENT(IN) :: sendtype
> 
>   REAL, INTENT(OUT) :: recvbuf(:,:)
>   INTEGER, INTENT(IN) :: recvcnt
>   INTEGER, INTENT(IN) :: recvtype
> 
>   INTEGER, INTENT(IN) :: root
>   INTEGER, INTENT(IN) :: comm
>   INTEGER, INTENT(OUT) :: ERROR
> 
>   END SUBROUTINE mpi_scatterv
> END INTERFACE
> #endif
> 
> ! Argument types
> REAL, INTENT(IN) :: field_global_land(:)
>                                      ! The field on the global land points
>                                      ! This only has to be properly defined
>                                      ! for the master task
> REAL, INTENT(OUT) :: field_local_land(land_pts)
>                                        ! The field on the land points for the
>                                        ! current task
>                                        ! This must be defined for all tasks
> 
> ! Work variables
> REAL, ALLOCATABLE :: field_global_2d(:,:)
>                                 ! The global field on the full 2d model grid
>                                 ! Only allocated in master task
> REAL :: field_local_2d(t_i_length,t_j_length)
>                                 ! The local field on the model grid for the
>                                 ! current task
>                                 ! Used in all tasks
> 
> INTEGER :: i,j,l  ! Indexing variables
> 
> INTEGER :: ERROR  ! Error indicator for MPI calls
>                   ! This is ignored as (most) MPI implementations fail
>                   ! rather than returning actual error codes
> 
> 
> !-----------------------------------------------------------------------------
> 
> 
> !-----------------------------------------------------------------------------
> ! In the master task, convert the full land points array into a 2d array
> ! on the full model grid
> !-----------------------------------------------------------------------------
> IF ( is_master_task() ) THEN
>   ! Check that the global field is properly defined in the master task
>   IF ( SIZE(field_global_land) /= global_land_pts )                            &
>     CALL log_fatal("scatter_land_field",                                       &
>                    "Input field should be on global land points")
> 
>   ! We then need to map back onto the full model grid before scattering
>   ALLOCATE(field_global_2d(model_grid%nx,model_grid%ny))
>   field_global_2d(:,:) = rmdi
>   field_global_2d(:,:) = UNPACK(                                               &
>     field_global_land, global_land_mask, field_global_2d                       &
>   )
> ELSE
>   ALLOCATE(field_global_2d(1,1))
> END IF
> 
> !-----------------------------------------------------------------------------
> ! Scatter the field into local 2d parts using the block datatype and
> ! calculated counts and offsets
> !-----------------------------------------------------------------------------
> CALL mpi_scatterv(field_global_2d, counts, offsets, mpi_type_global_col,       &
>                   field_local_2d,  t_i_length,      mpi_type_local_col,        &
>                   master_task_id, mpi_local_comm, ERROR)
> 
> !-----------------------------------------------------------------------------
> ! Convert the local 2d parts into land point arrays
> !-----------------------------------------------------------------------------
> DO l = 1,land_pts
>   j = (ainfo%land_index(l) - 1) / t_i_length + 1
>   i = ainfo%land_index(l) - (j-1) * t_i_length
> 
>   field_local_land(l) = field_local_2d(i,j)
> END DO
> 
> !-----------------------------------------------------------------------------
> ! Deallocate the global field at the end
> !-----------------------------------------------------------------------------
> IF ( ALLOCATED(field_global_2d) ) DEALLOCATE(field_global_2d)
> 
> RETURN
> 
> END SUBROUTINE scatter_land_field
> 
> 
> SUBROUTINE gather_land_field(field_local_land, field_global_land)
> 
> USE jules_vars_mod, ONLY: mpi_local_comm
> 
> USE missing_data_mod, ONLY: rmdi
> 
> USE ancil_info, ONLY: land_pts
> 
> USE jules_fields_mod, ONLY: ainfo
> 
> USE theta_field_sizes, ONLY: t_i_length, t_j_length
> 
> USE model_grid_mod, ONLY: model_grid, global_land_pts, global_land_mask
> 
> IMPLICIT NONE
> 
> ! Interface definition is only required if using the dummy MPI library - it
> ! allows the mpi_gatherv implementation to use assumed-shape arrays (without
> ! being in a module), which it needs to as it doesn't track MPI type information
> ! and relies purely on the shape of the array
> #if defined(MPI_DUMMY)
> INTERFACE
>   SUBROUTINE mpi_gatherv(sendbuf, sendcnt, sendtype,                           &
>                          recvbuf, recvcnts, displs, recvtype,                  &
>                          root, comm, ERROR)
> 
>   REAL, INTENT(IN) :: sendbuf(:,:)
>   INTEGER, INTENT(IN) :: sendcnt
>   INTEGER, INTENT(IN) :: sendtype
> 
>   REAL, INTENT(OUT) :: recvbuf(:,:)
>   INTEGER, INTENT(IN) :: recvcnts(:)
>   INTEGER, INTENT(IN) :: displs(:)
>   INTEGER, INTENT(IN) :: recvtype
> 
>   INTEGER, INTENT(IN) :: root
>   INTEGER, INTENT(IN) :: comm
>   INTEGER, INTENT(OUT) :: ERROR
> 
>   END SUBROUTINE mpi_gatherv
> END INTERFACE
> #endif
> 
> !-----------------------------------------------------------------------------
> ! Description:
> !   Takes a field defined on the land points of each task and gathers it
> !   onto the land points of the full model grid in the master task, in
> !   accordance with the decomposition performed by decompose_domain
> !-----------------------------------------------------------------------------
> ! Argument types
> REAL, INTENT(IN) :: field_local_land(land_pts)
>                                        ! The field on the land points for the
>                                        ! current task
>                                        ! This must be defined for all tasks
> REAL, INTENT(OUT) :: field_global_land(:)
>                                      ! The field on the global land points
>                                      ! This only has to be properly defined
>                                      ! for the master task
> 
> ! Work variables
> REAL, ALLOCATABLE :: field_global_2d(:,:)
>                                 ! The global field on the full 2d model grid
>                                 ! Only allocated in master task
> REAL :: field_local_2d(t_i_length,t_j_length)
>                                 ! The local field on the model grid for the
>                                 ! current task
>                                 ! Used in all tasks
> 
> INTEGER :: i,j,l  ! Indexing variables
> 
> INTEGER :: ERROR  ! Error indicator for MPI calls
>                   ! This is ignored as (most) MPI implementations fail
>                   ! rather than returning actual error codes
> 
> 
> !-----------------------------------------------------------------------------
> 
> 
> !-----------------------------------------------------------------------------
> ! Verify that the global land points field is the right size
> ! We do this at runtime to avoid forcing it to be defined at that size for
> ! non-master tasks
> ! We also allocate the global 2d array at this point, for the same reason
> !-----------------------------------------------------------------------------
> IF ( is_master_task() ) THEN
>   IF ( SIZE(field_global_land) /= global_land_pts )                            &
>     CALL log_fatal("gather_land_field",                                        &
>                    "Output field should be on global land points")
> 
>   ALLOCATE(field_global_2d(model_grid%nx,model_grid%ny))
> ELSE
>   ALLOCATE(field_global_2d(1,1))
> END IF
> 
> !-----------------------------------------------------------------------------
> ! Convert the local land point array into a 2d array on the model grid for
> ! the task
> !-----------------------------------------------------------------------------
> field_local_2d(:,:) = rmdi
> DO l = 1,land_pts
>   j = (ainfo%land_index(l) - 1) / t_i_length + 1
>   i = ainfo%land_index(l) - (j-1) * t_i_length
> 
>   field_local_2d(i,j) = field_local_land(l)
> END DO
> 
> !-----------------------------------------------------------------------------
> ! Gather the values from each task into the global field in the main task
> ! using the block datatype and calculated counts and offsets
> !-----------------------------------------------------------------------------
> CALL mpi_gatherv(field_local_2d,  t_i_length,      mpi_type_local_col,         &
>                  field_global_2d, counts, offsets, mpi_type_global_col,        &
>                  master_task_id, mpi_local_comm, ERROR)
> 
> !-----------------------------------------------------------------------------
> ! In the master task, convert the 2d array on the full model grid into
> ! an array on the global land points
> !-----------------------------------------------------------------------------
> IF ( is_master_task() )                                                        &
>   field_global_land(:) = PACK(field_global_2d, global_land_mask)
> 
> !-----------------------------------------------------------------------------
> ! Deallocate the global field at the end
> !-----------------------------------------------------------------------------
> IF ( ALLOCATED(field_global_2d) ) DEALLOCATE(field_global_2d)
> 
> RETURN
60,63c568
< #include "is_master_task.inc"
< #include "decompose_domain.inc"
< #include "scatter_land_field.inc"
< #include "gather_land_field.inc"
---
> END SUBROUTINE gather_land_field
Only in vn7.0copy1_c4/src/./control/standalone/parallel: scatter_land_field.inc
Only in vn7.0copy1_c4/src/./control/standalone/spinup: spinup_check.inc
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/standalone/spinup: spinup_check_mod.F90
Only in vn7.0copy1_c4/src/./control/standalone/spinup: spinup_init.inc
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/standalone/spinup: spinup_init_mod.F90
diff -r vn7.0copy1_c4/src/./control/standalone/spinup/spinup_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/standalone/spinup/spinup_mod.F90
13,14d12
< USE logging_mod, ONLY: log_info, log_fatal
< 
45,63d42
< 
< 
< !-----------------------------------------------------------------------------
< ! Visibility declarations
< !-----------------------------------------------------------------------------
< PRIVATE
< PUBLIC max_spinup_vars, nvars, spinup_vars,                                    &
<        spinup_init, spinup_check
< 
< 
< CONTAINS
< 
< 
< ! Fortran INCLUDE statements would be preferred, but (at least) the pgf90
< ! compiler objects to their use when the included file contains pre-processor
< ! directives. At present, such directives are used to exclude files from
< ! the UM build, so are required. This may change in the future.
< #include "spinup_init.inc"
< #include "spinup_check.inc"
diff -r vn7.0copy1_c4/src/./control/standalone/update/update_derived_variables_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/standalone/update/update_derived_variables_mod.F90
39c39
< USE ancil_info,           ONLY: land_pts, nsurft, surft_pts, nsoilt, soil_pts
---
> USE ancil_info,           ONLY: land_pts, nsurft, nsoilt, soil_pts
149c149
<        imgn_drive%q1p5m_ij_drive(i,j,current_time%month,current_time%day,insd)
---
>        imgn_drive%ql1_ij_drive(i,j,current_time%month,current_time%day,insd)
151c151
<        imgn_drive%t1p5m_ij_drive(i,j,current_time%month,current_time%day,insd)
---
>        imgn_drive%tl1_ij_drive(i,j,current_time%month,current_time%day,insd)
221c221
<   CALL sparm(land_pts, nsurft, surft_pts,                                      &
---
>   CALL sparm(land_pts, nsurft, ainfo%surft_pts,                                &
diff -r vn7.0copy1_c4/src/./control/standalone/var/model_grid_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/standalone/var/model_grid_mod.F90
14a15,21
> LOGICAL :: l_coord_latlon = .FALSE.
>   ! Switch indicating the coordinate system for the full grid.
>   ! TRUE: Coordinates are latitude and longitude
>   ! FALSE: Other projection coordinates (not lat-lon).
>   !   A rotated grid (which uses latitude and longitude relative to a rotated
>   !   pole) should be indicated with l_coord_latlon=F.
> 
40a48,57
> REAL, ALLOCATABLE :: projection_x_coord(:,:)
>                                     ! Projection coordinate in the x
>                                     ! direction for each model point.
> REAL, ALLOCATABLE :: projection_y_coord(:,:)
>                                     ! Projection coordinate in the y
>                                     ! direction for each model point.
> REAL, ALLOCATABLE :: projection_x_coord_land(:)
>   ! Projection x coordindates values of land points for the current task.
> REAL, ALLOCATABLE :: projection_y_coord_land(:)
>   ! Projection y coordindates values of land points for the current task.
42,45c59,63
< REAL, ALLOCATABLE :: latitude_of_land_pts(:)
<   ! The latitude of model land points for the current task
< REAL, ALLOCATABLE :: longitude_of_land_pts(:)
<   ! The longitude of model land points for the current task
---
>   ! Note: If the model grid is defined in terms of geographic coordinates
>   !   (latitude and longitude; as indicated by l_coord_latlon=TRUE), the
>   !   so-called projection coordinate variables above will in fact hold copies
>   !   of the geographic coordinates. The distinction only becomes important in
>   !   the case of l_coord_latlon=FALSE.
diff -r vn7.0copy1_c4/src/./control/standalone/var/model_time_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/standalone/var/model_time_mod.F90
30c30
< INTEGER :: timestep            ! The current timestep number.
---
> INTEGER :: timestep_number     ! The current timestep number.
32a33,37
> INTEGER :: oasis_time          ! Time controlling oasis coupling:
>                                !  the current timestep in seconds
>                                ! This time is not applicable to JULES or
>                                ! Rivers-only when not coupled to OASIS and
>                                ! should therefore not be used elsewhere.
diff -r vn7.0copy1_c4/src/./control/standalone/zenith_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/standalone/zenith_mod.F90
84a85
> USE datetime_mod,  ONLY: l_local_solar_time
128,129c129,134
<     hh = pi * ((2.0 * (REAL(TIME) / rsec_per_day))                             &
<          + (longitude(i,j) / 180.0) - 1.0)
---
>     IF (l_local_solar_time) THEN
>       hh = pi * ((2.0 * (REAL(TIME) / rsec_per_day)) - 1.0)
>     ELSE
>       hh = pi * ((2.0 * (REAL(TIME) / rsec_per_day))                           &
>            + (longitude(i,j) / 180.0) - 1.0)
>     END IF
diff -r vn7.0copy1_c4/src/./control/um/check_unavailable_options_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/um/check_unavailable_options_mod.F90
20,23c20,22
< USE jules_vegetation_mod, ONLY: photo_acclim_model, photo_collatz,             &
<     photo_farquhar, photo_model, stomata_jacobs, stomata_model,                &
<     l_gleaf_fix, l_o3_damage, l_use_pft_psi, fsmc_shape, l_prescsow,           &
<     l_croprotate, l_trif_biocrop, l_ag_expand
---
> USE jules_vegetation_mod, ONLY: l_gleaf_fix, l_o3_damage, l_use_pft_psi,       &
>     fsmc_shape, l_prescsow, l_croprotate, l_trif_biocrop, l_ag_expand,         &
>     l_sugar, stomata_model
26,27c25,26
< USE jules_rivers_mod, ONLY: i_river_vn, rivers_trip
< USE jules_soil_biogeochem_mod, ONLY: l_ch4_microbe, l_layeredc
---
> USE jules_rivers_mod, ONLY: l_riv_overbank, i_river_vn, rivers_trip
> USE jules_soil_biogeochem_mod, ONLY: l_ch4_microbe, l_label_frac_cs
30d28
< USE overbank_inundation_mod, ONLY: l_riv_overbank
31a30
> USE jules_deposition_mod, ONLY: l_deposition_from_ukca, l_deposition_gc_corr
79c78
< IF ( l_layeredc ) THEN
---
> IF ( l_label_frac_cs ) THEN
82,83c81,82
<      ": layered soil carbon is only available to standalone JULES. " //        &
<      "l_layeredc = ", l_layeredc
---
>      ": tracing of soil carbon is only available to standalone JULES. " //     &
>      "l_label_frac_cs = ", l_label_frac_cs
122,144c121,122
< ! photo_farquhar is not allowed yet, but if it is allowed further work will
< ! still be required to allow photo_acclim_model /= 0.
< !*******************************************************************************
< ! Clarification: IF photo_model == photo_collatz
< ! * photo_acclim_model does nothing regardless of value of photo_acclim_model.
< ! * photo_acclim_model == imdi when photo_model == photo_collatz, therefore the
< !   photo_model == photo_farquhar condition is required here. It appears
< !   inconsistent with the metadata, however it is not.
< IF ( photo_model == photo_farquhar .AND. photo_acclim_model /= 0 ) THEN
<   error_sum = error_sum + 1
<   WRITE(jules_message,'(I0,A)') error_sum,                                     &
<      ": photo_acclim_model must be set to zero (no acclimation)."
<   CALL jules_print(RoutineName, jules_message, level = PrNorm)
< END IF
< 
< IF ( photo_model /= photo_collatz ) THEN
<   error_sum = error_sum + 1
<   WRITE(jules_message,'(I0,A)') error_sum,                                     &
<      ": photo_model must be set to use the Collatz model."
<   CALL jules_print(RoutineName, jules_message, level = PrNorm)
< END IF
< 
< IF ( stomata_model /= stomata_jacobs ) THEN
---
> ! jules_vegetation
> IF ( l_sugar ) THEN
146,147c124,126
<   WRITE(jules_message,'(I0,A)') error_sum,                                     &
<      ": stomata_model must be set to use the original (Jacobs) model."
---
>   WRITE(jules_message,'(I0,A,I0)') error_sum,                                  &
>      ": Sugar only available standalone " //                                   &
>      "l_sugar= ", l_sugar
207a187,194
> IF ( stomata_model == 3 ) THEN
>   error_sum = error_sum + 1
>   WRITE(jules_message,'(I0,A,I0)') error_sum,                                  &
>      ": SOX stomata model is not currently available in the um " //            &
>      "stomata_model= ", stomata_model
>   CALL jules_print(RoutineName, jules_message, level = PrNorm)
> END IF
> 
230a218,234
>   CALL jules_print(RoutineName, jules_message, level = PrNorm)
> END IF
> 
> ! Deposition switch settings not available for use in UM-coupled JULES
> IF ( .NOT. l_deposition_from_ukca ) THEN
>   error_sum = error_sum + 1
>   WRITE(jules_message,'(I0,A,L1)') error_sum,                                  &
>      ": JULES-based deposition routines can only be called from the UKCA. " // &
>      "l_deposition_from_ukca must be true but = ", l_deposition_from_ukca
>   CALL jules_print(RoutineName, jules_message, level = PrNorm)
> END IF
> 
> IF ( l_deposition_gc_corr ) THEN
>   error_sum = error_sum + 1
>   WRITE(jules_message,'(I0,A,L1)') error_sum,                                  &
>      ": Stomatal conductance corrected for bare soil evaporation is not " //   &
>      "available in the UKCA. l_deposition_gc_corr = ", l_deposition_gc_corr
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/um: diagnostics_dep.F90
diff -r vn7.0copy1_c4/src/./control/um/diagnostics_veg.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/um/diagnostics_veg.F90
29c29
<               land_pts,                                                        &
---
>               land_pts, sm_levels,                                             &
47c47
<     num_stash_pseudo, si_last
---
>     num_stash_pseudo, stash_levels, num_stash_levels, si_last
57a58
> USE copydiag_3d_mod, ONLY: copydiag_3d
77a79,80
> , sm_levels                                                                    &
>            ! No of soil carbon levels if l_layeredc=TRUE in UM
146c149
< INTEGER :: i,j,l
---
> INTEGER :: i,j,k,l
157c160,161
<   interp_data(row_length,rows)
---
>   interp_data(row_length,rows),                                                &
>   interp_data_3d(row_length,rows,sm_levels)
1636c1640
<     interp_data(i,j) = trif_vars%n_gas_gb(l,1)
---
>     interp_data(i,j) = SUM( trif_vars%n_gas_gb(l,:) )
1674c1678
<     interp_data(i,j) = trif_vars%n_loss_gb(l) + trif_vars%n_gas_gb(l,1)
---
>     interp_data(i,j) = trif_vars%n_loss_gb(l) + SUM(trif_vars%n_gas_gb(l,:))
1693c1697
<     interp_data(i,j) = trif_vars%n_loss_gb(l) + trif_vars%n_gas_gb(l,1) +      &
---
>     interp_data(i,j) = trif_vars%n_loss_gb(l) + SUM(trif_vars%n_gas_gb(l,:)) + &
2169c2173
<     interp_data(i,j) = progs%ns_pool_gb(l,1,1)
---
>     interp_data(i,j) = SUM(progs%ns_pool_gb(l,:,1))
2188c2192
<     interp_data(i,j) = progs%ns_pool_gb(l,1,2)
---
>     interp_data(i,j) = SUM(progs%ns_pool_gb(l,:,2))
2207c2211
<     interp_data(i,j) = progs%ns_pool_gb(l,1,3)
---
>     interp_data(i,j) = SUM(progs%ns_pool_gb(l,:,3))
2226c2230
<     interp_data(i,j) = progs%ns_pool_gb(l,1,4)
---
>     interp_data(i,j) = SUM(progs%ns_pool_gb(l,:,4))
2245c2249
<     interp_data(i,j) = SUM(progs%ns_pool_gb(l,1,:))
---
>     interp_data(i,j) = SUM(progs%ns_pool_gb(l,:,:))
2284c2288
<          SUM(progs%ns_pool_gb(l,1,:)) + progs%n_inorg_gb(l) +                  &
---
>          SUM(progs%ns_pool_gb(l,:,:)) + progs%n_inorg_gb(l) +                  &
2547a2552,2553
> ! If l_layeredc=FALSE, get bulk soil value
> ! If l_layeredc=TRUE, get top layer soil value
2559a2566
>     ! either top soil layer (l_layeredc=true) or bulk soil (l_layeredc=false)
2578c2585
<     interp_data(i,j) = trif_vars%immob_n_pot_gb(l,1,1)
---
>     interp_data(i,j) = SUM(trif_vars%immob_n_pot_gb(l,:,1))
2597c2604
<     interp_data(i,j) = trif_vars%immob_n_pot_gb(l,1,2)
---
>     interp_data(i,j) = SUM(trif_vars%immob_n_pot_gb(l,:,2))
2616c2623
<     interp_data(i,j) = trif_vars%immob_n_pot_gb(l,1,3)
---
>     interp_data(i,j) = SUM(trif_vars%immob_n_pot_gb(l,:,3))
2635c2642
<     interp_data(i,j) = trif_vars%immob_n_pot_gb(l,1,4)
---
>     interp_data(i,j) = SUM(trif_vars%immob_n_pot_gb(l,:,4))
2654c2661
<     interp_data(i,j) = trif_vars%immob_n_pot_gb(l,1,5)
---
>     interp_data(i,j) = SUM(trif_vars%immob_n_pot_gb(l,:,5))
2673c2680
<     interp_data(i,j) = trif_vars%immob_n_gb(l,1,1)
---
>     interp_data(i,j) = SUM(trif_vars%immob_n_gb(l,:,1))
2692c2699
<     interp_data(i,j) = trif_vars%immob_n_gb(l,1,2)
---
>     interp_data(i,j) = SUM(trif_vars%immob_n_gb(l,:,2))
2711c2718
<     interp_data(i,j) = trif_vars%immob_n_gb(l,1,3)
---
>     interp_data(i,j) = SUM(trif_vars%immob_n_gb(l,:,3))
2730c2737
<     interp_data(i,j) = trif_vars%immob_n_gb(l,1,4)
---
>     interp_data(i,j) = SUM(trif_vars%immob_n_gb(l,:,4))
2749c2756
<     interp_data(i,j) = trif_vars%immob_n_gb(l,1,5)
---
>     interp_data(i,j) = SUM(trif_vars%immob_n_gb(l,:,5))
2768c2775
<     interp_data(i,j) = trif_vars%minl_n_pot_gb(l,1,1)
---
>     interp_data(i,j) = SUM(trif_vars%minl_n_pot_gb(l,:,1))
2787c2794
<     interp_data(i,j) = trif_vars%minl_n_pot_gb(l,1,2)
---
>     interp_data(i,j) = SUM(trif_vars%minl_n_pot_gb(l,:,2))
2806c2813
<     interp_data(i,j) = trif_vars%minl_n_pot_gb(l,1,3)
---
>     interp_data(i,j) = SUM(trif_vars%minl_n_pot_gb(l,:,3))
2825c2832
<     interp_data(i,j) = trif_vars%minl_n_pot_gb(l,1,4)
---
>     interp_data(i,j) = SUM(trif_vars%minl_n_pot_gb(l,:,4))
2844c2851
<     interp_data(i,j) = trif_vars%minl_n_pot_gb(l,1,5)
---
>     interp_data(i,j) = SUM(trif_vars%minl_n_pot_gb(l,:,5))
2863c2870
<     interp_data(i,j) = trif_vars%minl_n_gb(l,1,1)
---
>     interp_data(i,j) = SUM(trif_vars%minl_n_gb(l,:,1))
2882c2889
<     interp_data(i,j) = trif_vars%minl_n_gb(l,1,2)
---
>     interp_data(i,j) = SUM(trif_vars%minl_n_gb(l,:,2))
2901c2908
<     interp_data(i,j) = trif_vars%minl_n_gb(l,1,3)
---
>     interp_data(i,j) = SUM(trif_vars%minl_n_gb(l,:,3))
2920c2927
<     interp_data(i,j) = trif_vars%minl_n_gb(l,1,4)
---
>     interp_data(i,j) = SUM(trif_vars%minl_n_gb(l,:,4))
2939c2946
<     interp_data(i,j) = trif_vars%minl_n_gb(l,1,5)
---
>     interp_data(i,j) = SUM(trif_vars%minl_n_gb(l,:,5))
3145a3153,3637
> 
> ! Stashcode (19,190)
> ! Carbon loss from vegetation due to fire on PFTs (KGC/M2/YR)
> ! Loss of Carbon from vegetation due to fire on PFTs. Assumed to be lost as CO2,
> ! and is passed to the atmosphere when in CO2-emissions-driven mode (UKESM)
> 
> IF (sf(190,19)) THEN
>   CALL set_pseudo_list(npft,len_stlist,                                        &
>                        stlist(1,stindex(1,190,19,im_index)),                   &
>                        pllpft,stash_pseudo_levels,num_stash_pseudo)
>   pslevel_out = 0
> 
>   DO pslevel = 1,npft
>     IF (pllpft(pslevel)) THEN
>       pslevel_out = pslevel_out + 1
>       DO j = 1,rows
>         DO i = 1,row_length
>           interp_data(i,j) = rmdi
>         END DO
>       END DO
> 
>       DO l = 1,land_pts
>         j = (land_index(l) - 1) / row_length + 1
>         i = land_index(l) - (j-1) * row_length
>         interp_data(i,j) = trif_vars%veg_c_fire_emission_pft(l,pslevel_out)
>       END DO
> 
>       si_start = si(190,19,im_index) + (pslevel_out-1) * npoints_ij
>       si_stop  = si_start + npoints_ij - 1
>       CALL copydiag(STASHwork(si_start:si_stop),interp_data,row_length,rows)
>     END IF
>   END DO
> 
> END IF     !   sf(190,19)
> 
> ! Stashcode (19,191)
> ! Gridbox mean Carbon loss from vegetation due to fire (KGC/M2/YR)
> ! Loss of C from vegetation due to fire (gridbox mean). Assumed to be lost as
> ! CO2, and is passed to the atmosphere when in CO2-emissions-driven mode (UKESM)
> 
> IF (sf(191,19)) THEN
>   DO j = 1,rows
>     DO i = 1,row_length
>       interp_data(i,j) = rmdi
>     END DO
>   END DO
> 
>   DO l = 1,land_pts
>     j = (land_index(l) - 1) / row_length + 1
>     i = land_index(l) - (j-1) * row_length
>     interp_data(i,j) = trif_vars%veg_c_fire_emission_gb(l)
>   END DO
> 
>   CALL copydiag (STASHwork(si(191,19,im_index):si_last(191,19,im_index))       &
>        ,interp_data,row_length,rows)
> END IF     !   sf(191,19)
> 
> ! Stashcode (19,192): Carbon loss from DPM soil carbon pool due to fire
> !                    (KGC/M2/YR)
> 
> IF (sf(192,19)) THEN
>   DO j = 1,rows
>     DO i = 1,row_length
>       interp_data(i,j) = rmdi
>     END DO
>   END DO
> 
>   DO l = 1,land_pts
>     j = (land_index(l) - 1) / row_length + 1
>     i = land_index(l) - (j-1) * row_length
>     interp_data(i,j) = trif_vars%burnt_carbon_dpm(l)
>   END DO
> 
>   CALL copydiag (STASHwork(si(192,19,im_index):si_last(192,19,im_index))       &
>        ,interp_data,row_length,rows)
> END IF     !   sf(192,19)
> 
> 
> ! Stashcode (19,193): Carbon loss from RPM soil carbon pool due to fire
> !                     (KGC/M2/YR)
> 
> IF (sf(193,19)) THEN
>   DO j = 1,rows
>     DO i = 1,row_length
>       interp_data(i,j) = rmdi
>     END DO
>   END DO
> 
>   DO l = 1,land_pts
>     j = (land_index(l) - 1) / row_length + 1
>     i = land_index(l) - (j-1) * row_length
>     interp_data(i,j) = trif_vars%burnt_carbon_rpm(l)
>   END DO
> 
>   CALL copydiag (STASHwork(si(193,19,im_index):si_last(193,19,im_index))       &
>        ,interp_data,row_length,rows)
> END IF     !   sf(193,19)
> 
> 
> ! Stashcode (19,194): Carbon loss from soil (DPM+RPM) due to fire (KGC/M2/YR)
> ! Assumed to be lost as CO2, and is passed to the atmosphere when in
> ! CO2-emissions-driven mode (UKESM)
> 
> IF (sf(194,19)) THEN
>   DO j = 1,rows
>     DO i = 1,row_length
>       interp_data(i,j) = rmdi
>     END DO
>   END DO
> 
>   DO l = 1,land_pts
>     j = (land_index(l) - 1) / row_length + 1
>     i = land_index(l) - (j-1) * row_length
>     interp_data(i,j) = trif_vars%burnt_carbon_dpm(l) +                         &
>                        trif_vars%burnt_carbon_rpm(l)
>   END DO
> 
>   CALL copydiag (STASHwork(si(194,19,im_index):si_last(194,19,im_index))       &
>        ,interp_data,row_length,rows)
> END IF     !   sf(194,19)
> 
> ! Stashcode (19,195): Total carbon loss from land (soil+vegetation) due
> ! to fire (KGC/M2/YR). Assumed to be lost as CO2, and is passed to the
> ! atmosphere when in CO2-emissions-driven mode (UKESM).
> 
> IF (sf(195,19)) THEN
>   DO j = 1,rows
>     DO i = 1,row_length
>       interp_data(i,j) = rmdi
>     END DO
>   END DO
> 
>   DO l = 1,land_pts
>     j = (land_index(l) - 1) / row_length + 1
>     i = land_index(l) - (j-1) * row_length
>     interp_data(i,j) = trif_vars%veg_c_fire_emission_gb(l)   +                 &
>                        trif_vars%burnt_carbon_dpm(l)         +                 &
>                        trif_vars%burnt_carbon_rpm(l)
>   END DO
> 
>   CALL copydiag (STASHwork(si(195,19,im_index):si_last(195,19,im_index))       &
>        ,interp_data,row_length,rows)
> END IF     !   sf(195,19)
> 
> ! Stashcode (19,196): Net Biosphere Productivity (NBP) KGC/M2/YR
> 
> ! This is the net land carbon uptake, i.e. net primary productivity minus the
> ! sum of all fluxes out of the land, and is comprised of the following
> ! stashcodes / variables. Any additional loss terms developed in future should
> ! be included to maintain the accuracy of this diagnostic as the net flux of
> ! carbon into land.
> 
> ! 19102: NPP after N limitation (GBM) KGC/M2/YR
> ! 19053: Soil to atmosphere respiration flux (KG/M2/YR)
> ! 19039: FAST WP POOL DECOMP C FLUX kgC/m2/YR
> ! 19040: MED WP POOL DECOMP C FLUX kgC/m2/YR
> ! 19041: SLOW WP POOL DECOMP C FLUX kgC/m2/YR
> ! 19044: Harvest carbon flux (GBM) kgC/m2/yr
> ! 19191: Gridbox mean C loss from vegetation due to fire (KGC/M2/YR)
> ! 19192: Carbon loss from DPM soil pool due to fire (KGC/M2/YR)
> ! 19193: Carbon loss from RPM soil carbon pool due to fire (KGC/M2/YR)
> 
> IF (sf(196,19)) THEN
>   DO j = 1,rows
>     DO i = 1,row_length
>       interp_data(i,j) = rmdi
>     END DO
>   END DO
> 
>   DO l = 1,land_pts
>     j = (land_index(l) - 1) / row_length + 1
>     i = land_index(l) - (j-1) * row_length
>     interp_data(i,j) =  trif_vars%npp_n_gb(l)                    -             &
>                         SUM( trif_vars%resp_s_to_atmos_gb(l,:) ) -             &
>                         trif_vars%wp_fast_out_gb(l)              -             &
>                         trif_vars%wp_med_out_gb(l)               -             &
>                         trif_vars%wp_slow_out_gb(l)              -             &
>                         trif_vars%harvest_gb(l)                  -             &
>                         trif_vars%veg_c_fire_emission_gb(l)      -             &
>                         trif_vars%burnt_carbon_dpm(l)            -             &
>                         trif_vars%burnt_carbon_rpm(l)
>   END DO
> 
>   CALL copydiag (STASHwork(si(196,19,im_index):si_last(196,19,im_index))       &
>        ,interp_data,row_length,rows)
> END IF     !
> 
> ! Layered soil carbon and nitrogen diagnostics
> ! Item 19 201-204: LAYERED SOIL CARBON CONTENT AFTER TRIFFID, INDIVID. POOLS kgC/m2
> ! 19 201: LAYERED SOIL CARBON DPM kgC/m2
> IF (sf(201,19)) THEN
> 
> !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i,j,k,l)                                  &
> !$OMP SHARED(rows,row_length,interp_data_3d,land_pts,land_index,progs,sm_levels)
>   DO k = 1, sm_levels
> !$OMP DO SCHEDULE(STATIC)
>     DO j= 1, rows
>       DO i = 1, row_length
>         interp_data_3d(i,j,k) = rmdi
>       END DO
>     END DO
> !$OMP END DO
> 
> !$OMP DO SCHEDULE(STATIC)
>     DO l = 1, land_pts
>       j=(land_index(l) - 1) / row_length + 1
>       i = land_index(l) - (j-1) * row_length
>       interp_data_3d(i,j,k) = progs%cs_pool_soilt(l,1,k,1)
>     END DO
> !$OMP END DO
> 
>   END DO
> !$OMP END PARALLEL
> 
>   CALL copydiag_3d(stashwork(si(201,19,im_index):si_last(201,19,im_index)),    &
>        interp_data_3d,                                                         &
>        row_length,rows,sm_levels,                                              &
>        stlist(:,stindex(1,201,19,im_index)),len_stlist,                        &
>        stash_levels,num_stash_levels+1)
> END IF
> 
> 
> ! 19 202: LAYERED SOIL CARBON RPM kgC/m2
> IF (sf(202,19)) THEN
> 
> !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i,j,k,l)                                  &
> !$OMP SHARED(rows,row_length,interp_data_3d,land_pts,land_index,progs,sm_levels)
>   DO k = 1, sm_levels
> !$OMP DO SCHEDULE(STATIC)
>     DO j= 1, rows
>       DO i = 1, row_length
>         interp_data_3d(i,j,k) = rmdi
>       END DO
>     END DO
> !$OMP END DO
> 
> !$OMP DO SCHEDULE(STATIC)
>     DO l = 1, land_pts
>       j=(land_index(l) - 1) / row_length + 1
>       i = land_index(l) - (j-1) * row_length
>       interp_data_3d(i,j,k) = progs%cs_pool_soilt(l,1,k,2)
>     END DO
> !$OMP END DO
> 
>   END DO
> !$OMP END PARALLEL
> 
>   CALL copydiag_3d(stashwork(si(202,19,im_index):si_last(202,19,im_index)),    &
>        interp_data_3d,                                                         &
>        row_length,rows,sm_levels,                                              &
>        stlist(:,stindex(1,202,19,im_index)),len_stlist,                        &
>        stash_levels,num_stash_levels+1)
> END IF
> 
> 
> ! 19 203: LAYERED SOIL CARBON BIO kgC/m2
> IF (sf(203,19)) THEN
> 
> !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i,j,k,l)                                  &
> !$OMP SHARED(rows,row_length,interp_data_3d,land_pts,land_index,progs,sm_levels)
>   DO k = 1, sm_levels
> !$OMP DO SCHEDULE(STATIC)
>     DO j= 1, rows
>       DO i = 1, row_length
>         interp_data_3d(i,j,k) = rmdi
>       END DO
>     END DO
> !$OMP END DO
> 
> !$OMP DO SCHEDULE(STATIC)
>     DO l = 1, land_pts
>       j=(land_index(l) - 1) / row_length + 1
>       i = land_index(l) - (j-1) * row_length
>       interp_data_3d(i,j,k) = progs%cs_pool_soilt(l,1,k,3)
>     END DO
> !$OMP END DO
> 
>   END DO
> !$OMP END PARALLEL
> 
>   CALL copydiag_3d(stashwork(si(203,19,im_index):si_last(203,19,im_index)),    &
>        interp_data_3d,                                                         &
>        row_length,rows,sm_levels,                                              &
>        stlist(:,stindex(1,203,19,im_index)),len_stlist,                        &
>        stash_levels,num_stash_levels+1)
> END IF
> 
> 
> ! 19 204: LAYERED SOIL CARBON HUM kgC/m2
> IF (sf(204,19)) THEN
> 
> !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i,j,k,l)                                  &
> !$OMP SHARED(rows,row_length,interp_data_3d,land_pts,land_index,progs,sm_levels)
>   DO k = 1, sm_levels
> !$OMP DO SCHEDULE(STATIC)
>     DO j= 1, rows
>       DO i = 1, row_length
>         interp_data_3d(i,j,k) = rmdi
>       END DO
>     END DO
> !$OMP END DO
> 
> !$OMP DO SCHEDULE(STATIC)
>     DO l = 1, land_pts
>       j=(land_index(l) - 1) / row_length + 1
>       i = land_index(l) - (j-1) * row_length
>       interp_data_3d(i,j,k) = progs%cs_pool_soilt(l,1,k,4)
>     END DO
> !$OMP END DO
> 
>   END DO
> !$OMP END PARALLEL
> 
>   CALL copydiag_3d(stashwork(si(204,19,im_index):si_last(204,19,im_index)),    &
>        interp_data_3d,                                                         &
>        row_length,rows,sm_levels,                                              &
>        stlist(:,stindex(1,204,19,im_index)),len_stlist,                        &
>        stash_levels,num_stash_levels+1)
> END IF
> 
> 
> ! Item 19 205-208: LAYERED SOIL NITROGEN CONTENT AFTER TRIFFID, INDIVID. POOLS kgN/m2
> ! 19 205: LAYERED SOIL NITROGEN CONTENT DPM kgN/m2
> IF (sf(205,19)) THEN
> 
> !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i,j,k,l)                                  &
> !$OMP SHARED(rows,row_length,interp_data_3d,land_pts,land_index,progs,sm_levels)
>   DO k = 1, sm_levels
> !$OMP DO SCHEDULE(STATIC)
>     DO j= 1, rows
>       DO i = 1, row_length
>         interp_data_3d(i,j,k) = rmdi
>       END DO
>     END DO
> !$OMP END DO
> 
> !$OMP DO SCHEDULE(STATIC)
>     DO l = 1, land_pts
>       j=(land_index(l) - 1) / row_length + 1
>       i = land_index(l) - (j-1) * row_length
>       interp_data_3d(i,j,k) = progs%ns_pool_gb(l,k,1)
>     END DO
> !$OMP END DO
> 
>   END DO
> !$OMP END PARALLEL
> 
>   CALL copydiag_3d(stashwork(si(205,19,im_index):si_last(205,19,im_index)),    &
>        interp_data_3d,                                                         &
>        row_length,rows,sm_levels,                                              &
>        stlist(:,stindex(1,205,19,im_index)),len_stlist,                        &
>        stash_levels,num_stash_levels+1)
> END IF
> 
> 
> ! 19 206: LAYERED SOIL NITROGEN CONTENT RPM kgN/m2
> IF (sf(206,19)) THEN
> 
> !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i,j,k,l)                                  &
> !$OMP SHARED(rows,row_length,interp_data_3d,land_pts,land_index,progs,sm_levels)
>   DO k = 1, sm_levels
> !$OMP DO SCHEDULE(STATIC)
>     DO j= 1, rows
>       DO i = 1, row_length
>         interp_data_3d(i,j,k) = rmdi
>       END DO
>     END DO
> !$OMP END DO
> 
> !$OMP DO SCHEDULE(STATIC)
>     DO l = 1, land_pts
>       j=(land_index(l) - 1) / row_length + 1
>       i = land_index(l) - (j-1) * row_length
>       interp_data_3d(i,j,k) = progs%ns_pool_gb(l,k,2)
>     END DO
> !$OMP END DO
> 
>   END DO
> !$OMP END PARALLEL
> 
>   CALL copydiag_3d(stashwork(si(206,19,im_index):si_last(206,19,im_index)),    &
>        interp_data_3d,                                                         &
>        row_length,rows,sm_levels,                                              &
>        stlist(:,stindex(1,206,19,im_index)),len_stlist,                        &
>        stash_levels,num_stash_levels+1)
> END IF
> 
> 
> ! 19 207: LAYERED SOIL NITROGEN CONTENT BIO kgN/m2
> IF (sf(207,19)) THEN
> 
> !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i,j,k,l)                                  &
> !$OMP SHARED(rows,row_length,interp_data_3d,land_pts,land_index,progs,sm_levels)
>   DO k = 1, sm_levels
> !$OMP DO SCHEDULE(STATIC)
>     DO j= 1, rows
>       DO i = 1, row_length
>         interp_data_3d(i,j,k) = rmdi
>       END DO
>     END DO
> !$OMP END DO
> 
> !$OMP DO SCHEDULE(STATIC)
>     DO l = 1, land_pts
>       j=(land_index(l) - 1) / row_length + 1
>       i = land_index(l) - (j-1) * row_length
>       interp_data_3d(i,j,k) = progs%ns_pool_gb(l,k,3)
>     END DO
> !$OMP END DO
> 
>   END DO
> !$OMP END PARALLEL
> 
>   CALL copydiag_3d(stashwork(si(207,19,im_index):si_last(207,19,im_index)),    &
>        interp_data_3d,                                                         &
>        row_length,rows,sm_levels,                                              &
>        stlist(:,stindex(1,207,19,im_index)),len_stlist,                        &
>        stash_levels,num_stash_levels+1)
> END IF
> 
> 
> ! 19 208: LAYERED SOIL NITROGEN CONTENT HUM kgN/m2
> IF (sf(208,19)) THEN
> 
> !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i,j,k,l)                                  &
> !$OMP SHARED(rows,row_length,interp_data_3d,land_pts,land_index,progs,sm_levels)
>   DO k = 1, sm_levels
> !$OMP DO SCHEDULE(STATIC)
>     DO j= 1, rows
>       DO i = 1, row_length
>         interp_data_3d(i,j,k) = rmdi
>       END DO
>     END DO
> !$OMP END DO
> 
> !$OMP DO SCHEDULE(STATIC)
>     DO l = 1, land_pts
>       j=(land_index(l) - 1) / row_length + 1
>       i = land_index(l) - (j-1) * row_length
>       interp_data_3d(i,j,k) = progs%ns_pool_gb(l,k,4)
>     END DO
> !$OMP END DO
> 
>   END DO
> !$OMP END PARALLEL
> 
>   CALL copydiag_3d(stashwork(si(208,19,im_index):si_last(208,19,im_index)),    &
>        interp_data_3d,                                                         &
>        row_length,rows,sm_levels,                                              &
>        stlist(:,stindex(1,208,19,im_index)),len_stlist,                        &
>        stash_levels,num_stash_levels+1)
> END IF
> 
> 
> ! 19 209: Layered inorganic nitrogen, kgN/m2
> IF (sf(209,19)) THEN
> 
> !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i,j,k,l)                                  &
> !$OMP SHARED(rows,row_length,interp_data_3d,land_pts,land_index,progs,sm_levels)
>   DO k = 1, sm_levels
> !$OMP DO SCHEDULE(STATIC)
>     DO j= 1, rows
>       DO i = 1, row_length
>         interp_data_3d(i,j,k) = rmdi
>       END DO
>     END DO
> !$OMP END DO
> 
> !$OMP DO SCHEDULE(STATIC)
>     DO l = 1, land_pts
>       j=(land_index(l) - 1) / row_length + 1
>       i = land_index(l) - (j-1) * row_length
>       interp_data_3d(i,j,k) = progs%n_inorg_soilt_lyrs(l,1,k)
>     END DO
> !$OMP END DO
> 
>   END DO
> !$OMP END PARALLEL
> 
>   CALL copydiag_3d(stashwork(si(209,19,im_index):si_last(209,19,im_index)),    &
>        interp_data_3d,                                                         &
>        row_length,rows,sm_levels,                                              &
>        stlist(:,stindex(1,209,19,im_index)),len_stlist,                        &
>        stash_levels,num_stash_levels+1)
> END IF
diff -r vn7.0copy1_c4/src/./control/um/surf_couple_ancil_update_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/um/surf_couple_ancil_update_mod.F90
27c27
< USE nlsizes_namelist_mod, ONLY: sm_levels
---
> USE jules_soil_mod, ONLY: sm_levels
diff -r vn7.0copy1_c4/src/./control/um/update_smc.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/um/update_smc.F90
31a32
> USE jules_soil_mod, ONLY: sm_levels
36c37
< USE nlsizes_namelist_mod, ONLY: land_field,sm_levels
---
> USE nlsizes_namelist_mod, ONLY: land_field
diff -r vn7.0copy1_c4/src/./control/um/update_veg.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./control/um/update_veg.F90
114c114,115
<   CALL tilepts(land_pts,frac_surft,surft_pts,surft_index,ainfo%l_lice_point)
---
>   CALL tilepts(land_pts,frac_surft,surft_pts,surft_index,ainfo%l_lice_point,   &
>                ainfo%l_lice_surft)
Only in vn7.0copy1_c4/src/./initialisation/cable: grid_constants_cbl.F90
diff -r vn7.0copy1_c4/src/./initialisation/cable/init_cable_working_vars.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/cable/init_cable_working_vars.F90
1a2,11
> !******************************COPYRIGHT********************************************
> ! (c) CSIRO 2022.
> ! All rights reserved.
> !
> ! This routine has been licensed to the other JULES partners for use and
> ! distribution under the JULES collaboration agreement, subject to the terms and
> ! conditions set out therein.
> !
> ! [Met Office Ref SC0237]
> !******************************COPYRIGHT********************************************
7d16
< !
9a19,24
> ! This MODULE is USEd in:
> !      init.F90
> !
> ! This MODULE contains 1 public Subroutine:
> !      init_cable_work
> !
24a40,42
> 
> ! Description:
> !   Nothing further to add to the module description.
diff -r vn7.0copy1_c4/src/./initialisation/cable/init_soilin_cbl.inc vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/cable/init_soilin_cbl.inc
9a10,21
> !-----------------------------------------------------------------------------
> ! Description:
> !   Initialises the non-vegetation parameters
> !
> ! Code Owner: Please refer to ModuleLeaders.txt
> ! This file belongs in TECHNICAL
> !
> ! Code Description:
> !   Language: Fortran 90.
> !   This code is written to JULES coding standards v1.
> !-----------------------------------------------------------------------------
> 
24,34d35
< !-----------------------------------------------------------------------------
< ! Description:
< !   Initialises the non-vegetation parameters
< !
< ! Code Owner: Please refer to ModuleLeaders.txt
< ! This file belongs in TECHNICAL
< !
< ! Code Description:
< !   Language: Fortran 90.
< !   This code is written to JULES coding standards v1.
< !-----------------------------------------------------------------------------
diff -r vn7.0copy1_c4/src/./initialisation/cable/init_vegin_cbl.inc vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/cable/init_vegin_cbl.inc
4a5,16
> !-----------------------------------------------------------------------------
> ! Description:
> !  Reads the JULES_PFT_PARAMS_CABLE namelist for standalone runs
> !
> ! Code Owner: Please refer to ModuleLeaders.txt
> ! This file belongs in TECHNICAL
> !
> ! Code Description:
> !   Language: Fortran 90.
> !   This code is written to JULES coding standards v1.
> !-----------------------------------------------------------------------------
> 
24d35
< !TYPE definitions
26c37,39
< USE cable_fields_mod, ONLY: pars_io_data_cbl
---
> USE cable_fields_mod, ONLY: pars_io_data_cbl, pars_io_cbl
> 
> USE params_io_mod_cbl, ONLY: params_io_assoc_cbl
30,38d42
< !-----------------------------------------------------------------------------
< ! Description:
< !  Reads the JULES_PFT_PARAMS_CABLE namelist for standalone runs
< !-----------------------------------------------------------------------------
< !
< ! Code Description:
< !   Language: Fortran 90.
< !   This code is written to JULES coding standards v1.
< !-----------------------------------------------------------------------------
471a476,477
> 
> CALL params_io_assoc_cbl(pars_io_cbl,pars_io_data_cbl)
diff -r vn7.0copy1_c4/src/./initialisation/cable/prognostics/init_cable_progs.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/cable/prognostics/init_cable_progs.F90
1a2,11
> !******************************COPYRIGHT********************************************
> ! (c) CSIRO 2022.
> ! All rights reserved.
> !
> ! This routine has been licensed to the other JULES partners for use and
> ! distribution under the JULES collaboration agreement, subject to the terms and
> ! conditions set out therein.
> !
> ! [Met Office Ref SC0237]
> !******************************COPYRIGHT********************************************
7d16
< !
9a19,24
> ! This MODULE is USEd:
> !      init.F90
> !
> ! This MODULE contains 1 public Subroutine:
> !      init_cable_progs
> !
24a40,42
> 
> ! Description:
> !   Nothing further to add to the module description
diff -r vn7.0copy1_c4/src/./initialisation/cable/prognostics/read_cable_progs.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/cable/prognostics/read_cable_progs.F90
1a2,11
> !******************************COPYRIGHT********************************************
> ! (c) CSIRO 2022.
> ! All rights reserved.
> !
> ! This routine has been licensed to the other JULES partners for use and
> ! distribution under the JULES collaboration agreement, subject to the terms and
> ! conditions set out therein.
> !
> ! [Met Office Ref SC0237]
> !******************************COPYRIGHT********************************************
7d16
< !
10a20,25
> ! This MODULE is USEd in:
> !      init_cable_progs.F90
> !
> ! This MODULE contains 1 public Subroutine:
> !      read_cable_progs
> !
25a41,43
> ! Description:
> !   Nothing further to add to the module description
> 
46,54d63
< !------------------------------------------------------------------------------
< ! Description:
< !
< !   Reads in information about CABLE prognostic variables for their
< !   initialisation
< !
< ! Code Owner: Please refer to ModuleLeaders.txt
< ! This file belongs in CABLE SCIENCE
< !------------------------------------------------------------------------------
diff -r vn7.0copy1_c4/src/./initialisation/rivers-standalone/allocate_river_arrays_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/rivers-standalone/allocate_river_arrays_mod.F90
33c33,34
<                                  rivers_data)
---
>                                  rivers_data,                                  &
>                                  wtrac_jls_data)
36c37
<                                      l_acclim
---
>                                      l_acclim, l_sugar
40a42
> USE jules_water_tracers_mod,   ONLY: l_wtrac_jls
51a54
> USE jules_water_tracers_mod,   ONLY: n_wtrac_jls, n_evap_srce
59a63
> USE jules_wtrac_type_mod,      ONLY: wtrac_jls_alloc
62,67c66,72
< USE p_s_parms,         ONLY: psparms_data_type
< USE ancil_info,        ONLY: ainfo_data_type
< USE prognostics,       ONLY: progs_data_type
< USE coastal,           ONLY: coastal_data_type
< USE fluxes_mod,        ONLY: fluxes_data_type
< USE jules_rivers_mod,  ONLY: rivers_data_type
---
> USE p_s_parms,            ONLY: psparms_data_type
> USE ancil_info,           ONLY: ainfo_data_type
> USE prognostics,          ONLY: progs_data_type
> USE coastal,              ONLY: coastal_data_type
> USE fluxes_mod,           ONLY: fluxes_data_type
> USE jules_rivers_mod,     ONLY: rivers_data_type
> USE jules_wtrac_type_mod, ONLY: jls_wtrac_data_type
77,82c82,88
< TYPE(psparms_data_type), INTENT(IN OUT) :: psparms_data
< TYPE(ainfo_data_type),   INTENT(IN OUT) :: ainfo_data
< TYPE(progs_data_type),   INTENT(IN OUT) :: progs_data
< TYPE(coastal_data_type), INTENT(IN OUT) :: coastal_data
< TYPE(fluxes_data_type),  INTENT(IN OUT) :: fluxes_data
< TYPE(rivers_data_type),  INTENT(IN OUT) :: rivers_data
---
> TYPE(psparms_data_type),   INTENT(IN OUT) :: psparms_data
> TYPE(ainfo_data_type),     INTENT(IN OUT) :: ainfo_data
> TYPE(progs_data_type),     INTENT(IN OUT) :: progs_data
> TYPE(coastal_data_type),   INTENT(IN OUT) :: coastal_data
> TYPE(fluxes_data_type),    INTENT(IN OUT) :: fluxes_data
> TYPE(rivers_data_type),    INTENT(IN OUT) :: rivers_data
> TYPE(jls_wtrac_data_type), INTENT(IN OUT) :: wtrac_jls_data
84a91,98
> INTEGER :: temp_size
> 
> ! Dummy fields for the local river grid size which is used to set water tracer
> ! fields in UM_JULES.  Therefore, a dummy field is needed here to pass into
> ! wtrac_jls_assoc.
> INTEGER, PARAMETER :: river_row_length_dum = 1
> INTEGER, PARAMETER :: river_rows_dum = 1
> 
97a112,126
> ! For now set unset dimensions to 1, which are not on switches and thus
> ! allocated with full size when not required
> nsurft     = 1
> npft       = 1
> sm_levels  = 1
> 
> ! OASIS-Rivers will have zero land points, so allocate nominal space instead.
> IF ( land_pts > 0 ) THEN
>   temp_size  = land_pts
> ELSE
>   temp_size  = 1
>   t_i_length = 1
>   t_j_length = 1
> END IF
> 
102c131
< CALL prognostics_alloc(land_pts, t_i_length, t_j_length,                       &
---
> CALL prognostics_alloc(temp_size, t_i_length, t_j_length,                      &
107c136
<                       nmasst, nnpft, l_acclim, progs_data)
---
>                       nmasst, nnpft, l_acclim, l_sugar, progs_data)
111c140
< CALL fluxes_alloc(land_pts, t_i_length, t_j_length,                            &
---
> CALL fluxes_alloc(temp_size, t_i_length, t_j_length,                           &
118c147
< CALL psparms_alloc(land_pts, t_i_length, t_j_length,                           &
---
> CALL psparms_alloc(temp_size, t_i_length, t_j_length,                          &
123c152
< CALL ancil_info_alloc(land_pts, t_i_length, t_j_length,                        &
---
> CALL ancil_info_alloc(temp_size, t_i_length, t_j_length,                       &
127c156
< CALL jules_rivers_alloc(land_pts, rivers_data)
---
> CALL jules_rivers_alloc(temp_size, rivers_data)
129c158
< CALL coastal_alloc(land_pts, t_i_length, t_j_length,                           &
---
> CALL coastal_alloc(temp_size, t_i_length, t_j_length,                          &
132a162,168
> 
> ! Allocate water tracer arrays.  As water tracers cannot currently be used
> ! in standalone rivers, these arrays will be set to dimension=1.
> CALL wtrac_jls_alloc(land_pts, t_i_length, t_j_length, nsurft, nsoilt,         &
>                      sm_levels, nsmax, nice_use, n_wtrac_jls,                  &
>                      n_evap_srce, river_row_length_dum, river_rows_dum,        &
>                      l_wtrac_jls, wtrac_jls_data)
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/rivers-standalone: check_compatible_options_mod.F90
diff -r vn7.0copy1_c4/src/./initialisation/rivers-standalone/grid/init_grid_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/rivers-standalone/grid/init_grid_mod.F90
16c16,17
<                      rivers_data)
---
>                      rivers_data,                                              &
>                      wtrac_jls_data)
33,38c34,40
< USE p_s_parms,         ONLY: psparms_data_type
< USE ancil_info,        ONLY: ainfo_data_type
< USE prognostics,       ONLY: progs_data_type
< USE coastal,           ONLY: coastal_data_type
< USE fluxes_mod,        ONLY: fluxes_data_type
< USE jules_rivers_mod,  ONLY: rivers_data_type
---
> USE p_s_parms,            ONLY: psparms_data_type
> USE ancil_info,           ONLY: ainfo_data_type
> USE prognostics,          ONLY: progs_data_type
> USE coastal,              ONLY: coastal_data_type
> USE fluxes_mod,           ONLY: fluxes_data_type
> USE jules_rivers_mod,     ONLY: rivers_data_type
> USE jules_wtrac_type_mod, ONLY: jls_wtrac_data_type
58,63c60,66
< TYPE(psparms_data_type), INTENT(IN OUT) :: psparms_data
< TYPE(ainfo_data_type),   INTENT(IN OUT) :: ainfo_data
< TYPE(progs_data_type),   INTENT(IN OUT) :: progs_data
< TYPE(coastal_data_type), INTENT(IN OUT) :: coastal_data
< TYPE(fluxes_data_type),  INTENT(IN OUT) :: fluxes_data
< TYPE(rivers_data_type),  INTENT(IN OUT) :: rivers_data
---
> TYPE(psparms_data_type),   INTENT(IN OUT) :: psparms_data
> TYPE(ainfo_data_type),     INTENT(IN OUT) :: ainfo_data
> TYPE(progs_data_type),     INTENT(IN OUT) :: progs_data
> TYPE(coastal_data_type),   INTENT(IN OUT) :: coastal_data
> TYPE(fluxes_data_type),    INTENT(IN OUT) :: fluxes_data
> TYPE(rivers_data_type),    INTENT(IN OUT) :: rivers_data
> TYPE(jls_wtrac_data_type), INTENT(IN OUT) :: wtrac_jls_data
92c95
<                            fluxes_data, rivers_data                            &
---
>                            fluxes_data, rivers_data, wtrac_jls_data            &
diff -r vn7.0copy1_c4/src/./initialisation/rivers-standalone/grid/init_model_grid_arrays_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/rivers-standalone/grid/init_model_grid_arrays_mod.F90
16c16,17
<                                    fluxes_data, rivers_data                    &
---
>                                    fluxes_data, rivers_data,                   &
>                                    wtrac_jls_data                              &
23,29d23
< USE model_grid_mod, ONLY: latitude, longitude,                                 &
<                            latitude_of_land_pts, longitude_of_land_pts
< 
< USE coastal, ONLY: flandg
< 
< USE ancil_info, ONLY: land_pts
< 
31,36c25,31
< USE p_s_parms,         ONLY: psparms_data_type
< USE ancil_info,        ONLY: ainfo_data_type
< USE prognostics,       ONLY: progs_data_type
< USE coastal,           ONLY: coastal_data_type
< USE fluxes_mod,        ONLY: fluxes_data_type
< USE jules_rivers_mod,  ONLY: rivers_data_type
---
> USE p_s_parms,            ONLY: psparms_data_type
> USE ancil_info,           ONLY: ainfo_data_type
> USE prognostics,          ONLY: progs_data_type
> USE coastal,              ONLY: coastal_data_type
> USE fluxes_mod,           ONLY: fluxes_data_type
> USE jules_rivers_mod,     ONLY: rivers_data_type
> USE jules_wtrac_type_mod, ONLY: jls_wtrac_data_type
53,58c48,54
< TYPE(psparms_data_type), INTENT(IN OUT) :: psparms_data
< TYPE(ainfo_data_type),   INTENT(IN OUT) :: ainfo_data
< TYPE(progs_data_type),   INTENT(IN OUT) :: progs_data
< TYPE(coastal_data_type), INTENT(IN OUT) :: coastal_data
< TYPE(fluxes_data_type),  INTENT(IN OUT) :: fluxes_data
< TYPE(rivers_data_type),  INTENT(IN OUT) :: rivers_data
---
> TYPE(psparms_data_type),   INTENT(IN OUT) :: psparms_data
> TYPE(ainfo_data_type),     INTENT(IN OUT) :: ainfo_data
> TYPE(progs_data_type),     INTENT(IN OUT) :: progs_data
> TYPE(coastal_data_type),   INTENT(IN OUT) :: coastal_data
> TYPE(fluxes_data_type),    INTENT(IN OUT) :: fluxes_data
> TYPE(rivers_data_type),    INTENT(IN OUT) :: rivers_data
> TYPE(jls_wtrac_data_type), INTENT(IN OUT) :: wtrac_jls_data
67c63,64
<                            rivers_data)
---
>                            rivers_data,                                        &
>                            wtrac_jls_data)
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/rivers-standalone: init_ic_mod.F90
diff -r vn7.0copy1_c4/src/./initialisation/rivers-standalone/init_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/rivers-standalone/init_mod.F90
1d0
< #if !defined(UM_JULES)
16c15,16
<                 rivers_data, rivers)
---
>                 rivers_data, rivers,                                           &
>                 wtrac_jls_data, wtrac_jls)
20d19
< USE init_drive_mod,                 ONLY: init_drive
21a21
> USE init_ic_mod,                    ONLY: init_ic
29a30,35
> USE init_oasis_rivers_mod,          ONLY: init_oasis_rivers
> USE oasis_rivers_control_mod,       ONLY: oasis_partition, oasis_grid,         &
>                                           oasis_variables
> USE jules_model_environment_mod,    ONLY: l_oasis_rivers
> USE init_drive_mod,                 ONLY: init_drive
> USE check_compatible_options_mod,   ONLY: check_compatible_options
53a60,62
> USE jules_wtrac_type_mod,         ONLY: jls_wtrac_data_type,                   &
>                                         jls_wtrac_type,                        &
>                                         wtrac_jls_assoc
74,79c83,89
< TYPE(psparms_data_type), INTENT(IN OUT) :: psparms_data
< TYPE(ainfo_data_type),   INTENT(IN OUT) :: ainfo_data
< TYPE(progs_data_type),   INTENT(IN OUT) :: progs_data
< TYPE(coastal_data_type), INTENT(IN OUT) :: coastal_data
< TYPE(fluxes_data_type),  INTENT(IN OUT) :: fluxes_data
< TYPE(rivers_data_type),  INTENT(IN OUT) :: rivers_data
---
> TYPE(psparms_data_type),   INTENT(IN OUT) :: psparms_data
> TYPE(ainfo_data_type),     INTENT(IN OUT) :: ainfo_data
> TYPE(progs_data_type),     INTENT(IN OUT) :: progs_data
> TYPE(coastal_data_type),   INTENT(IN OUT) :: coastal_data
> TYPE(fluxes_data_type),    INTENT(IN OUT) :: fluxes_data
> TYPE(rivers_data_type),    INTENT(IN OUT) :: rivers_data
> TYPE(jls_wtrac_data_type), INTENT(IN OUT) :: wtrac_jls_data
82,87c92,98
< TYPE(psparms_type), INTENT(IN OUT) :: psparms
< TYPE(ainfo_type),   INTENT(IN OUT) :: ainfo
< TYPE(progs_type),   INTENT(IN OUT) :: progs
< TYPE(coastal_type), INTENT(IN OUT) :: coast
< TYPE(fluxes_type),  INTENT(IN OUT) :: fluxes
< TYPE(rivers_type),  INTENT(IN OUT) :: rivers
---
> TYPE(psparms_type),   INTENT(IN OUT) :: psparms
> TYPE(ainfo_type),     INTENT(IN OUT) :: ainfo
> TYPE(progs_type),     INTENT(IN OUT) :: progs
> TYPE(coastal_type),   INTENT(IN OUT) :: coast
> TYPE(fluxes_type),    INTENT(IN OUT) :: fluxes
> TYPE(rivers_type),    INTENT(IN OUT) :: rivers
> TYPE(jls_wtrac_type), INTENT(IN OUT) :: wtrac_jls
107a119,123
> IF (l_oasis_rivers) THEN
>   ! Initialize coupling parameters
>   CALL init_oasis_rivers(nml_dir)
> END IF
> 
115c131,132
<                rivers_data)
---
>                rivers_data,                                                    &
>                wtrac_jls_data)
123a141
> CALL wtrac_jls_assoc(wtrac_jls,wtrac_jls_data)
128,129c146,159
< ! Contains allocation of progs_data%seed_rain - hence passing in the data type
< CALL init_drive(nml_dir,ainfo,progs_data)
---
> ! Driving data obtained via coupling or via ancillary files
> IF (l_oasis_rivers) THEN
>   ! Once the river grid is set, define the OASIS partition,  &
>   ! write grid, and declare oasis coupled variables
>   CALL oasis_partition()
>   CALL oasis_grid()
>   CALL oasis_variables()
> ELSE
>   ! Contains allocation of progs_data%seed_rain - hence passing in the data type
>   CALL init_drive(nml_dir,ainfo,progs_data)
> END IF
> 
> ! Initialise the model prognostics
> CALL init_ic(nml_dir, rivers)
139,141c169
< ! Placemarker as a reminder if needed, but requires a suitable standalone
< ! Rivers version.
< ! CALL check_compatible_options()
---
> CALL check_compatible_options()
147,148c175
< ! Standalone Rivers: Ignore dumps for now
< ! CALL write_dump()
---
> CALL write_dump()
156d182
< #endif
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/rivers-standalone: river-coupling
diff -r vn7.0copy1_c4/src/./initialisation/shared/allocate_jules_arrays.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/shared/allocate_jules_arrays.F90
36c36,37
<                                  chemvars_data                                 &
---
>                                  chemvars_data, water_resources_data,          &
>                                  wtrac_jls_data                                &
41c42
<                                     l_acclim
---
>                                     l_acclim, l_sugar
50,51c51,55
< USE jules_deposition_mod,     ONLY: dry_dep_model, l_deposition,               &
<                                     ndry_dep_species
---
> USE jules_water_resources_mod,ONLY: l_water_domestic,                          &
>                                     l_water_industry, l_water_irrigation,      &
>                                     l_water_livestock, l_water_resources,      &
>                                     l_water_transfers, nwater_use
> USE jules_deposition_mod,     ONLY: l_deposition, ndry_dep_species
52a57
> USE jules_water_tracers_mod,  ONLY: l_wtrac_jls
68a74
> USE jules_water_tracers_mod,  ONLY: n_wtrac_jls, n_evap_srce
94a101
> USE jules_wtrac_type_mod,     ONLY: wtrac_jls_alloc
98,100d104
< USE jules_deposition_mod,     ONLY: jules_deposition_alloc
< USE deposition_species_mod,   ONLY: deposition_species_alloc
< USE jules_water_resources_mod, ONLY: water_resources_alloc
105a110,111
> USE deposition_species_mod,   ONLY: deposition_species_alloc
> USE water_resources_vars_mod, ONLY: water_resources_alloc
127a134,143
> USE water_resources_vars_mod, ONLY: water_resources_data_type
> USE jules_wtrac_type_mod,    ONLY: jls_wtrac_data_type
> 
> ! The following are needed to get the local river grid size
> ! (which is needed for water tracers)
> #if defined(UM_JULES)
> USE UM_ParVars,      ONLY: lasize
> USE UM_ParParams,    ONLY: halo_type_no_halo
> USE Field_Types,     ONLY: fld_type_r
> #endif
156a173,176
> TYPE(water_resources_data_type), INTENT(IN OUT) :: water_resources_data
> 
> !Water tracer TYPES containing field data (IN OUT)
> TYPE(jls_wtrac_data_type),  INTENT(IN OUT) :: wtrac_jls_data
158a179,186
> 
> INTEGER :: i_wt
> 
> ! Local river grid size
> ! These are used for water tracers.  They are only set correctly if UM_JULES.
> INTEGER :: river_row_length
> INTEGER :: river_rows
> 
177c205
<                       nmasst, nnpft, l_acclim, progs_data)
---
>                       nmasst, nnpft, l_acclim, l_sugar, progs_data)
184c212,213
< CALL chemvars_alloc(land_pts,npft,chemvars_data)
---
> CALL chemvars_alloc(land_pts, t_i_length, t_j_length, npft, ntype,             &
>                     l_deposition, ndry_dep_species, chemvars_data)
246,252d274
< 
< CALL jules_deposition_alloc(land_pts)
< 
< CALL deposition_species_alloc(ntype,ndry_dep_species,                          &
<                               l_deposition, dry_dep_model)
< 
< CALL water_resources_alloc(land_pts)
267a290,310
> 
> CALL deposition_species_alloc(ntype, ndry_dep_species, l_deposition)
> 
> CALL water_resources_alloc( land_pts, nwater_use, l_water_domestic,            &
>                             l_water_industry, l_water_irrigation,              &
>                             l_water_livestock, l_water_resources,              &
>                             l_water_transfers, water_resources_data )
> 
> ! Set up local river grid sizes  (Note, water tracers only work in UM_JULES)
> #if defined(UM_JULES)
> river_row_length = lasize(1,fld_type_r,halo_type_no_halo)
> river_rows       = lasize(2,fld_type_r,halo_type_no_halo)
> #else
> river_row_length = 1
> river_rows       = 1
> #endif
> 
> CALL wtrac_jls_alloc(land_pts, t_i_length, t_j_length, nsurft, nsoilt,         &
>                        sm_levels, nsmax, nice_use, n_wtrac_jls,                &
>                        n_evap_srce, river_row_length, river_rows,              &
>                        l_wtrac_jls, wtrac_jls_data)
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/shared: calc_urban_aero_fields_mod.F90
diff -r vn7.0copy1_c4/src/./initialisation/shared/check_compatible_options_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/shared/check_compatible_options_mod.F90
25a26
> USE jules_deposition_mod,          ONLY: l_deposition
29a31
> USE jules_soil_biogeochem_mod,     ONLY: l_layeredc, z_burn_max
34c36
< USE jules_vegetation_mod,          ONLY: l_triffid, l_inferno
---
> USE jules_vegetation_mod,          ONLY: l_triffid, l_inferno, l_trif_fire
39c41
< USE missing_data_mod,              ONLY: imdi
---
> USE missing_data_mod,              ONLY: imdi, rmdi
46a49,50
> USE jules_water_tracers_mod,       ONLY: l_wtrac_jls
> USE wtrac_check_options_mod,       ONLY: wtrac_check_options
121c125,128
< ! These checks are not to be carried out when called from UM RECON
---
> IF ( lsm_id == cable ) check_tiles_namelists = .FALSE.
> 
> ! These checks are not to be carried out when called from UM RECON or when the
> ! land surface model is CABLE, which has its own namelists.
147c154
<   ELSE IF ( lsm_id /= cable ) THEN
---
>   ELSE
198a206,226
> END IF
> 
> ! Deposition requires a tiled model.
> IF ( l_aggregate .AND. l_deposition) THEN
>   ERROR = 1
>   WRITE(jules_message,jules_format) 'Deposition cannot use aggregate tiles.'
> END IF
> 
> ! l_layeredc with l_inferno or l_trif_fire require z_burn_max to be set
> IF ( l_layeredc .AND. ( l_trif_fire .OR. l_inferno ) ) THEN
>   IF ( ABS( z_burn_max - rmdi ) < EPSILON(1.0) ) THEN
>     ERROR = 1
>     CALL jules_print(routinename,                                              &
>                    "z_burn_max must be set when using l_layeredc with " //     &
>                    "l_trif_fire / l_inferno")
>   END IF
> END IF
> 
> ! Check water tracer options
> IF (l_wtrac_jls) THEN
>   CALL wtrac_check_options(ERROR)
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/shared: init_layeredcn_mod.F90
diff -r vn7.0copy1_c4/src/./initialisation/shared/urban_empirical_morphology_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/shared/urban_empirical_morphology_mod.F90
10,12c10,12
< !     wrr 	Repeating width ratio (or canyon fraction, W/R)
< !     hwr 	Height-to-width ratio (H/W)
< !     hgt 	Building height (H)
---
> !     wrr   Repeating width ratio (or canyon fraction, W/R)
> !     hwr   Height-to-width ratio (H/W)
> !     hgt   Building height (H)
43c43,44
< SUBROUTINE urban_empirical_morphology(frac_surft, surft_index, urban_param)
---
> SUBROUTINE urban_empirical_morphology(frac_surft, surft_index, surft_pts,      &
>                                       urban_param)
45c46
< USE ancil_info, ONLY: land_pts, surft_pts
---
> USE ancil_info, ONLY: land_pts
61c62
< 
---
> INTEGER, INTENT(IN) :: surft_pts(ntype)
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/shared: wtrac_check_options_mod.F90
diff -r vn7.0copy1_c4/src/./initialisation/standalone/ancillaries/ancil_namelist_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/standalone/ancillaries/ancil_namelist_mod.F90
42c42
<                                      nvars_optional )
---
>                                      nvars_optional, optional_vars )
104a105,108
> CHARACTER(LEN=*), OPTIONAL, INTENT(OUT) ::                                     &
>   optional_vars(:)
>     ! Identifiers for optional variables.
> 
122a127,129
>   IF ( PRESENT( optional_vars ) ) THEN
>     optional_vars(:) = ''  ! Empty identifiers.
>   END IF
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/standalone/ancillaries: init_ancillaries_coupling_mod.F90
diff -r vn7.0copy1_c4/src/./initialisation/standalone/ancillaries/init_ancillaries_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/standalone/ancillaries/init_ancillaries_mod.F90
45,46d44
< USE jules_urban_mod, ONLY: l_moruses
< 
115c113
< IF ( l_urban2t .OR. l_moruses ) CALL init_urban_props(ainfo,urban_param)
---
> IF ( l_urban2t ) CALL init_urban_props(ainfo,urban_param)
diff -r vn7.0copy1_c4/src/./initialisation/standalone/ancillaries/init_co2_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/standalone/ancillaries/init_co2_mod.F90
20,21d19
< USE fill_variables_from_file_mod, ONLY: fill_variables_from_file
< 
diff -r vn7.0copy1_c4/src/./initialisation/standalone/ancillaries/init_irrig_props_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/standalone/ancillaries/init_irrig_props_mod.F90
81a82,83
> CHARACTER(LEN=*), PARAMETER :: RoutineName='INIT_IRRIG_PROPS'
> 
101c103
< CALL log_info("init_irrig_props", "Reading JULES_IRRIG_PROPS namelist...")
---
> CALL log_info(RoutineName, "Reading JULES_IRRIG_PROPS namelist...")
106c108
<   CALL log_fatal("init_irrig_props",                                           &
---
>   CALL log_fatal(RoutineName,                                                  &
111c113
< CALL jules_print('init_irrig_props', 'Contents of namelist init_irrig_props')
---
> CALL jules_print(RoutineName, 'Contents of namelist init_irrig_props')
114c116
< CALL jules_print('init_irrig_props',lineBuffer)
---
> CALL jules_print(RoutineName,lineBuffer)
117c119
< CALL jules_print('init_irrig_props',lineBuffer)
---
> CALL jules_print(RoutineName,lineBuffer)
120c122
< CALL jules_print('init_irrig_props',lineBuffer)
---
> CALL jules_print(RoutineName,lineBuffer)
123c125
< CALL jules_print('init_irrig_props',lineBuffer)
---
> CALL jules_print(RoutineName,lineBuffer)
126c128
< CALL jules_print('init_irrig_props',lineBuffer)
---
> CALL jules_print(RoutineName,lineBuffer)
129c131
< CALL jules_print('init_irrig_props',lineBuffer)
---
> CALL jules_print(RoutineName,lineBuffer)
139c141
<     CALL log_info("init_irrig_props", "'frac_irrig' will be read from file")
---
>     CALL log_info(RoutineName, "'frac_irrig' will be read from file")
143c145
<       CALL log_fatal("init_irrig_props", "No file name provided")
---
>       CALL log_fatal(RoutineName, "No file name provided")
153c155
<         CALL log_fatal("init_irrig_props",                                     &
---
>         CALL log_fatal(RoutineName,                                            &
155c157
<       CALL log_info("init_irrig_props",                                        &
---
>       CALL log_info(RoutineName,                                               &
164c166
<         CALL log_fatal("init_irrig_props",                                     &
---
>         CALL log_fatal(RoutineName,                                            &
167c169
<       CALL log_info("init_irrig_props",                                        &
---
>       CALL log_info(RoutineName,                                               &
180c182
<       CALL log_info("init_irrig_props",                                        &
---
>       CALL log_info(RoutineName,                                               &
187c189
<       CALL log_fatal("init_irrig_props",                                       &
---
>       CALL log_fatal(RoutineName,                                              &
197,198c199,200
<   CALL log_info("init_frac",                                                   &
<                 "frac will be read from the dump file.  " //                   &
---
>   CALL log_info(RoutineName,                                                   &
>                 "Irrigation ancil information will be read from the dump." //  &
200,201c202
< 
< END IF !.NOT. ancil_dump_read%frac
---
> END IF !.NOT. ancil_dump_read%irrig
diff -r vn7.0copy1_c4/src/./initialisation/standalone/ancillaries/init_overbank_props_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/standalone/ancillaries/init_overbank_props_mod.F90
13a14,17
> USE missing_data_mod, ONLY: rmdi
> 
> USE model_interface_mod, ONLY: identifier_len
> 
15a20,37
> !------------------------------------------------------------------------------
> ! Variables
> !------------------------------------------------------------------------------
> INTEGER, PARAMETER :: nvars_max = 2
>                                ! The maximum possible number of inundation
>                                ! variables.
> 
> INTEGER :: nvars_required      ! The number of inundation variables that are
>                                ! required in this configuration
> 
> CHARACTER(LEN=identifier_len) :: required_vars(nvars_max)
>                                ! The variable identifiers of the required
>                                ! variables
> 
> PRIVATE  !  private scope by default
> PUBLIC allocate_overbank_vars_rp, init_overbank_props,                         &
>        nvars_max, nvars_required, required_vars
> 
17a40,41
> !#############################################################################
> 
25,28d48
< USE missing_data_mod, ONLY: rmdi
< 
< USE ancil_info, ONLY: land_pts
< 
33,36d52
< USE model_interface_mod, ONLY: identifier_len
< 
< USE model_grid_mod, ONLY: global_land_pts
< 
38c54
<   np_rivers, nx_rivers, ny_rivers, l_rivers
---
>   np_rivers, nx_rivers, ny_rivers
41,44c57,59
<   l_riv_overbank, l_riv_hypsometry,                                            &
<   logn_mean, logn_stdev, logn_mean_rp, logn_stdev_rp,                          &
<   frac_fplain_lp, frac_fplain_rp,                                              &
<   qbf, dbf, wbf
---
>   overbank_hypsometric, overbank_model
> 
> USE parallel_mod, ONLY: is_master_task
52c67
< !-----------------------------------------------------------------------------
---
> !------------------------------------------------------------------------------
63c78
< !-----------------------------------------------------------------------------
---
> !------------------------------------------------------------------------------
67,90d81
< ! Work variables
< 
< INTEGER ::                                                                     &
<   ERROR        = 0,                                                            &
<                      ! Variable for trapping the error from each
<                      ! individual call to allocate
<   error_sum    = 0
<                      ! Variable to track the sum of all errors
<                      ! resulting from calls to allocate. Hence we
<                      ! know that everything was successful if and
<                      ! only if this is zero at the end
< 
< INTEGER, PARAMETER :: nvars_max = 2 ! The maximum possible number
<                                               ! of inundation variables
< 
< INTEGER :: nvars_required      ! The number of inundation variables that are
<                                ! required in this configuration
< CHARACTER(LEN=identifier_len) :: required_vars(nvars_max)
<                                ! The variable identifiers of the required
<                                ! variables
< CHARACTER(LEN=identifier_len) :: optional_vars(nvars_max)
<                                ! The variable identifiers of any optional
<                                ! variables
< 
136a128,129
> INTEGER :: ERROR  !  Error value.
> 
139a133
> !end of header
142,143c136,141
< ! If rivers or overbank inundation are not on, there is nothing to do
< IF (l_rivers .AND. l_riv_overbank) THEN
---
> !------------------------------------------------------------------------------
> ! All tasks need only be done on the master task, which is where the river
> ! routing code will run.
> !------------------------------------------------------------------------------
> 
> IF ( is_master_task() ) THEN
145c143
<   !---------------------------------------------------------------------------
---
>   !----------------------------------------------------------------------------
147c145
<   !---------------------------------------------------------------------------
---
>   !----------------------------------------------------------------------------
154,271c152,240
<   IF ( global_land_pts <= 1 ) THEN
<     l_rivers = .FALSE.
<     CALL log_warn(RoutineName,                                                 &
<                   "River routing not appropriate for single point runs. " //   &
<                   "Overbank inundation disabled.")
< 
<   ELSE
< 
<     !-------------------------------------------------------------------------
<     ! Read overbank inundation namelist
<     !--------------------------------------------------------------------------
< 
<     CALL log_info(RoutineName,"Reading JULES_OVERBANK_PROPS namelist...")
< 
<     READ(namelist_unit, NML = jules_overbank_props, IOSTAT = ERROR)
<     IF ( ERROR /= 0 ) CALL log_fatal(RoutineName,                              &
<                   "Error reading namelist JULES_OVERBANK_PROPS " //            &
<                   "(IOSTAT=" // TRIM(to_string(ERROR)) // ")")
< 
<     !--------------------------------------------------------------------------
<     ! Set up river overbank inundation properties
<     !--------------------------------------------------------------------------
< 
<     IF ( l_riv_hypsometry ) THEN
<       nvars_required = 2
<       required_vars(1:nvars_required) = [ 'logn_mean ', 'logn_stdev' ]
< 
<       !------------------------------------------------------------------------
<       ! Check that variables in the namelist have been provided and set up
<       ! other variables.
<       !------------------------------------------------------------------------
<       CALL check_namelist_values( nvars, nvars_max, nvars_required,            &
<                                   RoutineName, FILE, const_val,                &
<                                   use_file, required_vars, tpl_name, var,      &
<                                   nvars_const, nvars_file, l_have_template,    &
<                                   use_var, file_name, var_name )
< 
<       !-----------------------------------------------------------------------
<       ! Allocate inundation-specific arrays from ancillary information
<       !-----------------------------------------------------------------------
< 
<       IF ( nx_rivers > 0 .AND. ny_rivers > 0) THEN
< 
<         ALLOCATE( logn_mean(nx_rivers, ny_rivers), STAT = ERROR )
<         error_sum = ERROR
<         ALLOCATE( logn_stdev(nx_rivers, ny_rivers), STAT = ERROR )
<         error_sum = error_sum + ERROR
<         IF ( error_sum == 0 ) THEN
<           ! Initialise to impossible values.
<           logn_mean(:,:)  = rmdi
<           logn_stdev(:,:) = rmdi
<         ELSE
<           CALL log_fatal(RoutineName,                                          &
<                          "Error allocating arrays from ancillaries")
<         END IF
< 
<       ELSE
< 
<         CALL log_fatal(RoutineName,                                            &
<                   "No overbank inundation with invalid routing dimensions" )
<       END IF
<     END IF
< 
<     !--------------------------------------------------------------------------
<     ! Set variables that are using a constant value.
<     !--------------------------------------------------------------------------
<     CALL set_constant_vars( nvars, nvars_const, nvars_max, const_val,          &
<                             use_file, use_var, var )
< 
<     !--------------------------------------------------------------------------
<     ! Set variables that are to be read from a file.
<     !--------------------------------------------------------------------------
<     CALL set_file_vars( nvars, nvars_file, nvars_max, l_have_template,         &
<                         RoutineName, use_file, use_var, file_name, var,        &
<                         var_name)
< 
<     !-------------------------------------------------------------------------
<     ! Allocate inundation variables defined on river routing points
<     !-------------------------------------------------------------------------
< 
<     ALLOCATE(logn_mean_rp(np_rivers),       STAT = ERROR)
<     error_sum = ERROR
<     ALLOCATE(logn_stdev_rp(np_rivers),      STAT = ERROR)
<     error_sum = error_sum + ERROR
<     ALLOCATE(qbf(np_rivers),                STAT = ERROR)
<     error_sum = error_sum + ERROR
<     ALLOCATE(dbf(np_rivers),                STAT = ERROR)
<     error_sum = error_sum + ERROR
<     ALLOCATE(wbf(np_rivers),                STAT = ERROR)
<     error_sum = error_sum + ERROR
<     ALLOCATE(frac_fplain_rp(np_rivers), STAT = ERROR)
<     error_sum = error_sum + ERROR
<     IF ( error_sum == 0 ) THEN
<       ! Initialise array values
<       logn_mean_rp(:)       = rmdi
<       logn_stdev_rp(:)      = rmdi
<       qbf(:)                = rmdi
<       dbf(:)                = rmdi
<       wbf(:)                = rmdi
<       frac_fplain_rp(:)     = rmdi
<     ELSE
<       CALL log_fatal(RoutineName,                                              &
<                      "Error allocating river grid arrays")
<     END IF
< 
<     !-------------------------------------------------------------------------
<     ! Allocate inundation variables defined on land points
<     !-------------------------------------------------------------------------
< 
<     ALLOCATE(frac_fplain_lp(land_pts), STAT = ERROR)
<     error_sum = ERROR
<     IF ( error_sum == 0 ) THEN
<       ! Initialise array values
<       frac_fplain_lp(:) = 0.0
<     ELSE
<       CALL log_fatal(RoutineName,                                              &
<                      "Error allocating land grid arrays")
<     END IF
---
>   !----------------------------------------------------------------------------
>   ! Read overbank inundation namelist
>   !----------------------------------------------------------------------------
>   CALL log_info(RoutineName,"Reading JULES_OVERBANK_PROPS namelist...")
> 
>   READ(namelist_unit, NML = jules_overbank_props, IOSTAT = ERROR)
>   IF ( ERROR /= 0 ) THEN
>     CALL log_fatal(RoutineName,                                                &
>                    "Error reading namelist JULES_OVERBANK_PROPS " //           &
>                    "(IOSTAT=" // TRIM(to_string(ERROR)) // ")")
>   END IF
> 
>   !----------------------------------------------------------------------------
>   ! Set up river overbank inundation properties
>   !----------------------------------------------------------------------------
>   IF ( overbank_model == overbank_hypsometric ) THEN
>     nvars_required = 2
>     required_vars(1:nvars_required) = [ 'logn_mean ', 'logn_stdev' ]
>   END IF
> 
>   !----------------------------------------------------------------------------
>   ! Check that variables in the namelist have been provided and set up
>   ! other variables.
>   !----------------------------------------------------------------------------
>   CALL check_namelist_values( nvars, nvars_max, nvars_required,                &
>                               RoutineName, FILE, const_val,                    &
>                               use_file, required_vars, tpl_name, var,          &
>                               nvars_const, nvars_file, l_have_template,        &
>                               use_var, file_name, var_name )
> 
>   !----------------------------------------------------------------------------
>   ! Allocate space for gridded ancillary variables.
>   !----------------------------------------------------------------------------
>   CALL allocate_overbank_vars_grid( nx_rivers, ny_rivers )
> 
>   !--------------------------------------------------------------------------
>   ! Set variables that are using a constant value.
>   !--------------------------------------------------------------------------
>   CALL set_constant_vars( nvars, nvars_const, nvars_max, const_val,            &
>                           use_file, use_var, var )
> 
>   !--------------------------------------------------------------------------
>   ! Set variables that are to be read from a file.
>   !--------------------------------------------------------------------------
>   CALL set_file_vars( nvars, nvars_file, nvars_max, l_have_template,           &
>                       RoutineName, use_file, use_var, file_name, var,          &
>                       var_name)
> 
> END IF  !  is_master_task
> 
> RETURN
> END SUBROUTINE init_overbank_props
> 
> !#############################################################################
> 
> SUBROUTINE allocate_overbank_vars_grid( nx_rivers, ny_rivers )
> 
> !------------------------------------------------------------------------------
> ! Description:
> !   Allocates overbank inundation variables on the river input grid.
> !------------------------------------------------------------------------------
> 
> USE logging_mod, ONLY: log_fatal
> 
> USE overbank_inundation_mod, ONLY:                                             &
>   logn_mean, logn_stdev, overbank_hypsometric, overbank_model
> 
> IMPLICIT NONE
> 
> !------------------------------------------------------------------------------
> ! Scalar arguments with INTENT(IN)
> !------------------------------------------------------------------------------
> INTEGER, INTENT(IN) ::                                                         &
>   nx_rivers, ny_rivers
>     ! Size of the river input grid.
> 
> CHARACTER(LEN=*), PARAMETER :: RoutineName='allocate_overbank_vars_grid'
> 
> !------------------------------------------------------------------------------
> ! Local scalar variables.
> !------------------------------------------------------------------------------
> INTEGER ::                                                                     &
>   ERROR, error_sum,                                                            &
>     ! Error values.
>   nx, ny
>     ! Sizes used in allocation.
> 
> !end of header
> !------------------------------------------------------------------------------
273c242,253
<   END IF ! (check global_landpoint > 1)
---
> !------------------------------------------------------------------------------
> ! This routine is only called by the master task. All variables are allocated,
> ! but they are only allocated at full size when required by the run
> ! configuration.
> !------------------------------------------------------------------------------
> IF ( overbank_model == overbank_hypsometric ) THEN
>   nx = nx_rivers
>   ny = ny_rivers
> ELSE
>   nx = 1
>   ny = 1
> END IF
274a255,261
> ALLOCATE( logn_mean(nx, ny), STAT = ERROR )
> error_sum = ERROR
> ALLOCATE( logn_stdev(nx, ny), STAT = ERROR )
> error_sum = error_sum + ERROR
> IF ( error_sum /= 0 ) THEN
>   CALL log_fatal(RoutineName,                                                  &
>                  "Error allocating arrays from ancillaries")
277c264,423
< END SUBROUTINE init_overbank_props
---
> ! Initialise to missing data.
> logn_mean(:,:)  = rmdi
> logn_stdev(:,:) = rmdi
> 
> RETURN
> END SUBROUTINE allocate_overbank_vars_grid
> 
> !#############################################################################
> SUBROUTINE allocate_overbank_vars_rp( land_pts, np_rivers )
> 
> !------------------------------------------------------------------------------
> ! Description:
> !   Allocates overbank inundation variables on river points. Also allocates
> !   inundation variables on land points.
> !------------------------------------------------------------------------------
> 
> USE jules_rivers_mod, ONLY: l_riv_overbank
> 
> USE logging_mod, ONLY: log_fatal
> 
> USE overbank_inundation_mod, ONLY:                                             &
>   logn_mean_rp, logn_stdev_rp, overbank_hypsometric, overbank_model,           &
>   overbank_simple_rosgen, frac_fplain_lp, frac_fplain_rp, qbf, dbf, wbf
> 
> USE parallel_mod, ONLY: is_master_task
> 
> IMPLICIT NONE
> 
> ! Scalar arguments with INTENT(IN)
> INTEGER, INTENT(IN) ::                                                         &
>   land_pts,                                                                    &
>     ! Number of land points.
>   np_rivers
>     ! Number of river points.
> 
> CHARACTER(LEN=*), PARAMETER :: RoutineName='allocate_overbank_vars_rp'
> 
> ! Local scalar variables.
> INTEGER ::                                                                     &
>   ERROR, error_sum,                                                            &
>     ! Error values.
>   np_land_tmp,                                                                 &
>     ! Number of land points to allocate for.
>   np_rivers_tmp
>     ! Number of river points to allocate for.
> 
> !end of header
> !------------------------------------------------------------------------------
> 
> !------------------------------------------------------------------------------
> ! Allocate inundation variables defined on river routing points.
> ! All variables are allocated (on all tasks), but they are only allocated at
> ! full size on the master task and when required by the run configuration.
> !------------------------------------------------------------------------------
> 
> !------------------------------------------------------------------------------
> ! Allocate river point variables that are used by all overbank models.
> !------------------------------------------------------------------------------
> IF ( l_riv_overbank .AND. is_master_task() ) THEN
>   ! Full size.
>   np_rivers_tmp = np_rivers
> ELSE
>   ! Minimum size.
>   np_rivers_tmp = 1
> END IF
> 
> ALLOCATE(frac_fplain_rp(np_rivers_tmp), STAT = ERROR)
> 
> IF ( ERROR /= 0 ) THEN
>   CALL log_fatal(RoutineName,                                                  &
>                  "Error allocating river point arrays (1)")
> END IF
> 
> ! Initialise array values
> frac_fplain_rp(:) = rmdi
> 
> !------------------------------------------------------------------------------
> ! Allocate river point variables that are only used with the option
> ! overbank_hypsometric.
> !------------------------------------------------------------------------------
> IF ( overbank_model == overbank_hypsometric .AND. is_master_task() ) THEN
>   ! Full size.
>   np_rivers_tmp = np_rivers
> ELSE
>   ! Minimum size.
>   np_rivers_tmp = 1
> END IF
> 
> ALLOCATE(logn_mean_rp(np_rivers_tmp), STAT = ERROR)
> error_sum = ERROR
> ALLOCATE(logn_stdev_rp(np_rivers_tmp), STAT = ERROR)
> error_sum = error_sum + ERROR
> 
> IF ( error_sum /= 0 ) THEN
>   CALL log_fatal(RoutineName,                                                  &
>                  "Error allocating river point arrays (2)")
> END IF
> 
> ! Initialise array values
> logn_mean_rp(:)  = rmdi
> logn_stdev_rp(:) = rmdi
> 
> !------------------------------------------------------------------------------
> ! Allocate river point variables that are only used with the option
> ! overbank_simple_rosgen.
> !------------------------------------------------------------------------------
> IF ( overbank_model == overbank_simple_rosgen .AND. is_master_task() ) THEN
>   ! Full size.
>   np_rivers_tmp = np_rivers
> ELSE
>   ! Minimum size.
>   np_rivers_tmp = 1
> END IF
> 
> ! Note that these variables are part of the workspace required by the
> ! parameterisation.
> ALLOCATE(qbf(np_rivers_tmp), STAT = ERROR)
> error_sum = ERROR
> ALLOCATE(dbf(np_rivers_tmp), STAT = ERROR)
> error_sum = error_sum + ERROR
> ALLOCATE(wbf(np_rivers_tmp), STAT = ERROR)
> error_sum = error_sum + ERROR
> 
> IF ( error_sum /= 0 ) THEN
>   CALL log_fatal(RoutineName,                                                  &
>                  "Error allocating river point arrays (3)")
> END IF
> 
> ! Initialise array values
> qbf(:) = rmdi
> dbf(:) = rmdi
> wbf(:) = rmdi
> 
> !-------------------------------------------------------------------------
> ! Allocate inundation variables defined on land points.
> ! This is required on all tasks.
> !-------------------------------------------------------------------------
> IF ( l_riv_overbank ) THEN
>   ! Full size.
>   np_land_tmp = land_pts
> ELSE
>   ! Minimum size.
>   np_land_tmp = 1
> END IF
> 
> ALLOCATE(frac_fplain_lp(np_land_tmp), STAT = ERROR)
> 
> IF ( ERROR /= 0 ) THEN
>   CALL log_fatal(RoutineName,                                                  &
>                  "Error allocating land grid arrays")
> END IF
> 
> ! Initialise array values
> frac_fplain_lp(:) = 0.0
> 
> RETURN
> END SUBROUTINE allocate_overbank_vars_rp
> 
> !#############################################################################
> 
diff -r vn7.0copy1_c4/src/./initialisation/standalone/ancillaries/init_pdm_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/standalone/ancillaries/init_pdm_mod.F90
31c31
< USE jules_hydrology_mod, ONLY: l_spdmvar
---
> USE jules_hydrology_mod, ONLY: l_pdm, l_spdmvar
112,113c112,114
< ! If s_pdm as a slope dependent parameter is not on, we have nothing to do
< IF ( .NOT. l_spdmvar ) RETURN
---
> ! If we haven't selected PDM with s_pdm as a slope-dependent parameter, we
> ! have nothing to do
> IF ( .NOT. (l_pdm .AND. l_spdmvar ) ) RETURN
diff -r vn7.0copy1_c4/src/./initialisation/standalone/ancillaries/init_rivers_props_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/standalone/ancillaries/init_rivers_props_mod.F90
10c10
< IMPLICIT NONE
---
> USE model_interface_mod, ONLY: identifier_len
12c12
< CONTAINS
---
> USE jules_rivers_mod, ONLY: inland_drainage, river_mouth, sea
14c14
< SUBROUTINE init_rivers_props(rivers, rivers_data)
---
> USE logging_mod, ONLY: log_fatal, log_info, log_warn
16,17c16
< USE ancil_namelist_mod, ONLY: check_namelist_values, initialise_namelist_vars, &
<                               set_constant_vars, set_file_vars
---
> USE missing_data_mod, ONLY: imdi, rmdi
19c18
< USE mpi, ONLY: mpi_comm_world
---
> USE string_utils_mod, ONLY: to_string
21c20
< USE io_constants, ONLY: max_sdf_name_len, max_file_name_len, namelist_unit
---
> USE um_types, ONLY: real_jlslsm
23c22
< USE grid_utils_mod, ONLY: grid_create, grid_info
---
> IMPLICIT NONE
25,28c24,80
< USE input_mod, ONLY:                                                           &
<     od_grid => grid,                                                           &
<     dummy_grid => grid,                                                        &
<     use_subgrid
---
> !------------------------------------------------------------------------------
> ! Terminology and grids used:
> ! Land grid:
> !   the 2-D grid used by JULES (not rivers) and on which land points sit.
> !   If JULES is using a 1-D grid, the model grid is the notional 2D grid
> !   across which the points can be scattered.
> ! River input grid:
> !   the 2-D river input grid (as held in ancillary files).
> ! River grid:
> !   the 2-D river grid. In many configurations this is identical to the river
> !   input grid, but in others the input grid is transformed (e.g. the order
> !   of the rows is reversed and/or the columns of a global grid have undergone
> !   a cyclic shift).
> ! River domain:
> !   that part of the river grid that is scanned for river points.
> !   The size and location of this depends on the configuration, but ideally it
> !   should be just large enough to cover all land points.
> ! River points:
> !    the points within the river domain at which rivers are modelled.
> !------------------------------------------------------------------------------
> 
> !------------------------------------------------------------------------------
> ! Scalar parameters.
> !------------------------------------------------------------------------------
> ! The values of dir_mouth and dir_inland_drainage should differ and should not
> ! be in the range 1:SIZE(flow_dir_delta,1), i.e. not in the range of values
> ! used to encode the flow directions.
> INTEGER, PARAMETER :: dir_mouth = 9
>   ! The value of the flow direction field that indicates a river mouth.
> INTEGER, PARAMETER :: dir_inland_drainage = 10
>   ! The value of the flow direction field that indicates an inland drainage
>   ! point, i.e. an endorheic catchment.
> 
> INTEGER, PARAMETER :: land_off_domain = sea + 1
>     ! The value of river_mask that is used to indicate a land point (according
>     ! to the river ancillary) that is outside of the valid river domain, i.e.
>     ! it is not in the area covered by land and hence cannot become a river
>     ! point. This value must not be either of sea or land_in_domain.
> 
> INTEGER, PARAMETER :: land_in_domain = land_off_domain + 1
>     ! The value of river_mask that is used to indicate a land point (according
>     ! to the river ancillary) that is inside the valid river domain, i.e. it is
>     ! in the area covered by land and hence can become a river point.
>     ! This value must not be either sea or land_off_domain.
> 
> INTEGER, PARAMETER :: nvars_max = 6
>   ! The maximum possible number of ancillary variables that are read in.
> 
> REAL(KIND=real_jlslsm), PARAMETER :: frac_toler = 1.0e-3
>   ! Tolerance (fraction of a gridbox) used when testing whether model points
>   ! lie on a regular grid, if grids have the same resolution, and when setting
>   ! some bounding values.
> 
> LOGICAL, PARAMETER :: l_use_direction = .TRUE.
>   ! Parameter indicating that we are provided with a flow direction ancillary.
>   ! At present this is always the case, but anticipated developments will
>   ! create a need to start from nextx & nexty fields.
30c82,84
< USE missing_data_mod, ONLY: imdi, rmdi
---
> LOGICAL ::                                                                     &
>   l_riv_number = .FALSE.
>     ! Flag indicating if river number ancillary has been specified.
32c86,114
< USE ancil_info, ONLY: land_pts
---
> !------------------------------------------------------------------------------
> ! Array parameters.
> !------------------------------------------------------------------------------
> INTEGER, PARAMETER :: flow_dir_river(10) =                                     &
>   [ 1, 2, 3, 4, 5, 6, 7, 8, dir_mouth, dir_inland_drainage ]
>     ! The values of flow direction that are acceptable for a river point.
>     ! Effectively these also the only values that indicate land points in the
>     ! flow direction field. The first 8 places represent "compass directions"
>     ! for the 8 points immediately neighbouring a given point and these should
>     ! be >0. All values should be unique.
> 
> INTEGER, PARAMETER :: flow_dir_river_edge(8) = -flow_dir_river(1:8)
>   ! Values of nextx_grid that are used to indicate flow across the edge of the
>   ! river domain or grid. These are -1 * values of flow_dir_river that indicate
>   ! a "physical" flow direction and as such will have values <0.
> 
> !------------------------------------------------------------------------------
> ! Scalar variables.
> !------------------------------------------------------------------------------
> INTEGER :: nvars_required
>   ! The number of routing variables that are required in this configuration.
> 
> !------------------------------------------------------------------------------
> ! Array variables.
> !------------------------------------------------------------------------------
> INTEGER, ALLOCATABLE :: direction_grid(:,:)
>   ! Integer version of rivers_dir (the river routing direction index).
>   ! We use the REAL version for i.o (JULES cannot read an integer ancillary
>   ! field) but thereafter the integer version is easier to use.
34c116,128
< USE logging_mod, ONLY: log_info, log_warn, log_fatal
---
> INTEGER, ALLOCATABLE :: grid_riv_pt_number(:,:)
>   ! Map full river grid to river points. For each location on the grid, this
>   ! is the river point number.
> 
> INTEGER, ALLOCATABLE :: nextx_grid(:,:)
>   ! x index of the next downstream point.
> 
> INTEGER, ALLOCATABLE :: nexty_grid(:,:)
>   ! y index of the next downstream point.
> 
> INTEGER, ALLOCATABLE :: river_mask(:,:)
>   ! Indicates type of each point.
>   ! Values are sea, land_off_domain or land_in_domain.
36c130,131
< USE fill_variables_from_file_mod, ONLY: fill_variables_from_file
---
> CHARACTER(LEN=identifier_len) :: required_vars(nvars_max)
>   ! The variable identifiers of the required variables
38c133,134
< USE string_utils_mod, ONLY: to_string
---
> PRIVATE  !  private scope by default
> PUBLIC init_rivers_props
40c136
< USE templating_mod, ONLY: tpl_has_var_name
---
> CONTAINS
42c138
< USE model_interface_mod, ONLY: identifier_len
---
> !##############################################################################
44c140
< USE model_grid_mod, ONLY: latitude, longitude, global_land_pts, model_grid
---
> SUBROUTINE init_rivers_props(rivers, rivers_data)
46c142,143
< USE conversions_mod, ONLY: pi_over_180
---
> USE ancil_namelist_mod, ONLY: check_namelist_values, initialise_namelist_vars, &
>                               set_constant_vars, set_file_vars
48c145
< USE planet_constants_mod, ONLY: planet_radius  ! the Earth's radius (m)
---
> USE fill_variables_from_file_mod, ONLY: fill_variables_from_file
50,58c147
< USE jules_rivers_mod, ONLY:                                                    &
<      i_river_vn, inland_drainage, river_mouth, rivers_rfm, rivers_trip,        &
<      flow_dir_delta, np_rivers, nx_rivers, ny_rivers, rfm_land, rfm_river,     &
<      rivers_dlat, rivers_dlon, rivers_lat1, rivers_lon1, nx_grid, ny_grid,     &
<      nseqmax, reg_lon1, reg_lat1, reg_dlon, reg_dlat, rivers_dx,               &
<      rivers_reglatlon, rivers_regrid, l_rivers,                                &
<      a_thresh,                                                                 &
<      ! types
<      rivers_type,rivers_data_type
---
> USE grid_utils_mod, ONLY: grid_create, grid_info
60c149
< USE rivers_utils, ONLY: rivers_earth_area
---
> USE init_ancillaries_coupling_mod, ONLY: read_ancillaries_coupling
62,63c151,154
< USE rivers_regrid_mod, ONLY: rivers_remap_match, rivers_remap_unmatch,         &
<                              rivers_get_xy_pos
---
> USE input_mod, ONLY:                                                           &
>     od_grid => grid,                                                           &
>     dummy_grid => grid,                                                        &
>     use_subgrid
66a158,169
> USE io_constants, ONLY: max_sdf_name_len, max_file_name_len, namelist_unit
> 
> USE jules_rivers_mod, ONLY:                                                    &
>   i_river_vn, land_dx, land_dy, l_rivers, nx_land_grid,                        &
>   nx_rivers_in=>nx_rivers, ny_land_grid, ny_rivers_in=>ny_rivers,              &
>   rivers_length, rivers_regrid, rivers_rfm, rivers_trip, x1_land_grid,         &
>   y1_land_grid, l_riv_overbank,                                                &
>   ! types
>   rivers_type, rivers_data_type
> 
> USE model_grid_mod, ONLY: global_land_pts, l_coord_latlon
> 
68,77c171
<      l_riv_overbank, l_riv_hypsometry, use_rosgen,                             &
<      logn_mean, logn_stdev, logn_mean_rp, logn_stdev_rp,                       &
<      qbf, wbf, dbf,                                                            &
<      riv_a, riv_b, riv_c, riv_f, coef_b, exp_c
< 
< USE jules_irrig_mod, ONLY: l_irrig_limit
< 
< USE jules_print_mgr, ONLY:                                                     &
<   jules_message,                                                               &
<   jules_print
---
>   init_rosgen_vars, overbank_model, overbank_simple_rosgen
79c173,175
< USE um_types, ONLY: real_jlslsm
---
> USE parallel_mod, ONLY: is_master_task
> 
> USE templating_mod, ONLY: tpl_has_var_name
83c179
< !-----------------------------------------------------------------------------
---
> !------------------------------------------------------------------------------
85,86c181,186
< !    Reads in details of the river routing grid and river properties,
< !    and allocates various river variables.
---
> !    Top-level routine that controls reading of river routing grid and river
> !    and properties, and allocation and setting of river point values.
> !
> !    When running the river executable in coupled mode, no regridding between
> !    the land and river grids is necessary, so we can skip the calculation of
> !    some variables that will not be used.
94c194
< !-----------------------------------------------------------------------------
---
> !------------------------------------------------------------------------------
96c196,201
< ! Work variables
---
> !------------------------------------------------------------------------------
> ! Subroutine arguments.
> !------------------------------------------------------------------------------
> ! Types
> TYPE(rivers_type), INTENT(IN OUT) :: rivers
> TYPE(rivers_data_type), INTENT(IN OUT), TARGET :: rivers_data
98c203,206
< INTEGER :: ERROR, error_sum  ! Error indicators
---
> !------------------------------------------------------------------------------
> ! Local parameters.
> !------------------------------------------------------------------------------
> CHARACTER(LEN=*), PARAMETER :: RoutineName = 'INIT_RIVERS_PROPS'
100c208,213
< INTEGER :: ntasks ! Parallel mode indicator
---
> !------------------------------------------------------------------------------
> ! Local variables appearing in the namelist.
> !------------------------------------------------------------------------------
> ! Scalars in namelist.
> INTEGER :: nvars
>     ! The number of variables in this section
102,103c215,216
< INTEGER, PARAMETER :: nvars_max = 6 ! The maximum possible number of
<                                           ! routing variables
---
> INTEGER :: nx_rivers, ny_rivers
>     ! The sizes of the x and y dimensions of the river routing input grid.
105c218,303
< CHARACTER(LEN=*), PARAMETER :: RoutineName = 'INIT_RIVERS_PROPS'
---
> LOGICAL ::                                                                     &
>   l_find_grid = .FALSE.,                                                       &
>     ! Switch controlling how characteristics of the land and rivers grids are
>     ! determined.
>     ! F = use namelist values for the variables nx_land_grid, ny_land_grid,
>     !     x1_land_grid and y1_land_grid, which describe the land grid. Note
>     !     that in this case rivers_regrid=F requires nx_land_grid and
>     !     ny_land_grid only so as to ensure historical results are maintained.
>     ! T = calculate details of the land grid from the known coordinates of
>     !     land points. This also triggers differences in how the river domain
>     !     is set up, including better treatment of the cases in which the
>     !     resolutions of the land and river grids differ and/or land points
>     !     (e.g. from a regional domain) straddle the longitudinal edges of a
>     !     global river input grid.
>   l_use_area = .FALSE.
>     ! Switch (used with RFM) to use a drainage area ancillary field to identify
>     ! river points.
>     ! T means use ancillary data for area.
>     ! F means no ancillary data provided. Area will be set above threshold so
>     ! that all points will be identified as rivers.
> 
> LOGICAL ::                                                                     &
>   l_ignore_ancil_rivers_check = .FALSE.
>     ! Switch to check river routing & river number ancillary for compatibility.
>     ! The current Rose stem test ancils are not compatible as the land sea
>     ! mask is different. Setting this to true maintains bit comparability &
>     ! protects the calculation of the coupling field needed for the LFRic
>     ! coupled miniapp.
> 
> CHARACTER(LEN=max_file_name_len) :: FILE
>     ! The name of the file (or variable name template) to
>     ! use for variables that need to be filled from file.
>     ! Co-ordinate variables are also read from this file,
>     ! assuming file does not include variable-name
>     ! templating (i.e. assuming all ancillary variables will
>     ! come from the same file).
> 
> CHARACTER(LEN=max_file_name_len) :: coordinate_file
>     ! The name of the file given for reading coordinate
>     ! values from. This is only used if the ancillary file
>     ! name includes templating (i.e. ancillary variables will
>     ! come from multiple files), in which case this variable
>     ! is used to provide clarity as to where the coordinates
>     ! are read from.
> 
> CHARACTER(LEN=max_file_name_len) :: riv_number_file = ''
>     ! The name of the file given for reading river number
>     ! at each grid point
> 
> CHARACTER(LEN=max_sdf_name_len) :: x_dim_name, y_dim_name
>     ! The names of the x and y dimensions.
> 
> ! Arrays in namelist.
> REAL(KIND=real_jlslsm) :: const_val(nvars_max)
>     ! The constant value to use for each variable if
>     ! use_file = F for that variable
> 
> LOGICAL :: use_file(nvars_max)
>     !   T - the variable uses the file
>     !   F - the variable is set using a constant value
> LOGICAL ::                                                                     &
>   use_var(nvars_max)
>     ! Flag indicating if a variable is required.
> 
> CHARACTER(LEN=max_sdf_name_len) :: tpl_name(nvars_max)
>     ! The name to substitute in a template for each variable
> CHARACTER(LEN=identifier_len) :: var(nvars_max)
>     ! The variable identifiers of the variables
> CHARACTER(LEN=max_sdf_name_len) :: var_name(nvars_max)
>     ! The name of each variable in the file
> 
> !------------------------------------------------------------------------------
> ! Definition of the namelist. This contains local variables and some from
> ! jules_rivers_mod.
> !------------------------------------------------------------------------------
> NAMELIST  /jules_rivers_props/                                                 &
>    x_dim_name, y_dim_name, nx_rivers, ny_rivers, FILE, coordinate_file,        &
>    nvars, var, use_file, var_name, tpl_name, const_val,                        &
>    land_dx, land_dy, l_find_grid, l_use_area, nx_land_grid, ny_land_grid,      &
>    rivers_length, rivers_regrid, x1_land_grid, y1_land_grid, riv_number_file,  &
>    l_ignore_ancil_rivers_check
> 
> !------------------------------------------------------------------------------
> ! Local scalar variables (not in namelist).
> !------------------------------------------------------------------------------
> INTEGER :: ERROR, error_sum    ! Error indicators
109,119d306
< INTEGER :: nvars_required      ! The number of routing variables that are
<                                ! required in this configuration
< INTEGER :: nvars_optional      ! The number of optional routing variables
<                                ! in this configuration
< CHARACTER(LEN=identifier_len) :: required_vars(nvars_max)
<                                ! The variable identifiers of the required
<                                ! variables
< CHARACTER(LEN=identifier_len) :: optional_vars(nvars_max)
<                                ! The variable identifiers of any optional
<                                ! variables
< 
124c311,313
<   l_have_template
---
>   l_calc_rivers_length,                                                        &
>     ! Flag indicating if rivers_length will be calculated.
>   l_have_template,                                                             &
125a315,316
>   use_sub_local
>     ! A local copy of use_subgrid.
127,129d317
< LOGICAL ::                                                                     &
<   use_var(nvars_max)
<     ! Flag indicating if a variable is required.
130a319,321
> !------------------------------------------------------------------------------
> ! Local array variables (not in namelist).
> !------------------------------------------------------------------------------
133,149d323
< 
< CHARACTER(LEN=max_file_name_len) :: FILE
<                       ! The name of the file (or variable name template) to
<                       ! use for variables that need to be filled from file.
<                       ! Co-ordinate variables are also read from this file,
<                       ! assuming file does not include variable-name
<                       ! templating (i.e. assuming all ancillary variables will
<                       ! come from the same file).
< 
< CHARACTER(LEN=max_file_name_len) :: coordinate_file
<                       ! The name of the file given for reading coordinate
<                       ! values from. This is only used if the ancillary file
<                       ! name includes templating (i.e. ancillary variables will
<                       ! come from multiple files), in which case this variable
<                       ! is used to provide clarity as to where the coordinates
<                       ! are read from.
< 
151,152c325
<                       ! The name of the file to be used to read coordinate
<                       ! values from.
---
>     ! The name of the file to be used to read coordinate values from.
154,167c327,330
< INTEGER :: nvars      ! The number of variables in this section
< CHARACTER(LEN=identifier_len) :: var(nvars_max)
<                       ! The variable identifiers of the variables
< LOGICAL :: use_file(nvars_max)
<                       !   T - the variable uses the file
<                       !   F - the variable is set using a constant value
< CHARACTER(LEN=max_sdf_name_len) :: var_name(nvars_max)
<                       ! The name of each variable in the file
< CHARACTER(LEN=max_sdf_name_len) :: tpl_name(nvars_max)
<                       ! The name to substitute in a template for each
<                       ! variable
< REAL(KIND=real_jlslsm) :: const_val(nvars_max)
<                       ! The constant value to use for each variable if
<                       ! use_file = F for that variable
---
> !------------------------------------------------------------------------------
> ! Types
> !------------------------------------------------------------------------------
> TYPE(grid_info) :: local_grid
169,191c332,333
< INTEGER, PARAMETER :: flow_dir_sea = 0
<                       ! The value of flow direction that is used to indicate
<                       ! a sea point. This value is used to set the flow
<                       ! direction variable in this code, but it need not be
<                       ! the value used to indicate sea in the input ancillary
<                       ! file. This value must not be any of 1:8, river_mouth,
<                       ! inland_drainage, or land_off_domain.
< INTEGER, PARAMETER :: land_off_domain = -1
<                       ! The value of flow direction that is used to indicate
<                       ! a land point that is outside of the valid river domain,
<                       ! i.e. it is on the river grid but not in the area
<                       ! covered by land, hence it cannot become a river point.
<                       ! This value must not be any of 1:8, river_mouth,
<                       ! inland_drainage, or flow_dir_sea.
< INTEGER :: i,ip,ix,iy,j  ! Index variables
< INTEGER :: inext, jnext
< INTEGER :: i1, i2, ilat, ilon, step
< 
< REAL(KIND=real_jlslsm) :: reg_lat2, reg_lon2, min_lon, dlat, dlon
< 
< REAL(KIND=real_jlslsm) :: contribarea
<                       ! Upstream contributing drainage area (km^2)
< REAL(KIND=real_jlslsm) :: rix, riy ! Locations on grid.
---
> !end of header
> !------------------------------------------------------------------------------
193,205c335,336
< !Conversion from m2 to km2
< REAL(KIND=real_jlslsm), PARAMETER :: m2tokm2 = 1.0e-6
< REAL(KIND=real_jlslsm), PARAMETER :: global_lon_threshold = 359.9
<   ! Threshold value used when determining if a grid is cyclic (global) in the
<   ! longitudinal direction (degrees). This should be close to 360 degrees.
< REAL(KIND=real_jlslsm), PARAMETER :: location_toler = 1.0e-3
<   ! Tolerance (fraction of a gridbox)  used when testing whether model points
<   ! lie on a regular grid.
< 
< LOGICAL :: use_sub_local
< LOGICAL :: set_dra
< LOGICAL :: l_cyclic_x
<   ! Flag indicating a river grid that is cyclic (global) in the x direction.
---
> ! If rivers are not on, there is nothing to do.
> IF ( .NOT. l_rivers ) RETURN
207,212c338,363
< INTEGER, PARAMETER :: flow_dir_river(10) =                                     &
<   [ 1, 2, 3, 4, 5, 6, 7, 8, river_mouth, inland_drainage ]
<   ! The values of flow direction that are acceptable for a river point.
<   ! Effectively these also the only values that indicate land points in the
<   ! flow direction field. The first 8 places represent "compass directions"
<   ! for the 8 points immediately neighbouring a given point.
---
> ! If this run does not have any land points we cannot do river routing.
> IF ( global_land_pts == 0 ) THEN
>   CALL log_fatal( RoutineName,                                                 &
>                  "River routing not appropriate for runs with no land "     // &
>                  "points." )
> END IF
> 
> ! Check for a consistency between the river scheme and the coordinate system.
> ! This does not involve river ancillaries, but at present there is no obviously
> ! better location at which to do this.
> ! TRIP needs rivers_dx and rivers_dy to be defined in terms of latitude and
> ! longitude for use when calculating distances in SUBROUTINE get_rivers_len_rp.
> ! At present that is only the case when the grid is defined in terms of
> ! latitude and longitude.
> IF ( i_river_vn == rivers_trip .AND. .NOT. l_coord_latlon ) THEN
>   CALL log_fatal(RoutineName,                                                  &
>                  'TRIP can only be used with coordinates of latitude and '  // &
>                  'longitude.')
> END IF
> 
> !------------------------------------------------------------------------------
> ! Most tasks need only be done on the master task, which is where the river
> ! routing code will run. If the JULES_RIVERS_PROPS namelist were to contain
> ! values that are needed by other tasks, all tasks would have to read it.
> !------------------------------------------------------------------------------
> IF ( is_master_task() ) THEN
214,217c365,376
< INTEGER, ALLOCATABLE :: rivers_dir_int(:,:)
<   ! Integer version of rivers_dir.
<   ! We use the REAL version for i.o (JULES cannot read an integer ancillary
<   ! field) but thereafter the integer version is easier to use.
---
>   !----------------------------------------------------------------------------
>   ! Get ready for reading the river routing properties namelist.
>   !----------------------------------------------------------------------------
>   ! Initialisation of some common variables related to namelists.
>   CALL initialise_namelist_vars( nvars, nvars_const, nvars_file,               &
>                                  nvars_required, l_have_template,              &
>                                  FILE, const_val, use_file, use_var,           &
>                                  file_name, tpl_name, var, var_name )
> 
>   ! Initialisation of further variables.
>   coordinate_file = '' ! Empty file name.
>   l_calc_rivers_length = .FALSE.  !  value will not be calculated
219,220c378,381
< ! Remapping full grid to vector points
< INTEGER, ALLOCATABLE :: mapfr(:,:)                   ! map full to river
---
>   !----------------------------------------------------------------------------
>   ! Read river routing properties namelist
>   !----------------------------------------------------------------------------
>   CALL log_info( RoutineName, "Reading JULES_RIVERS_PROPS namelist..." )
222c383,388
< ! The names and sizes of the x and y dimensions
---
>   READ(namelist_unit, NML = jules_rivers_props, IOSTAT = ERROR)
>   IF ( ERROR /= 0 ) THEN
>     CALL log_fatal( RoutineName,                                               &
>                     "Error reading namelist JULES_RIVERS_PROPS "            // &
>                     "(IOSTAT=" // TRIM(to_string(ERROR)) // ")" )
>   END IF
224,225c390,396
< CHARACTER(LEN=max_sdf_name_len) :: x_dim_name, y_dim_name
< INTEGER :: nx, ny
---
>   !----------------------------------------------------------------------------
>   ! Pass the values of nx_rivers and ny_rivers that were read from
>   ! jules_rivers_props to the variables in jules_rivers_mod.
>   ! Note that these are only needed by the master task.
>   !----------------------------------------------------------------------------
>   nx_rivers_in = nx_rivers
>   ny_rivers_in = ny_rivers
227c398,403
< TYPE(grid_info) :: local_grid, rivers_grid
---
>   !----------------------------------------------------------------------------
>   ! Check values from the namelist.
>   !----------------------------------------------------------------------------
>   CALL check_jules_rivers_props( nx_rivers, ny_rivers, l_find_grid,            &
>                                  coordinate_file, FILE, riv_number_file,       &
>                                  l_calc_rivers_length )
229,231c405,409
< ! types
< TYPE(rivers_type), INTENT(IN OUT) :: rivers
< TYPE(rivers_data_type), INTENT(IN OUT), TARGET :: rivers_data
---
>   !----------------------------------------------------------------------------
>   ! Set up the list of required ancillary variables.
>   !----------------------------------------------------------------------------
>   ! Add variables that depend only on the chosen routing model.
>   SELECT CASE ( i_river_vn )
233,237c411
< NAMELIST  / jules_rivers_props/                                                &
<    x_dim_name, y_dim_name, nx, ny, FILE, coordinate_file,                      &
<    nvars, var, use_file, var_name, tpl_name, const_val,                        &
<    rivers_regrid, rivers_reglatlon,                                            &
<    nx_grid, ny_grid, reg_lat1, reg_lon1, reg_dlon, reg_dlat, rivers_dx
---
>   CASE ( rivers_trip )
239,240c413,414
< ! If rivers are not on, there is nothing to do
< IF ( .NOT. l_rivers ) RETURN
---
>     nvars_required = 2
>     required_vars(1:nvars_required) = [ 'direction', 'sequence ' ]
242,257c416
< !-----------------------------------------------------------------------------
< ! Initialise
< !-----------------------------------------------------------------------------
< ! Initialisation of some common variables.
< CALL initialise_namelist_vars( nvars, nvars_const, nvars_file,                 &
<                                nvars_required, l_have_template,                &
<                                FILE, const_val, use_file, use_var,             &
<                                file_name, tpl_name, var, var_name )
< ! Initialisation of further variables.
< coordinate_file = '' ! Empty file name.
< 
< IF ( global_land_pts <= 1 ) THEN
<   l_rivers = .FALSE.
<   CALL log_warn(RoutineName,                                                   &
<                 "River routing not appropriate for single point runs. " //     &
<                 "River routing disabled.")
---
>   CASE ( rivers_rfm )
259c418,419
< ELSE
---
>     nvars_required = 1
>     required_vars(1:nvars_required) = [ 'direction' ]
261,264c421,425
<   !---------------------------------------------------------------------------
<   ! Read river routing properties namelist
<   !---------------------------------------------------------------------------
<   CALL log_info(RoutineName, "Reading JULES_RIVERS_PROPS namelist...")
---
>   CASE DEFAULT
>     CALL log_fatal( RoutineName,                                               &
>                     "Do not recognise i_river_vn = '"                       // &
>                     TRIM(to_string(i_river_vn)) // "'" )
>   END SELECT
266,270c427,444
<   READ(namelist_unit, NML = jules_rivers_props, IOSTAT = ERROR)
<   IF ( ERROR /= 0 )                                                            &
<     CALL log_fatal(RoutineName,                                                &
<                    "Error reading namelist JULES_RIVERS_PROPS " //             &
<                    "(IOSTAT=" // TRIM(to_string(ERROR)) // ")")
---
>   ! Add required variables that depend on the coordinates used.
>   ! If the river grid is not a lat-lon grid, we need lat and lon variables.
>   ! These are needed for output files, and for calculating gridbox areas
>   ! under some configurations. The river grid is defined using the same
>   ! coordinate system (type) as the main model grid, hence we test using
>   ! l_coord_latlon here.
>   IF ( .NOT. l_coord_latlon ) THEN
>     nvars_required = nvars_required + 2
>     required_vars(nvars_required-1:nvars_required) =                           &
>       [ 'latitude_2d ', 'longitude_2d' ]
>   END IF
> 
>   ! Add variables that are required by some configurations.
>   IF ( i_river_vn == rivers_rfm .AND. l_use_area ) THEN
>     ! Add upstream drainage area.
>     nvars_required = nvars_required + 1
>     required_vars(nvars_required) = 'area'
>   END IF
272,274c446,454
<   !---------------------------------------------------------------------------
<   ! Define regular routing grid lat/lon
<   !---------------------------------------------------------------------------
---
>   !----------------------------------------------------------------------------
>   ! Check that variables in the namelist have been provided and set up other
>   ! variables.
>   !----------------------------------------------------------------------------
>   CALL check_namelist_values( nvars, nvars_max, nvars_required,                &
>                               RoutineName, FILE, const_val,                    &
>                               use_file, required_vars, tpl_name, var,          &
>                               nvars_const, nvars_file, l_have_template,        &
>                               use_var, file_name, var_name )
275a456,458
>   !----------------------------------------------------------------------------
>   ! Set up the regular routing input grid.
>   !----------------------------------------------------------------------------
281,283c464,466
<   local_grid = grid_create(dummy_grid%is_1d,dummy_grid%dim_name,               &
<                     dummy_grid%nx,dummy_grid%x_name,dummy_grid%nx,             &
<                     dummy_grid%y_name,dummy_grid%ny)
---
>   local_grid = grid_create( dummy_grid%is_1d, dummy_grid%dim_name,             &
>                             dummy_grid%nx, dummy_grid%x_name, dummy_grid%nx,   &
>                             dummy_grid%y_name, dummy_grid%ny )
286,290c469,470
<   ! whether variable-name templating is used.
<   ! First we check that a file name was provided.
<   IF ( LEN_TRIM(FILE) == 0 ) THEN
<     CALL log_fatal("init_rivers_props", "No file name provided")
<   END IF
---
>   ! whether variable-name templating is used. We have already checked that a
>   ! file name was provided.
294,299c474,475
<     ! We will use a separate variable to get the file name.
<     ! Check that a file name was provided.
<     IF ( LEN_TRIM(coordinate_file) == 0 ) THEN
<       CALL log_fatal("init_rivers_props",                                      &
<                      "No name given for coordinate_file.")
<     END IF
---
>     ! We use a separate variable to get the file name.
>     ! We have previously checked that a file name was provided.
306,307c482,483
<       CALL log_info("init_rivers_props",                                       &
<                     "No templating; coordinate_file will be ignored.")
---
>       CALL log_info( RoutineName,                                              &
>                      "No templating; coordinate_file will be ignored.")
311c487,488
<   ! Read latitude dimension from file
---
>   !----------------------------------------------------------------------------
>   ! Read y dimension from file.
313,314c490,491
<                          dim_name = TRIM(y_dim_name), npoints = ny )
<   ALLOCATE(rivers_data%rivers_ygrid(ny), STAT = ERROR)
---
>                          dim_name = TRIM(y_dim_name), npoints = ny_rivers )
>   ALLOCATE(rivers_data%rivers_ygrid(ny_rivers), STAT = ERROR)
319c496
<   ! Read longitude dimension from file
---
>   ! Read x dimension from file.
321,322c498,499
<                          dim_name = TRIM(x_dim_name), npoints = nx)
<   ALLOCATE(rivers_data%rivers_xgrid(nx), STAT = ERROR)
---
>                          dim_name = TRIM(x_dim_name), npoints = nx_rivers)
>   ALLOCATE(rivers_data%rivers_xgrid(nx_rivers), STAT = ERROR)
327,346c504,508
<     !---------------------------------------------------------------------------
<     ! Build the routing grid object from the namelist values
<     !---------------------------------------------------------------------------
<   dummy_grid = grid_create( .FALSE., "", 0, x_dim_name, nx, y_dim_name, ny)
<   rivers_grid = grid_create( .FALSE., "", 0, x_dim_name, nx, y_dim_name, ny)
< 
<   nx_rivers = rivers_grid%nx
<   ny_rivers = rivers_grid%ny
< 
<   ! Set all river routing arrays to be S to N irrespective of how latitudes
<   ! are stored in the ancillary files
<   IF ( rivers%rivers_ygrid(1) > MINVAL(rivers%rivers_ygrid) ) THEN
<     i1   = ny_rivers
<     i2   = 1
<     step = -1
<   ELSE
<     i1   = 1
<     i2   = ny_rivers
<     step = 1
<   END IF
---
>   !----------------------------------------------------------------------------
>   ! Build the routing grid object from the namelist values
>   !----------------------------------------------------------------------------
>   dummy_grid = grid_create( .FALSE., "", 0, x_dim_name, nx_rivers, y_dim_name, &
>                             ny_rivers)
348,350c510,514
<   !---------------------------------------------------------------------------
<   ! Set up routing properties using namelist values
<   !---------------------------------------------------------------------------
---
>   !----------------------------------------------------------------------------
>   ! Allocate gridded river ancillary variables.
>   !----------------------------------------------------------------------------
>   CALL allocate_river_vars_grid( global_land_pts, nx_rivers, ny_rivers,        &
>                                  rivers, rivers_data )
352c516,520
<   ! Set up the required and optional routing variables
---
>   !----------------------------------------------------------------------------
>   ! Set variables that are using a constant value.
>   !----------------------------------------------------------------------------
>   CALL set_constant_vars( nvars, nvars_const, nvars_max, const_val,            &
>                           use_file, use_var, var )
354c522,526
<   SELECT CASE ( i_river_vn )
---
>   !----------------------------------------------------------------------------
>   ! Set variables that are to be read from a file.
>   !----------------------------------------------------------------------------
>   CALL set_file_vars( nvars, nvars_file, nvars_max, l_have_template,           &
>                       RoutineName, use_file, use_var, file_name, var, var_name)
356c528,533
<   CASE ( rivers_trip )
---
>   !----------------------------------------------------------------------------
>   ! If required, read river number ancillary information from file.
>   !----------------------------------------------------------------------------
>   IF ( l_riv_number ) THEN
>     CALL read_ancillaries_coupling( riv_number_file, rivers, rivers_data )
>   END IF
358,361c535
<     nvars_required = 2
<     required_vars(1:nvars_required) = [ 'direction', 'sequence ' ]
<     nvars_optional = 2
<     optional_vars(1:nvars_optional) = [ 'latitude_2d ', 'longitude_2d' ]
---
> END IF  !  is_master_task
363c537,552
<   CASE ( rivers_rfm )
---
> !-----------------------------------------------------------------------------
> ! Read overbank properties namelists if required - so that any required
> ! ancillary fields are read from file before translating to the river routing
> ! points.
> !-----------------------------------------------------------------------------
> IF ( l_riv_overbank ) THEN
>   CALL init_overbank_props()
> END IF
> 
> !------------------------------------------------------------------------------
> ! Process the ancillary fields to identify river points and populate fields
> ! on river points.
> !------------------------------------------------------------------------------
> CALL process_rivers_data( l_calc_rivers_length, l_find_grid,                   &
>                           l_ignore_ancil_rivers_check, l_riv_number,           &
>                           l_use_area, rivers, rivers_data )
365,379c554
<     IF ( rivers_reglatlon ) THEN
<       nvars_required = 1
<       required_vars(1:nvars_required) = [ 'direction' ]
<       nvars_optional = 4
<       optional_vars(1:nvars_optional) =                                        &
<         [ 'latitude_2d ', 'longitude_2d',                                      &
<            'area        ', 'sequence    ' ]
<     ELSE
<       nvars_required = 3
<       required_vars(1:nvars_required) = [ 'direction   ',                      &
<                                   'latitude_2d ', 'longitude_2d' ]
<       nvars_optional = 2
<       optional_vars(1:nvars_optional) =                                        &
<         [ 'area        ', 'sequence    ' ]
<     END IF
---
> IF ( is_master_task() ) THEN
381,385c556,561
<   CASE DEFAULT
<     CALL log_fatal(RoutineName,                                                &
<                    "Do not recognise i_river_vn = '" //                        &
<                    TRIM(to_string(i_river_vn)) // "'")
<   END SELECT
---
>   !----------------------------------------------------------------------------
>   ! Calculate derived variables for inundation.
>   !----------------------------------------------------------------------------
>   IF ( l_riv_overbank .AND. overbank_model == overbank_simple_rosgen ) THEN
>     CALL init_rosgen_vars( rivers )
>   END IF
388,389c564
<   ! Check that variables in the namelist have been provided and set up other
<   ! variables.
---
>   ! Reset saved JULES grid from river to full land model
391,397c566,569
<   CALL check_namelist_values( nvars, nvars_max, nvars_required,                &
<                               RoutineName, FILE, const_val,                    &
<                               use_file, required_vars, tpl_name, var,          &
<                               nvars_const, nvars_file, l_have_template,        &
<                               use_var, file_name, var_name,                    &
<                               nvars_optional = nvars_optional,                 &
<                               optional_vars = optional_vars )
---
>   dummy_grid = grid_create(local_grid%is_1d,local_grid%dim_name,               &
>                            local_grid%nx,local_grid%x_name,local_grid%nx,      &
>                            local_grid%y_name,local_grid%ny)
>   use_subgrid = use_sub_local
399,401c571
<   !---------------------------------------------------------------------------
<   ! Allocate routing-specific arrays from ancillary information
<   !---------------------------------------------------------------------------
---
> END IF  !  is_master_task
403c573,574
<   IF ( nx_rivers > 0 .AND. ny_rivers > 0 ) THEN
---
> RETURN
> END SUBROUTINE init_rivers_props
405,422c576
<     ALLOCATE(rivers_data%rivers_dir(nx_rivers, ny_rivers),      STAT = ERROR )
<     error_sum = ERROR
<     ALLOCATE( rivers_dir_int(nx_rivers, ny_rivers),  STAT = ERROR )
<     error_sum = error_sum + ERROR
<     ALLOCATE(rivers_data%rivers_seq(nx_rivers, ny_rivers),      STAT = ERROR )
<     error_sum = error_sum + ERROR
<     ALLOCATE(rivers_data%rivers_dra(nx_rivers, ny_rivers),      STAT = ERROR )
<     error_sum = error_sum + ERROR
<     ALLOCATE(rivers_data%rivers_lat2d(nx_rivers, ny_rivers),    STAT = ERROR )
<     error_sum = error_sum + ERROR
<     ALLOCATE(rivers_data%rivers_lon2d(nx_rivers, ny_rivers),    STAT = ERROR )
<     error_sum = error_sum + ERROR
<     ALLOCATE( mapfr(nx_rivers, ny_rivers),           STAT = ERROR )
<     error_sum = error_sum + ERROR
<     IF ( error_sum /= 0 ) THEN
<       CALL log_fatal(RoutineName,                                              &
<                      "Error allocating for rivers arrays.")
<     END IF
---
> !##############################################################################
424c578,580
<     ! Initialise to impossible values.
---
> SUBROUTINE check_jules_rivers_props( nx_rivers, ny_rivers, l_find_grid,        &
>                                      coordinate_file, FILE, riv_number_file,   &
>                                      l_calc_rivers_length )
426,439c582,585
<     rivers_data%rivers_dir(:,:)      = rmdi
<     rivers_dir_int(:,:)  = imdi
<     rivers_data%rivers_seq(:,:)      = rmdi
<     rivers_data%rivers_dra(:,:)      = rmdi
<     rivers_data%rivers_lat2d(:,:)    = rmdi
<     rivers_data%rivers_lon2d(:,:)    = rmdi
<     mapfr(:,:)           = 0
< 
<     ! Associate pointers
<     rivers%rivers_dir => rivers_data%rivers_dir
<     rivers%rivers_seq => rivers_data%rivers_seq
<     rivers%rivers_dra => rivers_data%rivers_dra
<     rivers%rivers_lat2d => rivers_data%rivers_lat2d
<     rivers%rivers_lon2d => rivers_data%rivers_lon2d
---
> USE jules_rivers_mod, ONLY: i_river_vn, land_dx, land_dy, l_riv_overbank,      &
>                             nx_land_grid, ny_land_grid, x1_land_grid,          &
>                             y1_land_grid, rivers_length, l_outflow_per_river,  &
>                             rivers_regrid, rivers_rfm
440a587
> USE model_grid_mod, ONLY: l_coord_latlon
442c589,789
<   ELSE
---
> USE overbank_inundation_mod, ONLY: overbank_simple, overbank_simple_rosgen,    &
>                                    overbank_model
> 
> USE templating_mod, ONLY: tpl_has_var_name
> 
> USE jules_print_mgr, ONLY: jules_message
> 
> IMPLICIT NONE
> 
> !------------------------------------------------------------------------------
> ! Scalar arguments with INTENT(IN)
> !------------------------------------------------------------------------------
> INTEGER, INTENT(IN) ::                                                         &
>   nx_rivers, ny_rivers
>     ! The sizes of the x and y dimensions of the river routing input grid.
> 
> LOGICAL, INTENT(IN) ::                                                         &
>   l_find_grid
>     ! Switch controlling how characteristics of the land and rivers grids are
>     ! determined.
> 
> CHARACTER(LEN=*), INTENT(IN) ::                                                &
>   coordinate_file,                                                             &
>     ! The name of the file given for reading coordinate values from.
>   FILE,                                                                        &
>     ! The name of the file to be used to read data from.
>   riv_number_file
>     ! The name of the file given for reading river number
>     ! at each grid point
> 
> !------------------------------------------------------------------------------
> ! Scalar arguments with INTENT(IN OUT)
> !------------------------------------------------------------------------------
> LOGICAL, INTENT(IN OUT) ::                                                     &
>   l_calc_rivers_length
>     ! Flag indicating if rivers_length will be calculated.
> 
> CHARACTER(LEN=*), PARAMETER :: RoutineName = 'CHECK_JULES_RIVERS_PROPS'
> 
> !end of header
> !------------------------------------------------------------------------------
> 
> !------------------------------------------------------------------------------
> ! Check that a file name was provided.
> !------------------------------------------------------------------------------
> IF ( LEN_TRIM(FILE) == 0 ) THEN
>   CALL log_fatal( RoutineName, "No name given for file." )
> END IF
> 
> ! If templating is specified, check we have a coordinate_file.
> IF ( tpl_has_var_name(FILE) .AND. LEN_TRIM(coordinate_file) == 0 ) THEN
>   CALL log_fatal( RoutineName, "No name given for coordinate_file." )
> END IF
> 
> !------------------------------------------------------------------------------
> ! Regridding is only supported for (regular) lat-lon grids.
> ! The regularity is checked later.
> !------------------------------------------------------------------------------
> IF ( rivers_regrid .AND. .NOT. l_coord_latlon ) THEN
>   CALL log_fatal( RoutineName,                                                 &
>                  "Regridding can only be used with lat-lon grids." )
> END IF
> 
> !------------------------------------------------------------------------------
> ! Insist on a river grid that is at least 2 x 2. This is required for the
> ! calculations of rivers_dx and rivers_dy.
> !------------------------------------------------------------------------------
> IF ( nx_rivers < 2  .OR. ny_rivers < 2 ) THEN
>   CALL log_fatal( RoutineName,                                                 &
>                   "Routing grid must be at least 2x2. Dimensions provided: " //&
>                   "nx_rivers = " // TRIM(to_string(nx_rivers))               //&
>                   "ny_rivers = " // TRIM(to_string(ny_rivers)) )
> END IF
> 
> !------------------------------------------------------------------------------
> ! land_dy and land_dx are required, and should be >0.
> !------------------------------------------------------------------------------
> IF ( ABS( land_dy - rmdi ) < EPSILON(1.0) .OR.                                 &
>      ABS( land_dx - rmdi ) < EPSILON(1.0) ) THEN
>   CALL log_fatal( RoutineName,                                                 &
>                   "land_dy and land_dx must be provided." )
> ELSE IF ( land_dx <= 0.0 .OR. land_dy <= 0.0 ) THEN
>   CALL log_fatal( RoutineName,                                                 &
>                   "land_dy and land_dx must be >0." )
> END IF
> 
> !------------------------------------------------------------------------------
> ! Conditions for nx_land_grid, ny_land_grid, x1_land_grid and y1_land_grid.
> !------------------------------------------------------------------------------
> IF ( .NOT. l_find_grid ) THEN
>   ! Values shoud be supplied. Note that we later test that nx_land_grid and
>   ! ny_land_grid are large enough.
>   IF ( nx_land_grid == imdi .OR. ny_land_grid == imdi .OR.                     &
>        ABS( y1_land_grid - rmdi ) < EPSILON(1.0)  .OR.                         &
>        ABS( x1_land_grid - rmdi ) < EPSILON(1.0) ) THEN
>     CALL log_fatal( RoutineName,                                               &
>                     "nx_land_grid, ny_land_grid, x1_land_grid and "         // &
>                     "y1_land_grid must be provided for this configuration." )
>   ELSE IF ( nx_land_grid <= 0 .OR. ny_land_grid <= 0 ) THEN
>     CALL log_fatal( RoutineName,                                               &
>                     "nx_land_grid and ny_land_grid must be >0.")
>   END IF
> ELSE
>   ! l_find_grid = .TRUE.
>   ! Values are not required as they will be calculated.
>   IF ( nx_land_grid /= imdi .OR. ny_land_grid /= imdi .OR.                     &
>        ABS( y1_land_grid - rmdi ) > EPSILON(1.0)  .OR.                         &
>        ABS( x1_land_grid - rmdi ) > EPSILON(1.0) ) THEN
>     CALL log_fatal( RoutineName,                                               &
>                     "nx_land_grid, ny_land_grid, x1_land_grid and "         // &
>                     "y1_land_grid will be calculated and must not be "      // &
>                     "provided for this configuration." )
>   END IF
> END IF  !  l_find_grid
> 
> !------------------------------------------------------------------------------
> ! Conditions for rivers_length.
> !------------------------------------------------------------------------------
> IF ( .NOT. l_coord_latlon ) THEN
>   ! We don't have a latitude-longitude grid, and so must have rivers_length>0
>   ! because that is used to calculate box areas.
>   IF ( ABS( rivers_length - rmdi ) < EPSILON(1.0) .OR.                         &
>        rivers_length <= 0.0 ) THEN
>     CALL log_fatal( RoutineName,                                               &
>                     "rivers_length > 0 must be provided for this "          // &
>                     "configuration." )
>   END IF
> END IF
> 
> ! Note that this check requires that we have read the jules_overbank namelist.
> IF ( i_river_vn == rivers_rfm .OR.                                             &
>      ( l_riv_overbank .AND. ( overbank_model == overbank_simple .OR.           &
>                               overbank_model == overbank_simple_rosgen ) )     &
>    ) THEN
>   ! These configurations require rivers_length. A value <=0 will later trigger
>   ! calculation of rivers_length.
>   IF ( ABS( rivers_length - rmdi ) < EPSILON(1.0) ) THEN
>     CALL log_fatal( RoutineName,                                               &
>                     "rivers_length must be provided for this configuration." )
>   ELSE IF ( rivers_length <= 0.0 ) THEN
>     ! A non-missing value has been provided but it is <= 0, hence a new value
>     ! will be calculated - this is so as to mimic the behaviour of earlier
>     ! versions of the code. Note that we will only get here for grids that are
>     ! using lat and lon coords, because non-latlon grids were tested earlier
>     ! to ensure rivers_length > 0.
>     ! Set a switch to trigger later calculation of rivers_length.
>     l_calc_rivers_length = .TRUE.
>     CALL log_info( RoutineName,                                                &
>                    "rivers_length <= 0: value will be calculated from grid." )
>   END IF
> END IF
> 
> !-----------------------------------------------------------------------------
> ! Checks for outflow_per_river diagnostic, which requires the river number
> ! ancillary
> !-----------------------------------------------------------------------------
> ! OASIS-Rivers:
> !   l_outflow_per_river is set before now by check_oasis_rivers and is
> !   true when outflow_per_river is present in send_fields; requires the
> !   riv_number ancillary.
> IF ( l_outflow_per_river ) THEN
>   WRITE(jules_message,*)                                                       &
>      "OASIS send field outflow_per_river has been requested."
>   CALL log_info(RoutineName, jules_message)
>   IF ( LEN_TRIM(riv_number_file) == 0 ) THEN
>     CALL log_fatal(RoutineName, "No name given for riv_number_file.")
>   END IF
> END IF
> 
> IF ( LEN_TRIM(riv_number_file) > 0 ) THEN
>   l_riv_number = .TRUE.
>   WRITE(jules_message,*) "riv_number_file = ", TRIM(riv_number_file)
>   CALL log_info(RoutineName,jules_message)
>   ! Diagnostic output is requested later.
>   IF ( .NOT. l_outflow_per_river ) THEN
>     WRITE(jules_message,*)                                                     &
>        "riv_number_file detected; " //                                         &
>        "assume that outflow_per_river diagnostic will be requested."
>     CALL log_info(RoutineName, jules_message)
>     l_outflow_per_river = .TRUE.
>   END IF
> END IF
> 
> RETURN
> END SUBROUTINE check_jules_rivers_props
> 
> !##############################################################################
> 
> SUBROUTINE allocate_river_vars_grid( global_land_pts, nx_rivers, ny_rivers,    &
>                                      rivers, rivers_data )
> 
> !------------------------------------------------------------------------------
> ! Description:
> !   Allocate gridded river ancillary variables, initialise, and associate
> !   pointers.
> !------------------------------------------------------------------------------
> 
> USE jules_rivers_mod, ONLY: i_river_vn, rivers_rfm, rivers_trip,               &
>                             rivers_data_type, rivers_type
> 
> IMPLICIT NONE
444,447c791,1081
<     CALL log_fatal(RoutineName,                                                &
<                    "Invalid routing grid dimensions provided (nx_rivers = "//  &
<                     TRIM(to_string(nx_rivers)) // ", ny_rivers = " //          &
<                     TRIM(to_string(ny_rivers)) // "). Check inputs. ")
---
> !------------------------------------------------------------------------------
> ! Scalar arguments with INTENT(IN)
> !------------------------------------------------------------------------------
> INTEGER, INTENT(IN) ::                                                         &
>   global_land_pts,                                                             &
>     ! Number of land points.
>   nx_rivers, ny_rivers
>     ! Grid sizes.
> 
> !------------------------------------------------------------------------------
> ! Arguments with INTENT(IN OUT)
> !------------------------------------------------------------------------------
> TYPE(rivers_type), INTENT(IN OUT) :: rivers
> TYPE(rivers_data_type), INTENT(IN OUT), TARGET :: rivers_data
> 
> CHARACTER(LEN=*), PARAMETER :: RoutineName = 'ALLOCATE_RIVER_VARS_GRID'
> 
> INTEGER ::                                                                     &
>    ERROR, error_sum,                                                           &
>      ! Error values.
>    nx_size, ny_size
>      ! Sizes used for allocations.
> 
> !end of header
> !------------------------------------------------------------------------------
> 
> ! This routine is only called by the master task. All variables are allocated,
> ! but they are only allocated at full size when required by the run
> ! configuration.
> 
> ! Variables that are always required.
> ALLOCATE( grid_riv_pt_number(nx_rivers, ny_rivers), STAT = ERROR )
> error_sum = ERROR
> ALLOCATE( nextx_grid(nx_rivers, ny_rivers), STAT = ERROR )
> error_sum = error_sum + ERROR
> ALLOCATE( nexty_grid(nx_rivers, ny_rivers), STAT = ERROR )
> error_sum = error_sum + ERROR
> ALLOCATE( direction_grid(nx_rivers, ny_rivers), STAT = ERROR )
> error_sum = error_sum + ERROR
> ALLOCATE( river_mask(nx_rivers,ny_rivers), STAT = ERROR )
> error_sum = error_sum + ERROR
> ALLOCATE(rivers_data%rivers_dir(nx_rivers, ny_rivers), STAT = ERROR )
> error_sum = error_sum + ERROR
> ALLOCATE(rivers_data%rivers_lat2d(nx_rivers, ny_rivers), STAT = ERROR )
> error_sum = error_sum + ERROR
> ALLOCATE(rivers_data%rivers_lon2d(nx_rivers, ny_rivers), STAT = ERROR )
> error_sum = error_sum + ERROR
> 
> ! A remapping variable.
> ALLOCATE(rivers_data%global_land_index(global_land_pts), STAT = ERROR )
> error_sum = error_sum + ERROR
> 
> ! RFM variables.
> IF ( i_river_vn == rivers_rfm ) THEN
>   nx_size = nx_rivers
>   ny_size = ny_rivers
> ELSE
>   nx_size = 1
>   ny_size = 1
> END IF
> ALLOCATE(rivers_data%rivers_dra(nx_size,ny_size), STAT = ERROR )
> error_sum = error_sum + ERROR
> 
> ! TRIP variables.
> IF ( i_river_vn == rivers_trip ) THEN
>   nx_size = nx_rivers
>   ny_size = ny_rivers
> ELSE
>   nx_size = 1
>   ny_size = 1
> END IF
> ALLOCATE(rivers_data%rivers_seq(nx_size,ny_size), STAT = ERROR )
> error_sum = error_sum + ERROR
> 
> ! River coupling variables.
> IF ( l_riv_number ) THEN
>   nx_size = nx_rivers
>   ny_size = ny_rivers
> ELSE
>   nx_size = 1
>   ny_size = 1
> END IF
> ALLOCATE( rivers_data%rivers_outflow_number(nx_size,ny_size), STAT = ERROR )
> error_sum = error_sum + ERROR
> 
> IF ( error_sum /= 0 ) THEN
>   CALL log_fatal( RoutineName, "Error allocating for rivers arrays." )
> END IF
> 
> ! Initialise to missing data.
> grid_riv_pt_number(:,:)       = imdi
> nextx_grid(:,:)               = imdi
> nexty_grid(:,:)               = imdi
> direction_grid(:,:)           = imdi
> river_mask(:,:)               = imdi
> rivers_data%rivers_dir(:,:)   = rmdi
> rivers_data%rivers_lat2d(:,:) = rmdi
> rivers_data%rivers_lon2d(:,:) = rmdi
> rivers_data%global_land_index(:) = imdi
> rivers_data%rivers_dra(:,:)   = rmdi
> rivers_data%rivers_seq(:,:)   = rmdi
> rivers_data%rivers_outflow_number(:,:) = rmdi
> 
> ! Associate pointers
> rivers%rivers_dir   => rivers_data%rivers_dir
> rivers%rivers_lat2d => rivers_data%rivers_lat2d
> rivers%rivers_lon2d => rivers_data%rivers_lon2d
> rivers%global_land_index => rivers_data%global_land_index
> rivers%rivers_dra => rivers_data%rivers_dra
> rivers%rivers_seq => rivers_data%rivers_seq
> rivers%rivers_outflow_number => rivers_data%rivers_outflow_number
> 
> RETURN
> END SUBROUTINE allocate_river_vars_grid
> 
> !##############################################################################
> 
> SUBROUTINE process_rivers_data( l_calc_rivers_length, l_find_grid,             &
>                                 l_ignore_ancil_rivers_check, l_riv_number,     &
>                                 l_use_area, rivers, rivers_data )
> 
> !------------------------------------------------------------------------------
> ! Description:
> !   Process river ancillary data to produce variables on river points.
> !------------------------------------------------------------------------------
> 
> USE ancil_info, ONLY: land_pts
> 
> USE conversions_mod, ONLY: pi_over_180
> 
> USE init_ancillaries_coupling_mod, ONLY: check_ancil_rivers
> 
> USE init_overbank_props_mod, ONLY: allocate_overbank_vars_rp
> 
> USE jules_model_environment_mod, ONLY: l_oasis_rivers
> 
> USE jules_rivers_mod, ONLY:                                                    &
>   l_riv_overbank, l_trivial_mapping, np_rivers, nx_rivers, ny_rivers,          &
>   rivers_dx, rivers_dy, rivers_length, rivers_reglatlon, rivers_regrid,        &
>   rivers_x1, rivers_y1,                                                        &
>   ! types
>   rivers_data_type, rivers_type
> 
> USE model_grid_mod, ONLY: global_land_pts, projection_x_coord_land,            &
>                           projection_y_coord_land
> 
> USE parallel_mod, ONLY: gather_land_field, is_master_task
> 
> USE planet_constants_mod, ONLY: planet_radius
> 
> USE rivers_regrid_mod, ONLY: calc_map_river_to_land_points
> 
> USE rivers_utils, ONLY: rivers_earth_area
> 
> IMPLICIT NONE
> 
> !------------------------------------------------------------------------------
> ! Scalar arguments with INTENT(IN)
> !------------------------------------------------------------------------------
> LOGICAL, INTENT(IN) ::                                                         &
>   l_calc_rivers_length,                                                        &
>     ! Flag indicating if rivers_length will be calculated.
>   l_find_grid,                                                                 &
>     ! Switch controlling how characteristics of the land and rivers grids are
>     ! determined.
>   l_ignore_ancil_rivers_check,                                                 &
>     ! Switch to check river routing & river number ancillary for compatibility.
>   l_riv_number,                                                                &
>     ! Flag indicating if river number ancillary has been specified.
>   l_use_area
>     ! Switch (used with RFM) to use a drainage area ancillary field to identify
>     ! river points.
> 
> !------------------------------------------------------------------------------
> ! Arguments with INTENT(IN OUT)
> !------------------------------------------------------------------------------
> TYPE(rivers_type), INTENT(IN OUT) :: rivers
> TYPE(rivers_data_type), INTENT(IN OUT), TARGET :: rivers_data
> 
> !------------------------------------------------------------------------------
> ! Local parameters.
> !------------------------------------------------------------------------------
> CHARACTER(LEN=*), PARAMETER :: RoutineName = 'PROCESS_RIVERS_DATA'
> 
> !------------------------------------------------------------------------------
> ! Local scalar variables.
> !------------------------------------------------------------------------------
> INTEGER ::                                                                     &
>   ERROR,                                                                       &
>     ! An error value
>   error_sum,                                                                   &
>     ! Accumulated error values.
>   ip, ix, iy, l
>     ! Index variables
> 
> REAL(KIND=real_jlslsm) ::                                                      &
>   half_dlat, half_dlon,                                                        &
>     ! Sizes of half a gridbox (degrees)
>   rivers_x1_input
>     ! The first value of the x coordinate of the river input grid (i.e.
>     ! rivers_xgrid(1), after any conversion of longitude values).
> 
> LOGICAL ::                                                                     &
>   l_shift_x,                                                                   &
>     ! Flag indicating that a cyclic shift is to be applied in the x direction
>     ! to river ancillaries. This can be TRUE only if the coordinate is
>     ! longitude.
>   l_cyclic_x,                                                                  &
>     ! Flag indicating a river grid that is cyclic (global) in the x direction.
>   l_reverse_y
>     ! Flag indicating if the order in the y direction of ancillary fields is
>     ! to be reversed so that the coordinate is monotonically increasing.
> 
> !------------------------------------------------------------------------------
> ! Local array variables.
> !------------------------------------------------------------------------------
> REAL(KIND=real_jlslsm), ALLOCATABLE ::                                         &
>   global_proj_x_land(:),                                                       &
>     ! x-coordinates of land points.
>   global_proj_y_land(:)
>     ! y-coordinates of land points.
> 
> REAL(KIND=real_jlslsm), ALLOCATABLE ::                                         &
>   global_proj_x_land_work(:)
>     ! x coordinates of land points. In many circumstances this is simply a copy
>     ! of global_proj_x_land, but in others the values are transformed to allow
>     ! smaller grids to be used.
> 
> REAL(KIND=real_jlslsm) ::                                                      &
>   river_xbound(2), river_ybound(2)
>     ! Coordinates of the corners of the river domain - i.e. that part of the
>     ! river input grid that will be searched for river points. Units as given
>     ! by rivers_xgrid and rivers_ygrid.
> 
> !end of header
> !------------------------------------------------------------------------------
> 
> !------------------------------------------------------------------------------
> ! Overview of this subroutine:
> ! 1. Call process_rivers_coords to calculate values related to grid coordinates
> !    and the area that will be searched for river points (the river domain).
> ! 2. Call remap_ancil_control if necessary to remap from river input grid to
> !    river grid
> ! 3. Call process_direction_fields to convert flow direction to nextx and nexty
> !    indices.
> ! 4. Call find_river_points to search the river domain and establish the number
> !    of river points.
> ! 5. Call check_ancil_rivers if required, to check for consistency between
> !    river direction and river number fields.
> ! 6. Allocate river point arrays.
> ! 7. Call set_river_point_values to populate the river point arrays using
> !    values from the river input grid.
> ! 8. Call find_downstream_points to identify points downstream of others.
> ! 9. Calculate river grid mappings.
> !
> ! Step 6 is done on all tasks (though only the master task allocates at full
> ! size), all other steps are only necessary on the master task (because rivers
> ! are run on that).
> !------------------------------------------------------------------------------
> 
> !------------------------------------------------------------------------------
> ! Gather global land coordinate values from all tasks onto the master task.
> !------------------------------------------------------------------------------
> ALLOCATE(global_proj_x_land(global_land_pts), STAT = ERROR )
> error_sum = ERROR
> ALLOCATE(global_proj_x_land_work(global_land_pts), STAT = ERROR )
> error_sum = error_sum + ERROR
> ALLOCATE(global_proj_y_land(global_land_pts), STAT = ERROR )
> error_sum = error_sum + ERROR
> IF ( error_sum /= 0 ) THEN
>   CALL log_fatal( RoutineName, "Error allocating global lat/lon arrays." )
> END IF
> ! Initialise.
> global_proj_x_land(:) = 0.0
> global_proj_y_land(:) = 0.0
> ! Gather values onto master task.
> CALL gather_land_field( projection_x_coord_land, global_proj_x_land )
> CALL gather_land_field( projection_y_coord_land, global_proj_y_land )
> 
> IF ( is_master_task() ) THEN
> 
>   !----------------------------------------------------------------------------
>   ! Process coordinates and establish the extent of the river domain.
>   !----------------------------------------------------------------------------
>   CALL process_rivers_coords( l_find_grid, global_proj_x_land,                 &
>              global_proj_y_land, rivers%rivers_ygrid, rivers%rivers_xgrid,     &
>              rivers_dx,                                                        &
>              rivers_dy, rivers_x1, rivers_x1_input, rivers_y1, l_shift_x,      &
>              l_cyclic_x, l_reverse_y, rivers_reglatlon,                        &
>              rivers%global_land_index,                                         &
>              global_proj_x_land_work, river_xbound, river_ybound )
448a1083,1089
>   !----------------------------------------------------------------------------
>   ! If necessary remap from river input grid to river grid. This handles river
>   ! routing and overbank inundation variables.
>   !----------------------------------------------------------------------------
>   IF ( l_shift_x .OR. l_reverse_y ) THEN
>     CALL remap_ancil_control( nx_rivers, ny_rivers, rivers_dx, l_shift_x,      &
>                               l_reverse_y, rivers )
452c1093
<   ! Set variables that are using a constant value.
---
>   ! Convert the flow direction field into nextx and nexty fields.
454,455c1095,1119
<   CALL set_constant_vars( nvars, nvars_const, nvars_max, const_val,            &
<                           use_file, use_var, var )
---
>   CALL process_direction_fields( l_cyclic_x, rivers%rivers_dir,                &
>                                  direction_grid,                               &
>                                  nextx_grid, nexty_grid, river_mask )
> 
>   ! Comments below discriminate between river locations and river points.
>   ! River locations are any land point on the river grid.
>   ! River points are the subset of river locations that are modelled as rivers,
>   ! i.e. they are river locations within the valid river domain.
>   !
>   ! At this point all locations on the river grid fall into exactly one of the
>   ! following categories:
>   !
>   !  river locations that have a physical flow direction (that doesn't involve
>   !     flow across the edge of the grid):
>   !     nextx_grid is in [1:nx_rivers]
>   !     river_mask = land_off_domain
>   !  river locations that flow across the edge of the grid:
>   !     nextx_grid is in [-8:-1]
>   !     river_mask = land_off_domain
>   !  river locations that are mouths and inland drainage points:
>   !     nextx_grid is in [river_mouth, inland_drainage]
>   !     river_mask = land_off_domain
>   !  sea points:
>   !     nextx_grid = sea
>   !     river_mask = sea
458c1122
<   ! Set variables that are to be read from a file.
---
>   ! Establish the number and locations of river points.
460,461c1124,1159
<   CALL set_file_vars( nvars, nvars_file, nvars_max, l_have_template,           &
<                       RoutineName, use_file, use_var, file_name, var, var_name)
---
>   CALL find_river_points( rivers%rivers_xgrid, rivers%rivers_ygrid,            &
>                           river_xbound, river_ybound,                          &
>                           direction_grid, nextx_grid, nexty_grid,              &
>                           river_mask, np_rivers )
> 
>   ! direction_grid, nextx_grid and nexty_grid are not changed after this point.
>   !
>   ! At this point all locations on the river grid fall into exactly one of the
>   ! following categories:
>   !
>   !  river points that have a physical flow direction (that doesn't involve
>   !     flow across the edge of the grid):
>   !     nextx_grid is in [1:nx_rivers]
>   !     river_mask = land_in_domain
>   !  river points that flow across the edge of the grid):
>   !     nextx_grid is in [-8:-1]
>   !     river_mask = land_in_domain
>   !  river points that are mouths or inland drainage points:
>   !     nextx_grid = river_mouth or inland_drainage
>   !     river_mask = river_mouth or inland_drainage
>   !  river locations that are not in the domain (hence are not river points):
>   !     nextx_grid = land_off_domain
>   !     river_mask = land_off_domain
>   !  sea points:
>   !     nextx_grid = sea
>   !     river_mask = sea
> 
>   CALL log_info( RoutineName,                                                  &
>                  "River routing points = " // TRIM(to_string(np_rivers)) )
>   CALL log_info( RoutineName,                                                  &
>                  "Global land pts = " // TRIM(to_string(global_land_pts)) )
> 
>   IF ( np_rivers == 0 ) THEN
>     CALL log_fatal( RoutineName,                                               &
>                     "No river points found. Check inputs." )
>   END IF
463,471c1161,1169
<   !---------------------------------------------------------------------------
<   ! Create INTEGER version of rivers%rivers_dir. The REAL version is not used
<   ! after this.
<   !---------------------------------------------------------------------------
<   DO iy = 1, ny_rivers
<     DO ix = 1, nx_rivers
<       rivers_dir_int(ix,iy) = NINT( rivers%rivers_dir(ix,iy) )
<     END DO
<   END DO
---
>   !----------------------------------------------------------------------------
>   ! If required, check river number ancillary field.
>   ! We have waited until after find_river_points is called as that subroutine
>   ! can introduce additional river mouths.
>   !----------------------------------------------------------------------------
>   IF ( l_riv_number ) THEN
>     CALL check_ancil_rivers( dir_mouth, l_ignore_ancil_rivers_check,           &
>                              direction_grid, rivers, rivers_data )
>   END IF
473,476c1171
<   !---------------------------------------------------------------------------
<   ! Setup regular river routing grid (assuming same as model grid if not set
<   ! from namelist or model grid information)
<   !---------------------------------------------------------------------------
---
> END IF  ! is_master
478,483c1173,1176
<   ! Wrap longitude inputs -180 to +180
<   DO ix = 1,nx
<     IF ( rivers%rivers_xgrid(ix) > 180.0 ) THEN
<       rivers%rivers_xgrid(ix) = rivers%rivers_xgrid(ix) - 360.0
<     END IF
<   END DO
---
> !------------------------------------------------------------------------------
> ! Allocate routing point arrays.
> !------------------------------------------------------------------------------
> CALL allocate_rivers_vars_rp( np_rivers, rivers, rivers_data )
485,502c1178,1218
<   ! Set regular Lat/Lon grid variables (S to N)
<   rivers_lat1 = MINVAL( rivers%rivers_ygrid )
<   rivers_lon1 = MINVAL( rivers%rivers_xgrid )
<   rivers_dlat = ABS( rivers%rivers_ygrid(2) - rivers%rivers_ygrid(1) )
<   rivers_dlon = ABS( rivers%rivers_xgrid(2) - rivers%rivers_xgrid(1) )
< 
<   CALL mpi_comm_size(mpi_comm_world,ntasks,ERROR)
<   IF ( ntasks == 1 ) THEN
<     IF ( reg_dlat > -900.0 .OR. reg_dlon > -900.0 .OR.                         &
<         ny_grid > 0 .OR. nx_grid > 0 .OR.                                      &
<         reg_lat1 > -900.0 .OR. reg_lon1  > -900.0 ) THEN
< 
<       CALL log_info(RoutineName,                                               &
<                    "Running in serial mode and with grid_is_1d==.FALSE. " //   &
<                    "means that the values; nx_grid, ny_grid, reg_dlat, "  //   &
<                    "reg_dlon, reg_lat1 and reg_lon1 will be ignored "     //   &
<                    "in the init_rivers_props namelist.")
<     END IF
---
> !------------------------------------------------------------------------------
> ! Allocate overbank inundation variables.
> !------------------------------------------------------------------------------
> CALL allocate_overbank_vars_rp( land_pts, np_rivers )
> 
> IF ( is_master_task() ) THEN
> 
>   !----------------------------------------------------------------------------
>   ! Set values at river points.
>   !----------------------------------------------------------------------------
>   CALL set_river_point_values( rivers_x1_input, l_use_area, direction_grid,    &
>                                river_mask, rivers, grid_riv_pt_number )
> 
>   !----------------------------------------------------------------------------
>   ! Identify downstream points.
>   !----------------------------------------------------------------------------
>   CALL find_downstream_points( direction_grid, nextx_grid, nexty_grid,         &
>                                rivers%rivers_index_rp, river_mask,             &
>                                rivers%rivers_next_rp)
> 
>   ! At this point all values of rivers%rivers_next_rp are one of the following:
>   !   >0              : there is a downstream river point (in the river points
>   !                     vector)
>   !   river_mouth     : a river mouth
>   !   inland_drainage : an inland drainage point
>   !   -8:-1           : the downstream location is not a river point - because
>   !                     it is outside of the valid river domain (and possibly
>   !                     off the river grid).
> 
>   ! Note that the science code could use rivers%rivers_next_rp values in -8:-1
>   ! to sum flow across the edge of the domain, e.g. to check conservation of
>   ! mass. That is not currently coded.
> 
>   !----------------------------------------------------------------------------
>   ! Calculate river length scale and gridbox areas.
>   !----------------------------------------------------------------------------
>   IF ( l_calc_rivers_length ) THEN
>     ! Calculate length scale from grid parameters. Here rivers_dy will be the
>     ! gridbox size (degrees), because l_calc_rivers_length can be TRUE only
>     ! for lat-lon grids.
>     rivers_length = planet_radius * ( ABS( rivers_dy ) * pi_over_180 )
505c1221,1312
<   IF ( reg_lon1 <= -900.0 .OR. reg_lat1 <= -900.0 ) THEN
---
>   IF ( rivers_reglatlon ) THEN
>     half_dlat = 0.5 * rivers_dy
>     half_dlon = 0.5 * rivers_dx
>     DO ip = 1,np_rivers
>       rivers%rivers_boxareas_rp(ip) =                                          &
>         ABS( rivers_earth_area( rivers%rivers_lat_rp(ip) - half_dlat,          &
>                                 rivers%rivers_lat_rp(ip) + half_dlat,          &
>                                 rivers%rivers_lon_rp(ip) - half_dlon,          &
>                                 rivers%rivers_lon_rp(ip) + half_dlon ) )
>     END DO
>   ELSE
>     ! Note that this assumes that grids that are not using lat-lon coordinates
>     ! are equal area grids - i.e. all gridboxes have the same area.
>     rivers%rivers_boxareas_rp(:) = rivers_length * rivers_length
>   END IF
> 
>   IF ( .NOT. l_oasis_rivers ) THEN
>     !--------------------------------------------------------------------------
>     ! Calculate mapping ahead of main run.
>     !--------------------------------------------------------------------------
>     IF ( .NOT. rivers_regrid ) THEN
>       ! Find land points that are coincident with river points.
>       ! For large grids, this can be slow, hence we issue messages to keep the
>       ! user informed.
>       CALL log_info( RoutineName,                                              &
>                      "Searching for matching river and land points." )
>       CALL calc_map_river_to_land_points( global_land_pts,                     &
>                                  global_proj_x_land_work, global_proj_y_land,  &
>                                  rivers%rivers_x_coord_rp,                     &
>                                  rivers%rivers_y_coord_rp,                     &
>                                  rivers%map_river_to_land_points )
>       CALL log_info( RoutineName, "Search complete." )
> 
>       ! Note that if the mapping between land and river points is trivial
>       ! (indicated by l_trivial_mapping=T) we could deallocate
>       ! map_river_to_land_points at this point - but that has not beed coded.
> 
>     END IF  !  rivers_regrid
> 
>     !--------------------------------------------------------------------------
>     ! Calculate diagnostics of grid coverage.
>     !--------------------------------------------------------------------------
>     CALL check_river_coverage( rivers%map_river_to_land_points,                &
>                                global_proj_x_land_work, global_proj_y_land,    &
>                                rivers%rivers_x_coord_rp,                       &
>                                rivers%rivers_y_coord_rp )
> 
>   END IF  !  .NOT. l_oasis_rivers
> 
> END IF !  is_master_task
> 
> !------------------------------------------------------------------------------
> ! Dellocate local arrays.
> !------------------------------------------------------------------------------
> ! Variables that are allocated on all tasks.
> DEALLOCATE( global_proj_x_land )
> DEALLOCATE( global_proj_x_land_work )
> DEALLOCATE( global_proj_y_land )
> 
> ! Variables that are only allocated on master task.
> IF ( ALLOCATED(direction_grid) ) THEN
>   DEALLOCATE( direction_grid )
> END IF
> IF ( ALLOCATED(grid_riv_pt_number) ) THEN
>   DEALLOCATE( grid_riv_pt_number )
> END IF
> IF ( ALLOCATED(nextx_grid) ) THEN
>   DEALLOCATE( nextx_grid )
> END IF
> IF ( ALLOCATED(nexty_grid) ) THEN
>   DEALLOCATE( nexty_grid )
> END IF
> IF ( ALLOCATED(river_mask) ) THEN
>   DEALLOCATE( river_mask )
> END IF
> 
> RETURN
> END SUBROUTINE process_rivers_data
> 
> !##############################################################################
> 
> SUBROUTINE process_rivers_coords( l_find_grid, global_proj_x_land,             &
>              global_proj_y_land, rivers_ygrid, rivers_xgrid, rivers_dx,        &
>              rivers_dy, rivers_x1, rivers_x1_input, rivers_y1, l_shift_x,      &
>              l_cyclic_x, l_reverse_y, rivers_reglatlon, global_land_index,     &
>              global_proj_x_land_work, river_xbound, river_ybound )
> 
> !------------------------------------------------------------------------------
> ! Description:
> !   Process river coordinates, calculating characteristics and checking that
> !   grids make sense.
> !------------------------------------------------------------------------------
507,508c1314,1316
<     ! Infer model grid settings for 1-dimensional grid input
<     IF ( model_grid%nx == 1 .OR. .NOT. rivers_reglatlon ) THEN
---
> USE jules_rivers_mod, ONLY:                                                    &
>   nx_land_grid, nx_rivers, ny_land_grid, ny_rivers, land_dx, land_dy,          &
>   rivers_regrid, rivers_type, x1_land_grid, y1_land_grid
510,517c1318,1319
<       CALL log_info(RoutineName,                                               &
<               "No regular model grid set - assuming same as routing grid")
<       nx_grid  = nx_rivers
<       ny_grid  = ny_rivers
<       reg_lat1 = rivers_lat1
<       reg_lon1 = rivers_lon1
<       reg_dlon = rivers_dlon
<       reg_dlat = rivers_dlat
---
> USE model_grid_mod, ONLY:                                                      &
>   global_land_pts, l_coord_latlon
519c1321
<     ELSE
---
> USE rivers_regrid_mod, ONLY: calc_grid_index
521,528c1323
<       CALL log_info(RoutineName,                                               &
<                "Using 2D input model grid to define grid parameters")
<       nx_grid  = SIZE( latitude,1 )
<       ny_grid  = SIZE( latitude,2 )
<       reg_lat1 = MINVAL( latitude )
<       reg_lon1 = MINVAL( longitude )
<       reg_dlon = ABS( longitude(2,2) - longitude(1,1) )
<       reg_dlat = ABS( latitude(2,2) - latitude(1,1) )
---
> IMPLICIT NONE
530c1325,1565
<     END IF
---
> !------------------------------------------------------------------------------
> ! Scalar arguments with INTENT(IN)
> !------------------------------------------------------------------------------
> LOGICAL, INTENT(IN) ::                                                         &
>   l_find_grid
>     ! Switch controlling how characteristics of the land and rivers grids are
>     ! determined.
> 
> !------------------------------------------------------------------------------
> ! Array arguments with INTENT(IN)
> !------------------------------------------------------------------------------
> REAL(KIND=real_jlslsm), INTENT(IN) ::                                          &
>   global_proj_x_land(global_land_pts), global_proj_y_land(global_land_pts),    &
>     ! Coordinates of land points.
>   rivers_ygrid(ny_rivers)
>    ! Coordinate values for y-dimension of rivers grid
> 
> !------------------------------------------------------------------------------
> ! Array arguments with INTENT(IN OUT)
> !------------------------------------------------------------------------------
> REAL(KIND=real_jlslsm), INTENT(IN OUT) ::                                      &
>   rivers_xgrid(nx_rivers)
>     ! Coordinate values for x-dimension of rivers grid.
> 
> !------------------------------------------------------------------------------
> ! Scalar arguments with INTENT(OUT)
> !------------------------------------------------------------------------------
> REAL(KIND=real_jlslsm), INTENT(OUT) ::                                         &
>   rivers_dx,                                                                   &
>     ! Size of gridbox of rivers grid in x direction.
>     ! If l_coord_latlon=T, the units are degrees of longitude, otherwise units
>     ! are unknown.
>   rivers_dy,                                                                   &
>     ! Size of gridbox of rivers grid in y direction.
>     ! If l_coord_latlon=T, the units are degrees of latitude, otherwise units
>     ! are unknown.
>   rivers_x1,                                                                   &
>     ! x coordinate of of westernmost (first) column of gridpoints on the
>     ! rivers grid.
>   rivers_x1_input,                                                             &
>     ! The first value of the x coordinate of the river input grid.
>   rivers_y1
>     ! y coordinate of "southernmost" (first) row of gridpoints on the rivers
>     ! grid.
> 
> LOGICAL, INTENT(OUT) ::                                                        &
>   l_shift_x,                                                                   &
>     ! Flag indicating that a cyclic shift is to be applied in the x direction
>     ! to river ancillaries. This can be TRUE only if the coordinate is
>     ! longitude.
>   l_cyclic_x,                                                                  &
>     ! Flag indicating a river input grid that is cyclic (global) in the x
>     ! direction.
>   l_reverse_y,                                                                 &
>     ! Flag indicating if the order in the y direction of ancillary fields is to
>     ! be reversed so that the coordinate is monotonically increasing.
>   rivers_reglatlon
>     ! Flag indicating if rivers grid is regular in latitude and longitude.
> 
> !------------------------------------------------------------------------------
> ! Array arguments with INTENT(OUT)
> !------------------------------------------------------------------------------
> INTEGER, INTENT(OUT) ::                                                        &
>   global_land_index(global_land_pts)
>     ! List of indices for the land grid. For every land point, this gives the
>     ! location in a 2-D grid.
> 
> REAL(KIND=real_jlslsm), INTENT(OUT) ::                                         &
>   global_proj_x_land_work(global_land_pts),                                    &
>     ! x coordinates of land points, including any transformation.
>   river_xbound(2), river_ybound(2)
>     ! Coordinates of the corners of the river domain - i.e. that part of the
>     ! river input grid that will be searched for river points. Units as given
>     ! by rivers_xgrid and rivers_ygrid.
> 
> !------------------------------------------------------------------------------
> ! Local parameters.
> !------------------------------------------------------------------------------
> REAL(KIND=real_jlslsm), PARAMETER :: global_lon_threshold = 359.9
>   ! Threshold value used when determining if a grid is cyclic (global) in the
>   ! longitudinal direction (degrees). This should be close to 360 degrees.
> 
> CHARACTER(LEN=*), PARAMETER :: RoutineName = 'PROCESS_RIVERS_COORDS'
> 
> !------------------------------------------------------------------------------
> ! Local scalar variables.
> !------------------------------------------------------------------------------
> INTEGER ::                                                                     &
>   i, ix, iy, l,                                                                &
>     ! Index variables
>   n_change
>     ! Counter of number of longitudes that have been changed.
> 
> LOGICAL ::                                                                     &
>   l_land_180,                                                                  &
>     ! Flag indicating the range of land point longitudes.
>   l_river_180
>     ! Flag indicating the range of river longitudes.
> 
> !------------------------------------------------------------------------------
> ! Local array variables.
> !------------------------------------------------------------------------------
> INTEGER ::                                                                     &
>   land_index_tmp(global_land_pts)
>     ! Local version of global land index.
> 
> !-----------------------------------------------------------------------------
> ! Local array variables.
> !-----------------------------------------------------------------------------
> REAL(KIND=real_jlslsm) :: land_x(2), land_y(2)
>   ! Min and max values of the projection coordinates, at land points.
> 
> REAL(KIND=real_jlslsm) :: land_xbound(2), land_ybound(2)
>   ! Coordinates of the "extreme" land gridpoints (e.g. gridpoints at the
>   ! corners of the grid - though exact definition differs between
>   ! configurations). Units are those of the land grid projection coords.
> 
> !end of header
> !------------------------------------------------------------------------------
> 
> ! Initialise flag to show that we will not apply a cyclic shift to the input
> ! data (as part of the process of matching the land and river coordinates).
> l_shift_x = .FALSE.
> 
> !------------------------------------------------------------------------------
> ! Get river gridbox size.
> !------------------------------------------------------------------------------
> rivers_dy = ABS( rivers_ygrid(2) - rivers_ygrid(1) )
> rivers_dx = ABS( rivers_xgrid(2) - rivers_xgrid(1) )
> CALL log_info( RoutineName,                                                    &
>                'River gridbox size='                                        // &
>                TRIM(to_string(rivers_dx)) // ' x '                          // &
>                TRIM(to_string(rivers_dy)) )
> 
> !------------------------------------------------------------------------------
> ! Check if the river grid is regular.
> !------------------------------------------------------------------------------
> ! We assume that we always need a regular river grid, because:
> ! * if we are regridding, we need regular lat-lon
> ! * if not regridding (i.e. 1:1 mapping) it is easier if we can use a single
> !   length scale to characterise distances and areas.
> !
> ! For each coordinate value we compare with the previous value and flag if
> ! the separation does not match the expected uniform grid -
> ! if the difference is a non-negligible fraction of a gridbox.
> ! Essentially we are checking that this location appears to be on or
> ! "sufficiently close" to the grid (where "sufficiently close" allows for
> ! differences from the finite precision of the calculation).
> ! Note that comparing adjacent values in this way, rather than comparing
> ! each with an origin, seems to suffer less from issues related to
> ! precision.
> 
> ! Check spacings in x are regular.
> ! We can start at i=3 because 1 and 2 were used to get rivers_dx.
> DO i = 3, nx_rivers
>   IF ( ABS( ABS( rivers_xgrid(i) -  rivers_xgrid(i-1) )                        &
>             - rivers_dx ) / rivers_dx  > frac_toler ) THEN
>     CALL log_fatal( RoutineName, "River input grid must be regular (x)." )
>   END IF
> END DO
> 
> ! Check spacings in y are regular.
> DO i = 3, ny_rivers
>   IF ( ABS( ABS( rivers_ygrid(i) -  rivers_ygrid(i-1) )                        &
>             - rivers_dy ) / rivers_dy  > frac_toler ) THEN
>     CALL log_fatal( RoutineName, "River input grid must be regular (y)." )
>   END IF
> END DO
> 
> IF ( l_coord_latlon ) THEN
>   ! This is a regular lat-lon river grid.
>   rivers_reglatlon = .TRUE.
>   CALL log_info( RoutineName, "River grid is a regular lat-lon grid." )
> ELSE
>   rivers_reglatlon = .FALSE.
> END IF
> 
> IF ( .NOT. rivers_reglatlon .AND. rivers_regrid ) THEN
>   ! Regridding requires a regular lat-lon grid.
>   CALL log_fatal( RoutineName,                                                 &
>                   "River grid is not a regular lat-lon grid but regridding" // &
>                   "is requested. This is not supported." )
> ELSE IF ( .NOT. rivers_regrid ) THEN
>   ! Remapping requires grids of the same resolution. Here we test that the
>   ! difference does not exceed a given fraction of the land resolution.
>   IF ( ABS(rivers_dx - land_dx) > frac_toler * land_dx .OR.                    &
>        ABS(rivers_dy - land_dy) > frac_toler * land_dy ) THEN
>     CALL log_fatal( RoutineName,                                               &
>                     "Land and river grids are not of the same resolution " //  &
>                     "but regridding is not requested. This is not supported." )
>   END IF
> END IF
> 
> !------------------------------------------------------------------------------
> ! Detect if y coordinates are presented in increasing or decreasing order.
> ! We simply compare the extreme points.
> !------------------------------------------------------------------------------
> l_reverse_y = .FALSE.
> IF ( rivers_ygrid(1) > rivers_ygrid(ny_rivers) ) THEN
> 
>   l_reverse_y = .TRUE.
> 
>   !----------------------------------------------------------------------------
>   ! If l_coord_latlon=T (coordinates are latitude and longitude) this code
>   ! includes provision for reading input files that are presented in N to S
>   ! order before recasting the data in S to N order. Although we could allow
>   ! the same for l_coord_latlon=F, it is simpler to insist that in that case
>   ! the coordinates are presented in strictly increasing order.
>   !---------------------------------------------------------------------------
>   IF ( .NOT. l_coord_latlon ) THEN
>     CALL log_fatal( RoutineName,                                               &
>                     "l_coord_latlon=F requires that river coordinates "     // &
>                     "are presented in strictly increasing order." )
>   END IF
> 
> END IF  !  rivers_ygrid
> 
> !------------------------------------------------------------------------------
> ! Identify a grid for land points. This also sets other values that are always
> ! needed, even if details of the grid are not required.
> !------------------------------------------------------------------------------
> CALL find_land_grid( l_find_grid, global_proj_x_land, global_proj_y_land,      &
>                      nx_land_grid, ny_land_grid, x1_land_grid, y1_land_grid,   &
>                      l_land_180, global_proj_x_land_work, land_x, land_y )
> 
> !------------------------------------------------------------------------------
> ! Check that longitudes for land and river points are in the same range.
> ! This is only required if coordinates are latitude and longitude, because of
> ! the different ranges that are in common use. For other coordinate systems
> ! it is assumed that land and river grids use the same general range. If land
> ! and river ranges differ, the river longitudes are changed.
> !------------------------------------------------------------------------------
> IF ( l_coord_latlon ) THEN
>   ! Establish if longitude values of land and river grids are in the same
>   ! range. In particular, we want both to either use values in the range
>   ! [-180,180] or [0,360]. We assume that the presence of any value < 0
>   ! means [-180,180] is used, otherwise it is [0,360]. Note that the longitudes
>   ! of land points might have been changed to a new range so as to allow a
>   ! smaller land grid.
>   IF ( MINVAL( rivers_xgrid ) < 0.0 ) THEN
>     l_river_180 = .TRUE.
532,537c1567
<     IF ( reg_dlat <= -900.0 .OR. reg_dlon <= -900.0 .OR.                       &
<          ny_grid <= 0 .OR. nx_grid <= 0 ) THEN
<       CALL log_info(RoutineName,                                               &
<                     "If reg_lon1 and reg_lat1 are specified in namelist," //   &
<           " then you must specify reg_dlat, reg_dlon, ny_grid, nx_grid too." )
<     END IF
---
>     l_river_180 = .FALSE.
540,548c1570,1571
<   CALL log_info(RoutineName,"Setting regular routing grid " //                 &
<             " Minimum " // TRIM(x_dim_name) // ": " //                         &
<               TRIM(to_string(MINVAL(rivers%rivers_xgrid)))  //                 &
<             " Minimum " // TRIM(y_dim_name) // ": " //                         &
<               TRIM(to_string(MINVAL(rivers%rivers_ygrid))) //                  &
<             " Maximum " // TRIM(x_dim_name) // ": " //                         &
<               TRIM(to_string(MAXVAL(rivers%rivers_xgrid))) //                  &
<             " Maximum " // TRIM(y_dim_name) // ": " //                         &
<               TRIM(to_string(MAXVAL(rivers%rivers_ygrid))))
---
>   ! If ranges are different, change river values.
>   IF ( l_land_180 .NEQV. l_river_180 ) THEN
550,560c1573,1579
<   !---------------------------------------------------------------------------
<   ! Decide if the river grid is cyclic (global) in the x direction. We can
<   ! only do this reliably for a regular lat-lon grid - otherwise we have to
<   ! assume that it is not cyclic.
<   !---------------------------------------------------------------------------
<   l_cyclic_x = .FALSE.
<   IF ( rivers_reglatlon ) THEN
<     IF ( MAXVAL(rivers%rivers_xgrid) - rivers_lon1 + rivers_dlon               &
<          > global_lon_threshold ) THEN
<       l_cyclic_x = .TRUE.
<       CALL log_info(RoutineName,"River grid is cyclic in longitude.")
---
>     IF ( l_land_180 ) THEN
>       ! Land uses [-180,180]. Change river to [-180,180].
>       CALL change_longitude_from_360( rivers_xgrid, n_change )
>     ELSE
>       ! l_river_180=T.
>       ! Land uses [0,360]. Change river to [0,360].
>       CALL change_longitude_from_180( rivers_xgrid, n_change )
561a1581,1753
> 
>     ! Set a flag if some values were changed but others were not - because
>     ! this suggests that a cyclic shift in the x direction is required.
>     IF ( n_change /= nx_rivers ) THEN
>       l_shift_x = .TRUE.
>     END IF
> 
>   END IF  !  l_land_180 .NEQV. l_river_180
> 
> END IF  !  l_coord_latlon
> 
> !------------------------------------------------------------------------------
> ! Now that we have finished manipulating rivers_xgrid, we can save minima.
> ! Note that rivers_xgrid might no longer be strictly increasing - there could
> ! be a discontinuity at 180 or 360degE, which is catered for in the code. (It
> ! is assumed that input coordinates were strictly increasing.)
> !------------------------------------------------------------------------------
> rivers_x1 = MINVAL( rivers_xgrid )
> rivers_y1 = MINVAL( rivers_ygrid )
> 
> ! Save the first x-coord value of the river input grid.
> rivers_x1_input = rivers_xgrid(1)
> 
> CALL log_info( RoutineName,"River routing grid: x " //                         &
>                TRIM(to_string(MINVAL(rivers_xgrid)))  //  ' to ' //            &
>                TRIM(to_string(MAXVAL(rivers_xgrid))) //   ' y '  //            &
>                TRIM(to_string(MINVAL(rivers_ygrid))) //   ' to ' //            &
>                TRIM(to_string(MAXVAL(rivers_ygrid))) )
> 
> !------------------------------------------------------------------------------
> ! Decide if the river grid is cyclic (global) in the x direction. We can
> ! only do this reliably for a regular lat-lon grid - otherwise we have to
> ! assume that it is not cyclic.
> !------------------------------------------------------------------------------
> l_cyclic_x = .FALSE.
> IF ( rivers_reglatlon ) THEN
>   IF ( REAL(nx_rivers) * rivers_dx > global_lon_threshold ) THEN
>     l_cyclic_x = .TRUE.
>     CALL log_info( RoutineName, "River grid is cyclic in longitude." )
>   END IF
> END IF
> 
> !------------------------------------------------------------------------------
> ! Raise an error if a cyclic shift in x is indicated but the grid is not
> ! global in longitude.
> !------------------------------------------------------------------------------
> IF ( l_shift_x .AND. .NOT. l_cyclic_x ) THEN
>   CALL log_fatal( RoutineName,                                                 &
>                   "A cyclic shift can only be applied to a grid that is "   // &
>                   "cyclic (global) in longitude - see code for details. A " // &
>                   "possible solution is to use a cyclic (global) river "    // &
>                   "input grid.")
> END IF
> 
> !------------------------------------------------------------------------------
> ! Identify the coordinate values that delimit the river domain - i.e. the part
> ! of the river grid that is to be searched for river points.
> !
> ! In general the most satisfactory arrangement is if each land gridbox is
> ! completely covered by river points, and vice versa. In that case all runoff
> ! (from the land boxes) will be captured by the rivers, and all river boxes
> ! have well-defined runoff inputs. However:
> ! (1) Historically JULES could run with river boxes that did not include land
> !     (e.g. a large river domain in which a small land grid is embedded) and
> !     we need to be able to reproduce those configurations. The simulated
> !     river flow in these river boxes will not be realistic but this
> !     configuration could still be considered useful if, e.g., only river
> !     points within the land grid are considered and the river network is not
> !     missing upstream areas that contribute a significant amount of runoff.
> ! (2) In general it is non-trivial to reliably establish the overlap between
> !     grids which can be of different resolutions.
> !------------------------------------------------------------------------------
> IF ( l_find_grid ) THEN
> 
>   ! In both cases here, the river bounds are related to the extent of the land
>   ! grid. This means that if the river input grid is much larger than the land
>   ! grid, river points will not be added beyond the land grid. Although this
>   ! is reasonable (with no land we can't define inputs to rivers), it is a
>   ! restriction that is not present with l_find_grid=F.
>   IF ( rivers_regrid ) THEN
>     ! We know we are dealing with regular lat-lon grids in this case.
>     ! Ideally only want to include river boxes that are completely covered by
>     ! land (so that the input runoff can be calculated). However, given that
>     ! is relatively difficult to determine in the general case of grids of
>     ! different resolution and potentially a domain that includes land and sea
>     ! (i.e. we do not have a rectangle that is all land), we instead use a
>     ! necessary but not sufficient condition, that the river box falls within
>     ! the extremes of the land grid.
>     ! Calculate the coordinates (lat-lon) of the outer edges of the land grid
>     ! - i.e. outside edges of gridboxes (not centres).
>     land_xbound(1) = land_x(1) - 0.5 * land_dx
>     land_xbound(2) = land_x(2) + 0.5 * land_dx
>     land_ybound(1) = land_y(1) - 0.5 * land_dy
>     land_ybound(2) = land_y(2) + 0.5 * land_dy
> 
>     ! Calculate the coordinates of the extreme river gridpoints allowed within
>     ! the river domain. These have to be at least half a river gridbox
>     ! away from the outer edge of the land domain, so that the edges of the
>     ! the gridbox still lie within the land domain. We then allow a small
>     ! tolerance (to allow for imprecise arithmetic) by moving the bounds out
>     ! by a fraction of a gridbox (increasing the size of the rectangle).
>     river_xbound(1) = land_xbound(1) + ( 0.5 - frac_toler ) * rivers_dx
>     river_xbound(2) = land_xbound(2) - ( 0.5 - frac_toler ) * rivers_dx
>     river_ybound(1) = land_ybound(1) + ( 0.5 - frac_toler ) * rivers_dy
>     river_ybound(2) = land_ybound(2) - ( 0.5 - frac_toler ) * rivers_dy
>   ELSE
>     ! .NOT. rivers_regrid
>     ! In this case we only need to set the bounding coordinates so that they
>     ! do not exclude any land points. We have land and river boxes of the
>     ! same resolution and we allow a small tolerance when comparing
>     ! coordinates.
>     river_xbound(1) = land_x(1) - frac_toler * land_dx
>     river_xbound(2) = land_x(2) + frac_toler * land_dx
>     river_ybound(1) = land_y(1) - frac_toler * land_dy
>     river_ybound(2) = land_y(2) + frac_toler * land_dy
>   END IF  !  rivers_regrid
> 
> ELSE
>   !  .NOT. l_find_grid
> 
>   ! Use values from the namelist. The coordinates used to outline the valid
>   ! domain are calculated as in older versions - essentially assuming that
>   ! input parameters (e.g. y1_land_grid, ny_land_grid) are reasonable.
>   ! If these inputs are not specified correctly, the model might still run but
>   ! the results can be dubious - e.g. river points can be set up outside the
>   ! area of the land grid but these will not have any runoff inputs, meaning
>   ! the modelled riverflows are compromised. In other instances an error will
>   ! be raised at a later stage.
> 
>   ! In the older code, river gridpoints were simply compared with these
>   ! notional land extremes - and we do that here.
>   ! If we assume that x1_land_grid and y1_land_grid have been set to indicate
>   ! the gridpoint in the SW corner of the land grid, and nx_land_grid and
>   ! ny_land_grid are the smallest values that include all land points, then by
>   ! using nx_land_grid (rather than nx_land_grid-1) this calculation
>   ! effectively allows an extra column of points at the E edge (and similarly
>   ! in the y direction), i.e. the domain would be larger than required.
>   river_xbound(1) = x1_land_grid
>   river_xbound(2) = x1_land_grid + nx_land_grid * land_dx
>   river_ybound(1) = y1_land_grid
>   river_ybound(2) = y1_land_grid + ny_land_grid * land_dy
> 
> END IF  !  l_find_grid
> 
> CALL log_info( RoutineName,                                                    &
>                "River points will be searched for in x "                    // &
>                TRIM(to_string(river_xbound(1))) // ' to '                   // &
>                TRIM(to_string(river_xbound(2))) // ' y '                    // &
>                TRIM(to_string(river_ybound(1))) // ' to '                   // &
>                TRIM(to_string(river_ybound(2))) )
> 
> !------------------------------------------------------------------------------
> ! If we have a regular lat-lon river grid (which requires that the land grid
> ! must also be regular lat-lon, for regridding or mapping) check that land
> ! points fall on the regular grid (which was precribed or calculated) and
> ! return the mapping index.
> ! Although remapping does not strictly require a grid, CALC_GRID_INDEX includes
> ! some useful checks that test whether the declared grid is consistent with the
> ! data values. Hence we call it for l_find_grid=F because in that case the
> ! declared grid is used to set the bounds of the river domain.
> ! Note that here we use the longitudes that might have been changed to a new
> ! range so as to allow a smaller land grid.
> !------------------------------------------------------------------------------
> IF ( rivers_reglatlon ) THEN
>   IF ( rivers_regrid .OR. .NOT. l_find_grid ) THEN
>     CALL calc_grid_index( global_land_pts, nx_land_grid, ny_land_grid,         &
>                           land_dx, land_dy, frac_toler, x1_land_grid,          &
>                           y1_land_grid, global_proj_x_land_work,               &
>                           global_proj_y_land, land_index_tmp )
>   END IF
>   IF ( rivers_regrid ) THEN
>     ! Save the land index.
>     global_land_index(:) = land_index_tmp(:)
562a1755
> END IF  !  rivers_reglatlon
564,566c1757,1758
<   !---------------------------------------------------------------------------
<   ! Process the namelist values and set derived variables
<   !---------------------------------------------------------------------------
---
> RETURN
> END SUBROUTINE process_rivers_coords
568,570c1760,2163
<   ! Calculate maximum lat and lon of land grid.
<   reg_lat2 = reg_lat1 + ny_grid * reg_dlat
<   reg_lon2 = reg_lon1 + nx_grid * reg_dlon
---
> !##############################################################################
> 
> SUBROUTINE remap_ancil_control( nx_rivers, ny_rivers, rivers_dx, l_shift_x,    &
>                                 l_reverse_y, rivers )
> 
> !------------------------------------------------------------------------------
> ! Description:
> !   Controls the transfer of ancillary fields from the river input grid to the
> !   river grid.
> !------------------------------------------------------------------------------
> 
> USE jules_rivers_mod, ONLY:                                                    &
>   l_riv_overbank, rivers_type
> 
> USE init_overbank_props_mod, ONLY:                                             &
>   nvars_overbank=>nvars_required, required_vars_overbank=>required_vars
> 
> IMPLICIT NONE
> 
> !------------------------------------------------------------------------------
> ! Scalar arguments with INTENT(IN)
> !------------------------------------------------------------------------------
> INTEGER, INTENT(IN) ::                                                         &
>   nx_rivers, ny_rivers  ! Sizes of field.
> 
> REAL(KIND=real_jlslsm), INTENT(IN) ::                                          &
>   rivers_dx
>     !  Size of rivers gridbox in the x direction.
> 
> LOGICAL, INTENT(IN) ::                                                         &
>   l_shift_x,                                                                   &
>     ! Flag indicating that a cyclic shift is to be applied in the x direction
>     ! to river ancillaries. This can be TRUE only if the coordinate is
>     ! longitude.
>   l_reverse_y
>     ! Flag indicating if the order in the y direction of ancillary fields is
>     ! to be reversed so that the coordinate is monotonically increasing.
> 
> !------------------------------------------------------------------------------
> ! Type arguments with INTENT(IN OUT)
> !------------------------------------------------------------------------------
> TYPE(rivers_type), INTENT(IN OUT) :: rivers
> 
> !------------------------------------------------------------------------------
> ! Local scalar variables.
> !------------------------------------------------------------------------------
> INTEGER :: ivar  !  Loop counter.
> 
> !end of header
> !------------------------------------------------------------------------------
> 
> !------------------------------------------------------------------------------
> ! Deal with river fields.
> !------------------------------------------------------------------------------
> ! Loop through required fields.
> DO ivar=1, nvars_required
>   CALL remap_ancil( nx_rivers, ny_rivers, rivers_dx, l_shift_x, l_reverse_y,   &
>                     required_vars(ivar), rivers )
> END DO
> 
> ! Deal with the river outflow number field.
> IF ( l_riv_number ) THEN
>   CALL remap_ancil( nx_rivers, ny_rivers, rivers_dx, l_shift_x, l_reverse_y,   &
>                     'rivers_outflow_number', rivers )
> END IF
> 
> !------------------------------------------------------------------------------
> ! Deal with overbank inundation fields.
> !------------------------------------------------------------------------------
> IF ( l_riv_overbank ) THEN
>   DO ivar=1, nvars_overbank
>     CALL remap_ancil( nx_rivers, ny_rivers, rivers_dx, l_shift_x, l_reverse_y, &
>                       required_vars_overbank(ivar), rivers )
>   END DO
> END IF
> 
> !------------------------------------------------------------------------------
> ! Having used the river coordinates to remap all the required fields, we now
> ! change the coordinates themselves. This stage must be done after all other
> ! fields have been remapped.
> !------------------------------------------------------------------------------
> IF ( l_shift_x ) THEN
>   CALL remap_ancil( nx_rivers, ny_rivers, rivers_dx, l_shift_x, l_reverse_y,   &
>                     'rivers_xgrid', rivers )
> END IF
> 
> IF ( l_reverse_y ) THEN
>   CALL remap_ancil( nx_rivers, ny_rivers, rivers_dx, l_shift_x, l_reverse_y,   &
>                     'rivers_ygrid', rivers )
> END IF
> 
> RETURN
> END SUBROUTINE remap_ancil_control
> 
> !##############################################################################
> 
> SUBROUTINE remap_ancil( nx_rivers, ny_rivers, rivers_dx,                       &
>                         l_shift_x, l_reverse_y, var, rivers )
> 
> !------------------------------------------------------------------------------
> ! Description:
> !   Provides functionality to transfer each river ancillary field from the
> !   river input grid to the river grid.
> !------------------------------------------------------------------------------
> 
> USE jules_rivers_mod, ONLY:                                                    &
>   rivers_type
> 
> USE overbank_inundation_mod, ONLY:                                             &
>   logn_mean, logn_stdev
> 
> IMPLICIT NONE
> 
> !------------------------------------------------------------------------------
> ! Scalar arguments with INTENT(IN)
> !------------------------------------------------------------------------------
> INTEGER, INTENT(IN) ::                                                         &
>   nx_rivers, ny_rivers  ! Sizes of field.
> 
> REAL(KIND=real_jlslsm), INTENT(IN) ::                                          &
>   rivers_dx
>     !  Size of rivers gridbox in the x direction.
> 
> LOGICAL, INTENT(IN) ::                                                         &
>   l_shift_x,                                                                   &
>     ! Flag indicating that a cyclic shift is to be applied in the x direction
>     ! to river ancillaries. This can be TRUE only if the coordinate is
>     ! longitude.
>   l_reverse_y
>     ! Flag indicating if the order in the y direction of ancillary fields is
>     ! to be reversed so that the coordinate is monotonically increasing.
> 
> CHARACTER(LEN=*), INTENT(IN) :: var
>     ! The name of a variable.
> 
> !------------------------------------------------------------------------------
> ! Type arguments with INTENT(IN OUT)
> !------------------------------------------------------------------------------
> TYPE(rivers_type), INTENT(IN OUT) :: rivers
> 
> !------------------------------------------------------------------------------
> ! Local parameters.
> !------------------------------------------------------------------------------
> CHARACTER(LEN=*), PARAMETER :: RoutineName = 'REMAP_ANCIL'
> 
> !------------------------------------------------------------------------------
> ! Local variables.
> !------------------------------------------------------------------------------
> REAL(KIND=real_jlslsm) ::                                                      &
>   tmp_2d_coord(nx_rivers,ny_rivers)
>     ! A 2-D version of a 1-D coordinate variable.
> 
> !end of header
> !------------------------------------------------------------------------------
> 
> SELECT CASE ( var )
> 
>   !----------------------------------------------------------------------------
>   ! Cases for river (not overbank) variables.
>   !----------------------------------------------------------------------------
> CASE ( 'area' )
>   CALL remap_field( nx_rivers, ny_rivers, rivers_dx, l_shift_x, l_reverse_y,   &
>                     rivers%rivers_xgrid, rivers%rivers_dra )
> 
> CASE ( 'direction' )
>   CALL remap_field( nx_rivers, ny_rivers, rivers_dx, l_shift_x, l_reverse_y,   &
>                     rivers%rivers_xgrid, rivers%rivers_dir )
> 
> CASE ( 'latitude_2d' )
>   CALL remap_field( nx_rivers, ny_rivers, rivers_dx, l_shift_x, l_reverse_y,   &
>                     rivers%rivers_xgrid, rivers%rivers_lat2d )
> 
> CASE ( 'longitude_2d' )
>   CALL remap_field( nx_rivers, ny_rivers, rivers_dx, l_shift_x, l_reverse_y,   &
>                     rivers%rivers_xgrid, rivers%rivers_lon2d )
> 
> CASE ( 'rivers_outflow_number' )
>   CALL remap_field( nx_rivers, ny_rivers, rivers_dx, l_shift_x, l_reverse_y,   &
>                     rivers%rivers_xgrid, rivers%rivers_outflow_number )
> 
> CASE ( 'sequence' )
>   CALL remap_field( nx_rivers, ny_rivers, rivers_dx, l_shift_x, l_reverse_y,   &
>                     rivers%rivers_xgrid, rivers%rivers_seq )
> 
>   !----------------------------------------------------------------------------
>   ! Cases for river overbank inundation variables.
>   !----------------------------------------------------------------------------
> CASE ( 'logn_mean' )
>   CALL remap_field( nx_rivers, ny_rivers, rivers_dx, l_shift_x, l_reverse_y,   &
>                     rivers%rivers_xgrid, logn_mean )
> 
> CASE ( 'logn_stdev' )
>   CALL remap_field( nx_rivers, ny_rivers, rivers_dx, l_shift_x, l_reverse_y,   &
>                     rivers%rivers_xgrid, logn_stdev )
> 
>   !----------------------------------------------------------------------------
>   ! Cases for the 1-D coordinate variables.
>   ! Rather than requiring separate 1-D remapping routines, we instead create
>   ! temporary 2D coordinate variables that can be processed by remap_field.
>   !----------------------------------------------------------------------------
> CASE ( 'rivers_xgrid' )
>   ! Create a 2D field by copying the 1D xgrid.
>   tmp_2d_coord = SPREAD( rivers%rivers_xgrid, 2, ny_rivers )
>   CALL remap_field( nx_rivers, ny_rivers, rivers_dx, l_shift_x, l_reverse_y,   &
>                     rivers%rivers_xgrid, tmp_2d_coord )
>   ! Extract the first row from the 2D field.
>   rivers%rivers_xgrid(:) = tmp_2d_coord(:,1)
> 
> CASE ( 'rivers_ygrid' )
>   ! Create a 2D field by copying the 1D ygrid.
>   tmp_2d_coord = SPREAD( rivers%rivers_ygrid, 1, nx_rivers )
>   CALL remap_field( nx_rivers, ny_rivers, rivers_dx, l_shift_x, l_reverse_y,   &
>                     rivers%rivers_xgrid, tmp_2d_coord )
>   ! Extract the first column from the 2D field.
>   rivers%rivers_ygrid(:) = tmp_2d_coord(1,:)
> 
> CASE DEFAULT
>   CALL log_fatal( RoutineName,                                                 &
>                   "Do not recognise var: " // TRIM(var) )
> END SELECT
> 
> RETURN
> END SUBROUTINE remap_ancil
> 
> !##############################################################################
> SUBROUTINE remap_field( nx_rivers, ny_rivers, rivers_dx, l_shift_x,            &
>                         l_reverse_y, rivers_xgrid, field )
> 
> !------------------------------------------------------------------------------
> ! Description:
> !   Transfer a river ancillary field from the river input grid to the river
> !   grid.
> !------------------------------------------------------------------------------
> 
> !------------------------------------------------------------------------------
> ! Scalar arguments with INTENT(IN)
> !------------------------------------------------------------------------------
> INTEGER, INTENT(IN) ::                                                         &
>   nx_rivers, ny_rivers  ! Sizes of field.
> 
> REAL(KIND=real_jlslsm), INTENT(IN) ::                                          &
>   rivers_dx
>     !  Size of rivers gridbox in the x direction.
> 
> LOGICAL, INTENT(IN) ::                                                         &
>   l_shift_x,                                                                   &
>     ! Flag indicating that a cyclic shift is to be applied in the x direction
>     ! to river ancillaries. This can be TRUE only if the coordinate is
>     ! longitude.
>   l_reverse_y
>     ! Flag indicating if the order in the y direction of ancillary fields is
>     ! to be reversed so that the coordinate is monotonically increasing.
> 
> REAL(KIND=real_jlslsm), INTENT(IN) ::                                          &
>   rivers_xgrid(nx_rivers)
>     ! Coordinate values for x-dimension of rivers grid.
> 
> !------------------------------------------------------------------------------
> ! Array arguments with INTENT(IN OUT)
> !------------------------------------------------------------------------------
> REAL(KIND=real_jlslsm), INTENT(IN OUT) ::                                      &
>   field(nx_rivers,ny_rivers)
>     ! The field to be transformed. On input this is on the river input grid,
>     ! on output this is on the river grid.
> 
> !------------------------------------------------------------------------------
> ! Local scalar variables.
> !------------------------------------------------------------------------------
> INTEGER ::                                                                     &
>   dy,                                                                          &
>     ! Loop increment.
>   ix, iy,                                                                      &
>     ! Positions in input field.
>   iy1, iy2,                                                                    &
>     ! Loop bounds.
>   jx, jy,                                                                      &
>     ! Positions in output field.
>   xshift
>     ! Number of grid boxes by which fields are moved in the positive x
>     ! direction.
> 
> !------------------------------------------------------------------------------
> ! Local array variables.
> !------------------------------------------------------------------------------
> REAL(KIND=real_jlslsm) ::                                                      &
>   field_tmp(nx_rivers,ny_rivers)
>     ! Work space.
> 
> !end of header
> !-----------------------------------------------------------------------------
> 
> !------------------------------------------------------------------------------
> ! Set bounds and step for loop over rows.
> !------------------------------------------------------------------------------
> IF ( l_reverse_y ) THEN
>   iy1 = ny_rivers
>   iy2 = 1
>   dy  = -1
> ELSE
>   iy1 = 1
>   iy2 = ny_rivers
>   dy  = 1
> END IF
> 
> !------------------------------------------------------------------------------
> ! Calculate the size of any shift in the x direction. The remapping involves
> ! what is effectively a cyclic shift in x (performed element-by-element as the
> ! variable is loaded).
> !------------------------------------------------------------------------------
> IF ( l_shift_x ) THEN
>   xshift = NINT( (rivers_xgrid(1) - MINVAL(rivers_xgrid)) / rivers_dx )
> ELSE
>   xshift = 0
> END IF
> 
> !------------------------------------------------------------------------------
> ! Loop over elements of the input grid, mapping them onto the output grid.
> !------------------------------------------------------------------------------
> 
> DO ix = 1,nx_rivers
> 
>   ! Work out where in x to move this column to.
>   jx = ix + xshift
>   IF ( jx > nx_rivers ) THEN
>     ! Note that this can only occur if l_shift_x = TRUE.
>     jx = jx - nx_rivers
>   END IF
> 
>   ! Process rows in the order to match the required output order.
>   jy = 0
>   DO iy = iy1,iy2,dy
>     jy  = jy + 1
>     field_tmp(jx,jy) = field(ix,iy)
>   END DO
> 
> END DO  !  ix
> 
> ! Copy the transformed field into the output variable.
> field(:,:) = field_tmp(:,:)
> 
> END SUBROUTINE remap_field
> 
> 
> !##############################################################################
> 
> SUBROUTINE process_direction_fields( l_cyclic_x, rivers_dir, direction_grid,   &
>                                      nextx_grid, nexty_grid, river_mask )
> 
> !------------------------------------------------------------------------------
> ! Description:
> !   Convert a flow direction field to nextx and nexty fields, so that all
> !   configurations use those fields. Also check values are reasonable and set
> !   a mask that identifies different types of point.
> !------------------------------------------------------------------------------
> 
> USE jules_rivers_mod, ONLY:                                                    &
>   flow_dir_delta, nx_rivers, ny_rivers
> 
> IMPLICIT NONE
> 
> !------------------------------------------------------------------------------
> ! Scalar arguments with INTENT(IN)
> !------------------------------------------------------------------------------
> LOGICAL, INTENT(IN) ::                                                         &
>   l_cyclic_x
>     ! Flag indicating a river input grid that is cyclic (global) in the x
>     ! direction.
> 
> !------------------------------------------------------------------------------
> ! Array arguments with INTENT(IN)
> !------------------------------------------------------------------------------
> REAL(KIND=real_jlslsm), INTENT(IN) ::                                          &
>   rivers_dir(nx_rivers,ny_rivers)
>     ! River routing direction index (REAL version).
> 
> !------------------------------------------------------------------------------
> ! Array arguments with INTENT(OUT)
> !------------------------------------------------------------------------------
> INTEGER, INTENT(OUT) ::                                                        &
>   direction_grid(nx_rivers,ny_rivers),                                         &
>     ! Integer version of river routing direction index.
>   nextx_grid(nx_rivers,ny_rivers),                                             &
>     ! x index of the next downstream point.
>   nexty_grid(nx_rivers,ny_rivers),                                             &
>     ! y index of the next downstream point.
>   river_mask(nx_rivers,ny_rivers)
>   ! Indicates type of each point.
> 
> !------------------------------------------------------------------------------
> ! Local scalar variables.
> !------------------------------------------------------------------------------
> INTEGER ::                                                                     &
>   ix, iy
>     ! Loop counters.
> 
> !end of header
> !------------------------------------------------------------------------------
> 
> IF ( l_use_direction ) THEN
> 
>   !----------------------------------------------------------------------------
>   ! Flow direction is provided. Create an integer version (which is required
>   ! later in some configurations) and convert to nextx and nexty fields.
>   !----------------------------------------------------------------------------
572,577d2164
<   !---------------------------------------------------------------------------
<   ! Get the number of river points.
<   ! Consider points on the valid domain only (i.e. the part of the river grid
<   ! that is covered by land points).
<   !---------------------------------------------------------------------------
<   np_rivers = 0
580,589c2167,2193
<       IF ( (rivers%rivers_xgrid(ix) < reg_lon1) .OR.                           &
<            (rivers%rivers_ygrid(iy) < reg_lat1) .OR.                           &
<            (rivers%rivers_xgrid(ix) > reg_lon2) .OR.                           &
<            (rivers%rivers_ygrid(iy) > reg_lat2) ) THEN
<         ! This point is not in the valid river domain.
<         ! If this is a land point (as indicated by the flow direction) set
<         ! the direction to land_off_domain, or if this is sea (all other
<         ! values) set to flow_dir_sea.
<         IF ( ANY( rivers_dir_int(ix,iy) == flow_dir_river(:) ) ) THEN
<           rivers_dir_int(ix,iy) = land_off_domain
---
> 
>       !------------------------------------------------------------------------
>       ! Get an integer version of rivers_dir. The REAL version is not used
>       ! after this.
>       !------------------------------------------------------------------------
>       direction_grid(ix,iy) = NINT( rivers_dir(ix,iy) )
> 
>       !------------------------------------------------------------------------
>       ! Convert the flow direction field to nextx and nexty pairs.
>       !------------------------------------------------------------------------
>       IF ( ANY( direction_grid(ix,iy) == flow_dir_river(1:8) ) ) THEN
>         ! These are the 8 "physical" flow directions, i.e. there is a flow
>         ! direction. Set indices to show the next point on the grid.
>         ! Set river mask to show land (for now assumed to be outside the river
>         ! domain).
>         nextx_grid(ix,iy) = ix + flow_dir_delta( direction_grid(ix,iy),1 )
>         nexty_grid(ix,iy) = iy + flow_dir_delta( direction_grid(ix,iy),2 )
>         river_mask(ix,iy) = land_off_domain
> 
>         ! Deal with cyclic boundary conditions in x and flow across the edges
>         ! of the grid in the x direction.
>         IF ( l_cyclic_x ) THEN
>           IF ( nextx_grid(ix,iy) == 0 ) THEN
>             nextx_grid(ix,iy) = nx_rivers
>           ELSE IF ( nextx_grid(ix,iy) == nx_rivers + 1 ) THEN
>             nextx_grid(ix,iy) = 1
>           END IF
591c2195,2211
<           rivers_dir_int(ix,iy) = flow_dir_sea
---
>           ! Flow across the edge of the grid. Save the direction * -1.
>           IF ( nextx_grid(ix,iy) == 0 .OR.                                     &
>                nextx_grid(ix,iy) == nx_rivers + 1 ) THEN
>             ! Note that these values of -direction_grid should be appear in the
>             ! array parameter flow_dir_river_edge (see elsewhere).
>             nextx_grid(ix,iy) = -direction_grid(ix,iy)
>             nexty_grid(ix,iy) = -direction_grid(ix,iy)
>           END IF
>         END IF  !  l_cyclic_x
> 
>         ! In the y direction we do not allow a cyclic boundary condition but
>         ! we do still have to deal with flow across the edge of the grid.
>         IF ( nexty_grid(ix,iy) == 0 .OR.                                       &
>              nexty_grid(ix,iy) == ny_rivers + 1 ) THEN
>           ! Flow across the edge of the grid. Save the direction * -1.
>           nextx_grid(ix,iy) = -direction_grid(ix,iy)
>           nexty_grid(ix,iy) = -direction_grid(ix,iy)
593,596c2213,2225
<       ELSE IF ( ANY( rivers_dir_int(ix,iy) == flow_dir_river(:) ) ) THEN
<         ! This point is in the valid river domain and is land.
<         ! It is a river point.
<         np_rivers = np_rivers + 1
---
> 
>       ELSE IF ( direction_grid(ix,iy) == dir_mouth ) THEN
>         ! A river mouth. Identify this with a special value < 0.
>         nextx_grid(ix,iy) = river_mouth
>         nexty_grid(ix,iy) = river_mouth
>         river_mask(ix,iy) = land_off_domain
> 
>       ELSE IF ( direction_grid(ix,iy) == dir_inland_drainage ) THEN
>         ! An inland drainage point. Identify this with a special value < 0.
>         nextx_grid(ix,iy) = inland_drainage
>         nexty_grid(ix,iy) = inland_drainage
>         river_mask(ix,iy) = land_off_domain
> 
598,605c2227,2245
<         ! This point is in the valid river domain but is not land.
<         ! Set flow direction to indicate sea. This is not currently necessary
<         ! but doing so ensures that the same value is used for sea across
<         ! the grid, in case any later code changes rely on that.
<         rivers_dir_int(ix,iy) = flow_dir_sea
<       END IF
<     END DO
<   END DO
---
>         ! Set all other values to sea. This deals with files that have missing
>         ! data values at sea points, but could potentially obscure other
>         ! (hopefully obvious) issues such as a different encoding scheme having
>         ! been used.
>         nextx_grid(ix,iy) = sea
>         nexty_grid(ix,iy) = sea
>         river_mask(ix,iy) = sea
> 
>       END IF  !  direction_grid
> 
>     END DO  !  ix
>   END DO  !  iy
> 
> END IF  !  l_use_direction
> 
> RETURN
> END SUBROUTINE process_direction_fields
> 
> !##############################################################################
607,621c2247,2356
<   ! At this point all values of rivers_dir_int are one of the following:
<   ! values in flow_dir_river: these are land values in the river domain
<   ! land_off_domain: land but not in the valid river domain
<   ! flow_dir_sea: sea.
< 
<   CALL log_info(RoutineName,                                                   &
<                 "River routing points = " // TRIM(to_string(np_rivers)))
<   CALL log_info(RoutineName,                                                   &
<                 "Global land pts = " // TRIM(to_string(global_land_pts)))
< 
<   IF ( np_rivers <= 0 ) THEN
<     CALL log_fatal(RoutineName,                                                &
<                    "Invalid number of valid routing grid points " //           &
<                    "(np_rivers = " // TRIM(to_string(np_rivers)) //            &
<                    "). Check inputs. ")
---
> SUBROUTINE find_land_grid( l_find_grid, global_proj_x_land, global_proj_y_land,&
>                           nx_land_grid, ny_land_grid, x1_land_grid,            &
>                           y1_land_grid, l_land_180, global_proj_x_land_work,   &
>                           land_x, land_y )
> 
> !------------------------------------------------------------------------------
> ! Description:
> !   Calculate various characteristics of the land points and the land grid,
> !   including whether shifting in longitude allows a smaller grid.
> !------------------------------------------------------------------------------
> 
> USE jules_rivers_mod, ONLY: land_dx, land_dy, rivers_regrid
> 
> USE logging_mod, ONLY: log_info
> 
> USE model_grid_mod, ONLY: global_land_pts, l_coord_latlon
> 
> IMPLICIT NONE
> 
> !------------------------------------------------------------------------------
> ! Arguments with INTENT(IN)
> !------------------------------------------------------------------------------
> LOGICAL, INTENT(IN) :: l_find_grid
>     ! Switch controlling how characteristics of the land and rivers grids are
>     ! determined.
> 
> REAL(KIND=real_jlslsm), INTENT(IN) ::                                          &
>   global_proj_x_land(global_land_pts),                                         &
>     ! x-coordinates of land points.
>   global_proj_y_land(global_land_pts)
>     ! y-coordinates of land points.
> 
> !------------------------------------------------------------------------------
> ! Arguments with INTENT(IN OUT)
> !------------------------------------------------------------------------------
> INTEGER, INTENT(IN OUT) :: nx_land_grid, ny_land_grid
>   ! x and y sizes of the land grid. These are INTENT(IN) in some configurations
>   ! and INTENT(IN OUT) in others.
> 
> REAL(KIND=real_jlslsm), INTENT(IN OUT) ::                                      &
>   ! These are INTENT(IN) in some configurations and INTENT(OUT) in others.
>   x1_land_grid,                                                                &
>     ! x coordinate of "western-most" (i.e. first) column of gridpoints on a
>     ! regular land grid.
>   y1_land_grid
>     ! y coordinate of "southern-most" (i.e. first) row of gridpoints on a
>     ! regular land grid.
> 
> !------------------------------------------------------------------------------
> ! Arguments with INTENT(OUT)
> !------------------------------------------------------------------------------
> LOGICAL, INTENT(OUT) ::                                                        &
>   l_land_180
>     ! Flag indicating the range of land point longitudes.
> 
> REAL(KIND=real_jlslsm), INTENT(OUT) ::                                         &
>   global_proj_x_land_work(global_land_pts),                                    &
>     ! x coordinates of land points, including any transformation.
>   land_x(2), land_y(2)
>     ! Min and max values of the projection coordinates, at land points.
> 
> !------------------------------------------------------------------------------
> ! Local parameters.
> !------------------------------------------------------------------------------
> CHARACTER(LEN=*), PARAMETER :: RoutineName = 'FIND_LAND_GRID'
> 
> !------------------------------------------------------------------------------
> ! Local scalar variables.
> !------------------------------------------------------------------------------
> INTEGER ::                                                                     &
>   nx_land_grid_work
>     ! An alternative value of nx_land_grid (the grid size).
> 
> !------------------------------------------------------------------------------
> ! Local array variables.
> !------------------------------------------------------------------------------
> REAL(KIND=real_jlslsm) ::                                                      &
>   land_x_work(2)
>     ! Min and max values of the x projection coordinates, at land points.
> 
> !end of header
> !------------------------------------------------------------------------------
> 
> ! Get the min and max values of the projection coordinates - to describe the
> ! area in which land points occur.
> land_x(1) = MINVAL( global_proj_x_land )
> land_x(2) = MAXVAL( global_proj_x_land )
> land_y(1) = MINVAL( global_proj_y_land )
> land_y(2) = MAXVAL( global_proj_y_land )
> 
> ! Report range of coordinate values for global land points.
> CALL log_info( RoutineName,                                                    &
>                'Land points lie in x='                                      // &
>                TRIM(to_string( land_x(1) )) // ' to '                       // &
>                TRIM(to_string( land_x(2) )) // ' y='                        // &
>                TRIM(to_string( land_y(1) )) // ' to '                       // &
>                TRIM(to_string( land_y(2) )) )
> 
> ! Copy land x coordinate values into a new variable. If coordinates are
> ! longitude, these might later be altered.
> global_proj_x_land_work(:) = global_proj_x_land(:)
> 
> IF ( l_coord_latlon ) THEN
>   ! Establish if longitude values of land points use the range [-180,180] or
>   ! [0,360]. We assume that the presence of any value < 0 means [-180,180] is
>   ! used, otherwise it is [0,360].
>   IF ( land_x(1) < 0.0 ) THEN
>     l_land_180 = .TRUE.
>   ELSE
>     l_land_180 = .FALSE.
622a2358
> END IF
624,625c2360
<   ! Allocate land point arrays and initialise
<   !---------------------------------------------------------------------------
---
> IF ( l_find_grid .AND. l_coord_latlon ) THEN
627,631c2362,2421
<   ALLOCATE(rivers_data%ir_land_grid(global_land_pts), STAT = ERROR )
<   error_sum = ERROR
<   IF ( error_sum /= 0 ) THEN
<     CALL log_fatal(RoutineName,                                                &
<                    "Error allocating overbank variables.")
---
>   ! Get characteristics of the land grid.
>   ! Although we only need to identify a regular land grid (described by
>   ! variables such as nx_land_grid) if rivers_regrid=T, we use this section
>   ! more generally because it can also be used to give better values of land_x
>   ! and land_y that later are used in setting the part of the river grid that
>   ! is scanned for points.
>   ! Note that if l_coord_latlon=F (in which case this code is not executed) we
>   ! will have rivers_regrid=T and none of the values set here are needed
>   ! elsewhere.
> 
>   ! Get first estimate of grid location and size.
>   x1_land_grid = land_x(1)
>   y1_land_grid = land_y(1)
>   nx_land_grid = NINT( ( land_x(2) - land_x(1) ) / land_dx ) + 1
>   ny_land_grid = NINT( ( land_y(2) - land_y(1) ) / land_dy ) + 1
> 
>   ! Here we deal with a special case that follows from the cyclic nature of
>   ! longitude. In general we want to identify the smallest land grid
>   ! possible, which for many cases follows from simple arithmetic based on
>   ! the coordinate values (as is done if the x-coordinate is not longitude).
>   ! However, consider the case in which we have a global model input grid for
>   ! which longitudes are given in the range [0,360] and we are considering
>   ! a domain over part of Africa in the range of longitude [-10,10]. Points
>   ! with longitudes in [350,360] or [0,10] fall within this domain, and a
>   ! naive approach that simply looks at the min and max longitudes might
>   ! conclude that a land grid that covers [0,360] (i.e. global) is required.
>   ! If instead the longitudes are recast to be in the range [-180,180] it is
>   ! easy to identify that a grid covering [-10,10] can be used.
>   ! Below we compare the grid sizes that result from using longitudes in the
>   ! ranges [0,360] and [-180,180], and use whichever allows a smaller grid.
>   IF ( l_land_180 ) THEN
>     ! Change land longitudes to be in [0,360].
>     CALL change_longitude_from_180( global_proj_x_land_work )
>   ELSE
>     ! Change land longitudes to be in [-180,180].
>     CALL change_longitude_from_360( global_proj_x_land_work )
>   END IF  !  l_land_180
>   ! Recalculate grid size. In many cases this will not have changed.
>   land_x_work(1) = MINVAL( global_proj_x_land_work )
>   land_x_work(2) = MAXVAL( global_proj_x_land_work )
>   nx_land_grid_work = NINT( ( land_x_work(2) - land_x_work(1) )                &
>                       / land_dx ) + 1
> 
>   ! Identify if either arrangement gives a smaller grid.
>   IF ( nx_land_grid_work < nx_land_grid ) THEN
>     ! Changing the longitude range gives a smaller land grid.
>     ! Save the new values.
>     nx_land_grid = nx_land_grid_work
>     land_x(:)    = land_x_work(:)
>     l_land_180   = .NOT. l_land_180
>     CALL log_info( RoutineName,                                                &
>                    'Range of land longitudes altered to allow a smaller ' //   &
>                    'grid.')
>     CALL log_info( RoutineName,                                                &
>                    'Land points lie in x='                                //   &
>                    TRIM(to_string( land_x(1) )) // ' to '                 //   &
>                    TRIM(to_string( land_x(2) )) )
>   ELSE
>     ! Retain the original longitude values.
>     global_proj_x_land_work(:) = global_proj_x_land(:)
633a2424,2425
>   ! Reload the minimum value, as that might have changed.
>   x1_land_grid = land_x(1)
635,637c2427
<   ! If required, read overbank inundation ancillary information from file
<   ! before translating to the river routing grid
<   IF ( l_riv_overbank ) CALL init_overbank_props()
---
> END IF  !  l_find_grid .AND. l_coord_latlon
639,641c2429
<   !---------------------------------------------------------------------------
<   ! Allocate routing point arrays
<   !---------------------------------------------------------------------------
---
> END SUBROUTINE find_land_grid
643,771c2431
<   ALLOCATE(rivers_data%rivers_index_rp(np_rivers),    STAT = ERROR)
<   error_sum = ERROR
<   ALLOCATE(rivers_data%rivers_next_rp(np_rivers),     STAT = ERROR)
<   error_sum = error_sum + ERROR
<   ALLOCATE(rivers_data%rivers_seq_rp(np_rivers),      STAT = ERROR)
<   error_sum = error_sum + ERROR
<   ALLOCATE(rivers_data%rivers_dir_rp(np_rivers),      STAT = ERROR)
<   error_sum = error_sum + ERROR
<   ALLOCATE(rivers_data%rivers_dra_rp(np_rivers),      STAT = ERROR)
<   error_sum = error_sum + ERROR
<   ALLOCATE(rivers_data%rivers_lat_rp(np_rivers),      STAT = ERROR)
<   error_sum = error_sum + ERROR
<   ALLOCATE(rivers_data%rivers_lon_rp(np_rivers),      STAT = ERROR)
<   error_sum = error_sum + ERROR
<   ALLOCATE(rivers_data%rivers_boxareas_rp(np_rivers), STAT = ERROR)
<   error_sum = error_sum + ERROR
<   ALLOCATE(rivers_data%il_river_grid(np_rivers),      STAT = ERROR)
<   error_sum = error_sum + ERROR
<   ALLOCATE(rivers_data%rflow_rp(np_rivers),           STAT = ERROR)
<   error_sum = error_sum + ERROR
<   ALLOCATE(rivers_data%rrun_rp(np_rivers),            STAT = ERROR)
<   error_sum = error_sum + ERROR
<   ALLOCATE(rivers_data%rrun_surf_rp(np_rivers),       STAT = ERROR)
<   error_sum = error_sum + ERROR
<   ALLOCATE(rivers_data%rrun_sub_surf_rp(np_rivers),   STAT = ERROR)
<   error_sum = error_sum + ERROR
< 
<   ! Allocate TRIP variables
<   IF ( i_river_vn == rivers_trip ) THEN
<     ALLOCATE(rivers_data%rivers_sto_rp(np_rivers), STAT = ERROR)
<     error_sum = error_sum + ERROR
<   END IF
< 
<   ! Allocate RFM variables
<   ALLOCATE(rivers_data%rfm_rivflow_rp(np_rivers),    STAT = ERROR)
<   error_sum = error_sum + ERROR
< 
<   IF ( i_river_vn == rivers_rfm ) THEN
<     ALLOCATE(rivers_data%rfm_flowobs1_rp(np_rivers),  STAT = ERROR )
<     error_sum = error_sum + ERROR
<     ALLOCATE(rivers_data%rfm_surfstore_rp(np_rivers), STAT = ERROR )
<     error_sum = error_sum + ERROR
<     ALLOCATE(rivers_data%rfm_substore_rp(np_rivers),  STAT = ERROR )
<     error_sum = error_sum + ERROR
<     ALLOCATE(rivers_data%rfm_flowin_rp(np_rivers),    STAT = ERROR )
<     error_sum = error_sum + ERROR
<     ALLOCATE(rivers_data%rfm_bflowin_rp(np_rivers),   STAT = ERROR )
<     error_sum = error_sum + ERROR
<     ALLOCATE(rivers_data%rfm_iarea_rp(np_rivers),     STAT = ERROR )
<     error_sum = error_sum + ERROR
<     ALLOCATE(rivers_data%rfm_land_rp(np_rivers),      STAT = ERROR )
<     error_sum = error_sum + ERROR
<     ALLOCATE(rivers_data%rfm_baseflow_rp(np_rivers),  STAT = ERROR )
<     error_sum = error_sum + ERROR
<   END IF
< 
<   IF ( error_sum /= 0 ) THEN
<     CALL log_fatal(RoutineName,                                                &
<                    "Error allocating for routing point arrays.")
<   END IF
< 
<   ! Initialise array values
<   rivers_data%rivers_index_rp(:)  = imdi
<   rivers_data%rivers_next_rp(:)   = imdi
<   rivers_data%rivers_seq_rp(:)    = imdi
<   rivers_data%rivers_dir_rp(:)    = imdi
<   rivers_data%il_river_grid(:)    = 0
<   rivers_data%rflow_rp(:)         = 0.0
<   rivers_data%rrun_rp(:)          = 0.0
<   rivers_data%rrun_surf_rp(:)     = 0.0
<   rivers_data%rrun_sub_surf_rp(:) = 0.0
< 
<   ! Initialise TRIP array values
<   IF ( i_river_vn == rivers_trip ) THEN
<     rivers_data%rivers_sto_rp(:)    = 0.0
<   END IF
< 
<   ! Initialise RFM array values
<   rivers_data%rfm_rivflow_rp(:)   = 0.0
< 
<   IF ( i_river_vn == rivers_rfm ) THEN
<     rivers_data%rfm_land_rp(:)      = imdi
<     rivers_data%rfm_iarea_rp(:)     = imdi
<     rivers_data%rfm_flowobs1_rp(:)  = 0.0
<     rivers_data%rfm_surfstore_rp(:) = 0.0
<     rivers_data%rfm_substore_rp(:)  = 0.0
<     rivers_data%rfm_flowin_rp(:)    = 0.0
<     rivers_data%rfm_bflowin_rp(:)   = 0.0
<     rivers_data%rfm_baseflow_rp(:)  = 0.0
<   END IF  !  RFM
< 
<   ! Initialise max sequence and point number to zero.
<   nseqmax = 0
<   ip      = 0
< 
<   ! Initialise iarea from drainage?
<   set_dra = .FALSE.
<   IF ( MAXVAL(rivers_data%rivers_dra) > 0.0 ) set_dra = .TRUE.
< 
<   min_lon = MINVAL(rivers_data%rivers_xgrid)
< 
<   ! Associate pointers
<   rivers%il_river_grid => rivers_data%il_river_grid
<   rivers%ir_land_grid => rivers_data%ir_land_grid
<   rivers%rivers_dir_rp => rivers_data%rivers_dir_rp
<   rivers%rivers_seq_rp => rivers_data%rivers_seq_rp
<   rivers%rivers_dra_rp => rivers_data%rivers_dra_rp
<   rivers%rivers_index_rp => rivers_data%rivers_index_rp
<   rivers%rivers_next_rp => rivers_data%rivers_next_rp
<   rivers%rivers_sto_rp => rivers_data%rivers_sto_rp
<   rivers%rivers_lat_rp => rivers_data%rivers_lat_rp
<   rivers%rivers_lon_rp => rivers_data%rivers_lon_rp
<   rivers%rflow_rp => rivers_data%rflow_rp
<   rivers%rrun_rp => rivers_data%rrun_rp
<   rivers%rrun_surf_rp => rivers_data%rrun_surf_rp
<   rivers%rrun_sub_surf_rp => rivers_data%rrun_sub_surf_rp
<   rivers%rivers_boxareas_rp => rivers_data%rivers_boxareas_rp
<   rivers%rfm_rivflow_rp => rivers_data%rfm_rivflow_rp
< 
<   IF ( i_river_vn == rivers_rfm ) THEN
<     rivers%rfm_iarea_rp => rivers_data%rfm_iarea_rp
<     rivers%rfm_land_rp => rivers_data%rfm_land_rp
<     rivers%rfm_flowobs1_rp => rivers_data%rfm_flowobs1_rp
<     rivers%rfm_surfstore_rp => rivers_data%rfm_surfstore_rp
<     rivers%rfm_substore_rp => rivers_data%rfm_substore_rp
<     rivers%rfm_flowin_rp => rivers_data%rfm_flowin_rp
<     rivers%rfm_bflowin_rp => rivers_data%rfm_bflowin_rp
<     rivers%rfm_baseflow_rp => rivers_data%rfm_baseflow_rp
<   END IF  !  RFM
---
> !##############################################################################
773,775c2433,2619
<   !---------------------------------------------------------------------------
<   ! Set up routing point arrays, and correct 2d lat/lon grid (S to N)
<   !---------------------------------------------------------------------------
---
> SUBROUTINE change_longitude_from_180( longitude, n_change )
> 
> !------------------------------------------------------------------------------
> ! Description:
> !   Change the range of a list of longitudes from [-180,180] to [0,360].
> !   The current range has already been established.
> !------------------------------------------------------------------------------
> 
> IMPLICIT NONE
> 
> !------------------------------------------------------------------------------
> ! Array arguments with INTENT(IN OUT):
> !------------------------------------------------------------------------------
> REAL(KIND=real_jlslsm), INTENT(IN OUT) ::                                      &
>   longitude(:)
>     ! Longitude (degrees).
> 
> !------------------------------------------------------------------------------
> ! Scalar arguments with INTENT(OUT):
> !------------------------------------------------------------------------------
> INTEGER, INTENT(OUT), OPTIONAL ::                                              &
>   n_change
>     ! The number of longitude values that were changed.
> 
> !------------------------------------------------------------------------------
> ! Local scalars.
> !------------------------------------------------------------------------------
> INTEGER ::                                                                     &
>   i,                                                                           &
>     ! Loop index.
>   n_change_local
>     ! Local version of n_change.
> 
> !end of header
> !------------------------------------------------------------------------------
> 
> ! Initialise counter.
> n_change_local = 0
> 
> DO i = 1, SIZE(longitude)
>   IF ( longitude(i) < 0.0 ) THEN
>     longitude(i) = longitude(i) + 360.0
>     n_change_local = n_change_local + 1
>   END IF
> END DO
> 
> ! Return the counter if argument provided.
> IF ( PRESENT( n_change ) ) THEN
>   n_change = n_change_local
> END IF
> 
> RETURN
> END SUBROUTINE change_longitude_from_180
> 
> !##############################################################################
> 
> SUBROUTINE change_longitude_from_360( longitude, n_change )
> 
> !------------------------------------------------------------------------------
> ! Description:
> !   Change the range of a list of longitudes from [0,360] to [-180,180].
> !   The current range has already been established.
> !------------------------------------------------------------------------------
> 
> IMPLICIT NONE
> 
> !------------------------------------------------------------------------------
> ! Array arguments with INTENT(IN OUT):
> !------------------------------------------------------------------------------
> REAL(KIND=real_jlslsm), INTENT(IN OUT) ::                                      &
>   longitude(:)
>     ! Longitude (degrees).
> 
> !------------------------------------------------------------------------------
> ! Optional scalar arguments with INTENT(OUT):
> !------------------------------------------------------------------------------
> INTEGER, INTENT(OUT), OPTIONAL ::                                              &
>   n_change
>     ! The number of longitude values that were changed.
> 
> !------------------------------------------------------------------------------
> ! Local scalars.
> !------------------------------------------------------------------------------
> INTEGER ::                                                                     &
>   i,                                                                           &
>     ! Loop index.
>   n_change_local
>     ! Local version of n_change.
> 
> !end of header
> !------------------------------------------------------------------------------
> 
> ! Initialise counter.
> n_change_local = 0
> 
> DO i = 1, SIZE(longitude)
>   IF ( longitude(i) > 180.0 ) THEN
>     longitude(i) = longitude(i) - 360.0
>     n_change_local = n_change_local + 1
>   END IF
> END DO
> 
> ! Return the counter if argument provided.
> IF ( PRESENT( n_change ) ) THEN
>   n_change = n_change_local
> END IF
> 
> RETURN
> END SUBROUTINE change_longitude_from_360
> 
> !##############################################################################
> 
> SUBROUTINE find_river_points( rivers_xgrid, rivers_ygrid,                      &
>                               river_xbound, river_ybound,                      &
>                               direction_grid, nextx_grid, nexty_grid,          &
>                               river_mask, np_rivers )
> 
> !------------------------------------------------------------------------------
> ! Description:
> !   Identify points that are rivers.
> !------------------------------------------------------------------------------
> 
> USE jules_rivers_mod, ONLY:                                                    &
>   nx_rivers, ny_rivers, rivers_regrid
> 
> IMPLICIT NONE
> 
> !------------------------------------------------------------------------------
> ! Array arguments with INTENT(IN)
> !------------------------------------------------------------------------------
> REAL(KIND=real_jlslsm), INTENT(IN) ::                                          &
>   river_xbound(2), river_ybound(2),                                            &
>     ! Coordinates of the corners of the river domain - i.e. that part of the
>     ! river input grid that will be searched for river points. Units as given
>     ! by rivers_xgrid and rivers_ygrid.
>   rivers_xgrid(nx_rivers), rivers_ygrid(ny_rivers)
>     ! Coordinates for rivers grid.
> 
> !------------------------------------------------------------------------------
> ! Array arguments with INTENT(IN OUT)
> !------------------------------------------------------------------------------
> INTEGER, INTENT(IN OUT) ::                                                     &
>   direction_grid(nx_rivers,ny_rivers),                                         &
>     ! Integer version of river routing direction index.
>   nextx_grid(nx_rivers, ny_rivers),                                            &
>     ! x index of the next downstream point.
>   nexty_grid(nx_rivers, ny_rivers),                                            &
>     ! y index of the next downstream point.
>   river_mask(nx_rivers,ny_rivers)
>     ! Indicates type of each point.
> 
> !------------------------------------------------------------------------------
> ! Scalar arguments with INTENT(OUT)
> !------------------------------------------------------------------------------
> INTEGER, INTENT(OUT) ::                                                        &
>   np_rivers
>     ! Number of river points.
> 
> !------------------------------------------------------------------------------
> ! Local parameters.
> !------------------------------------------------------------------------------
> LOGICAL, PARAMETER :: l_add_mouths = .TRUE.
>     ! Switch to allow insertion of missing river mouths. This is provided in
>     ! case we later want to make it optional or switch it off.
> 
> CHARACTER(LEN=*), PARAMETER :: RoutineName = 'FIND_RIVER_POINTS'
> 
> !------------------------------------------------------------------------------
> ! Local scalar variables.
> !------------------------------------------------------------------------------
> INTEGER ::                                                                     &
>   ix, iy,                                                                      &
>     ! Loop counters.
>   n_mouths_added
>     ! Counter of missing river mouths that were added.
> 
> !end of header
> !------------------------------------------------------------------------------
> 
> ! Initialise counters.
> n_mouths_added = 0
> np_rivers      = 0
> 
> !------------------------------------------------------------------------------
> ! Scan the grid looking for river points. Sea points are not altered.
> !------------------------------------------------------------------------------
> DO iy = 1,ny_rivers
778,782c2622,2640
<     ilat = 0
<     IF ( rivers_reglatlon ) THEN
<       ilon = NINT( (rivers%rivers_xgrid(ix) - min_lon) / rivers_dlon ) + 1
<       IF ( ilon > nx_rivers ) THEN
<         ilon = ilon - nx_rivers
---
>     !-------------------------------------------------------------------------
>     ! Consider points on the valid domain only (i.e. the part of the river
>     ! grid that is to be searched for river points).
>     !-------------------------------------------------------------------------
>     IF ( ( rivers_xgrid(ix) < river_xbound(1) ) .OR.                           &
>          ( rivers_ygrid(iy) < river_ybound(1) ) .OR.                           &
>          ( rivers_xgrid(ix) > river_xbound(2) ) .OR.                           &
>          ( rivers_ygrid(iy) > river_ybound(2) ) ) THEN
> 
>       !-----------------------------------------------------------------------
>       ! This point is not in the valid river domain.
>       ! If this is a land point (as indicated by river_mask) set nextx to
>       ! land_off_domain.
>       !-----------------------------------------------------------------------
>       IF ( river_mask(ix,iy) == land_off_domain ) THEN
>         ! For clarity reset nextx_grid and nexty_grid - though these variables
>         ! are not used again at such points.
>         nextx_grid(ix,iy) = land_off_domain
>         nexty_grid(ix,iy) = land_off_domain
784,785c2642,2687
<     ELSE
<       ilon = ix
---
> 
>     ELSE IF ( river_mask(ix,iy) == land_off_domain ) THEN
> 
>       !------------------------------------------------------------------------
>       ! This point is in the valid river domain and is land (though currently
>       ! flagged as land_off_domain). It is a river point.
>       !------------------------------------------------------------------------
>       np_rivers   = np_rivers + 1
> 
>       ! Set river_mask to differentiate between different types of river point.
>       SELECT CASE ( nextx_grid(ix,iy) )
>       CASE ( river_mouth )
>         river_mask(ix,iy) = river_mouth
>       CASE ( inland_drainage )
>         river_mask(ix,iy) = inland_drainage
>       CASE DEFAULT
>         ! These will all have nextx_grid in the range 1:nx_rivers.
>         river_mask(ix,iy) = land_in_domain
>       END SELECT
> 
>       !------------------------------------------------------------------------
>       ! Insert any missing river mouth.
>       !------------------------------------------------------------------------
>       IF ( l_add_mouths .AND. nextx_grid(ix,iy) > 0 ) THEN
>         ! This point is indicated as having a physical flow direction.
>         ! Check if the next downstream point is sea.
>         IF ( river_mask(nextx_grid(ix,iy),nexty_grid(ix,iy)) == sea ) THEN
>           ! The next point is sea. In many ancillary files this point would
>           ! have been flagged as a river mouth. Convert the current point to a
>           ! river mouth.
>           n_mouths_added    = n_mouths_added + 1
>           nextx_grid(ix,iy) = river_mouth
>           nexty_grid(ix,iy) = river_mouth
>           river_mask(ix,iy) = river_mouth
>           IF ( l_use_direction ) THEN
>             ! If l_riv_number=T we will later check that the flow direction
>             ! field is consistent with the river number field, for which we
>             ! need to update direction_grid here. (Although nextx_grid contains
>             ! much the same information as direction_grid, we also need the
>             ! separate direction_grid variable to deal with flows across the
>             ! edge of the river domain.)
>             direction_grid(ix,iy) = dir_mouth
>           END IF
>         END IF
>       END IF  !  l_add_mouths
> 
788c2690,2691
<     DO iy = i1,i2,step
---
>   END DO  !  ix
> END DO  !  iy
790c2693,2698
<       ilat = ilat + 1
---
> ! Report if mouths were added.
> IF ( n_mouths_added > 0 ) THEN
>   CALL log_warn( RoutineName,                                                  &
>                  "Number of river mouths inserted = " //                       &
>                  TRIM(to_string(n_mouths_added)) )
> END IF
792,796c2700,3110
<       IF ( rivers_reglatlon ) THEN
<         ! Assume 1d x and y grid variables define lat / lon
<         rivers%rivers_lat2d(ilon,ilat) = rivers%rivers_ygrid(iy)
<         rivers%rivers_lon2d(ilon,ilat) = rivers%rivers_xgrid(ix)
<       END IF
---
> RETURN
> END SUBROUTINE find_river_points
> 
> !##############################################################################
> 
> SUBROUTINE allocate_rivers_vars_rp( np_rivers, rivers, rivers_data )
> 
> !------------------------------------------------------------------------------
> ! Description:
> !   Allocate river point variables, initialise, and associate pointers.
> !------------------------------------------------------------------------------
> 
> USE jules_model_environment_mod, ONLY: l_oasis_rivers
> 
> USE jules_rivers_mod, ONLY: i_river_vn, rivers_data_type, rivers_rfm,          &
>                             rivers_trip, rivers_type
> 
> USE parallel_mod, ONLY: is_master_task
> 
> IMPLICIT NONE
> 
> !------------------------------------------------------------------------------
> ! Scalar arguments with INTENT(IN)
> !------------------------------------------------------------------------------
> INTEGER, INTENT(IN) ::                                                         &
>   np_rivers
>     ! Number of river points.
> 
> !------------------------------------------------------------------------------
> ! Arguments with INTENT(IN OUT)
> !------------------------------------------------------------------------------
> TYPE(rivers_type), INTENT(IN OUT) :: rivers
> TYPE(rivers_data_type), INTENT(IN OUT), TARGET :: rivers_data
> 
> CHARACTER(LEN=*), PARAMETER :: RoutineName = 'ALLOCATE_RIVERS_VARS_RP'
> 
> !------------------------------------------------------------------------------
> ! Local scalar variables.
> !------------------------------------------------------------------------------
> INTEGER ::                                                                     &
>   ERROR, error_sum,                                                            &
>     ! Error flags.
>   nland_tmp,                                                                   &
>     ! Number of land points to allocate for.
>   np_rivers_tmp
>     ! Number of river points to allocate for.
> 
> !end of header
> !------------------------------------------------------------------------------
> 
> !------------------------------------------------------------------------------
> ! As river routing is performed on the master task, we only allocate arrays at
> ! full size on that task, and only if the run configuration requires it.
> !------------------------------------------------------------------------------
> 
> !------------------------------------------------------------------------------
> ! Allocate variables that are required by all configurations.
> !------------------------------------------------------------------------------
> IF ( is_master_task() ) THEN
>   ! Full size.
>   np_rivers_tmp = np_rivers
> ELSE
>   ! Minimum size.
>   np_rivers_tmp = 1
> END IF
> 
> ! Ancillaries and related fields.
> ALLOCATE(rivers_data%rivers_boxareas_rp(np_rivers_tmp),  STAT = ERROR)
> error_sum = ERROR
> ALLOCATE(rivers_data%rivers_index_rp(np_rivers_tmp),     STAT = ERROR)
> error_sum = error_sum + ERROR
> ALLOCATE(rivers_data%rivers_lat_rp(np_rivers_tmp),       STAT = ERROR)
> error_sum = error_sum + ERROR
> ALLOCATE(rivers_data%rivers_lon_rp(np_rivers_tmp),       STAT = ERROR)
> error_sum = error_sum + ERROR
> ALLOCATE(rivers_data%rivers_next_rp(np_rivers_tmp),      STAT = ERROR)
> error_sum = error_sum + ERROR
> ALLOCATE(rivers_data%rivers_x_coord_rp(np_rivers_tmp),   STAT = ERROR)
> error_sum = error_sum + ERROR
> ALLOCATE(rivers_data%rivers_y_coord_rp(np_rivers_tmp),   STAT = ERROR)
> error_sum = error_sum + ERROR
> ! Fluxes.
> ALLOCATE(rivers_data%rflow_rp(np_rivers_tmp),            STAT = ERROR)
> error_sum = error_sum + ERROR
> ALLOCATE(rivers_data%rivers_outflow_rp(np_rivers),       STAT = ERROR)
> error_sum = error_sum + ERROR
> ALLOCATE(rivers_data%rrun_rp(np_rivers_tmp),             STAT = ERROR)
> error_sum = error_sum + ERROR
> ALLOCATE(rivers_data%rrun_sub_surf_rp(np_rivers_tmp),    STAT = ERROR)
> error_sum = error_sum + ERROR
> ALLOCATE(rivers_data%rrun_surf_rp(np_rivers_tmp),        STAT = ERROR)
> error_sum = error_sum + ERROR
> 
> !------------------------------------------------------------------------------
> ! Allocate variable specific to remapping.
> !------------------------------------------------------------------------------
> ALLOCATE(rivers_data%map_river_to_land_points(np_rivers_tmp), STAT = ERROR)
> error_sum = error_sum + ERROR
> 
> !------------------------------------------------------------------------------
> ! Allocate RFM variables
> !------------------------------------------------------------------------------
> IF ( i_river_vn == rivers_rfm .AND. is_master_task() ) THEN
>   ! Full size.
>   np_rivers_tmp = np_rivers
> ELSE
>   ! Minimum size.
>   np_rivers_tmp = 1
> END IF
> 
> ! Ancillaries and related fields.
> ! Note: rfm_flowobs1_rp is not used by standalone JULES - but is left here
> !       for now.
> ALLOCATE(rivers_data%rfm_flowobs1_rp(np_rivers_tmp),  STAT = ERROR )
> error_sum = error_sum + ERROR
> ALLOCATE(rivers_data%rfm_iarea_rp(np_rivers_tmp),     STAT = ERROR )
> error_sum = error_sum + ERROR
> ALLOCATE(rivers_data%rfm_land_rp(np_rivers_tmp),      STAT = ERROR )
> error_sum = error_sum + ERROR
> ! Fluxes and stores.
> ALLOCATE(rivers_data%rfm_baseflow_rp(np_rivers_tmp),  STAT = ERROR )
> error_sum = error_sum + ERROR
> ALLOCATE(rivers_data%rfm_bflowin_rp(np_rivers_tmp),   STAT = ERROR )
> error_sum = error_sum + ERROR
> ALLOCATE(rivers_data%rfm_flowin_rp(np_rivers_tmp),    STAT = ERROR )
> error_sum = error_sum + ERROR
> ALLOCATE(rivers_data%rfm_rivflow_rp(np_rivers_tmp),   STAT = ERROR)
> error_sum = error_sum + ERROR
> ALLOCATE(rivers_data%rfm_substore_rp(np_rivers_tmp),  STAT = ERROR )
> error_sum = error_sum + ERROR
> ALLOCATE(rivers_data%rfm_surfstore_rp(np_rivers_tmp), STAT = ERROR )
> error_sum = error_sum + ERROR
> 
> !------------------------------------------------------------------------------
> ! Allocate TRIP variables
> !------------------------------------------------------------------------------
> IF ( i_river_vn == rivers_trip .AND. is_master_task() ) THEN
>   ! Full size.
>   np_rivers_tmp = np_rivers
> ELSE
>   ! Minimum size.
>   np_rivers_tmp = 1
> END IF
> ! Ancillaries and related fields.
> ALLOCATE(rivers_data%rivers_seq_rp(np_rivers_tmp), STAT = ERROR)
> error_sum = error_sum + ERROR
> ! Stores.
> ALLOCATE(rivers_data%rivers_sto_rp(np_rivers_tmp), STAT = ERROR)
> error_sum = error_sum + ERROR
> 
> !------------------------------------------------------------------------------
> ! Allocate River coupling variables.
> !------------------------------------------------------------------------------
> IF ( l_oasis_rivers .AND. is_master_task() ) THEN
>   ! Full size.
>   np_rivers_tmp = np_rivers
> ELSE
>   ! Minimum size.
>   np_rivers_tmp = 1
> END IF
> ALLOCATE(rivers_data%sub_surf_roff_rp(np_rivers_tmp), STAT = ERROR)
> error_sum = error_sum + ERROR
> ALLOCATE(rivers_data%surf_roff_rp(np_rivers_tmp),     STAT = ERROR)
> error_sum = error_sum + ERROR
> ALLOCATE(rivers_data%rivers_ilat_rp(np_rivers_tmp),   STAT = ERROR)
> error_sum = error_sum + ERROR
> ALLOCATE(rivers_data%rivers_ilon_rp(np_rivers_tmp),   STAT = ERROR)
> error_sum = error_sum + ERROR
> 
> IF ( l_riv_number .AND. is_master_task() ) THEN
>   ! Full size.
>   np_rivers_tmp = np_rivers
> ELSE
>   ! Minimum size.
>   np_rivers_tmp = 1
> END IF
> ALLOCATE(rivers_data%rivers_outflow_number_rp(np_rivers_tmp), STAT = ERROR)
> error_sum = error_sum + ERROR
> 
> IF ( error_sum /= 0 ) THEN
>   CALL log_fatal( RoutineName, "Error allocating for routing point arrays." )
> END IF
> 
> !------------------------------------------------------------------------------
> ! Initialise array values to missing values, except fluxes can be zero to
> ! preserve existing results.
> !------------------------------------------------------------------------------
> ! Ancillaries etc.
> rivers_data%rivers_boxareas_rp(:) = rmdi
> rivers_data%rivers_index_rp(:)   = imdi
> rivers_data%rivers_lat_rp(:)     = rmdi
> rivers_data%rivers_lon_rp(:)     = rmdi
> rivers_data%rivers_next_rp(:)    = imdi
> rivers_data%rivers_x_coord_rp(:) = rmdi
> rivers_data%rivers_y_coord_rp(:) = rmdi
> ! Fluxes.
> rivers_data%rflow_rp(:)          = 0.0
> rivers_data%rivers_outflow_rp(:) = rmdi
> rivers_data%rrun_rp(:)           = 0.0
> rivers_data%rrun_sub_surf_rp(:)  = 0.0
> rivers_data%rrun_surf_rp(:)      = 0.0
> 
> ! Initialise regridding variable.
> rivers_data%map_river_to_land_points(:) = imdi
> 
> ! Initialise RFM array values
> rivers_data%rfm_flowobs1_rp(:)  = rmdi
> rivers_data%rfm_iarea_rp(:)     = imdi
> rivers_data%rfm_land_rp(:)      = imdi
> rivers_data%rfm_baseflow_rp(:)  = 0.0
> ! rfm_bflowin_rp, rfm_flowin_rp, rfm_substore_rp and rfm_surfstore_rp should
> ! be initiailsed to zero to preserve existing results and until better
> ! initialisation is possible.
> rivers_data%rfm_bflowin_rp(:)   = 0.0
> rivers_data%rfm_flowin_rp(:)    = 0.0
> rivers_data%rfm_rivflow_rp(:)   = 0.0
> rivers_data%rfm_substore_rp(:)  = 0.0
> rivers_data%rfm_surfstore_rp(:) = 0.0
> 
> ! Initialise TRIP array values
> rivers_data%rivers_seq_rp(:) = imdi
> ! rivers_sto_rp should be initialised to zero to preserve existing results and
> ! until better initialisation is possible.
> rivers_data%rivers_sto_rp(:) = 0.0
> 
> ! Initialise coupling variables.
> rivers_data%rivers_outflow_number_rp(:) = imdi
> rivers_data%sub_surf_roff_rp(:) = 0.0
> rivers_data%surf_roff_rp(:)     = 0.0
> 
> !------------------------------------------------------------------------------
> ! Associate pointers
> !------------------------------------------------------------------------------
> ! Ancillaries etc.
> rivers%rivers_boxareas_rp => rivers_data%rivers_boxareas_rp
> rivers%rivers_index_rp => rivers_data%rivers_index_rp
> rivers%rivers_lat_rp => rivers_data%rivers_lat_rp
> rivers%rivers_lon_rp => rivers_data%rivers_lon_rp
> rivers%rivers_ilat_rp => rivers_data%rivers_ilat_rp
> rivers%rivers_ilon_rp => rivers_data%rivers_ilon_rp
> rivers%rivers_next_rp => rivers_data%rivers_next_rp
> rivers%rivers_x_coord_rp => rivers_data%rivers_x_coord_rp
> rivers%rivers_y_coord_rp => rivers_data%rivers_y_coord_rp
> ! Fluxes.
> rivers%rflow_rp => rivers_data%rflow_rp
> rivers%rivers_outflow_rp => rivers_data%rivers_outflow_rp
> rivers%rrun_rp => rivers_data%rrun_rp
> rivers%rrun_sub_surf_rp => rivers_data%rrun_sub_surf_rp
> rivers%rrun_surf_rp => rivers_data%rrun_surf_rp
> 
> ! Associate pointers for regridding variable.
> rivers%map_river_to_land_points => rivers_data%map_river_to_land_points
> 
> ! Associate pointers for RFM variables.
> rivers%rfm_flowobs1_rp => rivers_data%rfm_flowobs1_rp
> rivers%rfm_iarea_rp => rivers_data%rfm_iarea_rp
> rivers%rfm_land_rp => rivers_data%rfm_land_rp
> rivers%rfm_baseflow_rp => rivers_data%rfm_baseflow_rp
> rivers%rfm_bflowin_rp => rivers_data%rfm_bflowin_rp
> rivers%rfm_flowin_rp => rivers_data%rfm_flowin_rp
> rivers%rfm_rivflow_rp => rivers_data%rfm_rivflow_rp
> rivers%rfm_substore_rp => rivers_data%rfm_substore_rp
> rivers%rfm_surfstore_rp => rivers_data%rfm_surfstore_rp
> 
> ! Associate pointers for TRIP variables.
> rivers%rivers_seq_rp => rivers_data%rivers_seq_rp
> rivers%rivers_sto_rp => rivers_data%rivers_sto_rp
> 
> ! Associate pointers for coupling variables.
> rivers%rivers_outflow_number_rp => rivers_data%rivers_outflow_number_rp
> rivers%sub_surf_roff_rp => rivers_data%sub_surf_roff_rp
> rivers%surf_roff_rp => rivers_data%surf_roff_rp
> 
> RETURN
> END SUBROUTINE allocate_rivers_vars_rp
> 
> !##############################################################################
> 
> SUBROUTINE set_river_point_values( rivers_x1_input, l_use_area, direction_grid,&
>                                    river_mask, rivers, grid_riv_pt_number )
> 
> !------------------------------------------------------------------------------
> ! Description:
> !   Set values at river points - generally by extracting from 2-D ancillary
> !   fields.
> !------------------------------------------------------------------------------
> 
> USE jules_rivers_mod, ONLY:                                                    &
>   a_thresh, i_river_vn, l_riv_overbank, np_rivers, nseqmax, nx_rivers,         &
>   ny_rivers, rfm_land, rfm_river, rivers_dx, rivers_rfm, rivers_trip,          &
>   rivers_x1,                                                                   &
>   ! types
>   rivers_type
> 
> USE model_grid_mod, ONLY: l_coord_latlon
> USE jules_model_environment_mod, ONLY: l_oasis_rivers
> 
> USE overbank_inundation_mod, ONLY:                                             &
>   logn_mean, logn_stdev, logn_mean_rp, logn_stdev_rp, overbank_hypsometric,    &
>   overbank_model
> 
> IMPLICIT NONE
> 
> !------------------------------------------------------------------------------
> ! Scalar arguments with INTENT(IN)
> !------------------------------------------------------------------------------
> REAL(KIND=real_jlslsm), INTENT(IN) ::                                          &
>   rivers_x1_input
>     ! The first value of the x coordinate of the river input grid.
> 
> LOGICAL, INTENT(IN) ::                                                         &
>   l_use_area
>     ! Switch (used with RFM) to use a drainage area ancillary field to identify
>     ! river points.
> 
> !------------------------------------------------------------------------------
> ! Array arguments with INTENT(IN)
> !------------------------------------------------------------------------------
> INTEGER, INTENT(IN) ::                                                         &
>   direction_grid(nx_rivers, ny_rivers),                                        &
>     ! River direction index.
>   river_mask(nx_rivers, ny_rivers)
> 
> !------------------------------------------------------------------------------
> ! Arguments with INTENT(IN OUT)
> !------------------------------------------------------------------------------
> TYPE(rivers_type), INTENT(IN OUT) :: rivers
> 
> !------------------------------------------------------------------------------
> ! Array arguments with INTENT(OUT)
> !------------------------------------------------------------------------------
> INTEGER, INTENT(OUT) ::                                                        &
>   grid_riv_pt_number(nx_rivers, ny_rivers)
>     ! Map full river grid to river points. For each location on the grid, this
>     ! is the river point number.
> 
> !------------------------------------------------------------------------------
> ! Local parameters.
> !------------------------------------------------------------------------------
> CHARACTER(LEN=*), PARAMETER :: RoutineName = 'SET_RIVER_POINT_VALUES'
> 
> !------------------------------------------------------------------------------
> ! Local scalar variables.
> !------------------------------------------------------------------------------
> INTEGER ::                                                                     &
>   ERROR, error_sum,                                                            &
>     ! Error variables.
>   ip, irx, iry, ix, iy
>     ! Counters and index variables.
> 
> !end of header
> !------------------------------------------------------------------------------
> 
> ! Initialise mapping to show no points on grid.
> grid_riv_pt_number(:,:) = 0
> 
> ! Initialise max sequence and point number to zero.
> nseqmax = 0
> ip      = 0
> 
> !------------------------------------------------------------------------------
> ! Scan the river grid for river points and add these to the 1-D river point
> ! fields. The scanning is done so that the order in which points are found is
> ! the same as in previous versions of the code - scanning is columnwise (bottom
> ! to top, i.e. "south to north"), starting with the first column of the river
> ! input grid (NOT the river grid). The intention is to simplify this in future
> ! so that we will simply scan the river grid in a more straightforward
> ! manner, but that will change the order of points in the 1D fields, which
> ! cannot be allowed while standalone JULES does not check that restart files
> ! contain the required locations in the required order. (Without such a check
> ! we would be able to run from an old restart file that had the required points
> ! but in a different order, which would generate incorrect results.)
> !
> ! Here we use the loops over ix and iy to scan the grid. Within this, irx and
> ! iry are calculated so as to preserve the order of points used in previous
> ! versions - in particular irx can differ from ix (if a cyclic shift in the x
> ! direction has been used to map the river input grid to the river grid).
> !------------------------------------------------------------------------------
> 
> ! Initialise irx so that the first increment will take us to the first column
> ! in the river input grid - essentially we are locating rivers_x1_input in the
> ! river grid.
> irx = NINT( (rivers_x1_input - rivers%rivers_xgrid(1)) / rivers_dx )
> 
> ! For now we use ix and iy to scan across a full-sized grid. We calculate irx
> ! and iry to match the old scan order, and load grid value at (irx,iry) into
> ! river vector point ip.
> 
> DO ix = 1,nx_rivers
> 
>   ! Move to next column of river grid.
>   irx = irx + 1
>   ! Deal with cyclic grid.
>   IF ( irx == nx_rivers + 1 ) THEN
>     irx = 1
>   END IF
> 
>   DO iy = 1,ny_rivers
> 
>     ! Trivially iry = iy, but we use this separate iry variable for similarity
>     ! with the (less trivial) irx variable.
>     iry = iy
> 
>     ! Populate 2-D latitude and longitude coordinates.
>     ! Note that if l_coord_latlon=F, the lat-lon coordinates were read from
>     ! a file (and the river input and river grids are identical) and there is
>     ! nothing to do here.
>     IF ( l_coord_latlon ) THEN
>       rivers%rivers_lat2d(irx,iry) = rivers%rivers_ygrid(iry)
>       rivers%rivers_lon2d(irx,iry) = rivers%rivers_xgrid(irx)
>     END IF
798,799c3112,3144
<       ! Set values at river points.
<       IF ( ANY( rivers_dir_int(ix,iy) == flow_dir_river(:) ) ) THEN
---
>     !--------------------------------------------------------------------------
>     ! Set values at river points.
>     !--------------------------------------------------------------------------
>     SELECT CASE ( river_mask(irx,iry) )
> 
>     CASE ( land_in_domain, river_mouth, inland_drainage )
>       ! This should catch all types of river point.
> 
>       ! Increment counter of river points.
>       ip = ip + 1
> 
>       !------------------------------------------------------------------------
>       ! Define mapping between river vector and routing grid.
>       !------------------------------------------------------------------------
>       grid_riv_pt_number(irx,iry) = ip
> 
>       !------------------------------------------------------------------------
>       ! Calculate index of position on river grid.
>       ! Note that this index scans row-wise from bottom left, bottom to top.
>       ! The loops (inside which this comment sits) that control the order in
>       ! which points are found do not necessarily scan the same way - which is
>       ! confusing but acceptable.
>       !------------------------------------------------------------------------
>       rivers%rivers_index_rp(ip) = (iry-1) * nx_rivers + irx
> 
>       !----------------------------------------------------------------------
>       ! Store the latitude and longitude indices for coupling from
>       ! and to the atmospheric model (via OASIS)
>       !----------------------------------------------------------------------
>       IF ( l_oasis_rivers ) THEN
>         rivers%rivers_ilat_rp(ip) = iry
>         rivers%rivers_ilon_rp(ip) = irx
>       END IF
801,802c3146,3175
<         ip = ip + 1
<         rivers%rivers_index_rp(ip) = (ilat-1) * nx_rivers + ilon
---
>       !----------------------------------------------------------------------
>       ! Set river vector information based on 2D input ancillaries.
>       ! First, coordinates and flow direction.
>       !------------------------------------------------------------------------
>       rivers%rivers_lon_rp(ip)     = rivers%rivers_lon2d(irx,iry)
>       rivers%rivers_lat_rp(ip)     = rivers%rivers_lat2d(irx,iry)
>       rivers%rivers_x_coord_rp(ip) = rivers%rivers_xgrid(irx)
>       rivers%rivers_y_coord_rp(ip) = rivers%rivers_ygrid(iry)
> 
>       !------------------------------------------------------------------------
>       ! Set values that depend on the chosen river model.
>       !------------------------------------------------------------------------
>       IF ( i_river_vn == rivers_rfm ) THEN
>         !----------------------------------------------------------------------
>         ! RFM variables.
>         !----------------------------------------------------------------------
>         IF ( l_use_area ) THEN
>           ! Set drainage area from ancillary.
>           rivers%rfm_iarea_rp(ip) = NINT( rivers%rivers_dra(irx,iry) )
>         ELSE
>           ! Ancillary not present. Set area above threshold, so that all
>           ! points will be identified as rivers.
>           rivers%rfm_iarea_rp(ip) = a_thresh + 1
>         END IF
>         ! Set points to be either land or river.
>         IF (rivers%rfm_iarea_rp(ip) > a_thresh) THEN
>           rivers%rfm_land_rp(ip) = rfm_river  ! river
>         ELSE
>           rivers%rfm_land_rp(ip) = rfm_land   ! land
>         END IF
804,809c3177,3181
<         ! Update river vector information from 2D input ancillaries
<         rivers%rivers_lon_rp(ip) = rivers%rivers_lon2d(ilon,ilat)
<         rivers%rivers_lat_rp(ip) = rivers%rivers_lat2d(ilon,ilat)
<         rivers%rivers_dir_rp(ip) = rivers_dir_int(ix,iy)
<         rivers%rivers_dra_rp(ip) = rivers%rivers_dra(ix,iy)
<         rivers%rivers_seq_rp(ip) = NINT(rivers%rivers_seq(ix,iy))
---
>       ELSE IF ( i_river_vn == rivers_trip ) THEN
>         !----------------------------------------------------------------------
>         ! TRIP variables.
>         !----------------------------------------------------------------------
>         rivers%rivers_seq_rp(ip) = NINT(rivers%rivers_seq(irx,iry))
814,829c3186,3194
<         IF ( i_river_vn == rivers_rfm ) THEN
<           ! Initialise drainage area from iarea ancillary
<           IF ( set_dra ) THEN
<             rivers%rfm_iarea_rp(ip) = NINT( rivers%rivers_dra(ix,iy) )
<           ELSE
<             ! if not present, set area above threshold, so that all points
<             ! will be identified as rivers
<             rivers%rfm_iarea_rp(ip) = a_thresh + 1
<           END IF
<           ! Set points to be either land or river.
<           IF (rivers%rfm_iarea_rp(ip) > a_thresh) THEN
<             rivers%rfm_land_rp(ip) = rfm_river  ! river
<           ELSE
<             rivers%rfm_land_rp(ip) = rfm_land   ! land
<           END IF
<         END IF  !  RFM
---
>       END IF  !  i_river_vn
> 
>       !------------------------------------------------------------------------
>       ! Set values of coupling variables.
>       !------------------------------------------------------------------------
>       IF ( l_riv_number ) THEN
>         rivers%rivers_outflow_number_rp(ip) =                                  &
>                                     NINT(rivers%rivers_outflow_number(irx,iry))
>       END IF
831,832c3196,3202
<         ! Define mapping between ip river vector and 2D x,y routing grid
<         mapfr(ilon,ilat) = ip
---
>       !------------------------------------------------------------------------
>       ! Set overbank inundation ancillary variables, if required.
>       !------------------------------------------------------------------------
>       IF ( l_riv_overbank .AND. overbank_model == overbank_hypsometric ) THEN
>         logn_mean_rp(ip)  = logn_mean(irx,iry)
>         logn_stdev_rp(ip) = logn_stdev(irx,iry)
>       END IF
834,838c3204
<         ! Define overbank inundation ancillary variables, if required
<         IF ( l_riv_overbank .AND. l_riv_hypsometry ) THEN
<           logn_mean_rp(ip) = logn_mean(ix,iy)
<           logn_stdev_rp(ip) = logn_stdev(ix,iy)
<         END IF
---
>     END SELECT  !  river_mask
840c3206,3207
<       END IF  !  rivers_dir_int
---
>   END DO  !  iy
> END DO  !  ix
842,843c3209,3213
<     END DO     ! iy river rows
<   END DO    ! ix river columns
---
> ! Double check that we have found all the river points.
> IF ( ip /= np_rivers ) THEN
>   CALL log_fatal( RoutineName,                                                 &
>                   "Failure of logic; did not find all river points." )
> END IF
845,849c3215,3216
<   ! Double check that we have found all the river points.
<   IF ( ip /= np_rivers ) THEN
<     CALL log_fatal(RoutineName,                                                &
<                    "Failure of logic; did not find all river points.")
<   END IF
---
> RETURN
> END SUBROUTINE set_river_point_values
851,853c3218,3227
<   !---------------------------------------------------------------------------
<   ! Identify the next downstream point from flow direction.
<   !---------------------------------------------------------------------------
---
> !##############################################################################
> 
> SUBROUTINE find_downstream_points( direction_grid, nextx_grid, nexty_grid,     &
>                                    rivers_index_rp, river_mask,                &
>                                    rivers_next_rp )
> 
> !------------------------------------------------------------------------------
> ! Description:
> !   Identify the next downstream point in the river vector.
> !------------------------------------------------------------------------------
855c3229,3232
<   DO ip = 1,np_rivers
---
> USE jules_rivers_mod, ONLY:                                                    &
>   flow_dir_delta, np_rivers, nx_rivers, ny_rivers
> 
> USE rivers_regrid_mod, ONLY: get_xy_pos
857c3234
<     SELECT CASE ( rivers%rivers_dir_rp(ip) )
---
> IMPLICIT NONE
859,871c3236,3294
<     CASE ( 1:8 )
<       ! These are the 8 "physical" flow directions, i.e. there is a flow
<       ! direction and a point downstream of this.
<       CALL rivers_get_xy_pos(rivers%rivers_index_rp(ip),nx_rivers,ny_rivers,ix,iy)
<       inext = ix + flow_dir_delta( rivers%rivers_dir_rp(ip),1 )
<       jnext = iy + flow_dir_delta( rivers%rivers_dir_rp(ip),2 )
< 
<       ! Deal with cyclic boundaries.
<       ! Note that these lines allow the possibility of flow to a point that
<       ! is not an immediate neighbour.
<       IF ( l_cyclic_x ) THEN
<         IF ( inext > nx_rivers ) inext = inext - nx_rivers
<         IF ( inext < 1 ) inext = inext + nx_rivers
---
> !------------------------------------------------------------------------------
> ! Array arguments with INTENT(IN)
> !------------------------------------------------------------------------------
> INTEGER, INTENT(IN) ::                                                         &
>   direction_grid(nx_rivers,ny_rivers),                                         &
>     ! River routing direction index.
>   nextx_grid(nx_rivers,ny_rivers),                                             &
>     ! x index of the next downstream point.
>   nexty_grid(nx_rivers,ny_rivers),                                             &
>     ! y index of the next downstream point.
>   rivers_index_rp(np_rivers),                                                  &
>     ! Index of points where routing is calculated.
>     ! This index refers to position in the river grid.
>   river_mask(nx_rivers,ny_rivers)
>     ! Indicates type of each point.
> 
> !------------------------------------------------------------------------------
> ! Array arguments with INTENT(OUT)
> !------------------------------------------------------------------------------
> INTEGER, INTENT(OUT) ::                                                        &
>   rivers_next_rp(np_rivers)
>     ! Index (river point number) of the next downstream point.
> 
> !------------------------------------------------------------------------------
> ! Local parameters.
> !------------------------------------------------------------------------------
> CHARACTER(LEN=*), PARAMETER :: RoutineName = 'FIND_DOWNSTREAM_POINTS'
> 
> !------------------------------------------------------------------------------
> ! Local scalar variables.
> !------------------------------------------------------------------------------
> INTEGER ::                                                                     &
>   inext, ip, ix, iy, jnext
>     ! Counters and index variables.
> 
> !end of header
> !------------------------------------------------------------------------------
> 
> ! Note that there is no need to initialise rivers_next_rp as we set a value at
> ! every point.
> 
> DO ip = 1,np_rivers
> 
>   ! Get location on the river grid.
>   CALL get_xy_pos(rivers_index_rp(ip),nx_rivers,ny_rivers,ix,iy)
> 
>   SELECT CASE ( river_mask(ix,iy) )
> 
>   CASE ( land_in_domain )
> 
>     ! This is a "regular" river point with a defined flow direction (not a
>     ! special case such as a mouth). The next point can be either another river
>     ! point or flow across the edge of the river domain or river grid.
> 
>     IF ( ANY( nextx_grid(ix,iy) == flow_dir_river_edge(:) ) ) THEN
> 
>       ! Flow across the edge of the river domain or grid.
>       IF ( l_use_direction ) THEN
>         rivers_next_rp(ip) = -direction_grid(ix,iy)
874,898c3297,3306
<       ! Identify the next point downstream.
<       IF ( inext >= 1 .AND. inext <= nx_rivers .AND. jnext >=1                 &
<            .AND. jnext <= ny_rivers ) THEN
<         ! The next point is on the river grid. Check that it is a river point.
<         IF ( mapfr(inext, jnext) > 0 ) THEN
<           ! The next point is a river point.
<           rivers%rivers_next_rp(ip) = mapfr(inext,jnext)
<         ELSE
<           ! The next point is on the grid but is not a river point.
<           IF ( rivers_dir_int(inext,jnext) == flow_dir_sea ) THEN
<             ! The next point is sea. In many ancillary files this point would
<             ! have been flagged as a river mouth. Convert the current  point
<             ! to a river mouth (but there is no need to change
<             ! rivers%rivers_dir_rpas it is not used again).
<             rivers%rivers_next_rp(ip) = -river_mouth
<           ELSE
<             ! The next point is land (but it is not in the valid river
<             ! domain). Save the direction in which it lies.
<             ! Note that because it it on the grid we know its location (i.e.
<             ! we have lat-lon values) but this information will not be
<             ! available to the science code (which only gets the coordinates
<             ! of river points).
<             rivers%rivers_next_rp(ip) = -rivers%rivers_dir_rp(ip)
<           END IF
<         END IF  !  mapfr
---
>     ELSE
> 
>       ! Flow to another river location in the grid.
>       inext = nextx_grid(ix,iy)
>       jnext = nexty_grid(ix,iy)
> 
>       !  Check if the next location is also in the river point vector.
>       IF ( grid_riv_pt_number(inext, jnext) > 0 ) THEN
>         ! The next location is a river (vector) point.
>         rivers_next_rp(ip) = grid_riv_pt_number(inext,jnext)
900,919c3308,3322
<         ! The next point is not on the grid, but we know which direction it
<         ! lies in. Save that information for later use when getting a length
<         ! for the flow. Note that flow across the E or W edge of a cyclic
<         ! global grid is dealt with above.
<         rivers%rivers_next_rp(ip) = -rivers%rivers_dir_rp(ip)
<       END IF  !  inext
< 
<     CASE ( river_mouth )
< 
<       ! Identify this with a special value < 0.
<       rivers%rivers_next_rp(ip) = -river_mouth
< 
<     CASE ( inland_drainage )
<       ! Identify this with a special value < 0.
<       rivers%rivers_next_rp(ip) = -inland_drainage
< 
<     CASE DEFAULT
<       CALL log_fatal(RoutineName,                                              &
<                      "Unexpected flow direction: " //                          &
<                      TRIM(to_string(rivers%rivers_dir_rp(ip))) )
---
>         ! The next point is a river but it is not in the valid river domain
>         ! (not in the river point vector). For some configurations we will save
>         ! the direction in which this next point lies.
>         ! It is relatively straightforward to get the direction if that was a
>         ! direct input (l_use_direction=T), but more involved if we start with
>         ! nextx and nexty fields - and for now we do not attempt to deal with
>         ! that possibility (which is not yet allowed).
>         ! Note that because the next point is on the grid we currently know its
>         ! location (i.e. we have lat-lon values) but this information will not
>         ! be available to the science code (which only gets the coordinates
>         ! of river points).
>         IF ( l_use_direction ) THEN
>           rivers_next_rp(ip) = -direction_grid(ix,iy)
>         END IF
>       END IF  !  grid_riv_pt_number
921c3324
<     END SELECT  !  rivers%rivers_dir_rp
---
>     END IF  !  nextx_grid
923c3326
<   END DO  !  ip
---
>   CASE ( river_mouth )
925,931c3328,3329
<   ! At this point all values of rivers%rivers_next_rp are one of the following:
<   !   -10 : an inland drainage point (value = -1*inland_drainage)
<   !    -9 : a river mouth (value = -1*river_mouth)
<   ! -8:-1 : next point is not a river point - it is outside of the valid river
<   !         domain, and possibly off the river grid
<   !         (value = -1*rivers%rivers_dir_rp)
<   !    >0 : next point is on the grid.
---
>     ! A river mouth. Identify this with a special value < 0.
>     rivers_next_rp(ip) = river_mouth
933,935c3331,3333
<   ! Note that the science code could use rivers%rivers_next_rp values in -8:-1 to
<   ! sum flow across the edge of the domain, e.g. to check conservation of
<   ! mass. That is not currently coded.
---
>   CASE ( inland_drainage )
>     ! An inand drainage point. Identify this with a special value < 0.
>     rivers_next_rp(ip) = inland_drainage
937c3335,3338
<   DEALLOCATE(mapfr)
---
>   CASE DEFAULT
>     CALL log_fatal( RoutineName,                                               &
>                     "Unexpected flow direction (nextx_grid): "              // &
>                     TRIM(to_string(nextx_grid(ix,iy))) )
939,941c3340
<   !---------------------------------------------------------------------------
<   ! Check routing and model grid settings are appropriate
<   !---------------------------------------------------------------------------
---
>   END SELECT  !  river_mask
943,970c3342
<   ! Check that full routing latitude/longitude grid within range
<   IF ( ANY(rivers%rivers_lat2d < -90.0) .OR. ANY(rivers%rivers_lat2d > 90.0) ) &
<     CALL log_fatal(RoutineName,                                                &
<                    "Latitude is out of range - allowed range is " //           &
<                    "-90.0 to 90.0, given range is " //                         &
<                    TRIM(to_string(MINVAL(rivers%rivers_lat2d))) // " to " //   &
<                    TRIM(to_string(MAXVAL(rivers%rivers_lat2d))))
< 
<   IF (ANY(rivers%rivers_lon2d < -180.0) .OR. ANY(rivers%rivers_lon2d > 360.0)) &
<      CALL log_fatal(RoutineName,                                               &
<                    "Longitude is out of range - allowed range is " //          &
<                    "-180.0 to 360.0, given range is " //                       &
<                    TRIM(to_string(MINVAL(rivers%rivers_lon2d))) // " to " //   &
<                    TRIM(to_string(MAXVAL(rivers%rivers_lon2d))))
< 
<   ! Checks for grids other than regular latitude/longitude.
<   IF ( .NOT. rivers_reglatlon ) THEN
< 
<     ! Must be regular for any regridding methods
<     IF ( rivers_regrid ) THEN
<       WRITE(jules_message,*) "ERROR: init_rivers: routing codes with " //      &
<                              "regridding only currently exist for " //         &
<                              "regular lat/lon grids."
<       CALL jules_print('init_rivers_props',jules_message)
<       CALL log_fatal(RoutineName,                                              &
<                      "Error in routing - non-regular lat/lon river grid " //   &
<                      "defined and regridding requested. This is not a " //     &
<                      "valid option currently.")
---
> END DO  !  ip
972c3344
<     END IF
---
> END SUBROUTINE find_downstream_points
974,983c3346
<     ! Check if rivers_dx set
<     IF ( rivers_dx <= 0 ) THEN
<       WRITE(jules_message,*) "ERROR: init_rivers: routing codes with " //      &
<                            "non-regular lat/lon grid require setting " //      &
<                            "rivers_dx > 0 in the namelist."
<       CALL jules_print('init_rivers_props',jules_message)
<       CALL log_fatal(RoutineName,                                              &
<                    "Error in routing - non-regular lat/lon river grid " //     &
<                    "defined but no grid dimension size provided.")
<     END IF
---
> !##############################################################################
985c3348,3349
<   END IF  !  .NOT. rivers_reglatlon
---
> SUBROUTINE check_river_coverage( map_river_to_land_points, global_proj_x_land, &
>                  global_proj_y_land, rivers_x_coord_rp, rivers_y_coord_rp )
987,989c3351,3355
<   !---------------------------------------------------------------------------
<   ! Check that land grid points fall on the calculated model grid.
<   !---------------------------------------------------------------------------
---
> !------------------------------------------------------------------------------
> ! Description:
> !   Assesses the extent to which the land and river layers overlap, so as to
> !   produce diagnostic messages.
> !------------------------------------------------------------------------------
991,1014c3357,3358
<   IF ( rivers_reglatlon ) THEN
<     ! n.b. in parallel mode, this check is not comprehensive (there might be
<     ! a different gap around the edges of the regions given to each task)
<     DO i = 1,SIZE(latitude, DIM = 1)
<       DO j = 1,SIZE(longitude, DIM = 2)
<         ! Calculate number of gridboxes from edge.
<         rix = (longitude(i,j) - reg_lon1) / reg_dlon
<         riy = (latitude(i,j) - reg_lat1)  / reg_dlat
<         ! Error if the location does not match the expected grid - if the
<         ! difference is a non-negligible fraction of a gridbox.
<         ! Essentially we are checking that this location appears to be
<         ! "sufficiently close" to the model grid (where "sufficiently close"
<         ! allows for differences from the finite precision of the calculation)
<         IF ( ABS( rix - NINT(rix) ) > location_toler .OR.                      &
<              ABS( riy - NINT(riy) ) > location_toler ) THEN
<           CALL log_fatal(RoutineName,                                          &
<                          "Land grid points do not coincide with " //           &
<                          "calculated main model grid. "           //           &
<                          "latitude=" // TRIM(to_string(latitude(i,j))) //      &
<                          " longitude=" // TRIM(to_string(longitude(i,j))) )
<         END IF
<       END DO
<     END DO
<   END IF
---
> USE jules_rivers_mod, ONLY: land_dx, land_dy, l_trivial_mapping, np_rivers,    &
>                             rivers_dx, rivers_dy, rivers_regrid
1016c3360
<   ! Checks for compatible dimension sizes if not regridding
---
> USE model_grid_mod, ONLY: global_land_pts
1018c3362
<   IF ( .NOT. rivers_regrid ) THEN
---
> IMPLICIT NONE
1020,1026c3364,3410
<     IF ( nx_rivers /= nx_grid .OR. ny_rivers /= ny_grid ) THEN
<       CALL jules_print(RoutineName,jules_message)
<       CALL log_fatal(RoutineName,                                              &
<          "Error in routing - model grid and river grid dimensions " //         &
<          " must be equal size if no regridding attempted.")
<     END IF
<   END IF
---
> !------------------------------------------------------------------------------
> ! Array arguments with INTENT(IN)
> !------------------------------------------------------------------------------
> INTEGER, INTENT(IN) ::                                                         &
>   map_river_to_land_points(np_rivers)
>     ! List of coincident land point numbers, on river points.
> 
> REAL(KIND=real_jlslsm), INTENT(IN) ::                                          &
>   global_proj_x_land(global_land_pts),                                         &
>     ! x coordinates of land points.
>   global_proj_y_land(global_land_pts),                                         &
>     ! y coordinates of land points.
>   rivers_x_coord_rp(np_rivers),                                                &
>     ! River routing point projection x coordinates.
>   rivers_y_coord_rp(np_rivers)
>     ! River routing point projection y coordinates.
> 
> !------------------------------------------------------------------------------
> ! Local scalar parameters.
> !------------------------------------------------------------------------------
> CHARACTER(LEN=*), PARAMETER :: RoutineName = 'CHECK_RIVER_COVERAGE'
> 
> !------------------------------------------------------------------------------
> ! Local scalar variables.
> !------------------------------------------------------------------------------
> INTEGER ::                                                                     &
>   num_match,                                                                   &
>     ! Number of points for which a matching point is found.
>   num_no_match
>     ! Number of points for which no matching point is found.
> 
> REAL(KIND=real_jlslsm) ::                                                      &
>   dx_toler, dy_toler
>     ! Tolerances. Units depend on the coordinate system in use.
> 
> !------------------------------------------------------------------------------
> ! Local array variables.
> !------------------------------------------------------------------------------
> REAL(KIND=real_jlslsm) ::                                                      &
>   land_x_bounds_edge(2),                                                       &
>     ! x coordinates of westermost and easternmost edges of land gridboxes.
>   land_y_bounds_edge(2),                                                       &
>     ! y coordinates of southernmost and northernmost edges of land gridboxes.
>   rivers_x_bounds_edge(2),                                                     &
>     ! x coordinates of westermost and easternmost edges of river gridboxes.
>   rivers_y_bounds_edge(2)
>     ! y coordinates of southernmost and northernmost edges of river gridboxes.
1028,1030c3412,3413
<   !---------------------------------------------------------------------------
<   ! Initialise river gridbox areas (m2) and set grid spacing (m)
<   !---------------------------------------------------------------------------
---
> !end of header
> !------------------------------------------------------------------------------
1032,1037c3415
<   IF ( rivers_dlat == 0 ) THEN
<     rivers_dlat = rivers%rivers_lat2d(2,2) - rivers%rivers_lat2d(1,1)
<   END IF
<   IF ( rivers_dlon == 0 ) THEN
<     rivers_dlon = rivers%rivers_lon2d(2,2) - rivers%rivers_lon2d(1,1)
<   END IF
---
> IF ( rivers_regrid ) THEN
1039c3417,3424
<   IF ( rivers_reglatlon ) THEN
---
>   !----------------------------------------------------------------------------
>   ! Regridding can take place between grids of different resolutions and with
>   ! grids that do not nest (i.e. a gridbox on one grid can straddle multiple
>   ! gridboxes on the other grid). As such it is non-trivial to determine the
>   ! extent to which each land gridbox is covered by river boxes, and vice
>   ! versa. Instead we test and report on some necessary but not sufficient
>   ! conditions.
>   !----------------------------------------------------------------------------
1041,1043c3426,3478
<     IF ( rivers_dx < 0 ) THEN
<       rivers_dx = planet_radius * (ABS(rivers_dlat) * pi_over_180)
<     END IF
---
>   ! Get the coordinates at the outer edges of the extreme land gridboxes.
>   ! (For some configurations these have already been calculated.)
>   land_x_bounds_edge(1) = MINVAL( global_proj_x_land ) - 0.5 * land_dx
>   land_x_bounds_edge(2) = MAXVAL( global_proj_x_land ) + 0.5 * land_dx
>   land_y_bounds_edge(1) = MINVAL( global_proj_y_land ) - 0.5 * land_dy
>   land_y_bounds_edge(2) = MAXVAL( global_proj_y_land ) + 0.5 * land_dy
> 
>   CALL log_info( RoutineName,                                                  &
>                  "Outer edges of land gridboxes are at x="                 //  &
>                   TRIM(to_string(land_x_bounds_edge(1))) // ' to '         //  &
>                   TRIM(to_string(land_x_bounds_edge(2))) // ' y='          //  &
>                   TRIM(to_string(land_y_bounds_edge(1))) // ' to '         //  &
>                   TRIM(to_string(land_y_bounds_edge(2))) )
> 
>   ! Get the coordinates at the outer edges of the extreme river gridboxes.
>   rivers_x_bounds_edge(1) = MINVAL( rivers_x_coord_rp(:) ) - 0.5 * rivers_dx
>   rivers_x_bounds_edge(2) = MAXVAL( rivers_x_coord_rp(:) ) + 0.5 * rivers_dx
>   rivers_y_bounds_edge(1) = MINVAL( rivers_y_coord_rp(:) ) - 0.5 * rivers_dy
>   rivers_y_bounds_edge(2) = MAXVAL( rivers_y_coord_rp(:) ) + 0.5 * rivers_dy
> 
>   CALL log_info( RoutineName,                                                  &
>                  "Outer edges of river gridboxes are at x="                 // &
>                  TRIM(to_string(rivers_x_bounds_edge(1))) // ' to '         // &
>                  TRIM(to_string(rivers_x_bounds_edge(2))) // ' y='          // &
>                  TRIM(to_string(rivers_y_bounds_edge(1))) // ' to '         // &
>                  TRIM(to_string(rivers_y_bounds_edge(2))) )
> 
>   ! Look for river gridboxes that have some area outside the land area, by
>   ! comparing the coordinates of the edges of the extreme gridboxes, allowing
>   ! a small tolerance based on river gridbox size.
>   dx_toler = frac_toler * rivers_dx
>   dy_toler = frac_toler * rivers_dy
>   IF ( rivers_x_bounds_edge(1) < land_x_bounds_edge(1) - dx_toler  .OR.        &
>        rivers_x_bounds_edge(2) > land_x_bounds_edge(2) + dx_toler  .OR.        &
>        rivers_y_bounds_edge(1) < land_y_bounds_edge(1) - dy_toler  .OR.        &
>        rivers_y_bounds_edge(2) > land_y_bounds_edge(2) + dy_toler ) THEN
>     CALL log_info( RoutineName,                                                &
>                    "There are river gridboxes outside the area of land. " //   &
>                    " Runoff to these river sections will be zero." )
>   END IF
> 
>   ! Look for land gridboxes that have some area outside the river area,
>   ! allowing a small tolerance based on land gridbox size.
>   dx_toler = frac_toler * land_dx
>   dy_toler = frac_toler * land_dy
>   IF ( land_x_bounds_edge(1) < rivers_x_bounds_edge(1) - dx_toler  .OR.        &
>        land_x_bounds_edge(2) > rivers_x_bounds_edge(2) + dx_toler  .OR.        &
>        land_y_bounds_edge(1) < rivers_y_bounds_edge(1) - dy_toler  .OR.        &
>        land_y_bounds_edge(2) > rivers_y_bounds_edge(2) + dy_toler ) THEN
>     CALL log_info( RoutineName,                                                &
>                    "There are land gridboxes outside the area of rivers. " //  &
>                    " Runoff from these will not enter the river system." )
>   END IF
1045,1046c3480
<     dlat = 0.5 * rivers_dlat
<     dlon = 0.5 * rivers_dlon
---
> ELSE
1048,1054c3482,3487
<     DO ip = 1,np_rivers
<       rivers%rivers_boxareas_rp(ip) = ABS( rivers_earth_area(                  &
<                                              rivers%rivers_lat_rp(ip) - dlat,  &
<                                              rivers%rivers_lat_rp(ip) + dlat,  &
<                                              rivers%rivers_lon_rp(ip) - dlon,  &
<                                              rivers%rivers_lon_rp(ip) + dlon ))
<     END DO
---
>   !----------------------------------------------------------------------------
>   ! .NOT. river_regrid
>   ! In this case grids are of the same resolution and we have 1:1 mappings.
>   !----------------------------------------------------------------------------
>   ! Report on how many land and river points match.
>   IF ( l_trivial_mapping ) THEN
1056c3489,3490
<   ELSE
---
>     CALL log_info( RoutineName,                                                &
>                    "Land and river points are identical (trivial mapping)." )
1058c3492
<     rivers%rivers_boxareas_rp(:) = rivers_dx * rivers_dx
---
>   ELSE
1060c3494,3504
<   END IF
---
>     ! Report on river points for which no matching land point was found.
>     num_no_match = COUNT( map_river_to_land_points(:) == 0 )
>     IF ( num_no_match == 0 ) THEN
>       CALL log_info( RoutineName,                                              &
>                      "All river points have a matching land point." )
>     ELSE
>       CALL log_info( RoutineName,                                              &
>                      "Number of river points without a matching land "      // &
>                      "point = " // TRIM(to_string(num_no_match))            // &
>                      ". Runoff to these river sections will be zero." )
>     END IF
1062,1077c3506,3518
<   !---------------------------------------------------------------------------
<   ! Define overbank inundation initial variables for bankfull on river points
<   ! if using Rosgen entrenchment option.
<   ! Bankfull discharge (qbf) from power-law relationship from
<   ! "Flood Modeling, Prediction and Mitigation" by Sen 2018.
<   ! Bankfull width and depth (wbf, dbf) from Leopold & Maddock (1953).
<   !---------------------------------------------------------------------------
<   IF ( l_riv_overbank .AND. use_rosgen ) THEN
<     DO ip = 1,np_rivers
<       contribarea = (rivers%rivers_boxareas_rp(ip) * m2tokm2) *                &
<                     ( 1.0 + MAX(0.0, REAL(rivers%rfm_iarea_rp(ip))) )
<       qbf(ip) = coef_b * ( contribarea**exp_c )
<       wbf(ip) = riv_a * ( qbf(ip)**riv_b )
<       dbf(ip) = riv_c * ( qbf(ip)**riv_f )
<     END DO
<   END IF
---
>     ! Report on land points for which no matching river point was found.
>     ! First count river points with matching land points.
>     num_match = COUNT( map_river_to_land_points(:) > 0 )
>     IF ( num_match == global_land_pts ) THEN
>       CALL log_info( RoutineName,                                              &
>                      "All land points have a matching river point." )
>     ELSE
>       CALL log_info( RoutineName,                                              &
>                      "Number of land points without a matching river "      // &
>                      "point = "                                             // &
>                      TRIM(to_string(global_land_pts - num_match))           // &
>                      ". Runoff from these will not enter the river system." )
>     END IF
1079,1087c3520
<   !---------------------------------------------------------------------------
<   ! Calculate land_pts to river_pts remappings ahead of main run
<   !---------------------------------------------------------------------------
<   IF ( rivers_regrid ) THEN
<     CALL rivers_remap_unmatch(rivers%ir_land_grid)
<   ELSE IF ( global_land_pts /= np_rivers ) THEN
<     CALL rivers_remap_match(rivers%ir_land_grid, rivers%il_river_grid,         &
<                             rivers%rivers_lat_rp, rivers%rivers_lon_rp)
<   END IF
---
>   END IF  !  l_trivial_match
1089,1091c3522
<   !---------------------------------------------------------------------------
<   ! Reset saved JULES grid from river to full land model
<   !---------------------------------------------------------------------------
---
> END IF  !  rivers_regrid
1093,1096c3524,3525
<   dummy_grid = grid_create(local_grid%is_1d,local_grid%dim_name,               &
<                            local_grid%nx,local_grid%x_name,local_grid%nx,      &
<                            local_grid%y_name,local_grid%ny)
<   use_subgrid = use_sub_local
---
> RETURN
> END SUBROUTINE check_river_coverage
1098c3527
< END IF ! (check global_landpoint > 1)
---
> !##############################################################################
1100d3528
< END SUBROUTINE init_rivers_props
diff -r vn7.0copy1_c4/src/./initialisation/standalone/ancillaries/init_soil_props_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/standalone/ancillaries/init_soil_props_mod.F90
33c33
<    soil_model_ecosse, soil_model_rothc,                                        &
---
>    soil_model_ecosse, soil_model_4pool,                                        &
160,161c160,161
<   ! If RothC is selected, clay is required.
<   IF ( soil_bgc_model == soil_model_rothc ) THEN
---
>   ! If 4-pool soil C is selected, clay is required.
>   IF ( soil_bgc_model == soil_model_4pool ) THEN
169,171c169,171
<                     "No value given for soil clay content. "            //     &
<                     "Soil clay content is required with RothC model. "  //     &
<                     "It will be set to 0.0 as for previous versions. "  //     &
---
>                     "No value given for soil clay content. "              //   &
>                     "Soil clay content is required with 4-pool C model. " //   &
>                     "It will be set to 0.0 as for previous versions. "    //   &
diff -r vn7.0copy1_c4/src/./initialisation/standalone/ancillaries/init_urban_props_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/standalone/ancillaries/init_urban_props_mod.F90
26a27
> USE calc_urban_aero_fields_mod,     ONLY: calc_urban_aero_fields
33c34
< USE ancil_info, ONLY: land_pts, surft_pts
---
> USE ancil_info, ONLY: land_pts
35c36
< USE jules_surface_types_mod, ONLY: ice, urban, urban_canyon
---
> USE jules_surface_types_mod, ONLY: urban_canyon, urban_roof
39,40d39
< USE urban_param_mod, ONLY: cdz, kappa2, a, z0m_mat
< 
83,87d81
< REAL(KIND=real_jlslsm) :: sc_hwr(land_pts), d_h(land_pts)  ! Work variables
< REAL(KIND=real_jlslsm) :: lambdaf, lambdap
< 
< INTEGER :: i,l  ! Index variables
< 
157,159c151,153
< CALL tilepts(land_pts, ainfo%frac_surft, surft_pts, ainfo%surft_index,         &
<              ainfo%l_lice_point)
< IF ( surft_pts(urban_canyon) == 0 )                                            &
---
> CALL tilepts(land_pts, ainfo%frac_surft, ainfo%surft_pts, ainfo%surft_index,   &
>              ainfo%l_lice_point, ainfo%l_lice_surft)
> IF ( ainfo%surft_pts(urban_canyon) == 0 )                                      &
189,191c183,191
<   ! For urban2t, we only need wrr
<   nvars_required = 1
<   required_vars(1) = 'wrr'
---
>   ! For urban2t, we only need wrr if there are no urban_roof points. This
>   ! indicates that total urban fraction is contained in frac(urban_canyon)
>   IF ( ainfo%surft_pts(urban_roof) == 0 .AND.                                  &
>        ainfo%surft_pts(urban_canyon) > 0 ) THEN
>     CALL log_info(RoutineName,                                                 &
>        "wrr is a required variable as total urban fraction supplied")
>     nvars_required = 1
>     required_vars(1) = 'wrr'
>   END IF
218c218
<                                   urban_param)
---
>                                   ainfo%surft_pts, urban_param)
222,240c222,224
<   ! Macdonald Formulation
<   CALL log_info(RoutineName, "Using MacDonald formulation")
< 
<   sc_hwr(:) = 0.5 * ( urban_param%hwr_gb(:) / (2.0 * ATAN(1.0)) )
<   d_h(:)    = 1.0 - urban_param%wrr_gb(:) *                                    &
<               ( a**(urban_param%wrr_gb(:) - 1.0) )
<   DO l = 1,land_pts
<     IF ( urban_param%wrr_gb(l) > 0.0 .AND. urban_param%wrr_gb(l) < 1.0 ) THEN
<       urban_param%disp_gb(l) = d_h(l) * urban_param%hgt_gb(l)
<       urban_param%ztm_gb(l)  = (cdz * (1.0 - d_h(l)) *                         &
<                    sc_hwr(l) * urban_param%wrr_gb(l) / kappa2)**(-0.5)
<       urban_param%ztm_gb(l)  = (1.0 - d_h(l)) * EXP(-urban_param%ztm_gb(l))
<       urban_param%ztm_gb(l)  = urban_param%ztm_gb(l) * urban_param%hgt_gb(l)
<       urban_param%ztm_gb(l)  = MAX(urban_param%ztm_gb(l), z0m_mat)
<     ELSE
<       urban_param%disp_gb(l) = 0.0
<       urban_param%ztm_gb(l)  = 0.0
<     END IF
<   END DO
---
>   CALL calc_urban_aero_fields(land_pts, urban_param%wrr_gb,                    &
>                               urban_param%hwr_gb, urban_param%hgt_gb,          &
>                               urban_param%ztm_gb, urban_param%disp_gb)
diff -r vn7.0copy1_c4/src/./initialisation/standalone/grid/fill_model_grid_arrays_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/standalone/grid/fill_model_grid_arrays_mod.F90
16,17c16,17
< USE model_grid_mod, ONLY: latitude, longitude,                                 &
<                            latitude_of_land_pts, longitude_of_land_pts
---
> USE model_grid_mod, ONLY: projection_x_coord, projection_x_coord_land,         &
>                           projection_y_coord, projection_y_coord_land
51,52c51,52
< ALLOCATE(latitude_of_land_pts(land_pts))
< ALLOCATE(longitude_of_land_pts(land_pts))
---
> ALLOCATE( projection_x_coord_land(land_pts) )
> ALLOCATE( projection_y_coord_land(land_pts) )
59,62c59,62
<       ainfo_data%land_index(l) = (j-1) * t_i_length + i
<       coastal_data%fland(l) = flandg(i,j)
<       latitude_of_land_pts(l)  = latitude(i,j)
<       longitude_of_land_pts(l) = longitude(i,j)
---
>       ainfo_data%land_index(l)   = (j-1) * t_i_length + i
>       coastal_data%fland(l)      = flandg(i,j)
>       projection_x_coord_land(l) = projection_x_coord(i,j)
>       projection_y_coord_land(l) = projection_y_coord(i,j)
diff -r vn7.0copy1_c4/src/./initialisation/standalone/grid/init_dim_sizes_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/standalone/grid/init_dim_sizes_mod.F90
19c19
<                                       soil_model_rothc, l_layeredC,            &
---
>                                       soil_model_4pool, l_layeredC,            &
27c27
<                        dim_cs1, dim_cs2,                                       &
---
>                        dim_cs1,                                                &
46c46
<                                 sclayer_dim_size, tracer_dim_size,             &
---
>                                 sclayer_dim_size, dep_species_dim_size,        &
92d91
<   dim_cs2         = 1  !  1 as this model is not used with TRIFFID
98c97
< CASE ( soil_model_rothc )
---
> CASE ( soil_model_4pool )
101d99
<   dim_cs2         = land_pts
110d107
<   dim_cs2         = land_pts
138c135
< tracer_dim_size   = ndry_dep_species
---
> dep_species_dim_size = ndry_dep_species
diff -r vn7.0copy1_c4/src/./initialisation/standalone/grid/init_grid_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/standalone/grid/init_grid_mod.F90
21a22
>                               imgn_vars_data,                                  &
25c26,27
<                               chemvars_data                                    &
---
>                               chemvars_data, water_resources_data,             &
>                               wtrac_jls_data                                   &
63a66
> USE imgn_vars_mod, ONLY: imgn_vars_data_type
67a71,72
> USE water_resources_vars_mod, ONLY: water_resources_data_type
> USE jules_wtrac_type_mod, ONLY: jls_wtrac_data_type
102a108
> TYPE(imgn_vars_data_type), INTENT(IN OUT) :: imgn_vars_data
106a113,114
> TYPE(water_resources_data_type), INTENT(IN OUT) :: water_resources_data
> TYPE(jls_wtrac_data_type), INTENT(IN OUT) :: wtrac_jls_data
144c152,153
<                             rivers_data, chemvars_data)
---
>                             imgn_vars_data, rivers_data, chemvars_data,        &
>                             water_resources_data, wtrac_jls_data)
diff -r vn7.0copy1_c4/src/./initialisation/standalone/grid/init_input_grid_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/standalone/grid/init_input_grid_mod.F90
28c28
<                                sclayer_dim_name, tracer_dim_name,              &
---
>                                sclayer_dim_name, dep_species_dim_name,         &
80c80
<                               sclayer_dim_name, tracer_dim_name,               &
---
>                               sclayer_dim_name, dep_species_dim_name,          &
diff -r vn7.0copy1_c4/src/./initialisation/standalone/grid/init_latlon_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/standalone/grid/init_latlon_mod.F90
12,13c12,13
< LOGICAL :: l_const_latlon
<   ! TRUE if at least one of latitude and longitude is set using a constant.
---
> LOGICAL :: l_const_coord
>   ! TRUE if at least one coordinate is set using a constant.
30a31
> USE update_mod, ONLY: l_imogen
35c36,37
<       grid_lon => longitude
---
>       grid_lon => longitude, grid_x_coord => projection_x_coord,               &
>       grid_y_coord => projection_y_coord, l_coord_latlon
66c68
< INTEGER, PARAMETER :: max_vars = 3
---
> INTEGER, PARAMETER :: max_vars = 5
101c103,104
< ! Definition of the jules_latlon namelist
---
> ! Definition of the jules_latlon namelist. This also uses l_coord_latlon from
> ! a module.
131c134,135
<                           use_file, var_name, tpl_name, const_val
---
>                           use_file, var_name, tpl_name, const_val,             &
>                           l_coord_latlon
161a166,172
> ! Projection coordinates are always allocated, though if l_coord_latlon=T
> ! the coordinates are simply a copy of latitude and longitude.
> ALLOCATE(grid_x_coord(input_grid%nx,input_grid%ny), STAT = ERROR)
> error_sum = error_sum + ERROR
> ALLOCATE(grid_y_coord(input_grid%nx,input_grid%ny), STAT = ERROR)
> error_sum = error_sum + ERROR
> 
193,194c204,215
< ! If irrigation is used, add gridbox area (unless it will be read from dump).
< IF ( l_water_irrigation ) THEN
---
> ! If the grid is not defined by latitude and longitude, add projection
> ! coordinates, regardless of the value of read_from_dump.
> IF ( .NOT. l_coord_latlon ) THEN
>   nvars_required = nvars_required + 1
>   required_vars(nvars_required) = 'projection_x_coord'
>   nvars_required = nvars_required + 1
>   required_vars(nvars_required) = 'projection_y_coord'
> END IF
> 
> ! If irrigation or imogen is used, add gridbox area
> ! (unless it will be read from dump).
> IF ( l_water_irrigation .OR. l_imogen) THEN
223,225c244,245
< ! Initialise flag to show that neither latitude nor longitude is set using a
< ! constant.
< l_const_latlon = .FALSE.
---
> ! Initialise flag to show that no coordinates were set using constants.
> l_const_coord = .FALSE.
256c276
<       ! Set flag if a constant value has been used for latitude or longitude.
---
>       ! Set flag if a constant value has been used for a coordinate.
258,259c278,280
<       CASE ( 'latitude', 'longitude' )
<         l_const_latlon = .TRUE.
---
>       CASE ( 'latitude', 'longitude', 'projection_x_coord',                    &
>              'projection_y_coord' )
>         l_const_coord = .TRUE.
311a333,340
> END IF
> 
> !-----------------------------------------------------------------------------
> ! Copy latitude and longitude into coordinate variables, if required.
> !-----------------------------------------------------------------------------
> IF ( l_coord_latlon ) THEN
>   grid_x_coord(:,:) = grid_lon(:,:)
>   grid_y_coord(:,:) = grid_lat(:,:)
diff -r vn7.0copy1_c4/src/./initialisation/standalone/grid/init_model_grid_arrays_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/standalone/grid/init_model_grid_arrays_mod.F90
22a23
>                           imgn_vars_data,                                      &
26c27,28
<                           chemvars_data                                        &
---
>                           chemvars_data, water_resources_data,                 &
>                           wtrac_jls_data                                       &
30a33
> USE imgn_vars_mod, ONLY: imgn_vars_alloc
38,44d40
< USE model_grid_mod, ONLY: latitude, longitude,                                 &
<                            latitude_of_land_pts, longitude_of_land_pts
< 
< USE coastal, ONLY: flandg
< 
< USE theta_field_sizes, ONLY: t_i_length, t_j_length
< 
64a61
> USE imgn_vars_mod,         ONLY: imgn_vars_data_type
68a66,67
> USE water_resources_vars_mod, ONLY: water_resources_data_type
> USE jules_wtrac_type_mod, ONLY: jls_wtrac_data_type
101a101
> TYPE(imgn_vars_data_type),         INTENT(IN OUT) :: imgn_vars_data
105a106,107
> TYPE(water_resources_data_type), INTENT(IN OUT) :: water_resources_data
> TYPE(jls_wtrac_data_type), INTENT(IN OUT) :: wtrac_jls_data
120a123
>   CALL imgn_vars_alloc(land_pts, imgn_vars_data)
134c137,138
<                           chemvars_data                                        &
---
>                           chemvars_data, water_resources_data,                 &
>                           wtrac_jls_data                                       &
diff -r vn7.0copy1_c4/src/./initialisation/standalone/grid/init_model_grid_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/standalone/grid/init_model_grid_mod.F90
18c18
< USE init_latlon_mod, ONLY: l_const_latlon
---
> USE init_latlon_mod, ONLY: l_const_coord
43a44,45
> USE jules_model_environment_mod, ONLY: lsm_id, rivers
> 
45c47,48
<                           grid_area_ij, latitude, longitude
---
>                           grid_area_ij, latitude, longitude, l_coord_latlon,   &
>                           projection_x_coord, projection_y_coord
77a81,83
> REAL :: x_coord(grid_in%nx,grid_in%ny)
>   ! x co-ordinates of points on the input grid.
> 
82,84c88,91
< REAL(KIND=real_jlslsm) :: point_lat, point_lon
<                               ! Latitude and longitude of points read from
<                               ! points file
---
> REAL(KIND=real_jlslsm) :: point_x, point_y
>                               ! x and y coordinates of points read from
>                               ! points file. If l_coord_latlon=T these are
>                               ! longitude and latitude respectively.
90,93c97,101
< REAL(KIND=real_jlslsm)                                                         &
<     , ALLOCATABLE :: global_area(:,:), global_lat(:,:), global_lon(:,:), global_land_frac(:,:)
<                              ! Latitude, longitude and land fraction on
<                              ! the full model grid
---
> REAL(KIND=real_jlslsm), ALLOCATABLE ::                                         &
>   global_area(:,:), global_lat(:,:), global_lon(:,:), global_land_frac(:,:),   &
>   global_xcoord(:,:), global_ycoord(:,:)
>                              ! Latitude, longitude, land fraction and more on
>                              ! the full model grid.
95c103
<                              ! routine
---
>                              ! routine.
100a109,117
> INTEGER :: np, np_previous      ! Counters of values set in mask.
> 
> LOGICAL :: l_bounds_180
>   ! TRUE if bounds values are taken to be in [-180,180], otherwise FALSE.
> LOGICAL :: l_lon_180
>   ! TRUE if longitude values are taken to be in [-180,180], otherwise FALSE.
> LOGICAL :: l_missing
>   ! TRUE if a coordinate pair cannot be matched to a location in the input
>   !   grid, when reading a list f coordinate pairs.
115,120c132,136
< LOGICAL :: latlon_region  ! T - subgrid is to be selected with latitude and
<                           !     longitude bounds
<                           ! F - subgrid is to be selected using a list
<                           !     of latitudes and longitudes
< REAL(KIND=real_jlslsm) :: lat_bounds(2)   ! USED IF latlon_region=T
< REAL(KIND=real_jlslsm) :: lon_bounds(2)
---
> LOGICAL :: l_bounds       ! T - subgrid is to be selected with coordinate bounds
>                           ! F - subgrid is to be selected using a list of
>                           !     coordinates
> REAL(KIND=real_jlslsm) :: y_bounds(2)   ! USED IF l_bounds=T
> REAL(KIND=real_jlslsm) :: x_bounds(2)
128,130c144,146
< NAMELIST  / jules_model_grid/ land_only, use_subgrid, latlon_region,           &
<                             lat_bounds, lon_bounds, npoints, points_file,      &
<                             force_1d_grid
---
> NAMELIST  / jules_model_grid/ land_only, use_subgrid, l_bounds,                &
>                               y_bounds, x_bounds, npoints, points_file,        &
>                               force_1d_grid
151c167
< IF ( ERROR /= 0 )                                                              &
---
> IF ( ERROR /= 0 ) THEN
155a172
> END IF
157,160c174,178
< !-----------------------------------------------------------------------------
< ! Read the jules_nlsizes namelist.
< !-----------------------------------------------------------------------------
< CALL log_info("init_model_grid", "Reading JULES_NLSIZES namelist...")
---
> IF ( lsm_id /= rivers ) THEN
>   !-----------------------------------------------------------------------------
>   ! Read the jules_nlsizes namelist.
>   !-----------------------------------------------------------------------------
>   CALL log_info("init_model_grid", "Reading JULES_NLSIZES namelist...")
162,167c180,186
< READ(namelist_unit, NML = jules_nlsizes, IOSTAT = ERROR, IOMSG = iomessage)
< IF ( ERROR /= 0 ) THEN
<   CALL log_fatal("init_model_grid",                                            &
<                  "Error reading namelist JULES_NLSIZES " //                    &
<                  "(IOSTAT=" // TRIM(to_string(ERROR)) // " IOMSG=" //          &
<                  TRIM(iomessage) // ")")
---
>   READ(namelist_unit, NML = jules_nlsizes, IOSTAT = ERROR, IOMSG = iomessage)
>   IF ( ERROR /= 0 ) THEN
>     CALL log_fatal("init_model_grid",                                          &
>                    "Error reading namelist JULES_NLSIZES " //                  &
>                    "(IOSTAT=" // TRIM(to_string(ERROR)) // " IOMSG=" //        &
>                    TRIM(iomessage) // ")")
>   END IF
187a207,209
> ! Copy x coordinates of input grid.
> x_coord(:,:) = projection_x_coord(:,:)
> 
189c211
<   IF ( latlon_region ) THEN
---
>   IF ( l_bounds ) THEN
191c213
<     ! The subgrid will be selected using latitude and longitude bounds
---
>     ! The subgrid will be selected using coordinate bounds.
194,195c216
<                   "Subgrid will be selected using latitude and " //            &
<                   "longitude bounds")
---
>                   "Subgrid will be selected using coordinate bounds")
197,198c218,219
<                   "Latitude range - " // TRIM(to_string(lat_bounds(1))) //     &
<                   " to " // TRIM(to_string(lat_bounds(2))))
---
>                   "y range - " // TRIM(to_string(y_bounds(1))) //              &
>                   " to " // TRIM(to_string(y_bounds(2))))
200,201c221,227
<                   "Longitude range - " // TRIM(to_string(lon_bounds(1))) //    &
<                   " to " // TRIM(to_string(lon_bounds(2))))
---
>                   "x range - " // TRIM(to_string(x_bounds(1))) //              &
>                   " to " // TRIM(to_string(x_bounds(2))))
>     ! Check that the bounds are given in increasing order.
>     IF ( x_bounds(2) < x_bounds(1) .OR. y_bounds(2) < y_bounds(1) ) THEN
>       CALL log_fatal("init_model_grid",                                        &
>                      "Bounds must be given in increasing order.")
>     END IF
203,206c229,272
<     input_mask = ( lat_bounds(1) <= latitude ) .AND.                           &
<                  ( latitude <= lat_bounds(2) ) .AND.                           &
<                  ( lon_bounds(1) <= longitude ) .AND.                          &
<                  ( longitude <= lon_bounds(2) )
---
>     !-------------------------------------------------------------------------
>     ! Deal with the case when longitude bounds cross the edge of the input
>     ! grid - e.g. longitude values are given in [0,360] but a regional subgrid
>     ! for [-10,10] is required. In this case we adjust the longitude values to
>     ! fall within [-180,180].
>     !-------------------------------------------------------------------------
>     IF ( l_coord_latlon ) THEN
>       ! Establish the ranges used for longitude and bounds.
>       ! A value <0 is taken to indicate that values are in [-180,180];
>       ! otherwise [0,360] is assumed.
>       l_lon_180    = MINVAL( x_coord) < 0.0
>       l_bounds_180 = x_bounds(1) < 0.0
>       ! If ranges are different, change longitude values.
>       IF ( l_lon_180 .NEQV. l_bounds_180 ) THEN
>         IF ( l_bounds_180 ) THEN
>           ! Change longitude to [-180,180].
>           DO j = 1,grid_in%ny
>             DO i = 1,grid_in%nx
>               IF ( x_coord(i,j) > 180.0 ) THEN
>                 x_coord(i,j) = x_coord(i,j) - 360.0
>               END IF
>             END DO
>           END DO
>         ELSE
>           ! l_lon_180=T. Change longitude to [0,360].
>           DO j = 1,grid_in%ny
>             DO i = 1,grid_in%nx
>               IF ( x_coord(i,j) < 0.0 ) THEN
>                 x_coord(i,j) = x_coord(i,j) + 360.0
>               END IF
>             END DO
>           END DO
>         END IF
>       END IF  !  l_lon_180 .NEQV. l_bounds_180
>     END IF  !  l_coord_latlon
> 
>     ! Set mask at locations within coordinate bounds.
>     ! Here we use projection_y_coord and x_coord (rather than
>     ! projection_x_coord) which includes any modification to fit with the
>     ! bounds.
>     input_mask = ( y_bounds(1) <= projection_y_coord ) .AND.                   &
>                  ( projection_y_coord <= y_bounds(2) ) .AND.                   &
>                  ( x_bounds(1) <= x_coord ) .AND.                              &
>                  ( x_coord <= x_bounds(2) )
209,210c275,276
<     ! The subgrid will be selected using a list of latitudes and longitudes
<     ! from the given file
---
>     ! The subgrid will be selected using a list of coordinates from the given
>     ! file.
216,217c282,283
<     !     Check that a file name was provided.
<     IF ( LEN_TRIM(points_file) == 0 )                                          &
---
>     ! Check that a file name was provided.
>     IF ( LEN_TRIM(points_file) == 0 ) THEN
218a285
>     END IF
224c291
<     ! Read the point latitudes and longitudes from file
---
>     ! Read the point coordinates from file.
229,233c296,305
<     IF ( ERROR /= 0 )                                                          &
<     CALL log_fatal("init_model_grid",                                          &
<                    "Error opening points file " //                             &
<                    "(IOSTAT=" // TRIM(to_string(ERROR)) // " IOMSG=" //        &
<                    TRIM(iomessage) // ")")
---
>     IF ( ERROR /= 0 ) THEN
>       CALL log_fatal("init_model_grid",                                        &
>                      "Error opening points file " //                           &
>                      "(IOSTAT=" // TRIM(to_string(ERROR)) // " IOMSG=" //      &
>                      TRIM(iomessage) // ")")
>     END IF
> 
>     ! Initialise to show no points found and none missing.
>     np_previous = 0
>     l_missing   = .FALSE.
236,239c308,311
<       ! Try to read the next latitude/longitude pair
<       READ(points_file_unit, *, IOSTAT = ERROR, IOMSG = iomessage) point_lat,  &
<                                                                point_lon
<       IF ( ERROR /= 0 )                                                        &
---
>       ! Try to read the next coordinate pair
>       READ(points_file_unit, *, IOSTAT = ERROR, IOMSG = iomessage) point_y,    &
>                                                                    point_x
>       IF ( ERROR /= 0 ) THEN
241c313
<                        "Error reading lat/lon pair from points file " //       &
---
>                        "Error reading coordinate pair from points file " //    &
243a316
>       END IF
245,247c318,322
<       ! Set input_mask to .TRUE. at that point
<       WHERE ( ABS(latitude - point_lat) < EPSILON(1.0) .AND.                   &
<               ABS(longitude - point_lon) < EPSILON(1.0) )
---
>       ! Set input_mask to .TRUE. wherever coordinates match.
>       ! We assume that at most 1 location matches each coordinate pair - which
>       ! will be true as long as grid spacing is larger than EPSILON.
>       WHERE ( ABS(projection_y_coord - point_y) < EPSILON(1.0) .AND.           &
>               ABS(projection_x_coord - point_x) < EPSILON(1.0) )
250c325,341
<     END DO
---
> 
>       ! Count the number of locations selected.
>       np = COUNT( input_mask )
> 
>       ! Warn if no new location was identified.
>       IF ( np == np_previous ) THEN
>         l_missing = .TRUE.
>         CALL log_warn("init_model_grid",                                       &
>                        "No location found to match (x,y)="                 //  &
>                        TRIM(to_string(point_x)) // ' '                     //  &
>                        TRIM(to_string(point_y)))
>       END IF
> 
>       ! Set counter ready for next loop.
>       np_previous = np
> 
>     END DO  !  points
253c344
<     IF ( ERROR /= 0 )                                                          &
---
>     IF ( ERROR /= 0 ) THEN
258c349,358
<   END IF  ! latlon_region
---
>     END IF
> 
>     ! Raise an error if any locations were not matched.
>     IF ( l_missing ) THEN
>       CALL log_fatal("init_model_grid",                                        &
>                      "One or more locations in list are not in the model " //  &
>                      "input grid. See earlier messages.")
>     END IF
> 
>   END IF  ! l_bounds
279c379
< IF ( .NOT. ANY(input_mask) )                                                   &
---
> IF ( .NOT. ANY(input_mask) ) THEN
282a383
> END IF
311a413,418
> ALLOCATE(global_xcoord(model_grid%nx,model_grid%ny))
> global_xcoord(:,:) = subgrid_extract(subgrid_in, projection_x_coord)
> 
> ALLOCATE(global_ycoord(model_grid%nx,model_grid%ny))
> global_ycoord(:,:) = subgrid_extract(subgrid_in, projection_y_coord)
> 
327,329c434,437
< ! latitude and longitude has been set using a constant, as this is the most
< ! likely way that duplicates could arise inadvertently. By contrast, values
< ! read from an ancillary file are assumed to be correct.
---
> ! the coordinate variables (e.g. latitude and longitude) has been set using a
> ! constant, as this is the most likely way that duplicates could arise
> ! inadvertently. By contrast, values read from an ancillary file are assumed
> ! to be correct.
334c442
< IF ( l_const_latlon ) THEN
---
> IF ( l_const_coord ) THEN
352,353c460,461
<           IF ( global_lat(i,j) == global_lat(i2,j2) .AND.                      &
<                global_lon(i,j) == global_lon(i2,j2) ) THEN
---
>           IF ( global_ycoord(i,j) == global_ycoord(i2,j2) .AND.                &
>                global_xcoord(i,j) == global_xcoord(i2,j2) ) THEN
359,360c467,468
<                               " Latitude=" // to_string(global_lat(i,j))   //  &
<                               " Longitude=" // to_string(global_lon(i,j)) )
---
>                               " y=" // to_string(global_ycoord(i,j))       //  &
>                               " x= " // to_string(global_xcoord(i,j)) )
366,367c474,475
<                              " Latitude=" // to_string(global_lat(i,j))    //  &
<                              " Longitude=" // to_string(global_lon(i,j)) )
---
>                              " y=" // to_string(global_ycoord(i,j))        //  &
>                              " x=" // to_string(global_xcoord(i,j)) )
376c484
< END IF  !  l_const_latlon
---
> END IF  !  l_const_coord
414c522,531
< END IF
---
> 
>   DEALLOCATE(projection_x_coord)
>   ALLOCATE(projection_x_coord(task_subgrid%nx,task_subgrid%ny))
>   projection_x_coord(:,:) = subgrid_extract(task_subgrid, global_xcoord)
> 
>   DEALLOCATE(projection_y_coord)
>   ALLOCATE(projection_y_coord(task_subgrid%nx,task_subgrid%ny))
>   projection_y_coord(:,:) = subgrid_extract(task_subgrid, global_ycoord)
> 
> END IF  !  use_subgrid
420a538,539
> DEALLOCATE(global_xcoord)
> DEALLOCATE(global_ycoord)
471c590
< IF ( l_point_data .AND. t_i_length * t_j_length > 1 )                          &
---
> IF ( l_point_data .AND. t_i_length * t_j_length > 1 ) THEN
473a593
> END IF
diff -r vn7.0copy1_c4/src/./initialisation/standalone/init_deposition_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/standalone/init_deposition_mod.F90
36c36
< USE io_constants, ONLY: namelist_unit
---
> USE io_constants,           ONLY: namelist_unit
38c38
< USE string_utils_mod, ONLY: to_string
---
> USE string_utils_mod,       ONLY: to_string
40c40
< USE jules_deposition_mod, ONLY:                                                &
---
> USE jules_deposition_mod,   ONLY:                                              &
42c42
<   dry_dep_ukca_jules,                                                          &
---
>   dry_dep_model_jules, dry_dep_model_ukca,                                     &
47c47
<   check_jules_deposition,                                                      &
---
>   check_jules_deposition, print_nlist_jules_deposition,                        &
51c51,53
< USE logging_mod, ONLY: log_info, log_fatal
---
> USE logging_mod,            ONLY: log_info, log_fatal
> 
> USE missing_data_mod,       ONLY: rmdi
117a120,124
> ! Print our namelist
> !-----------------------------------------------------------------------------
> CALL print_nlist_jules_deposition()
> 
> !-----------------------------------------------------------------------------
131c138,142
<   CASE ( dry_dep_ukca_jules )
---
>   CASE ( dry_dep_model_ukca )
>     CALL log_info( RoutineName, "Dry deposition is modelled by JULES, " //     &
>                                 "using the UKCA routines." )
> 
>   CASE ( dry_dep_model_jules )
134,135c145
<     CALL log_info( RoutineName, "This code is still being developed and " //   &
<                                 "is not recommended for general use!" )
---
>     CALL log_info( RoutineName, "Restriction on pft ordering removed." )
149,161c159,163
<   SELECT CASE ( dry_dep_model )
< 
<   CASE ( dry_dep_ukca_jules )
< 
<     IF ( l_deposition_flux ) THEN
<       IF ( l_ukca_ddep_lev1 ) THEN
<         CALL log_info( RoutineName,                                            &
<                        "Deposition only occurs from the lowest " //            &
<                        "layer.")
<       ELSE
<         CALL log_info( RoutineName,                                            &
<                        "Deposition occurs throughout the boundary layer." )
<       END IF
---
>   IF ( l_deposition_flux ) THEN
>     IF ( l_ukca_ddep_lev1 ) THEN
>       CALL log_info( RoutineName,                                              &
>                      "Deposition only occurs from the lowest atmospheric " //  &
>                      "boundary-layer level." )
164,168c166,172
<                      "Dry deposition velocities are modelled (not fluxes)." )
<     END IF  !  l_deposition_flux
< 
<     CALL log_info( RoutineName, "tundra_s_limit = " //                         &
<                    to_string(tundra_s_limit) )
---
>                      "Deposition occurs on all atmospheric boundary-layer " // &
>                      "levels." )
>     END IF
>   ELSE
>     CALL log_info( RoutineName,                                                &
>                    "Dry deposition velocities are modelled (not fluxes)." )
>   END IF  !  l_deposition_flux
170c174,175
<   END SELECT  !  dry_dep_model
---
>   CALL log_info( RoutineName, "tundra_s_limit = " //                           &
>                  to_string(tundra_s_limit) )
diff -r vn7.0copy1_c4/src/./initialisation/standalone/init.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/standalone/init.F90
1d0
< #if !defined(UM_JULES)
26a26
>                    imgn_vars_data, imgn_vars,                                  &
30a31,32
>                    water_resources_data, water_resources,                      &
>                    wtrac_jls_data, wtrac_jls,                                  &
46,47c48,49
< USE initial_conditions_mod,       ONLY: init_ic
< USE spinup_mod,                   ONLY: spinup_init
---
> USE init_ic_mod,                  ONLY: init_ic
> USE spinup_init_mod,              ONLY: spinup_init
130a133,135
> USE imgn_vars_mod,                ONLY: imgn_vars_data_type,                   &
>                                         imgn_vars_type,                        &
>                                         imgn_vars_assoc
140,142c145,150
< USE jules_chemvars_mod,         ONLY: chemvars_data_type,                      &
<                                       chemvars_type,                           &
<                                       chemvars_assoc
---
> USE jules_chemvars_mod,           ONLY: chemvars_data_type,                    &
>                                         chemvars_type,                         &
>                                         chemvars_assoc
> USE water_resources_vars_mod,     ONLY: water_resources_data_type,             &
>                                         water_resources_type,                  &
>                                         water_resources_assoc
151a160,163
> USE jules_wtrac_type_mod,         ONLY: jls_wtrac_type,                        &
>                                         jls_wtrac_data_type,                   &
>                                         wtrac_jls_assoc
> 
187a200
> TYPE(imgn_vars_data_type), INTENT(IN OUT) :: imgn_vars_data
191a205,206
> TYPE(water_resources_data_type), INTENT(IN OUT) :: water_resources_data
> TYPE(jls_wtrac_data_type), INTENT(IN OUT)      :: wtrac_jls_data
212a228
> TYPE(imgn_vars_type), INTENT(IN OUT) :: imgn_vars
216a233,234
> TYPE(water_resources_type), INTENT(IN OUT) :: water_resources
> TYPE(jls_wtrac_type), INTENT(IN OUT)      :: wtrac_jls
218a237
> 
295a315
>                imgn_vars_data,                                                 &
299c319,320
<                chemvars_data                                                   &
---
>                chemvars_data, water_resources_data,                            &
>                wtrac_jls_data                                                  &
319a341
> CALL imgn_vars_assoc(imgn_vars,imgn_vars_data)
323a346,347
> CALL water_resources_assoc(water_resources,water_resources_data)
> CALL wtrac_jls_assoc(wtrac_jls,wtrac_jls_data)
351c375
<   CALL init_imogen(nml_dir,progs_data, trifctltype, imgn_drive, ainfo)
---
>   CALL init_imogen(nml_dir,progs_data, trifctltype, imgn_drive, imgn_vars, ainfo)
407d430
< #endif
Only in vn7.0copy1_c4/src/./initialisation/standalone/initial_conditions: calc_fit_fsat.inc
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/standalone/initial_conditions: calc_fit_fsat_mod.F90
Only in vn7.0copy1_c4/src/./initialisation/standalone/initial_conditions: get_default_ic_values.inc
Only in vn7.0copy1_c4/src/./initialisation/standalone/initial_conditions: initial_conditions_mod.F90
Only in vn7.0copy1_c4/src/./initialisation/standalone/initial_conditions: init_ic.inc
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/standalone/initial_conditions: init_ic_mod.F90
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/standalone/initial_conditions: jules_initial_mod.F90
Only in vn7.0copy1_c4/src/./initialisation/standalone/initial_conditions: topmodel_init.inc
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/standalone/initial_conditions: topmodel_init_mod.F90
Only in vn7.0copy1_c4/src/./initialisation/standalone/initial_conditions: total_snow_init.inc
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/standalone/initial_conditions: total_snow_init_mod.F90
diff -r vn7.0copy1_c4/src/./initialisation/standalone/init_imogen.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/standalone/init_imogen.F90
9c9,10
< SUBROUTINE init_imogen(nml_dir,progs_data, trifctltype, imgn_drive, ainfo)
---
> SUBROUTINE init_imogen(nml_dir, progs_data, trifctltype, imgn_drive,           &
>                        imgn_vars, ainfo)
20a22,23
> USE fill_variables_from_file_mod, ONLY: fill_variables_from_file
> 
25,29c28
< USE imogen_constants, ONLY: drive_month, n_imogen_land
< 
< USE imogen_map, ONLY: sgindinv, get_imogen_map
< 
< USE imogen_time, ONLY: step_day, nsdmax, mm, md
---
> USE imogen_time, ONLY: nsdmax
31,32c30,31
< USE imogen_run, ONLY: imogen_run_list, file_points_order, wgen, c_emissions,   &
<                       include_co2, include_non_co2, land_feed_co2,             &
---
> USE imogen_run, ONLY: imogen_run_list, c_emissions,                            &
>                       include_co2, include_non_co2_radf, land_feed_co2,        &
35c34,36
<                       initialise_from_dump, dump_file
---
>                       initialise_from_dump, dump_file,                         &
>                       l_drive_with_global_temps, initial_co2_ch4_year,         &
>                       fch4_ref, yr_fch4_ref, tau_ch4_ref, ch4_ppbv_ref
37c38
< USE imogen_anlg_vals, ONLY: imogen_anlg_vals_list, dir_clim,                   &
---
> USE imogen_anlg_vals, ONLY: imogen_anlg_vals_list, file_clim, file_patt,       &
40,49d40
< USE imogen_clim, ONLY: t_clim, rainfall_clim, snowfall_clim, rh15m_clim,       &
<                        uwind_clim, vwind_clim, dtemp_clim, pstar_ha_clim,      &
<                      sw_clim, lw_clim, f_wet_clim, lat, dctot_co2, dctot_ch4,  &
<                        longmin_clim, latmin_clim, longmax_clim, latmax_clim,   &
<                        LONG
< 
< USE imogen_drive_vars, ONLY: t_out, conv_rain_out, conv_snow_out, ls_rain_out, &
<                              ls_snow_out, qhum_out, wind_out, pstar_out,       &
<                              sw_out, lw_out
< 
52,54d42
< USE imogen_progs, ONLY: ch4_ppbv, co2_ppmv, co2_change_ppmv, dtemp_o,          &
<                         fa_ocean, seed_wg
< 
57a46,47
> USE ereport_mod, ONLY: ereport
> USE jules_print_mgr, ONLY: jules_message
58a49
> USE missing_data_mod,   ONLY: rmdi, imdi
64a56
> USE imgn_vars_mod, ONLY: imgn_vars_type
67,69d58
< USE theta_field_sizes, ONLY: t_i_length
< 
< 
90a80
> TYPE(imgn_vars_type), INTENT(IN OUT)   :: imgn_vars
93,95c83,121
< ! Work variables
< CHARACTER(LEN=max_file_name_len) :: file_clim  ! File to read IMOGEN
<                                                ! climatology from
---
> CHARACTER(LEN=24), DIMENSION(8) ::                                             &
>   imgn_name_clim = ['tl1_ij_clim_imgn        ',                                &
>                     'ql1_ij_clim_imgn        ',                                &
>                     'wind_ij_clim_imgn       ',                                &
>                     'lwdown_ij_clim_imgn     ',                                &
>                     'swdown_ij_clim_imgn     ',                                &
>                     'precip_ij_clim_imgn     ',                                &
>                     'pstar_ij_clim_imgn      ',                                &
>                     'diurnal_tl1_ij_clim_imgn']
> 
> CHARACTER(LEN=24), DIMENSION(8) ::                                             &
>   imgn_name_patt = ['tl1_ij_patt_imgn        ',                                &
>                     'ql1_ij_patt_imgn        ',                                &
>                     'wind_ij_patt_imgn       ',                                &
>                     'lwdown_ij_patt_imgn     ',                                &
>                     'swdown_ij_patt_imgn     ',                                &
>                     'precip_ij_patt_imgn     ',                                &
>                     'pstar_ij_patt_imgn      ',                                &
>                     'diurnal_tl1_ij_patt_imgn']
> 
> CHARACTER(LEN=14), DIMENSION(8) ::                                             &
>   nc_name_clim = ['tl1_clim      ',                                            &
>                   'ql1_clim      ',                                            &
>                   'wind_clim     ',                                            &
>                   'lwdown_clim   ',                                            &
>                   'swdown_clim   ',                                            &
>                   'precip_clim   ',                                            &
>                   'pstar_clim    ',                                            &
>                   'range_tl1_clim']
> 
> CHARACTER(LEN=14), DIMENSION(8) ::                                             &
>   nc_name_patt = ['tl1_patt      ',                                            &
>                   'ql1_patt      ',                                            &
>                   'wind_patt     ',                                            &
>                   'lwdown_patt   ',                                            &
>                   'swdown_patt   ',                                            &
>                   'precip_patt   ',                                            &
>                   'pstar_patt    ',                                            &
>                   'range_tl1_patt']
97c123
< INTEGER :: i,j,l,n,im,ijk  ! Index variables
---
> INTEGER :: n  ! Index variables
99c125
< INTEGER :: ERROR, error_sum  ! Error indicator
---
> INTEGER :: ERROR, error_sum, errorstatus  ! Error indicator
100a127
> CHARACTER(LEN=*), PARAMETER :: RoutineName='INIT_IMOGEN'
109c136
<   CALL log_fatal("init_imogen",                                                &
---
>   CALL log_fatal(RoutineName,                                                  &
119c146
<   CALL log_fatal("init_imogen",                                                &
---
>   CALL log_fatal(RoutineName,                                                  &
123a151
> 
128c156
<   CALL log_fatal("init_imogen",                                                &
---
>   CALL log_fatal(RoutineName,                                                  &
137c165
<   CALL log_fatal("init_imogen",                                                &
---
>   CALL log_fatal(RoutineName,                                                  &
142a171,237
> !-----------------------------------------------------------------------------
> ! check all variables are set in imogen_run
> !-----------------------------------------------------------------------------
> ! co2_init_ppmv
> IF ( ABS( co2_init_ppmv - rmdi ) < EPSILON(1.0) ) THEN
>   errorstatus = 101
>   CALL ereport(RoutineName, errorstatus, "co2_init_ppmv not found")
> ELSE IF ( co2_init_ppmv < 100.0 .OR. co2_init_ppmv > 10000.0 ) THEN
>   CALL ereport(RoutineName, errorstatus,                                       &
>                "co2_init_ppmv must lie in the range 100.0 to 10000.0")
> END IF
> 
> ! initial_co2_ch4_year
> IF ( ocean_feed ) THEN
>   IF ( ABS( initial_co2_ch4_year - imdi ) < EPSILON(1.0) ) THEN
>     errorstatus = 101
>     CALL ereport(RoutineName, errorstatus, "initial_co2_ch4_year not found")
>   ELSE IF ( initial_co2_ch4_year < 1000 .OR. initial_co2_ch4_year > 5000 ) THEN
>     CALL ereport(RoutineName, errorstatus,                                     &
>                  "initial_co2_ch4_year must lie in the range 1000 to 5000")
>   END IF
> END IF
> 
> 
> ! yr_fch4_ref, ch4_init_ppbv, fch4_ref, tau_ch4_ref, ch4_ppbv_ref
> IF ( land_feed_ch4 ) THEN
>   IF ( ABS( yr_fch4_ref - imdi ) < EPSILON(1.0) ) THEN
>     errorstatus = 101
>     CALL ereport(RoutineName, errorstatus, "yr_fch4_ref not found")
>   ELSE IF ( yr_fch4_ref < 1000 .OR. yr_fch4_ref > 5000 ) THEN
>     CALL ereport(RoutineName, errorstatus,                                     &
>                  "yr_fch4_ref must lie in the range 1000 to 5000")
>   END IF
> 
>   IF ( ABS( ch4_init_ppbv - rmdi ) < EPSILON(1.0) ) THEN
>     errorstatus = 101
>     CALL ereport(RoutineName, errorstatus, "ch4_init_ppbv not found")
>   ELSE IF ( ch4_init_ppbv < 100.0 .OR. ch4_init_ppbv > 5000.0 ) THEN
>     CALL ereport(RoutineName, errorstatus,                                     &
>                  "ch4_init_ppbv must lie in the range 100.0 to 5000.")
>   END IF
> 
>   IF ( ABS( fch4_ref - rmdi ) < EPSILON(1.0) ) THEN
>     errorstatus = 101
>     CALL ereport(RoutineName, errorstatus, "fch4_ref not found")
>   ELSE IF ( fch4_ref < 1.0 .OR. fch4_ref > 1000.0 ) THEN
>     CALL ereport(RoutineName, errorstatus,                                     &
>                  "fch4_ref must lie in the range 1.0 to 1000.")
>   END IF
> 
>   IF ( ABS( tau_ch4_ref - rmdi ) < EPSILON(1.0) ) THEN
>     errorstatus = 101
>     CALL ereport(RoutineName, errorstatus, "fch4tau_ch4_ref_ref not found")
>   ELSE IF ( tau_ch4_ref < 0.1 .OR. tau_ch4_ref > 100.0 ) THEN
>     CALL ereport(RoutineName, errorstatus,                                     &
>                  "tau_ch4_ref must lie in the range 0.1 to 100.0")
>   END IF
> 
>   IF ( ABS( ch4_ppbv_ref - rmdi ) < EPSILON(1.0) ) THEN
>     errorstatus = 101
>     CALL ereport(RoutineName, errorstatus, "ch4_ppbv_ref not found")
>   ELSE IF ( ch4_ppbv_ref < 100.0 .OR. ch4_ppbv_ref > 5000.0 ) THEN
>     CALL ereport(RoutineName, errorstatus,                                     &
>                  "ch4_ppbv_ref must lie in the range 100.0 to 5000.")
>   END IF
> 
> END IF
150c245
<   CALL log_fatal("init_imogen", "360 day year must be used with IMOGEN")
---
>   CALL log_fatal(RoutineName, "360 day year must be used with IMOGEN")
155c250
<   CALL log_fatal("init_imogen",                                                &
---
>   CALL log_fatal(RoutineName,                                                  &
161c256
<   CALL log_fatal("init_imogen", "Too many timesteps per day")
---
>   CALL log_fatal(RoutineName, "Too many timesteps per day")
163,255d257
< !-----------------------------------------------------------------------------
< ! Find corresponding land sites from the imogen grid 'sgind'.
< !-----------------------------------------------------------------------------
< CALL get_imogen_map(file_points_order)
< 
< !-----------------------------------------------------------------------------
< ! Allocate imogen arrays
< !-----------------------------------------------------------------------------
< error_sum = 0
< ALLOCATE(t_clim(land_pts,mm), STAT = ERROR )
< error_sum = error_sum + ERROR
< ALLOCATE(rainfall_clim(land_pts,mm), STAT = ERROR )
< error_sum = error_sum + ERROR
< ALLOCATE(snowfall_clim(land_pts,mm), STAT = ERROR )
< error_sum = error_sum + ERROR
< ALLOCATE(rh15m_clim(land_pts,mm), STAT = ERROR )
< error_sum = error_sum + ERROR
< ALLOCATE(uwind_clim(land_pts,mm), STAT = ERROR )
< error_sum = error_sum + ERROR
< ALLOCATE(vwind_clim(land_pts,mm), STAT = ERROR )
< error_sum = error_sum + ERROR
< ALLOCATE(dtemp_clim(land_pts,mm), STAT = ERROR )
< error_sum = error_sum + ERROR
< ALLOCATE(pstar_ha_clim(land_pts,mm), STAT = ERROR )
< error_sum = error_sum + ERROR
< ALLOCATE(sw_clim(land_pts,mm), STAT = ERROR )
< error_sum = error_sum + ERROR
< ALLOCATE(lw_clim(land_pts,mm), STAT = ERROR )
< error_sum = error_sum + ERROR
< ALLOCATE(f_wet_clim(land_pts,mm), STAT = ERROR )
< error_sum = error_sum + ERROR
< 
< ALLOCATE(t_out(land_pts,mm,md,nsdmax), STAT = ERROR )
< error_sum = error_sum + ERROR
< ALLOCATE(conv_rain_out(land_pts,mm,md,nsdmax), STAT = ERROR )
< error_sum = error_sum + ERROR
< ALLOCATE(conv_snow_out(land_pts,mm,md,nsdmax), STAT = ERROR )
< error_sum = error_sum + ERROR
< ALLOCATE(ls_rain_out(land_pts,mm,md,nsdmax), STAT = ERROR )
< error_sum = error_sum + ERROR
< ALLOCATE(ls_snow_out(land_pts,mm,md,nsdmax), STAT = ERROR )
< error_sum = error_sum + ERROR
< ALLOCATE(qhum_out(land_pts,mm,md,nsdmax), STAT = ERROR )
< error_sum = error_sum + ERROR
< ALLOCATE(wind_out(land_pts,mm,md,nsdmax), STAT = ERROR )
< error_sum = error_sum + ERROR
< ALLOCATE(pstar_out(land_pts,mm,md,nsdmax), STAT = ERROR )
< error_sum = error_sum + ERROR
< ALLOCATE(sw_out(land_pts,mm,md,nsdmax), STAT = ERROR )
< error_sum = error_sum + ERROR
< ALLOCATE(lw_out(land_pts,mm,md,nsdmax), STAT = ERROR )
< error_sum = error_sum + ERROR
< 
< ALLOCATE(lat(land_pts), STAT = ERROR )
< error_sum = error_sum + ERROR
< ALLOCATE(LONG(land_pts), STAT = ERROR )
< error_sum = error_sum + ERROR
< 
< ! Check for error.
< IF ( error_sum /= 0 ) THEN
<   CALL log_fatal("init_imogen", "Error allocating IMOGEN arrays")
< ELSE
<   ! Initialise.
<   t_clim(:,:)        = 0.0
<   rainfall_clim(:,:) = 0.0
<   snowfall_clim(:,:) = 0.0
<   rh15m_clim(:,:)    = 0.0
<   uwind_clim(:,:)    = 0.0
<   vwind_clim(:,:)    = 0.0
<   dtemp_clim(:,:)    = 0.0
<   pstar_ha_clim(:,:) = 0.0
<   sw_clim(:,:)       = 0.0
<   lw_clim(:,:)       = 0.0
<   f_wet_clim(:,:)    = 0.0
< 
<   t_out(:,:,:,:)         = 0.0
<   conv_rain_out(:,:,:,:) = 0.0
<   conv_snow_out(:,:,:,:) = 0.0
<   ls_rain_out(:,:,:,:)   = 0.0
<   ls_snow_out(:,:,:,:)   = 0.0
<   qhum_out(:,:,:,:)      = 0.0
<   wind_out(:,:,:,:)      = 0.0
<   pstar_out(:,:,:,:)     = 0.0
<   sw_out(:,:,:,:)        = 0.0
<   lw_out(:,:,:,:)        = 0.0
< 
<   lat(:)   = 0.0
<   LONG(:)  = 0.0
< END IF
< 
< ! Weather generator is not available at present
< IF ( wgen )                                                                    &
<   CALL log_fatal("init_imogen", "Weather generator not available at present")
264,265c266,267
<   c_emissions, include_co2, include_non_co2, land_feed_co2,                    &
<   land_feed_ch4, ocean_feed, anlg, anom, wgen)
---
>   c_emissions, include_co2, include_non_co2_radf, land_feed_co2,               &
>   land_feed_ch4, ocean_feed, anlg, anom, l_drive_with_global_temps)
291c293
< ! Read in monthly control climate data.
---
> ! Read in monthly climatology of climate data.
293,299c295
< DO im = 1,mm
<   file_clim = TRIM(dir_clim) // drive_month(im)
< 
<   OPEN(imogen_unit, FILE=file_clim,                                            &
<                     STATUS='old', POSITION='rewind', ACTION='read')
< 
<   READ(imogen_unit,*) longmin_clim,latmin_clim,longmax_clim, latmax_clim
---
> CALL fill_variables_from_file(file_clim, imgn_name_clim, nc_name_clim)
301,326d296
<   DO ijk = 1,n_imogen_land
<     IF (sgindinv(ijk) > 0) THEN
<       l = sgindinv(ijk)
<       READ(imogen_unit,*) LONG(l), lat(l), t_clim(l,im), rh15m_clim(l,im),     &
<                           uwind_clim(l,im), vwind_clim(l,im), lw_clim(l,im),   &
<                           sw_clim(l,im), dtemp_clim(l,im),                     &
<                           rainfall_clim(l,im), snowfall_clim(l,im),            &
<                           pstar_ha_clim(l,im), f_wet_clim(l,im)
< 
<       j = (ainfo%land_index(l) - 1) / t_i_length + 1
<       i = ainfo%land_index(l) - (j-1) * t_i_length
< 
<       imgn_drive%t1p5m_ij_clim(i,j,im)=t_clim(l,im)
<       imgn_drive%rh1p5m_ij_clim(i,j,im)=rh15m_clim(l,im)
<       imgn_drive%uwind_ij_clim(i,j,im)=uwind_clim(l,im)
<       imgn_drive%vwind_ij_clim(i,j,im)=vwind_clim(l,im)
<       imgn_drive%lwdown_ij_clim(i,j,im)=lw_clim(l,im)
<       imgn_drive%swdown_ij_clim(i,j,im)=sw_clim(l,im)
<       imgn_drive%precip_ij_clim(i,j,im)=rainfall_clim(l,im)+snowfall_clim(l,im)
<       imgn_drive%pstar_ij_clim(i,j,im)=pstar_ha_clim(l,im)
<       imgn_drive%diurnal_t1p5m_ij_clim(i,j,im)=dtemp_clim(l,im)
< 
<     ELSE
<       READ(imogen_unit,*)
<     END IF
<   END DO
328,329c298,310
<   CLOSE(imogen_unit)
< END DO
---
> IF ( (l_drive_with_global_temps) .OR. (anlg .AND. anom) ) THEN
>   !-----------------------------------------------------------------------
>   ! Read in spatial climate patterns (/K) - only read in once
>   ! there is a value for every grid cell and every month
>   ! patterns used for the driving climate data for the following cases:
>   !    - driving directly with global temperatures
>   !                                    (l_drive_with_global_temps=.TRUE.)
>   !    - anomalies prescribed from patterns using the analogue model where
>   !      the global temperature change is calculated from the change in
>   !      radiative forcing (anom=.TRUE. and anlg=.TRUE.)
>   !-----------------------------------------------------------------------
>   CALL fill_variables_from_file(file_patt, imgn_name_patt, nc_name_patt)
> END IF
332c313
< ! Set up the initial conditions
---
> ! Set up the initial conditions and intialise values
335c316
<   ch4_ppbv = ch4_init_ppbv
---
>   imgn_vars%ch4_ppbv = ch4_init_ppbv
338c319
< co2_ppmv = co2_init_ppmv
---
> imgn_vars%co2_ppmv(:) = co2_init_ppmv
340c321
< IF ( include_co2 ) co2_change_ppmv = 0.0
---
> IF ( include_co2 ) imgn_vars%co2_change_ppmv(:) = 0.0
343c324
<   dtemp_o(:) = 0.0
---
>   imgn_vars%dtemp_o(:) = 0.0
345c326,329
<   IF ( include_co2 .AND. ocean_feed .AND. c_emissions ) fa_ocean(:)=0.0
---
>   IF ( include_co2 .AND. ocean_feed .AND. c_emissions ) THEN
>     imgn_vars%fa_ocean(:)=0.0
>     ! already initialsed in allocation
>   END IF
356,362d339
< ! Initiate seeding values for the weather generator
< IF ( wgen ) THEN
<   seed_wg(1) = 5810
<   seed_wg(2) = 5575
<   seed_wg(3) = 5817
<   seed_wg(4) = 9119
< END IF
378c355
< co2_mmr = co2_ppmv * 44.0 / 28.97 * 1.0e-6
---
> co2_mmr = imgn_vars%co2_ppmv(1) * 44.0 / 28.97 * 1.0e-6
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/standalone: init_initial_mod.F90
diff -r vn7.0copy1_c4/src/./initialisation/standalone/init_output_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/standalone/init_output_mod.F90
49a50,51
> USE jules_rivers_mod, ONLY: l_outflow_per_river
> 
53a56,57
> USE jules_print_mgr, ONLY: jules_message, jules_format
> 
79a84,86
> LOGICAL :: l_outflow_per_river_check = .FALSE.
>     ! Check that both ancillary and diagnostic/send field has been specified.
> 
133c140,142
< NAMELIST  / jules_output_profile/ profile_name, output_initial, output_spinup, &
---
> CHARACTER(LEN=*), PARAMETER :: RoutineName='INIT_OUTPUT'
> 
> NAMELIST  /jules_output_profile/ profile_name, output_initial, output_spinup,  &
154c163
<   CALL log_fatal("init_output",                                                &
---
>   CALL log_fatal(RoutineName,                                                  &
162c171
< CALL log_info("init_output", "Reading JULES_OUTPUT namelist...")
---
> CALL log_info(RoutineName, "Reading JULES_OUTPUT namelist...")
165c174
<   CALL log_fatal("init_output",                                                &
---
>   CALL log_fatal(RoutineName,                                                  &
175c184
< IF ( LEN_TRIM(run_id) == 0 ) CALL log_fatal("init_output", "No run_id given")
---
> IF ( LEN_TRIM(run_id) == 0 ) CALL log_fatal(RoutineName, "No run_id given")
186c195
<   CALL log_fatal("init_output",                                                &
---
>   CALL log_fatal(RoutineName,                                                  &
195,196c204
<   CALL log_warn(                                                               &
<     "init_output",                                                             &
---
>   CALL log_warn(RoutineName,                                                   &
205c213
<   CALL log_warn("init_output",                                                 &
---
>   CALL log_warn(RoutineName,                                                   &
229c237
<   output_type(:)  = 'S'
---
>   output_type(:)  = ''
232c240
<   CALL log_info("init_output", "Reading JULES_OUTPUT_PROFILE namelist...")
---
>   CALL log_info(RoutineName, "Reading JULES_OUTPUT_PROFILE namelist...")
236c244
<     CALL log_fatal("init_output",                                              &
---
>     CALL log_fatal(RoutineName,                                                &
246,247c254,255
<   CALL check_output_vars( nvars, var, var_name, output_type, any_river_out )
< 
---
>   CALL check_output_vars( nvars, var, var_name, output_type, any_river_out,    &
>                           l_outflow_per_river_check )
252c260
<     CALL log_error("init_output",                                              &
---
>     CALL log_error(RoutineName,                                                &
283a292,301
> ! If riv_number_file specified in error reset switch as no need to output
> ! rivers_outflow_rp to dump and could also probably reduce the allocation of
> ! rivers%rivers_outflow_number_rp to nominal size.
> IF ( .NOT. l_outflow_per_river_check .AND. l_outflow_per_river ) THEN
>   WRITE(jules_message,*)                                                       &
>      "outflow_per_river not requested; " //                                    &
>      "river number ancillary specified in error."
>   CALL log_warn(RoutineName, jules_message)
>   l_outflow_per_river = .FALSE.
> END IF
294c312
<   CALL log_fatal("init_output",                                                &
---
>   CALL log_fatal(RoutineName,                                                  &
306c324,325
< SUBROUTINE check_output_vars( nvars, var, var_name, output_type, any_river_out )
---
> SUBROUTINE check_output_vars( nvars, var, var_name, output_type,               &
>                               any_river_out, l_outflow_per_river_check )
309a329,330
> USE jules_model_environment_mod, ONLY: l_oasis_rivers
> 
312c333
< USE jules_soil_biogeochem_mod, ONLY: soil_model_ecosse, soil_model_rothc,      &
---
> USE jules_soil_biogeochem_mod, ONLY: soil_model_ecosse, soil_model_4pool,      &
320c341
<     photo_acclim_model
---
>     photo_acclim_model, l_sugar, stomata_model, stomata_sox
326c347,348
< USE jules_rivers_mod, ONLY: l_rivers, i_river_vn, rivers_rfm, rivers_trip
---
> USE jules_rivers_mod, ONLY: l_rivers, l_riv_overbank, l_outflow_per_river,     &
>     i_river_vn, rivers_rfm, rivers_trip
328c350
< USE logging_mod, ONLY: log_error
---
> USE jules_deposition_mod, ONLY: l_deposition, l_deposition_flux
330c352
< USE overbank_inundation_mod, ONLY: l_riv_overbank
---
> USE logging_mod, ONLY: log_error, log_warn, log_info, log_fatal
335a358,363
> USE jules_print_mgr, ONLY: jules_message
> 
> USE string_utils_mod, ONLY: to_string
> 
> USE parallel_mod, ONLY: is_master_task
> 
361c389
<   any_river_out
---
>   any_river_out,                                                               &
362a391,392
>   l_outflow_per_river_check
>     ! Check that both ancillary and diagnostic/send field has been specified.
385a416,431
> !---------------------------------------------------------------------------
> ! First check output variables requiring extra ancillaries.
> !---------------------------------------------------------------------------
> IF ( is_master_task() ) THEN
>   ! Rivers is only called on the master task
>   IF ( l_outflow_per_river ) THEN
>     IF ( ANY( var(:) == 'outflow_per_river' ) .OR. l_oasis_rivers ) THEN
>       l_outflow_per_river_check = .TRUE.
>     END IF
>   ELSE IF ( ANY( var(:) == 'outflow_per_river' ) ) THEN
>     WRITE(jules_message,*)                                                     &
>        'outflow_per_river requested without a river number ancillary specified.'
>     CALL log_fatal(RoutineName, jules_message)
>   END IF
> END IF
> 
403a450,461
>   ! Coordinates are automatically included in output files and should not be
>   ! requested separately.
>   !---------------------------------------------------------------------------
>   SELECT CASE ( var(j) )
>   CASE ( 'latitude', 'longitude', 'projection_x_coord', 'projection_y_coord',  &
>          'rivers_lat_rp', 'rivers_lon_rp', 'rivers_x_coord_rp',                &
>          'rivers_y_coord_rp' )
>     remove_var = .TRUE.
>     message    = 'Coordinates are automatically included in files.'
>   END SELECT
> 
>   !---------------------------------------------------------------------------
413,416d470
< 
<     CASE DEFAULT
<       remove_var = .FALSE.
< 
446c500
<       IF ( soil_bgc_model == soil_model_rothc ) THEN
---
>       IF ( soil_bgc_model == soil_model_4pool ) THEN
458c512
<   IF ( soil_bgc_model /= soil_model_rothc .AND.                                &
---
>   IF ( soil_bgc_model /= soil_model_4pool .AND.                                &
471c525
<   IF ( soil_bgc_model /= soil_model_rothc .AND.                                &
---
>   IF ( soil_bgc_model /= soil_model_4pool .AND.                                &
573c627
<            'grid_area_rp' )
---
>            'grid_area_rp', 'rivers_outflow_rp', 'outflow_per_river' )
585c639
<            'grid_area_rp' )
---
>            'grid_area_rp', 'rivers_outflow_rp', 'outflow_per_river' )
599c653,654
<     message    = 'These river variables are not yet supported.'
---
>     message    = 'Variables on the full river grid are not available ' //      &
>                  'for output.'
607,609c662
<     CASE ( 't_home_gb', 't_growth_gb', 'l_growth_gb', 'vpd_growth_gb',        &
<         'co2_growth_gb','pstar_growth_gb','xipam_opt','vcmax_opt','jmax_opt', &  
<         't_sum','l_sum','t_night','nt_sum','vpd_sum','co2_sum','pstar_sum')
---
>     CASE (  't_home_gb', 't_growth_gb' )
611c664
<       message    = 'Thermal acclimation (photo_acclim_model,photo_pmodel) not used.'
---
>       message    = 'Thermal acclimation (photo_acclim_model) not used.'
687a741,765
>   ! Variables that are only allowed with atmospheric deposition
>   !---------------------------------------------------------------------------
>   IF ( .NOT. l_deposition ) THEN
>     ! Remove deposition diagnostics if l_deposition = FALSE
>     SELECT CASE ( var(j) )
>     CASE ( 'deposition_ra', 'deposition_rb', 'deposition_rc',                  &
>            'deposition_rc_stom', 'deposition_rc_nonstom',                      &
>            'deposition_vd', 'deposition_lossrate', 'deposition_flux',          &
>            'deposition_conc', 'level_separation')
>       remove_var = .TRUE.
>       message    = 'Atmospheric deposition is not selected.'
>     END SELECT
>   ELSE
>     ! Remove deposition flux diagnostics if l_deposition = TRUE and
>     ! l_deposition_flux = FALSE
>     IF ( .NOT. l_deposition_flux ) THEN
>       SELECT CASE ( var(j) )
>       CASE ( 'deposition_flux', 'deposition_conc' )
>         remove_var = .TRUE.
>         message    = 'Atmospheric deposition flux is not selected.'
>       END SELECT
>     END IF  !  not Atmospheric Deposition
>   END IF
> 
>   !---------------------------------------------------------------------------
691,693c769,771
<   ! wrr 	Repeating width ratio (or canyon fraction, W/R)
<   ! hwr 	Height-to-width ratio (H/W)
<   ! hgt 	Building height (H)
---
>   ! wrr   Repeating width ratio (or canyon fraction, W/R)
>   ! hwr   Height-to-width ratio (H/W)
>   ! hgt   Building height (H)
706a785,805
>   !---------------------------------------------------------------------------
>   ! Variables that are only allowed when l_sugar is true
>   !---------------------------------------------------------------------------
>   IF ( .NOT. l_sugar ) THEN
>     SELECT CASE ( var(j) )
>     CASE ( 'f_nsc', 'growth_sug' )
>       remove_var = .TRUE.
>       message    = 'l_sugar not selected'
>     END SELECT
>   END IF
> 
>   !---------------------------------------------------------------------------
>   ! Variables that only allowed when SOX is used
>   !---------------------------------------------------------------------------
>   IF ( stomata_model /= stomata_sox ) THEN
>     SELECT CASE ( var(j) )
>     CASE ( 'lwp_c' )
>       remove_var = .TRUE.
>       message    = 'SOX (stomata_model = 3) is not selected'
>     END SELECT
>   END IF
711c810
<     CALL log_error(RoutineName,                                                &
---
>     CALL log_warn(RoutineName,                                                 &
diff -r vn7.0copy1_c4/src/./initialisation/standalone/init_parms.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/standalone/init_parms.F90
22,23c22
< USE ancil_info, ONLY: land_pts, nsurft, sea_pts, sice_pts, ssi_pts, surft_pts, &
<                       sice_pts_ncat
---
> USE ancil_info, ONLY: land_pts, nsurft, sea_pts, sice_pts, ssi_pts
69c68
< CALL sparm(land_pts, nsurft, surft_pts,                                        &
---
> CALL sparm(land_pts, nsurft, ainfo%surft_pts,                                  &
75c74
< CALL infiltration_rate(land_pts, nsurft, surft_pts, ainfo%surft_index,         &
---
> CALL infiltration_rate(land_pts, nsurft, ainfo%surft_pts, ainfo%surft_index,   &
141c140
< sice_pts_ncat(:) = 0
---
> ainfo%sice_pts_ncat(:) = 0
150,151c149,150
<         sice_pts_ncat(n) = sice_pts_ncat(n) + 1
<         ainfo%sice_index_ncat(sice_pts_ncat(n),n) = l
---
>         ainfo%sice_pts_ncat(n) = ainfo%sice_pts_ncat(n) + 1
>         ainfo%sice_index_ncat(ainfo%sice_pts_ncat(n),n) = l
diff -r vn7.0copy1_c4/src/./initialisation/standalone/init_prescribed_data.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/standalone/init_prescribed_data.F90
532c532
< IF ( l_deposition_flux .AND. .NOT. ANY(all_vars == 'tracer') ) THEN
---
> IF ( l_deposition_flux .AND. .NOT. ANY(all_vars == 'deposition_conc') ) THEN
535c535,536
<                  "tracer concentrations must be prescribed.")
---
>                  "surface concentrations of deposited species " //             &
>                  "must be prescribed.")
diff -r vn7.0copy1_c4/src/./initialisation/standalone/init_rivers.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/standalone/init_rivers.F90
26d25
< USE io_constants, ONLY: namelist_unit
28c27,28
< USE string_utils_mod, ONLY: to_string
---
> USE jules_rivers_mod, ONLY: read_nml_jules_rivers, print_nlist_jules_rivers,   &
>                             check_jules_rivers, l_riv_overbank
30,34c30,32
< USE jules_rivers_mod, ONLY: jules_rivers, check_jules_rivers,                  &
<                             l_rivers, i_river_vn, nstep_rivers
< USE logging_mod, ONLY: log_info, log_fatal
< USE overbank_inundation_mod, ONLY: check_jules_overbank, jules_overbank,       &
<                                    l_riv_overbank
---
> USE overbank_inundation_mod, ONLY: read_nml_jules_overbank,                    &
>                                    print_nlist_jules_overbank,                 &
>                                    check_jules_overbank
43,86c41,42
< ! Work variables
< INTEGER :: ERROR  ! Error indicator
< 
< !-----------------------------------------------------------------------------
< ! Read river routing namelist
< !----------------------------------------------------------------------------
< CALL log_info("init_rivers", "Reading JULES_RIVERS namelist...")
< 
< ! Open the river routing parameters namelist file
< OPEN(namelist_unit, FILE=(TRIM(nml_dir) // '/' // 'jules_rivers.nml'),         &
<                STATUS='old', POSITION='rewind', ACTION='read', IOSTAT = ERROR)
< IF ( ERROR /= 0 ) THEN
<   CALL log_fatal("init_rivers",                                                &
<                  "Error opening namelist file jules_rivers.nml " //            &
<                  "(IOSTAT=" // TRIM(to_string(ERROR)) // ")")
< END IF
< 
< READ(namelist_unit, NML = jules_rivers, IOSTAT = ERROR)
< IF ( ERROR /= 0 ) THEN
<   CALL log_fatal("init_rivers",                                                &
<                  "Error reading namelist JULES_RIVERS " //                     &
<                  "(IOSTAT=" // TRIM(to_string(ERROR)) // ")")
< END IF
< 
< IF (l_rivers) THEN
<   ! Read the jules_overbank namelist.
<   CALL log_info("init_rivers", "Reading JULES_OVERBANK namelist...")
<   READ(namelist_unit, NML = jules_overbank, IOSTAT = ERROR)
<   IF ( ERROR /= 0 ) THEN
<     CALL log_fatal("init_overbank",                                            &
<                    "Error reading namelist JULES_OVERBANK " //                 &
<                    "(IOSTAT=" // TRIM(to_string(ERROR)) // ")")
<   END IF
< END IF
< 
< ! Close the namelist file
< CLOSE(namelist_unit, IOSTAT = ERROR)
< IF ( ERROR /= 0 ) THEN
<   CALL log_fatal("init_rivers",                                                &
<                  "Error closing namelist file jules_rivers.nml " //            &
<                  "(IOSTAT=" // TRIM(to_string(ERROR)) // ")")
< END IF
< 
< ! Check namelist values.
---
> CALL read_nml_jules_rivers(nml_dir)
> CALL print_nlist_jules_rivers()
88,103c44,47
< CALL check_jules_overbank()
< 
< ! Print some information.
< IF (l_rivers) THEN
<   CALL log_info("init_rivers",                                                 &
<                 "river routing model #" // TRIM(to_string(i_river_vn)) //      &
<                 "has been selected")
<   CALL log_info("init_rivers",                                                 &
<                 "Integer river routing timestep = " //                         &
<                  TRIM(to_string(nstep_rivers)))
< ELSE
<   CALL log_info("init_rivers", "No river routing selected")
< END IF
< 
< IF (l_riv_overbank) THEN
<   CALL log_info("init_rivers", "overbank inundation is selected")
---
> IF ( l_riv_overbank ) THEN
>   CALL read_nml_jules_overbank(nml_dir)
>   CALL print_nlist_jules_overbank()
>   CALL check_jules_overbank()
diff -r vn7.0copy1_c4/src/./initialisation/standalone/init_soil_biogeochem_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/standalone/init_soil_biogeochem_mod.F90
38c38
<    soil_model_ecosse, soil_model_1pool, soil_model_rothc,                      &
---
>    soil_model_ecosse, soil_model_1pool, soil_model_4pool,                      &
125,126c125,126
< ELSE IF ( soil_bgc_model == soil_model_rothc ) THEN
<   CALL log_info( RoutineName, "Soil C is modelled using RothC." )
---
> ELSE IF ( soil_bgc_model == soil_model_4pool ) THEN
>   CALL log_info( RoutineName, "Soil C is modelled using 4-pool C model." )
135c135
< CASE ( soil_model_1pool, soil_model_rothc )
---
> CASE ( soil_model_1pool, soil_model_4pool )
138c138
<                    "Q10 equation will be used for soil respiration" )
---
>              "Q10 equation used for soil respiration temp dependence" )
141c141
<                    "RothC equations will be used for soil respiration" )
---
>              "4-pool equation used for soil respiration temp dependence" )
diff -r vn7.0copy1_c4/src/./initialisation/standalone/init_soil_ecosse_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/standalone/init_soil_ecosse_mod.F90
49c49
<   temp_mod_q10, temp_mod_rothc, water_mod_jules, water_mod_rothc,              &
---
>   temp_mod_q10, temp_mod_smith, water_mod_clark, water_mod_smith,              &
165c165
< CASE ( temp_mod_rothc )
---
> CASE ( temp_mod_smith )
167c167
<                  "RothC form of T modifier equation used." )
---
>                  "Smith et al. (2010)  form of T modifier equation used." )
170c170
<                  "Q10 form of T modifier equation used." )
---
>                  "Clark et al. (2005) --Q10-- form of T modifier equation used." )
174c174
< CASE ( water_mod_rothc )
---
> CASE ( water_mod_smith )
176,177c176,177
<                  "RothC form of moisture modifier equation used." )
< CASE ( water_mod_jules )
---
>                  "4-pool form of moisture modifier equation used." )
> CASE ( water_mod_clark )
diff -r vn7.0copy1_c4/src/./initialisation/standalone/init_soil.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/standalone/init_soil.F90
77c77
< CALL check_jules_soil(sm_levels)
---
> CALL check_jules_soil()
diff -r vn7.0copy1_c4/src/./initialisation/standalone/init_surface.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/standalone/init_surface.F90
29c29,30
< USE jules_surface_mod, ONLY: jules_surface, l_aggregate, check_jules_surface
---
> USE jules_surface_mod, ONLY: jules_surface, l_aggregate, check_jules_surface,  &
>    print_nlist_jules_surface
74a76
> CALL print_nlist_jules_surface()
diff -r vn7.0copy1_c4/src/./initialisation/standalone/init_time_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/standalone/init_time_mod.F90
27c27
<                            l_360, l_leap
---
>                            l_360, l_leap, l_local_solar_time
30c30
< USE timestep_mod, ONLY: timestep_real => timestep
---
> USE timestep_mod, ONLY: timestep
32,33c32,33
<   run_min_time, run_max_time, current_time, timestep, timestep_len,            &
<   print_step,                                                                  &
---
>   run_min_time, run_max_time, current_time, timestep_number, timestep_len,     &
>   print_step, oasis_time,                                                      &
47a48,49
> USE jules_model_environment_mod, ONLY: lsm_id, rivers
> 
85c87
<                       main_run_end, print_step
---
>                       main_run_end, print_step, l_local_solar_time
103c105
< NAMELIST  / jules_spinup/ max_spinup_cycles, spinup_start, spinup_end,         &
---
> NAMELIST  /jules_spinup/ max_spinup_cycles, spinup_start, spinup_end,          &
137,144c139,148
< ! Then read the spinup namelist
< CALL log_info("init_time", "Reading JULES_SPINUP namelist...")
< READ(namelist_unit, NML = jules_spinup, IOSTAT = ERROR, IOMSG = iomessage)
< IF ( ERROR /= 0 )                                                              &
<   CALL log_fatal("init_time",                                                  &
<                  "Error reading namelist JULES_SPINUP " //                     &
<                  "(IOSTAT=" // TRIM(to_string(ERROR)) // " IOMSG=" //          &
<                  TRIM(iomessage) // ")")
---
> IF ( lsm_id /= rivers ) THEN
>   ! Then read the spinup namelist
>   CALL log_info("init_time", "Reading JULES_SPINUP namelist...")
>   READ(namelist_unit, NML = jules_spinup, IOSTAT = ERROR, IOMSG = iomessage)
>   IF ( ERROR /= 0 )                                                            &
>      CALL log_fatal("init_time",                                               &
>                     "Error reading namelist JULES_SPINUP " //                  &
>                     "(IOSTAT=" // TRIM(to_string(ERROR)) // " IOMSG=" //       &
>                     TRIM(iomessage) // ")")
> END IF
148,151c152,155
<   CALL log_fatal("init_time",                                                  &
<                  "Error closing namelist file timesteps.nml " //               &
<                  "(IOSTAT=" // TRIM(to_string(ERROR)) // " IOMSG=" //          &
<                  TRIM(iomessage) // ")")
---
>    CALL log_fatal("init_time",                                                 &
>                   "Error closing namelist file timesteps.nml " //              &
>                   "(IOSTAT=" // TRIM(to_string(ERROR)) // " IOMSG=" //         &
>                   TRIM(iomessage) // ")")
164a169,171
> IF ( l_local_solar_time )                                                      &
>   CALL log_info("init_time", "Interpreting time as local solar time")
> 
249c256,257
< timestep = 1
---
> timestep_number = 1
> oasis_time = 0
266c274
< timestep_real = REAL(timestep_len)
---
> timestep = REAL(timestep_len)
diff -r vn7.0copy1_c4/src/./initialisation/standalone/init_vegetation.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/standalone/init_vegetation.F90
34,39c34,38
<                                 photo_pmodel, photo_adapt,                     &
<                                 photo_acclim, photo_adapt_acclim,              &
<                                 photo_pmodel_acclim,                           &
<                                 photo_act_model, photo_act_pft, photo_act_gb,  &
<                                 photo_jv_model, jv_scale, jv_ntotal,           &
<                                 stomata_model, stomata_jacobs, stomata_medlyn, &
---
>                                 photo_sox_collatz, photo_adapt,photo_acclim,   &
>                                 photo_adapt_acclim, photo_act_model,           &
>                                 photo_act_pft, photo_act_gb, photo_jv_model,   &
>                                 jv_scale, jv_ntotal, stomata_model,            &
>                                 stomata_jacobs, stomata_medlyn, stomata_sox,   &
119c118
< CASE ( photo_pmodel )
---
> CASE ( photo_sox_collatz )
121c120,121
<                 "C3 plants use the P model of photosynthesis.")
---
>                 "C3 plants use the Collatz model of photosynthesis "//         &
>                 "as derived for use with the SOX stomata model.")
123,125d122
< SELECT CASE ( photo_model )
< CASE ( photo_collatz, photo_farquhar )
< 
128,131d124
< CASE ( photo_pmodel )
< CALL log_info("init_vegetation",                                               &
<               "C4 plants use the P model of photosynthesis.")
< END SELECT
133,135c126,127
< ! Report options that are ony allowed with Farquhar photosynthesis and P-model
< IF ( photo_model ==  photo_farquhar .OR.                                       &
<        photo_model == photo_pmodel ) THEN
---
> ! Report options that are ony allowed with Farquhar photosynthesis.
> IF ( photo_model ==  photo_farquhar ) THEN
149,151d140
<   CASE (photo_pmodel_acclim)
<     CALL log_info("init_vegetation",                                           &
<                   "Acclimation of photosynthesis selected.")           
184a174,176
> CASE ( stomata_sox )
>   CALL log_info("init_vegetation",                                             &
>                 "Using the SOX model of stomatal conductance.")
Only in vn7.0copy1_c4/src/./initialisation/standalone/params: init_deposition_species.inc
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/standalone/params: init_deposition_species_mod.F90
diff -r vn7.0copy1_c4/src/./initialisation/standalone/params/init_params_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/standalone/params/init_params_mod.F90
12a13,14
> USE init_deposition_species_mod, ONLY: init_deposition_species
> 
31d32
< #include "init_deposition_species.inc"
diff -r vn7.0copy1_c4/src/./initialisation/standalone/params/init_pftparm.inc vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/standalone/params/init_pftparm.inc
20c20
<                                       soil_model_rothc
---
>                                       soil_model_4pool
49,62c49,65
<   g1_stomata,   g_leaf_0,      glmin,                                          &
<   gpp_st,       gsoil_f,       hw_sw,                                          &
<   ief,          infil_f,       jv25_ratio,                                     &
<   kext,         kn,            knl,                                            &
<   kpar,         lai_alb_lim,   lma,                                            &
<   mef,          neff,          nl0,                                            &
<   nmass,        nr,            nr_nl,                                          &
<   ns_nl,        nsw,           omega,                                          &
<   omegal,       omegau,        omnir,                                          &
<   omnirl,       omniru,        orient,                                         &
<   q10_leaf,     r_grow,        rootd_ft,                                       &
<   sigl,         tef,           tleaf_of,                                       &
<   tlow,         tupp,          vint,                                           &
<   vsl,          z0v
---
>   sug_g0,       g1_stomata,    g_leaf_0,                                       &
>   glmin,        gpp_st,        sug_grec,                                       &
>   gsoil_f,      hw_sw,         ief,                                            &
>   infil_f,      jv25_ratio,    kext,                                           &
>   kn,           knl,           kpar,                                           &
>   lai_alb_lim,  lma,           mef,                                            &
>   neff,         nl0,           nmass,                                          &
>   nr,           nr_nl,         ns_nl,                                          &
>   nsw,          omega,         omegal,                                         &
>   omegau,       omnir,         omnirl,                                         &
>   omniru,       orient,        q10_leaf,                                       &
>   r_grow,       rootd_ft,      sigl,                                           &
>   tef,          tleaf_of,      tlow,                                           &
>   tupp,         vint,          vsl,                                            &
>   sug_yg,       z0v,           sox_a,                                          &
>   sox_p50,      sox_rp_min
> 
70,72c73,76
<                                  photo_farquhar, photo_model, photo_pmodel,    &
<                                  stomata_jacobs, stomata_medlyn,               &
<                                  stomata_model, l_spec_veg_z0
---
>                                  photo_farquhar, photo_model,                  &
>                                  stomata_jacobs, stomata_medlyn, stomata_sox,  &
>                                  stomata_model, l_spec_veg_z0, l_sugar,        &
>                                  l_scale_resp_pm
273,274c277
< CASE (photo_pmodel)
<    ! no check for now 
---
> 
291a295,307
> CASE ( stomata_sox )
>   IF ( ANY( ABS( sox_p50(:) - rmdi ) < EPSILON(1.0) ) ) THEN
>     ERROR = 1
>     CALL log_error(routinename, "No value for sox_p50")
>   END IF
>   IF ( ANY( ABS( sox_rp_min(:) - rmdi ) < EPSILON(1.0) ) ) THEN
>     ERROR = 1
>     CALL log_error(routinename, "No value for sox_rp_min")
>   END IF
>   IF ( ANY( ABS( sox_a(:) - rmdi ) < EPSILON(1.0) ) ) THEN
>     ERROR = 1
>     CALL log_error(routinename, "No value for sox_a")
>   END IF
592a609,623
> IF ( l_sugar ) THEN
>   IF ( ANY( ABS( sug_g0(:) - rmdi ) < EPSILON(1.0) ) ) THEN
>     ERROR = 1
>     CALL log_error(routinename, "No value for sug_g0")
>   END IF
>   IF ( ANY( ABS( sug_grec(:) - rmdi ) < EPSILON(1.0) ) ) THEN
>     ERROR = 1
>     CALL log_error(routinename, "No value for sug_grec")
>   END IF
>   IF ( ANY( ABS( sug_yg(:) - rmdi ) < EPSILON(1.0) ) ) THEN
>     ERROR = 1
>     CALL log_error(routinename, "No value for sug_yg")
>   END IF
> END IF
> 
654c685
< ! fsmc_mod=1 should not be allowed with a layered RothC  model until this has
---
> ! fsmc_mod=1 should not be allowed with a layered 4-pool C model until this has
657d687
< ! Note that l_layeredC=T is not currently allowed with the UM.
659c689
< IF ( l_layeredC .AND. ( soil_bgc_model == soil_model_rothc ) .AND.             &
---
> IF ( l_layeredC .AND. ( soil_bgc_model == soil_model_4pool ) .AND.             &
662c692,719
<                  "fsmc_mod=1 is not allowed with l_layeredC and RothC")
---
>                  "fsmc_mod=1 is not allowed with l_layeredC and 4-pool C model")
> END IF
> 
> !-----------------------------------------------------------------------------
> ! stomata_model = stomata_sox must be used with fsmc_mod = 1
> ! Cannot be run with l_scale_resp_pm
> ! Must be run with can_rad_mod = 1 (implementation for can_rad_mod = 6 ongoing)
> !-----------------------------------------------------------------------------
> IF ( stomata_model == stomata_sox ) THEN ! SOX
>   IF ( l_scale_resp_pm ) THEN
>     CALL log_fatal(routinename,                                                &
>     'l_scale_resp_pm=T is incompatible with SOX (stomata_model=3)')
>   END IF
> 
>   IF ( .NOT. ANY ( fsmc_mod(:) == 1 ) ) THEN
>     CALL log_fatal(routinename,                                                &
>     'SOX (stomata_model=3) must be used with fsmc_mod = 1')
>   END IF
> 
>   IF ( .NOT. ( can_rad_mod == 1 ) ) THEN
>     CALL log_fatal(routinename,                                                &
>     'SOX (stomata_model=3) must be used with can_rad_mod = 1')
>   END IF
> 
>   IF ( .NOT. ( photo_model == 3 ) ) THEN
>     CALL log_fatal(routinename,                                                &
>     'SOX (stomata_model=3) uses the SOX derivation of Collatz (photo_model=3)')
>   END IF
diff -r vn7.0copy1_c4/src/./initialisation/um/init_acc.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/um/init_acc.F90
16c16
<        resp_w_pft_acc,resp_s_acc1)
---
>        resp_w_pft_acc,resp_s_acc_4pool)
20a21,25
> USE jules_soil_biogeochem_mod, ONLY: l_layeredC
> 
> USE atm_fields_mod, ONLY:                                                      &
>   resp_s_acclyr_p1, resp_s_acclyr_p2,                                          &
>   resp_s_acclyr_p3, resp_s_acclyr_p4
63c68
< REAL(KIND=real_jlslsm), INTENT(IN OUT) :: resp_s_acc1(land_pts,1,4)
---
> REAL(KIND=real_jlslsm), INTENT(IN OUT) :: resp_s_acc_4pool(land_pts,4)
88c93
< DO n = 1,4
---
> DO n = 1,4  ! soil carbon pools
90,91c95
<     ! dim_cslayer is 1
<     resp_s_acc1(l,1,n)           = 0.0
---
>     resp_s_acc_4pool(l,n) = 0.0
93a98,106
> 
> IF (l_layeredc) THEN
>   DO l=1,land_pts
>     resp_s_acclyr_p1(l,:) = 0.0
>     resp_s_acclyr_p2(l,:) = 0.0
>     resp_s_acclyr_p3(l,:) = 0.0
>     resp_s_acclyr_p4(l,:) = 0.0
>   END DO
> END IF
diff -r vn7.0copy1_c4/src/./initialisation/um/init_urban.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/um/init_urban.F90
25c25
< USE jules_surface_mod, ONLY: l_urban2t
---
> USE jules_surface_mod, ONLY: l_urban2t, l_anthrop_heat_use_wrr
67a68,69
>   ! To maintain bit comparability in generate_anthropogenic_heat
>   IF ( ANY( urban_param%wrr_gb(:) > 0.0 ) ) l_anthrop_heat_use_wrr = .TRUE.
diff -r vn7.0copy1_c4/src/./initialisation/um/init_veg.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/um/init_veg.F90
14c14,15
< SUBROUTINE init_veg(a_step, triffid_period_arg, nstep_since_triffid, trif_vars)
---
> SUBROUTINE init_veg(a_step, triffid_period_arg, nstep_since_triffid,           &
>                     trif_vars, progs)
21a23
> USE init_layeredcn_mod,       ONLY: init_layeredcn
26c28,29
<                                     triffid_period, l_trif_init_accum
---
>                                     triffid_period, l_trif_init_accum,         &
>                                     l_nitrogen
28a32
> USE prognostics,   ONLY: progs_type
51c55,56
<                                     rsp_w_pft_acc, resp_s_acc1, g_lf_pft_acc,  &
---
>                                     rsp_w_pft_acc, resp_s_acc_4pool,           &
>                                     g_lf_pft_acc,                              &
86a92
> TYPE(progs_type), INTENT(IN OUT) :: progs
134c140,141
< CALL tilepts(land_pts,frac_surft,surft_pts,surft_index,ainfo%l_lice_point)
---
> CALL tilepts(land_pts,frac_surft,surft_pts,surft_index,ainfo%l_lice_point,     &
>              ainfo%l_lice_surft)
186a194,198
>       IF (l_nitrogen) THEN
>         ! initialise n_inorg_avail_pft
>         CALL init_layeredcn(ainfo%soil_index, progs)
>       END IF
> 
190c202
<                       rsp_w_pft_acc, resp_s_acc1)
---
>                       rsp_w_pft_acc, resp_s_acc_4pool)
diff -r vn7.0copy1_c4/src/./initialisation/um/jules_init.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/um/jules_init.F90
39c39,40
< USE nlsizes_namelist_mod,     ONLY: ntiles, land_field, sm_levels
---
> USE jules_soil_mod,           ONLY: sm_levels
> USE nlsizes_namelist_mod,     ONLY: ntiles, land_field
diff -r vn7.0copy1_c4/src/./initialisation/um/read_jules_namelists_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/um/read_jules_namelists_mod.F90
29a30,31
> USE ereport_mod,      ONLY: ereport
> 
105a108,193
> 
> ! *********************************************************************
> 
> SUBROUTINE read_jules_deposition (unitnumber)
> 
> ! Description:
> !  Read the JULES_DEPOSITION control namelist
> 
> USE jules_deposition_mod,  ONLY:                                               &
>   print_nlist_jules_deposition, check_jules_deposition,                        &
>   read_nml_jules_deposition
> 
> IMPLICIT NONE
> 
> ! Subroutine arguments
> INTEGER, INTENT(IN) :: unitnumber
> 
> REAL(KIND=jprb) :: zhook_handle
> CHARACTER(LEN=*), PARAMETER :: RoutineName='READ_JULES_DEPOSITION'
> 
> IF (lhook) CALL dr_hook(ModuleName//':'//RoutineName,zhook_in,zhook_handle)
> 
> CALL read_nml_jules_deposition(unitnumber)
> IF (PrintStatus >= PrStatus_Oper .AND. mype == 0) THEN
>   CALL print_nlist_jules_deposition()
> END IF
> CALL check_jules_deposition()
> 
> IF (lhook) CALL dr_hook(ModuleName//':'//RoutineName,zhook_out,zhook_handle)
> RETURN
> END SUBROUTINE read_jules_deposition
> 
> ! *********************************************************************
> 
> SUBROUTINE read_jules_deposition_species (unitnumber)
> 
> ! Description:
> !  Read the JULES_DEPOSITION_OTHER and JULES_DEPOSITION_SPECIES namelists
> 
> USE jules_deposition_mod,       ONLY:                                          &
>   dry_dep_model, dry_dep_model_ukca, dry_dep_model_jules
> 
> USE deposition_species_io_mod,  ONLY:                                          &
>   print_nlist_jules_deposition_species,                                        &
>   read_nml_jules_deposition_species
> 
> USE deposition_species_specific_io_mod,  ONLY:                                 &
>   print_nlist_jules_deposition_species_specific,                               &
>   read_nml_jules_deposition_species_specific
> 
> IMPLICIT NONE
> 
> ! Subroutine arguments
> INTEGER, INTENT(IN) :: unitnumber
> INTEGER             :: errorstatus
> 
> REAL(KIND=jprb) :: zhook_handle
> CHARACTER(LEN=*), PARAMETER :: RoutineName='READ_JULES_DEPOSITION_SPECIES'
> 
> IF (lhook) CALL dr_hook(ModuleName//':'//RoutineName,zhook_in,zhook_handle)
> 
> errorstatus = dry_dep_model
> SELECT CASE ( dry_dep_model )
> 
> CASE ( dry_dep_model_ukca, dry_dep_model_jules )
>   ! Species deposition parameter values from namelists
>   CALL read_nml_jules_deposition_species(unitnumber)
>   IF (PrintStatus >= PrStatus_Oper .AND. mype == 0) THEN
>     CALL print_nlist_jules_deposition_species()
>   END IF
> 
>   CALL read_nml_jules_deposition_species_specific(unitnumber)
>   IF (PrintStatus >= PrStatus_Oper .AND. mype == 0) THEN
>     CALL print_nlist_jules_deposition_species_specific()
>   END IF
>   ! Check is on deposition science variables
> 
> CASE DEFAULT
>   CALL ereport (RoutineName, errorstatus,                                      &
>                "Invalid value for dry_dep_model. Should be 1 or 2." )
> 
> END SELECT
> 
> IF (lhook) CALL dr_hook(ModuleName//':'//RoutineName,zhook_out,zhook_handle)
> RETURN
> END SUBROUTINE read_jules_deposition_species
diff -r vn7.0copy1_c4/src/./initialisation/um/surf_couple_allocate_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/um/surf_couple_allocate_mod.F90
40c40
< USE ancil_info,               ONLY: dim_cs1,                                   &
---
> USE ancil_info,               ONLY: dim_cs1, dim_cslayer,                      &
45c45
< USE jules_surface_types_mod,   ONLY: nnvg, npft, soil
---
> USE jules_surface_types_mod,   ONLY: npft, nnvg, ntype, soil
48a49
> USE jules_soil_biogeochem_mod,ONLY: l_layeredc
84d84
< ! This check must be run once we have access to sm_levels
89a90,115
> ! JULES with atmospheric deposition
> USE jules_deposition_mod, ONLY: l_deposition, ndry_dep_species,                &
>   dry_dep_model, dry_dep_model_jules, dry_dep_model_ukca
> 
> USE deposition_initialisation_aerod_mod, ONLY:                                 &
>   deposition_initialisation_aerod_jules, deposition_initialisation_aerod_ukca
> 
> USE deposition_initialisation_surfddr_mod, ONLY:                               &
>   deposition_initialisation_surfddr_ukca
> 
> USE deposition_species_io_mod, ONLY: deposition_io_data_all
> ! Deposition io variables from set of "jules_deposition_species" namelists
> ! carried in structure deposition_io_data_all.
> 
> USE deposition_species_mod, ONLY:                                              &
> ! namelist variables
>   ch4_scaling,     ch4dd_tundra,     ch4_up_flux,         ch4_mml,             &
>   cuticle_o3,      dd_ice_coeff,     dep_species_name,                         &
>   diffusion_coeff, diffusion_corr,   dep_species_rmm,                          &
>   h2dd_c,          h2dd_m,           h2dd_q,                                   &
>   r_tundra,        r_wet_soil_o3,    rsurf_std,                                &
> ! routines
>   check_jules_deposition_species
> 
> USE jules_print_mgr,  ONLY: jules_print
> 
107a134
> USE water_resources_vars_mod, ONLY: water_resources_assoc
108a136
> USE jules_wtrac_type_mod, ONLY: wtrac_jls_assoc
129c157,159
<                           rivers_data, rivers
---
>                           water_resources_data, water_resources,               &
>                           rivers_data, rivers,                                 &
>                           wtrac_jls_data, wtrac_jls
171a202
> dim_cslayer = 1
173a205,207
>   IF (l_layeredc) THEN
>     dim_cslayer = sm_levels
>   END IF
190c224,225
<                            forcing_data, rivers_data, chemvars_data)
---
>                            forcing_data, rivers_data, chemvars_data,           &
>                            water_resources_data, wtrac_jls_data)
211a247
> CALL water_resources_assoc(water_resources, water_resources_data)
212a249
> CALL wtrac_jls_assoc(wtrac_jls, wtrac_jls_data)
252,254c289,349
< ! Now we have access to sm_levels from the dump, we can check the JULES_SOIL
< ! namelist for consistency
< CALL check_jules_soil(sm_levels)
---
> ! jules_deposition
> IF ( l_deposition ) THEN
> 
>   CALL jules_print(RoutineName,                                                &
>                'Check assignment from deposition_io_data_all')
> 
>   ! Loop over the species.
>   DO i = 1,ndry_dep_species
> 
>     ! Load values into the final variables.
>     ! Variables that have a value for every species
>     ! (even if not necessarily used for all species).
>     dep_species_name(i) = deposition_io_data_all % dep_species_name_io(i)
>     dd_ice_coeff(i,:)   = deposition_io_data_all % dd_ice_coeff_io(i,:)
>     diffusion_coeff(i)  = deposition_io_data_all % diffusion_coeff_io(i)
>     dep_species_rmm(i)  = deposition_io_data_all % dep_species_rmm_io(i)
>     diffusion_corr(i)   = deposition_io_data_all % diffusion_corr_io(i)
>     r_tundra(i)         = deposition_io_data_all % r_tundra_io(i)
>     rsurf_std(:,i)      = deposition_io_data_all % rsurf_std_io(1:ntype,i)
> 
>     ! Deal with variables that only apply to one species.
>     ! If values are given for other species they will be ignored.
>     SELECT CASE ( dep_species_name(i) )
> 
>     CASE ( 'CH4' )
> 
>       ch4_scaling       = deposition_io_data_all % ch4_scaling_io
>       ch4_mml           = deposition_io_data_all % ch4_mml_io
>       ch4dd_tundra(:)   = deposition_io_data_all % ch4dd_tundra_io(:)
>       ch4_up_flux(:)    = deposition_io_data_all % ch4_up_flux_io(1:ntype)
> 
>     CASE ( 'H2' )
>       h2dd_c(:)         = deposition_io_data_all % h2dd_c_io(1:ntype)
>       h2dd_m(:)         = deposition_io_data_all % h2dd_m_io(1:ntype)
>       h2dd_q(:)         = deposition_io_data_all % h2dd_q_io(1:ntype)
> 
>     CASE ( 'O3' )
>       cuticle_o3        = deposition_io_data_all % cuticle_o3_io
>       r_wet_soil_o3     = deposition_io_data_all % r_wet_soil_o3_io
> 
>     END SELECT
> 
>   END DO  ! Species
> 
>   CALL check_jules_deposition_species(ntype)
> 
>   ! Initialise the parameters for the calculation of
>   ! (1) the aerodynamic (Ra) & quasi-laminar (Rb) resistance terms
>   ! (2) surface resistance (Rc) terms (for dry_dep_model=dry_dep_model_ukca)
>   SELECT CASE ( dry_dep_model )
>   CASE ( dry_dep_model_ukca )
>     CALL deposition_initialisation_aerod_ukca()
>     CALL deposition_initialisation_surfddr_ukca()
>   CASE ( dry_dep_model_jules )
>     CALL deposition_initialisation_aerod_jules()
>   END SELECT
> 
> END IF  ! l_deposition
> 
> ! Check the jules_soil namelist for consistency
> CALL check_jules_soil()
282c377
< ! Now that the arrays have been allocated and filled we can now check them
---
> ! Now that the arrays have been allocated and filled we can check them
diff -r vn7.0copy1_c4/src/./initialisation/um/surf_couple_initialise.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/um/surf_couple_initialise.F90
36a37
> USE soil_biogeochem_utils_mod, ONLY: calc_litc_norm
53a55,56
> USE jules_soil_biogeochem_mod, ONLY: l_layeredC
> USE veg_param,                 ONLY: litc_norm
129a133,139
> IF (l_layeredc) THEN
>   IF (land_field  >   0) THEN
>     ! Calculate litc_norm
>     CALL calc_litc_norm(litc_norm)
>   END IF
> END IF
> 
132c142,143
<     CALL init_veg(a_step, triffid_period_arg, nstep_since_triffid, trif_vars)
---
>     CALL init_veg(a_step, triffid_period_arg, nstep_since_triffid,             &
>                   trif_vars, progs)
diff -r vn7.0copy1_c4/src/./initialisation/um/surf_couple_read_namelists_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/um/surf_couple_read_namelists_mod.F90
39c39,40
<     read_jules_irrigation
---
>     read_jules_irrigation,                                                     &
>     read_jules_deposition, read_jules_deposition_species
41c42,46
< USE jules_rivers_mod, ONLY: l_rivers
---
> USE jules_deposition_mod, ONLY: l_deposition
> 
> USE jules_rivers_mod, ONLY: l_riv_overbank
> 
> USE jules_vegetation_mod, ONLY: l_triffid
68c73
< IF (l_rivers) CALL read_jules_overbank(shared_unit)
---
> IF ( l_riv_overbank ) CALL read_jules_overbank(shared_unit)
77c82
< 
---
> CALL read_jules_deposition(shared_unit)
83c88
<   CALL read_jules_triffid(atmoscntl_unit)
---
>   IF ( l_triffid ) CALL read_jules_triffid(atmoscntl_unit)
84a90,92
>   IF (l_deposition) THEN
>     CALL read_jules_deposition_species(atmoscntl_unit)
>   END IF
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/um: wtrac_init_jls_mod.F90
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./initialisation/um: wtrac_setup_jls_mod.F90
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./io/dump: add_dump_coords_for_rivers_mod.F90
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./io/dump: add_to_list_mod.F90
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./io/dump: create_dump_file_mod.F90
diff -r vn7.0copy1_c4/src/./io/dump/dump_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./io/dump/dump_mod.F90
20c20
< INTEGER, PARAMETER :: max_var_dump = 84
---
> INTEGER, PARAMETER :: max_var_dump = 85
diff -r vn7.0copy1_c4/src/./io/dump/get_dim_info_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./io/dump/get_dim_info_mod.F90
1d0
< #if !defined(UM_JULES)
16a16
> #if !defined(RIVERS_ONLY)
29c29
<   dim_cs1, dim_soil_n_pool, nsurft, nsoilt, dim_cslayer
---
>   dim_cs1, dim_soil_n_pool, nsurft, nsoilt, dim_cslayer, nmasst
34,36d33
< USE jules_rivers_mod, ONLY:                                                    &
<   np_rivers
< 
64d60
<                                p_rivers_dim_name => p_rivers_dim_name_out,     &
134c130
< CASE ( 'gs',  'cv', 'frac_agr_prev', 'frac_past_prev',           &
---
> CASE ( 'gs', 't_growth_gb', 'cv', 'frac_agr_prev', 'frac_past_prev',           &
148c144,145
<        'lake_h_ice_gb', 'lake_shape_factor_gb', 'latitude', 'longitude')
---
>        'lake_h_ice_gb', 'lake_shape_factor_gb', 'latitude', 'longitude',       &
>        'projection_x_coord', 'projection_y_coord' )
158,164d154
< CASE(  't_growth_gb', 'l_growth_gb','vpd_growth_gb', 'co2_growth_gb',         &
<         'pstar_growth_gb', 'xipam_opt','vcmax_opt','jmax_opt',                &
<         't_sum','l_sum', 't_night','nt_sum','vpd_sum','co2_sum','pstar_sum')
<   ndims = 2
<   dim_names(1:ndims) = [ land_dim_name, pft_dim_name ]
<   dim_sizes(1:ndims) = [ global_land_pts, npft ]
<          
170c160
< CASE ( 'canht', 'lai','years_since_harvest')
---
> CASE ( 'canht', 'lai', 'years_since_harvest', 'f_nsc' )
174a165,169
> CASE ( 'plantNumDensity' )
>   ndims = 3
>   dim_names(1:ndims) = [ land_dim_name, pft_dim_name, nmasst_dim_name ]
>   dim_sizes(1:ndims) = [ global_land_pts, npft, nmasst ]
> 
270,277d264
<   ! River routing variables.
< CASE ( 'rivers_lat_rp', 'rivers_lon_rp',                                       &
<        'rivers_sto_rp', 'rfm_surfstore_rp', 'rfm_substore_rp',                 &
<        'rfm_flowin_rp', 'rfm_bflowin_rp' )
<   ndims = 1
<   dim_names(1) = p_rivers_dim_name
<   dim_sizes(1) = np_rivers
< 
484a472,567
>   ! River routing variables and calls log_fatal is identifier not found
>   CALL get_dim_info_rivers( l_reading, identifier, ndims, dim_sizes,           &
>      dim_names, l_read_from_dump )
> 
> END SELECT
> 
> RETURN
> 
> END SUBROUTINE get_dim_info
> 
> SUBROUTINE get_dim_info_rivers( l_reading, identifier, ndims, dim_sizes,       &
>    dim_names, l_read_from_dump )
> #endif
> !-----------------------------------------------------------------------------
> ! Description:
> !   Given a River routing variable's identifier, return the number, sizes and
> !   names of its dimensions. Used when reading or writing a dump file.
> !
> ! Code Owner: Please refer to ModuleLeaders.txt
> ! This file belongs in TECHNICAL
> !-----------------------------------------------------------------------------
> 
> USE jules_rivers_mod, ONLY:                                                    &
>   np_rivers
> 
> USE string_utils_mod, ONLY:                                                    &
>   to_string
> 
> USE logging_mod, ONLY: log_fatal
> 
> USE model_interface_mod, ONLY: p_rivers_dim_name => p_rivers_dim_name_out
> 
> IMPLICIT NONE
> 
> !-----------------------------------------------------------------------------
> ! Arguments with INTENT(IN).
> !-----------------------------------------------------------------------------
> LOGICAL, INTENT(IN) ::                                                         &
>   l_reading
>     ! Flag indicating where this routine has been called from.
>     ! T means the call is from read_dump.
>     ! F means the call is from write_dump.
> 
> CHARACTER(LEN=*), INTENT(IN) ::                                                &
>   identifier  ! The identifier.
> 
> !-----------------------------------------------------------------------------
> ! Arguments with INTENT(OUT).
> !-----------------------------------------------------------------------------
> INTEGER, INTENT(OUT) ::                                                        &
>   ndims,                                                                       &
>     ! Number of dimensions for the variable.
>   dim_sizes(:)
>     ! Size of each dimension.
> 
> CHARACTER(LEN=*), INTENT(OUT) ::                                               &
>   dim_names(:)
>     ! Name of each dimension.
> 
> !-----------------------------------------------------------------------------
> ! Optional arguments.
> !-----------------------------------------------------------------------------
> LOGICAL, INTENT(OUT), OPTIONAL ::                                              &
>   l_read_from_dump
>     ! Flag passed to read_dump to indicate that a variable should be read from
>     ! the dump file. This is TRUE for most variables, FALSE only for ancillary
>     ! variables that were read from ancillary files (not the dump).
> 
> !-----------------------------------------------------------------------------
> ! If this is call from read_dump, check we have the optional argument.
> ! If it is present, set the default to TRUE.
> !-----------------------------------------------------------------------------
> IF ( l_reading ) THEN
>   IF ( .NOT. PRESENT(l_read_from_dump) ) THEN
>     CALL log_fatal("get_dim_info",                                             &
>                    "l_read_from_dump must be present when called from " //     &
>                    "read_dump.")
>   ELSE
>     l_read_from_dump = .TRUE.
>   END IF
> END IF
> 
> !-----------------------------------------------------------------------------
> 
> SELECT CASE ( identifier )
> 
>   ! River routing variables.
> CASE ( 'rivers_lat_rp', 'rivers_lon_rp', 'rivers_x_coord_rp',                  &
>        'rivers_y_coord_rp', 'rivers_sto_rp', 'rfm_surfstore_rp',               &
>        'rfm_substore_rp', 'rfm_flowin_rp', 'rfm_bflowin_rp',                   &
>        'rivers_outflow_rp', 'outflow_per_river' )
>   ndims = 1
>   dim_names(1) = p_rivers_dim_name
>   dim_sizes(1) = np_rivers
> 
> CASE DEFAULT
492a576,578
> #if !defined(RIVERS_ONLY)
> END SUBROUTINE get_dim_info_rivers
> #else
493a580
> #endif
544d630
< #endif
diff -r vn7.0copy1_c4/src/./io/dump/read_dump_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./io/dump/read_dump_mod.F90
1c1
< #if !defined(UM_JULES)
---
> #if !defined(RIVERS_ONLY)
18c18,19
<                             jules_vars, fluxes, rivers
---
>                             jules_vars, fluxes, rivers, water_resources
> USE imgn_vars_mod, ONLY: imgn_vars
25c26,27
<   land_pts, dim_cs1, dim_soil_n_pool, nsurft, nsoilt, dim_cslayer, nsoilt
---
>   land_pts, dim_cs1, dim_soil_n_pool, nsurft, nsoilt, dim_cslayer, nsoilt,     &
>   nmasst
38,40d39
< USE imogen_progs, ONLY:                                                        &
<   co2_ppmv, co2_change_ppmv, dtemp_o, fa_ocean, ch4_ppbv
< 
56,58d54
< USE jules_water_resources_mod, ONLY:                                           &
<   conveyance_loss, irrig_eff, sfc_water_frac
< 
63,65c59,60
< USE mpi, ONLY: mpi_real, mpi_comm_world, mpi_logical, mpi_integer
< USE io_constants, ONLY:                                                        &
<   mode_read, max_dim_var, max_sdf_name_len
---
> USE mpi, ONLY: mpi_real, mpi_logical, mpi_integer
> USE jules_vars_mod, ONLY: mpi_local_comm
70,72d64
< USE string_utils_mod, ONLY:                                                    &
<   to_string
< 
74,76c66
<   file_handle, file_open, file_introspect,                                     &
<   file_inquire_dim, file_inquire_var, file_read_var,                           &
<   file_close
---
>   file_handle, file_read_var, file_close
80c70,72
< USE get_dim_info_mod, ONLY: get_dim_info
---
> 
> USE read_dump_shared_mod,     ONLY: read_dump_shared
> USE read_dump_var_rivers_mod, ONLY: read_dump_var_rivers
104,109d95
< ! Local parameters.
< LOGICAL, PARAMETER :: l_reading_true = .TRUE.
<   ! A value of .TRUE. that is passed to argument l_reading of subroutine
<   ! get_dim_info to show that it is being called in connection with reading
<   ! (rather than writing) a dump.
< 
117,140d102
< INTEGER :: dim_size_file
<   ! The size of the dimension currently being
<   ! processed in the file
< 
< ! Used when defining dimensions and variables
< INTEGER :: ndims
<   ! The number of dimensions the current variable has
< CHARACTER(LEN=max_sdf_name_len) :: dim_names(max_dim_var)
<   ! The dimension names the current variable should use
< INTEGER :: dim_sizes(max_dim_var)
<   ! The dimension sizes for the current variable
< INTEGER :: dim_ids(max_dim_var)
<   ! The dimension ids for the current variable as
<   ! calculated from file_inquire_dim
< LOGICAL :: is_record_dim
<   ! Detects if the current dimension is a record dim
< INTEGER :: ndims_file
<   ! The number of dimensions the variable has in file
<   ! Compared to ndims above for each variable
< INTEGER :: dim_ids_file(max_dim_var)
<   ! The ids of the dimensions the variable has in the file
<   ! Compared to dim_ids above to verify the variable has the
<   ! correct dimensions
< 
144,150d105
< LOGICAL :: is_record_var
<   ! Indicates if a variable uses the record dimension
< 
< LOGICAL :: l_read_from_dump
<   ! Used to bypass checking the dimensions of ancil variables that are
<   ! not to be read from the dump.
< 
180d134
< nvars = SIZE(identifiers)
187,277c141,143
< !-----------------------------------------------------------------------------
< ! In the master task only, we open the file and check that the correct
< ! dimensions exist and are of a size compatible with this run
< !-----------------------------------------------------------------------------
< IF ( is_master_task() ) THEN
<   !-----------------------------------------------------------------------------
<   ! We use the lowest level file API here, as we don't want to impose the input
<   ! grid
<   !-----------------------------------------------------------------------------
<   FILE=file_open(file_name, mode_read)
< 
<   ! We want to auto-detect the dimensions and variables in the file
<   CALL file_introspect(FILE)
< 
<   DO i = 1,nvars
< 
<     !-----------------------------------------------------------------------
<     ! Get information about the dimensions used by the variable.
<     ! The argument l_reading_true shows that we are reading (not writing) a
<     ! dump.
<     !-----------------------------------------------------------------------
<     CALL get_dim_info( l_reading_true, identifiers(i), ndims,  dim_sizes,      &
<                        dim_names, l_read_from_dump )
< 
<     !-------------------------------------------------------------------------
<     ! Check the dimensions exist and have the correct size
<     !-------------------------------------------------------------------------
<     IF ( l_read_from_dump ) THEN
<       DO j = 1,ndims
<         ! Retrive information about the dimension from the file we store the id
<         ! for use outside this loop
<         CALL file_inquire_dim(                                                 &
<           FILE, dim_names(j), dim_ids(j), dim_size_file, is_record_dim         &
<         )
< 
<         ! Check that we found a dimension
<         IF ( dim_ids(j) < 0 )                                                  &
<           CALL log_fatal("read_dump",                                          &
<                          "Could not find expected dimension '" //              &
<                          TRIM(dim_names(j)) // "' in dump file")
< 
<         ! Check that the dimension is not a record dimension (there shouldn't
<         ! be one in dump files).
<         IF ( is_record_dim )                                                   &
<           CALL log_fatal("read_dump",                                          &
<                          "Dimension '" // TRIM(dim_names(j)) // "' is a " //   &
<                          "record dimension - should not exist in dump file")
< 
<         ! Check that the dimension has the correct size
<         IF ( dim_size_file /= dim_sizes(j) )                                   &
<           CALL log_fatal("read_dump",                                          &
<                          "Dimension '" // TRIM(dim_names(j)) // "' has " //    &
<                          "size incompatible with current run (required: " //   &
<                          TRIM(to_string(dim_sizes(j))) // ", found: " //       &
<                          TRIM(to_string(dim_size_file)) // ")")
<       END DO  ! dims
< 
<       !-----------------------------------------------------------------------
<       ! Check that the variable exists and has the correct dimensions
<       !-----------------------------------------------------------------------
<       ! Retrieve information about the variable from the file
<       CALL file_inquire_var(                                                   &
<         FILE, identifiers(i), var_ids(i), ndims_file, dim_ids_file,            &
<         is_record_var                                                          &
<       )
< 
<       ! Check that we found a variable
<       IF ( var_ids(i) < 1 )                                                    &
<         CALL log_fatal("read_dump",                                            &
<                        "Failed to find requested variable '" //                &
<                        TRIM(identifiers(i)) // "' in dump file")
< 
<       ! Check that the number of dimensions match
<       IF ( ndims_file /= ndims )                                               &
<         CALL log_fatal("read_dump",                                            &
<                        "Variable '" // TRIM(identifiers(i)) // "' has " //     &
<                        "incorrect number of dimensions in dump file (" //      &
<                        "expected: " // TRIM(to_string(ndims)) // ", " //       &
<                        "found: " // TRIM(to_string(ndims_file)) // ")")
< 
<       ! Check that the dimension ids match
<       IF ( .NOT. ALL(dim_ids(1:ndims) == dim_ids_file(1:ndims)) )              &
<         CALL log_fatal("read_dump",                                            &
<                        "Variable '" // TRIM(identifiers(i)) // "' has " //     &
<                        "incorrect dimensions in dump file")
< 
<     END IF  !  l_read_from_dump
< 
<   END DO  ! vars
< 
< END IF  ! MASTER TASK
---
> ! Check that the given file is a dump compatible with the current
> ! run, and read the given identifiers from it.
> CALL read_dump_shared(file_name, identifiers, nvars, FILE, var_ids)
296,297c162,163
<                           MAX(nsurft, dim_cslayer, nsoilt),                    &
<                           MAX(nsmax, dim_cs1, sm_levels)))
---
>                           MAX(nsurft, dim_cslayer, nsoilt, npft),              &
>                           MAX(nsmax, dim_cs1, sm_levels, nmasst)))
320c186
<     CASE ( 'gs',  'sthzw', 'zw', 'cv',                           &
---
>     CASE ( 'gs', 't_growth_gb', 'sthzw', 'zw', 'cv',                           &
344,347c210
<     CASE ( 'canht', 'lai', 't_growth_gb','years_since_harvest',               &
<            'l_growth_gb','vpd_growth_gb', 'co2_growth_gb','pstar_growth_gb',  &
<            'xipam_opt','jmax_opt','vcmax_opt', 't_sum','l_sum',               &
<            't_night','nt_sum','vpd_sum','co2_sum','pstar_sum'  )
---
>     CASE ( 'canht', 'lai', 'years_since_harvest' , 'f_nsc' )
349a213,215
>     CASE ( 'plantNumDensity' )
>       CALL file_read_var(FILE, var_ids(i), global_data_3d(:,1:npft,1:nmasst))
> 
406c272
<       CALL file_read_var(FILE, var_ids(i), co2_ppmv)
---
>       CALL file_read_var(FILE, var_ids(i), imgn_vars%co2_ppmv)
409c275
<       CALL file_read_var(FILE, var_ids(i), co2_change_ppmv)
---
>       CALL file_read_var(FILE, var_ids(i), imgn_vars%co2_change_ppmv)
412c278
<       CALL file_read_var(FILE, var_ids(i), dtemp_o)
---
>       CALL file_read_var(FILE, var_ids(i), imgn_vars%dtemp_o)
415c281
<       CALL file_read_var(FILE, var_ids(i), fa_ocean)
---
>       CALL file_read_var(FILE, var_ids(i), imgn_vars%fa_ocean)
428,444c294
<       CALL file_read_var(FILE, var_ids(i), ch4_ppbv)
< 
<       ! River routing variables
<     CASE ( 'rivers_sto_rp' )
<       CALL file_read_var(FILE, var_ids(i), rivers%rivers_sto_rp)
< 
<     CASE ( 'rfm_surfstore_rp' )
<       CALL file_read_var(FILE, var_ids(i), rivers%rfm_surfstore_rp)
< 
<     CASE ( 'rfm_substore_rp' )
<       CALL file_read_var(FILE, var_ids(i), rivers%rfm_substore_rp)
< 
<     CASE ( 'rfm_flowin_rp' )
<       CALL file_read_var(FILE, var_ids(i), rivers%rfm_flowin_rp)
< 
<     CASE ( 'rfm_bflowin_rp' )
<       CALL file_read_var(FILE, var_ids(i), rivers%rfm_bflowin_rp)
---
>       CALL file_read_var(FILE, var_ids(i), imgn_vars%ch4_ppbv)
561c411
<       IF ( ancil_dump_read%vegetation_props ) THEN
---
>       IF ( ancil_dump_read%water_resources_props ) THEN
572,574c422,423
<       CALL log_fatal("read_dump",                                              &
<                      "Unexpected variable in dump - " //                       &
<                      TRIM(identifiers(i)))
---
>       ! Cases for river routing variables plus log fatal for unknown identifier
>       CALL read_dump_var_rivers( identifiers(i), FILE, var_ids(i) )
586a436,438
>   CASE ( 't_growth_gb' )
>     CALL scatter_land_field(global_data_1d, progs%t_growth_gb)
> 
689,731c541
<   CASE ( 'years_since_harvest' )
<     DO n = 1,npft
<       CALL scatter_land_field(global_data_2d(:,n),                             &
<                               years_since_harvest_real(:,n))
<     END DO
<     progs%years_since_harvest(:,:) = NINT(years_since_harvest_real(:,:))
< 
<   CASE ( 't_growth_gb' )
<     DO n = 1,npft
<     CALL scatter_land_field(global_data_2d(:,n), progs%t_growth_gb(:,n))
<     END DO
< 
<   CASE ( 'l_growth_gb' )
<     DO n = 1,npft
<     CALL scatter_land_field(global_data_2d(:,n), progs%l_growth_gb(:,n))
<     END DO
< 
<   CASE ( 'vpd_growth_gb' )
<     DO n = 1,npft
<     CALL scatter_land_field(global_data_2d(:,n), progs%vpd_growth_gb(:,n))
<     END DO
< 
<   CASE ( 'co2_growth_gb' )
<     DO n = 1,npft
<     CALL scatter_land_field(global_data_2d(:,n), progs%co2_growth_gb(:,n))
<     END DO
< 
<   CASE ( 'pstar_growth_gb' )
<     DO n = 1,npft
<     CALL scatter_land_field(global_data_2d(:,n), progs%pstar_growth_gb(:,n))
<     END DO
< 
<   CASE ( 'xipam_opt' )
<     DO n = 1,npft
<     CALL scatter_land_field(global_data_2d(:,n), progs%xipam_opt(:,n))
<     END DO
< 
<   CASE ( 'vcmax_opt' )
<     DO n = 1,npft
<     CALL scatter_land_field(global_data_2d(:,n), progs%vcmax_opt(:,n))
<     END DO
< 
<   CASE ( 'jmax_opt' )
---
>   CASE ( 'f_nsc' )
733c543
<     CALL scatter_land_field(global_data_2d(:,n), progs%jmax_opt(:,n))
---
>       CALL scatter_land_field(global_data_2d(:,n), progs%f_nsc_pft(:,n))
736c546
<   CASE ( 't_sum' )
---
>   CASE ( 'plantNumDensity' )
738,763c548,551
<     CALL scatter_land_field(global_data_2d(:,n), progs%t_sum(:,n))
<     END DO
< 
<   CASE ( 'l_sum' )
<     DO n = 1,npft
<     CALL scatter_land_field(global_data_2d(:,n), progs%l_sum(:,n))
<     END DO
< 
<   CASE ( 't_night' )
<     DO n = 1,npft
<     CALL scatter_land_field(global_data_2d(:,n), progs%t_night(:,n))
<     END DO
< 
<   CASE ( 'nt_sum' )
<     DO n = 1,npft
<     CALL scatter_land_field(global_data_2d(:,n), progs%nt_sum(:,n))
<     END DO
< 
<   CASE ( 'vpd_sum' )
<     DO n = 1,npft
<     CALL scatter_land_field(global_data_2d(:,n), progs%vpd_sum(:,n))
<     END DO
< 
<   CASE ( 'co2_sum' )
<     DO n = 1,npft
<     CALL scatter_land_field(global_data_2d(:,n), progs%co2_sum(:,n))
---
>       DO m = 1,nmasst
>         CALL scatter_land_field(global_data_3d(:,n,m),                         &
>                                 progs%plantNumDensity(:,n,m))
>       END DO
766c554
<   CASE ( 'pstar_sum' )
---
>   CASE ( 'years_since_harvest' )
768c556,557
<     CALL scatter_land_field(global_data_2d(:,n), progs%pstar_sum(:,n))
---
>       CALL scatter_land_field(global_data_2d(:,n),                             &
>                               years_since_harvest_real(:,n))
769a559
>     progs%years_since_harvest(:,:) = NINT(years_since_harvest_real(:,:))
1160,1161c950,951
<     CALL mpi_bcast(co2_ppmv, 1, mpi_real,                                      &
<                    master_task_id, mpi_comm_world, ERROR)
---
>     CALL mpi_bcast(imgn_vars%co2_ppmv, 1, mpi_real,                            &
>                    master_task_id, mpi_local_comm, ERROR)
1164,1165c954,955
<     CALL mpi_bcast(co2_change_ppmv, 1, mpi_real,                               &
<                    master_task_id, mpi_comm_world, ERROR)
---
>     CALL mpi_bcast(imgn_vars%co2_change_ppmv, 1, mpi_real,                     &
>                    master_task_id, mpi_local_comm, ERROR)
1168,1169c958,959
<     CALL mpi_bcast(dtemp_o, n_olevs, mpi_real,                                 &
<                    master_task_id, mpi_comm_world, ERROR)
---
>     CALL mpi_bcast(imgn_vars%dtemp_o, n_olevs, mpi_real,                       &
>                    master_task_id, mpi_local_comm, ERROR)
1172,1173c962,963
<     CALL mpi_bcast(fa_ocean, nfarray, mpi_real,                                &
<                    master_task_id, mpi_comm_world, ERROR)
---
>     CALL mpi_bcast(imgn_vars%fa_ocean, nfarray, mpi_real,                      &
>                    master_task_id, mpi_local_comm, ERROR)
1184c974
<                      master_task_id, mpi_comm_world, ERROR)
---
>                      master_task_id, mpi_local_comm, ERROR)
1192,1193c982,983
<     CALL mpi_bcast(ch4_ppbv, 1, mpi_real,                                      &
<                    master_task_id, mpi_comm_world, ERROR)
---
>     CALL mpi_bcast(imgn_vars%ch4_ppbv, 1, mpi_real,                            &
>                    master_task_id, mpi_local_comm, ERROR)
1197c987
<          'rfm_flowin_rp', 'rfm_bflowin_rp' )
---
>          'rfm_flowin_rp', 'rfm_bflowin_rp', 'rivers_outflow_rp' )
1627c1417
<            master_task_id, mpi_comm_world, ERROR)
---
>            master_task_id, mpi_local_comm, ERROR)
1643c1433
<            master_task_id, mpi_comm_world, ERROR)
---
>            master_task_id, mpi_local_comm, ERROR)
1649c1439
<            master_task_id, mpi_comm_world, ERROR)
---
>            master_task_id, mpi_local_comm, ERROR)
1655c1445
<            master_task_id, mpi_comm_world, ERROR)
---
>            master_task_id, mpi_local_comm, ERROR)
1661c1451
<       CALL scatter_land_field(global_data_1d, conveyance_loss)
---
>       CALL scatter_land_field(global_data_1d, water_resources%conveyance_loss)
1666c1456
<       CALL scatter_land_field(global_data_1d, irrig_eff)
---
>       CALL scatter_land_field(global_data_1d, water_resources%irrig_eff)
1671c1461
<       CALL scatter_land_field(global_data_1d, sfc_water_frac)
---
>       CALL scatter_land_field(global_data_1d, water_resources%sfc_water_frac)
1678c1468
<            master_task_id, mpi_comm_world, ERROR)
---
>            master_task_id, mpi_local_comm, ERROR)
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./io/dump: read_dump_shared_mod.F90
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./io/dump: read_dump_var_rivers_mod.F90
diff -r vn7.0copy1_c4/src/./io/dump/required_vars_for_configuration_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./io/dump/required_vars_for_configuration_mod.F90
1c1
< #if !defined(UM_JULES)
---
> #if !defined(RIVERS_ONLY)
27c27
< USE jules_soil_biogeochem_mod, ONLY: soil_model_ecosse, soil_model_rothc,      &
---
> USE jules_soil_biogeochem_mod, ONLY: soil_model_ecosse, soil_model_4pool,      &
39,40c39
<                                 photo_pmodel_acclim,                           &
<                                 l_croprotate, l_trif_biocrop
---
>                                 l_croprotate, l_trif_biocrop, l_sugar
59c58
< USE jules_rivers_mod, ONLY: l_rivers, i_river_vn, rivers_trip, rivers_rfm
---
> USE jules_rivers_mod, ONLY: l_rivers
68a68,73
> USE veg3_parm_mod, ONLY: l_veg3
> 
> USE add_to_list_mod, ONLY: add_to_list
> 
> USE required_vars_for_rivers_mod, ONLY: required_vars_for_rivers
> 
84c89
< INTEGER, INTENT(OUT) :: nvars  ! The number of variables
---
> INTEGER, INTENT(IN OUT) :: nvars  ! The number of variables
173d177
< nvars = 0
194,195c198
<      photo_acclim_model == photo_adapt_acclim .OR.                             &  
<      photo_acclim_model == photo_pmodel_acclim ) THEN
---
>      photo_acclim_model == photo_adapt_acclim) THEN
197,211d199
<   CALL add_to_list( 'l_growth_gb', nvars, identifiers )
<   CALL add_to_list( 'vpd_growth_gb', nvars, identifiers )
<   CALL add_to_list( 'co2_growth_gb', nvars, identifiers )
<   CALL add_to_list( 'pstar_growth_gb', nvars, identifiers )
<   CALL add_to_list( 'xipam_opt', nvars, identifiers )
<   CALL add_to_list( 'vcmax_opt', nvars, identifiers )
<   CALL add_to_list( 'jmax_opt', nvars, identifiers )
<   !CALL add_to_list( 'Rd25New', nvars, identifiers )
<   CALL add_to_list( 't_sum', nvars, identifiers )
<   CALL add_to_list( 'l_sum', nvars, identifiers )
<   CALL add_to_list( 't_night', nvars, identifiers )
<   CALL add_to_list( 'nt_sum', nvars, identifiers )
<   CALL add_to_list( 'vpd_sum', nvars, identifiers )
<   CALL add_to_list( 'co2_sum', nvars, identifiers )
<   CALL add_to_list( 'pstar_sum', nvars, identifiers )
257c245
< IF ( soil_bgc_model == soil_model_rothc .AND. l_nitrogen ) THEN
---
> IF ( soil_bgc_model == soil_model_4pool .AND. l_nitrogen ) THEN
269a258,261
> IF ( l_veg3 ) THEN
>   CALL add_to_list( 'plantNumDensity', nvars, identifiers )
> END IF
> 
276a269,273
> IF ( l_sugar ) THEN
>   ! With SUGAR on, NSC mass fraction is prognostic for all PFTs
>   CALL add_to_list( 'f_nsc', nvars, identifiers )
> END IF
> 
301,321c298,299
< ! River storage if river routing on and using TRIP
< IF ( l_rivers .AND. ( i_river_vn == rivers_trip ) ) THEN
<   IF ( read_or_write_dump_local ) THEN
<     CALL add_to_list( 'rivers_sto_rp', nvars, identifiers )
<   ELSE
<     CALL log_warn( RoutineName,                                                &
<                   "rivers_sto_rp will be initialised to zero.")
<   END IF
< END IF
< 
< ! Surface and subsurface stores and flows if river routing on and using RFM
< IF ( l_rivers .AND. (i_river_vn == rivers_rfm) ) THEN
<   IF ( read_or_write_dump_local ) THEN
<     CALL add_to_list( 'rfm_surfstore_rp', nvars, identifiers )
<     CALL add_to_list( 'rfm_substore_rp',  nvars, identifiers )
<     CALL add_to_list( 'rfm_flowin_rp',    nvars, identifiers )
<     CALL add_to_list( 'rfm_bflowin_rp',   nvars, identifiers )
<   ELSE
<     CALL log_warn( RoutineName,                                                &
<                   "RFM river prognostics will be initialised to zero.")
<   END IF
---
> IF ( l_rivers ) THEN
>   CALL required_vars_for_rivers(nvars, identifiers, read_or_write_dump)
500c478,479
< ! Note that latitude and longitude are not handled here.
---
> ! Note that latitude and longitude (and projection coordinates) are not
> ! handled here.
558c537
< IF ( soil_bgc_model == soil_model_rothc .OR.                                   &
---
> IF ( soil_bgc_model == soil_model_4pool .OR.                                   &
587c566
<   IF ( soil_bgc_model == soil_model_rothc .OR.                                 &
---
>   IF ( soil_bgc_model == soil_model_4pool .OR.                                 &
766,840d744
< SUBROUTINE add_to_list( identifier, nvars, varlist, l_append )
< 
< ! Adds an identifier to a list, optionally appending a suffix.
< 
< USE logging_mod, ONLY: log_fatal
< 
< IMPLICIT NONE
< 
< !-----------------------------------------------------------------------------
< ! Arguments with intent(in)
< !-----------------------------------------------------------------------------
< CHARACTER(LEN=*), INTENT(IN) ::                                                &
<   identifier
<     ! An identifier for a variable.
< 
< !-----------------------------------------------------------------------------
< ! Arguments with intent(inout)
< !-----------------------------------------------------------------------------
< 
< INTEGER, INTENT(IN OUT) ::                                                     &
<   nvars
<     ! The number of values set in the list.
< 
< CHARACTER(LEN=*), INTENT(IN OUT) ::                                            &
<   varlist(:)
<     ! A list of identifiers.
< 
< !-----------------------------------------------------------------------------
< ! Optional arguments with intent(in)
< !-----------------------------------------------------------------------------
< LOGICAL, INTENT(IN), OPTIONAL ::                                               &
<   l_append
<     ! Flag indicating if a suffix should be attached to the identifier.
< 
< !-----------------------------------------------------------------------------
< ! Local scalar parameters.
< !-----------------------------------------------------------------------------
< CHARACTER(LEN=*), PARAMETER ::                                                 &
<   RoutineName = 'ADD_TO_LIST'
<     ! The name of this routine.
< 
< !-----------------------------------------------------------------------------
< ! Local scalar variables.
< !-----------------------------------------------------------------------------
< LOGICAL ::                                                                     &
<   l_append_soilt_local
<     ! A local version of the optional argument l_append.
< 
< ! end of header
< !-----------------------------------------------------------------------------
< 
< ! Set a local variables depending on the optional argument.
< IF ( PRESENT(l_append) ) THEN
<   l_append_soilt_local = l_append
< ELSE
<   l_append_soilt_local = .FALSE.
< END IF
< 
< !-----------------------------------------------------------------------------
< ! Append to the list.
< !-----------------------------------------------------------------------------
< IF ( nvars + 1 > SIZE( varlist ) ) THEN
<   CALL log_fatal( RoutineName,                                                 &
<                   "Too many values. Increase size of variable." )
<   STOP
< ELSE
<   nvars          = nvars + 1
<   varlist(nvars) = identifier
<   IF ( l_append_soilt_local ) THEN
<     varlist(nvars) = TRIM(varlist(nvars)) // '_soilt'
<   END IF
< END IF
< 
< RETURN
< END SUBROUTINE add_to_list
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./io/dump: required_vars_for_rivers_mod.F90
diff -r vn7.0copy1_c4/src/./io/dump/write_dump_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./io/dump/write_dump_mod.F90
1c1
< #if !defined(UM_JULES)
---
> #if !defined(RIVERS_ONLY)
18c18
<                             fluxes, lake_vars, rivers
---
>                             fluxes, lake_vars, rivers, water_resources
22a23
> USE imgn_vars_mod, ONLY: imgn_vars
25c26,27
<   global_land_pts, grid_area_ij, latitude, longitude
---
>   global_land_pts, grid_area_ij, latitude, longitude, l_coord_latlon,          &
>   projection_x_coord, projection_y_coord
28c30
<   dim_cs1, dim_soil_n_pool, nsurft, nsoilt, dim_cslayer
---
>   dim_cs1, dim_soil_n_pool, nsurft, nsoilt, dim_cslayer, nmasst
36,38d37
< USE imogen_progs, ONLY:                                                        &
<   co2_ppmv, co2_change_ppmv, dtemp_o, fa_ocean, ch4_ppbv
< 
60,62d58
< USE jules_water_resources_mod, ONLY:                                           &
<   conveyance_loss, irrig_eff, sfc_water_frac
< 
64,67d59
< USE io_constants, ONLY:                                                        &
<   max_file_name_len, max_dim_var, mode_write, max_sdf_name_len, format_ascii,  &
<   format_ncdf
< 
74,79d65
< USE dictionary_mod, ONLY:                                                      &
<   dict, dict_create, dict_set, dict_get, dict_has_key, dict_free
< 
< USE string_utils_mod, ONLY:                                                    &
<   to_string
< 
81,88c67
<   file_handle, file_open, file_def_dim, file_def_var,                          &
<   file_enddef, file_write_var, file_close
< 
< USE output_mod, ONLY:                                                          &
<   output_dir, run_id
< 
< USE model_time_mod, ONLY:                                                      &
<   current_time, is_spinup, spinup_cycle
---
>   file_handle, file_write_var, file_close
90,92c69,70
< USE get_dim_info_mod,  ONLY: get_dim_info
< USE dump_mod,          ONLY: max_dim_dump, max_var_dump, dump_format
< USE logging_mod,       ONLY: log_fatal, log_info
---
> USE dump_mod,                            ONLY: max_var_dump
> USE logging_mod,                         ONLY: log_fatal, log_info
93a72,74
> USE create_dump_file_mod,                ONLY: create_dump_file
> USE write_dump_var_rivers_mod,           ONLY: write_dump_var_rivers
> USE add_dump_coords_for_rivers_mod,      ONLY: add_dump_coords_for_rivers
111,116d91
< ! Local parameters.
< LOGICAL, PARAMETER :: l_reading_false = .FALSE.
<   ! A value of .FALSE. that is passed to argument l_reading of subroutine
<   ! get_dim_info to show that it is being called in connection with writing
<   ! (not reading) a dump.
< 
118,122d92
< CHARACTER(LEN=max_file_name_len) :: file_name
<                                     ! The filename to use for the dump file
< CHARACTER(LEN=max_file_name_len) :: dt_string
<                                     ! The datetime string to use in the file
<                                     ! name
135,147d104
< ! Variables used when defining dimensions
< TYPE(dict) :: file_dim_ids  ! Dictionary of the dimensions that have been
<                             ! defined
<                             ! Maps dim_name => dim_id
< 
< INTEGER :: ndims  ! The number of levels dims for the current variable
< CHARACTER(LEN=max_sdf_name_len) :: dim_names(max_dim_var)
<                   ! The levels dimension names for the current variable
< INTEGER :: dim_sizes(max_dim_var)
<                   ! The sizes of the levels dims for the current variable
< INTEGER :: dim_ids(max_dim_var)
<                   ! The ids in file of the levels dims for the current
<                   ! variable
151c108
< INTEGER :: i, j, m, n, s  ! Loop counters
---
> INTEGER :: i, m, n, s  ! Loop counters
172a130
> nvars = 0
177,180c135,140
< ! Add latitude and longitude to the list to help offline inspection of the
< ! dump file, ie they are diagnostics, not prognostics or ancillaries.
< ! Lat & lon will not be read in from the dump to prevent confusion with the
< ! model grid namelists
---
> ! Add latitude and longitude, and possibly projection coordinates, to the list
> ! to help offline inspection of the dump file, ie they are diagnostics, not
> ! prognostics or ancillaries. Projection coordinates are only included if
> ! they are not latitude and longitude - primarily to preserve existing results.
> ! Lat & lon (and projection coords) will not be read in from the dump to
> ! prevent confusion with the model grid namelists.
186,188c146
< 
< ! Similarly, add latitude and longitude of river points, if needed.
< IF ( l_rivers ) THEN
---
> IF ( .NOT. l_coord_latlon ) THEN
190c148
<   identifiers(nvars) = 'rivers_lat_rp'
---
>   identifiers(nvars) = 'projection_x_coord'
192c150
<   identifiers(nvars) = 'rivers_lon_rp'
---
>   identifiers(nvars) = 'projection_y_coord'
195,286c153,156
< !-----------------------------------------------------------------------------
< ! In the master task only, we open a new file and define the required
< ! dimensions and variables
< !-----------------------------------------------------------------------------
< IF ( is_master_task() ) THEN
<   !---------------------------------------------------------------------------
<   ! Generate the file name that we want to use and open the file
<   !---------------------------------------------------------------------------
<   ! File name starts with run id + indicator of a dump file
<   file_name = TRIM(run_id) // ".dump."
< 
<   ! Include the current spinup cycle if there is one
<   IF ( is_spinup )                                                             &
<     file_name = TRIM(file_name) //                                             &
<                 "spin" // TRIM(to_string(spinup_cycle)) // "."
< 
<   ! Then current date and time
<   WRITE(dt_string, '(I4.4,I2.2,I2.2)') current_time%year,                      &
<                                        current_time%month,                     &
<                                        current_time%day
<   dt_string = TRIM(dt_string) // "." // TRIM(to_string(current_time%TIME))
<   file_name = TRIM(file_name) // TRIM(dt_string)
< 
<   ! Add the extension based on dump format
<   SELECT CASE ( dump_format )
<   CASE ( format_ascii )
<     file_name = TRIM(file_name) // ".asc"
< 
<   CASE ( format_ncdf )
<     file_name = TRIM(file_name) // ".nc"
< 
<   CASE DEFAULT
<     CALL log_fatal("write_dump",                                               &
<                    "Unrecognised file format - " // TRIM(dump_format))
<   END SELECT
< 
<   ! Prepend the output directory
<   file_name = TRIM(output_dir) // "/" // TRIM(file_name)
< 
<   ! We use the lowest level file API here, as we don't want to impose a grid
<   FILE=file_open(file_name, mode_write)
< 
<   !---------------------------------------------------------------------------
<   ! Create the dimensions and variables
<   !---------------------------------------------------------------------------
<   file_dim_ids = dict_create(max_dim_dump, INT(1))
< 
<   DO i = 1,nvars
< 
<     !------------------------------------------------------------------------
<     ! Get information about the dimensions used by the variable.
<     ! The argument l_reading_false shows that we are writing (not reading) a
<     ! dump.
<     !------------------------------------------------------------------------
<     CALL get_dim_info( l_reading_false, identifiers(i), ndims,  dim_sizes,     &
<                        dim_names )
< 
<     !-------------------------------------------------------------------------
<     ! Define the dimensions if they have not already been defined
<     ! We use a dictionary to keep track of defined dimension ids
<     !
<     ! At the same time, gather up the dimension ids needed by the current
<     ! variable.
<     !-------------------------------------------------------------------------
<     DO j = 1,ndims
<       ! If it has not yet been defined, define the dimension, storing its id
<       IF ( .NOT. dict_has_key(file_dim_ids, dim_names(j)) )                    &
<         CALL dict_set(                                                         &
<           file_dim_ids, dim_names(j),                                          &
<           file_def_dim(FILE, dim_names(j), dim_sizes(j))                       &
<         )
< 
<       ! Get the dimension id from the dict and add it to the list for this
<       ! variable.
<       CALL dict_get(file_dim_ids, dim_names(j), dim_ids(j))
<     END DO
< 
<     !-------------------------------------------------------------------------
<     ! Define the variable, saving the id in the file for later
<     !-------------------------------------------------------------------------
<     var_ids(i) = file_def_var(FILE, identifiers(i), dim_ids(1:ndims),          &
<                               .FALSE.)
< 
<   END DO
< 
<   !---------------------------------------------------------------------------
<   ! We have finished defining things
<   !---------------------------------------------------------------------------
<   CALL file_enddef(FILE)
<   CALL dict_free(file_dim_ids)
< 
< END IF  ! MASTER TASK
---
> ! Similarly, add latitude and longitude of river points, if needed.
> IF ( l_rivers ) THEN
>   CALL add_dump_coords_for_rivers(nvars, identifiers)
> END IF
287a158
> CALL create_dump_file(nvars, identifiers, FILE, var_ids)
299,300c170,172
<                           MAX(nsurft, dim_cslayer, nsoilt),                    &
<                           MAX(nsmax, dim_cs1, dim_soil_n_pool, sm_levels)))
---
>                           MAX(nsurft, dim_cslayer, nsoilt, npft),              &
>                           MAX(nsmax, dim_cs1, dim_soil_n_pool, sm_levels,      &
>                               nmasst)))
322,394c194
<     DO n = 1,npft
<       CALL gather_land_field(progs%t_growth_gb(:,n), global_data_2d(:,n))
<     END DO
< 
<   CASE ( 'l_growth_gb' )
<     DO n = 1,npft
<     CALL gather_land_field(progs%l_growth_gb(:,n), global_data_2d(:,n))
<     END DO
< 
<   CASE ( 'vpd_growth_gb' )
<     DO n = 1,npft
<       CALL gather_land_field(progs%vpd_growth_gb(:,n), global_data_2d(:,n))
<     END DO
< 
<   CASE ( 'co2_growth_gb' )
<     DO n = 1,npft
<       CALL gather_land_field(progs%co2_growth_gb(:,n), global_data_2d(:,n))
<     END DO
< 
<   CASE ( 'pstar_growth_gb' )
<     DO n = 1,npft
<     CALL gather_land_field(progs%pstar_growth_gb(:,n), global_data_2d(:,n))
<     END DO
< 
<   CASE ( 'xipam_opt' )
<     DO n = 1,npft
<     CALL gather_land_field(progs%xipam_opt(:,n), global_data_2d(:,n))
<     END DO
< 
<   CASE ( 'vcmax_opt' )
<     DO n = 1,npft
<     CALL gather_land_field(progs%vcmax_opt(:,n), global_data_2d(:,n))
<     END DO
< 
<   CASE ( 'jmax_opt' )
<     DO n = 1,npft
<     CALL gather_land_field(progs%jmax_opt(:,n), global_data_2d(:,n))
<     END DO
< 
<   CASE ( 't_sum' )
<     DO n = 1,npft
<     CALL gather_land_field(progs%t_sum(:,n), global_data_2d(:,n))
<     END DO
< 
<   CASE ( 'l_sum' )
<     DO n = 1,npft
<     CALL gather_land_field(progs%l_sum(:,n), global_data_2d(:,n))
<     END DO
< 
<   CASE ( 't_night' )
<     DO n = 1,npft
<     CALL gather_land_field(progs%t_night(:,n), global_data_2d(:,n))
<     END DO
< 
<   CASE ( 'nt_sum' )
<     DO n = 1,npft
<     CALL gather_land_field(progs%nt_sum(:,n), global_data_2d(:,n))
<     END DO
< 
<   CASE ( 'vpd_sum' )
<     DO n = 1,npft
<     CALL gather_land_field(progs%vpd_sum(:,n), global_data_2d(:,n))
<     END DO
< 
<     CASE ( 'co2_sum' )
<     DO n = 1,npft
<     CALL gather_land_field(progs%co2_sum(:,n), global_data_2d(:,n))
<     END DO
< 
<   CASE ( 'pstar_sum' )
<     DO n = 1,npft
<     CALL gather_land_field(progs%pstar_sum(:,n), global_data_2d(:,n))
<     END DO
---
>     CALL gather_land_field(progs%t_growth_gb, global_data_1d)
461a262,267
>   CASE ( 'projection_x_coord' )
>     CALL gather_land_field(projection_y_coord, global_data_1d)
> 
>   CASE ( 'projection_y_coord' )
>     CALL gather_land_field(projection_x_coord, global_data_1d)
> 
522a329,333
>   CASE ( 'f_nsc' )
>     DO n = 1,npft
>       CALL gather_land_field(progs%f_nsc_pft(:,n), global_data_2d(:,n))
>     END DO
> 
540a352,359
>   CASE ( 'plantNumDensity' )
>     DO n = 1,npft
>       DO m = 1,nmasst
>         CALL gather_land_field(progs%plantNumDensity(:,n,m),                   &
>                                global_data_3d(:,n,m))
>       END DO
>     END DO
> 
857a677
>          'rivers_x_coord_rp', 'rivers_y_coord_rp',                             &
859,860c679,680
<          'rfm_flowin_rp', 'rfm_bflowin_rp' )
<     ! Nothing to do
---
>          'rfm_flowin_rp', 'rfm_bflowin_rp', 'rivers_outflow_rp' )
>     ! Rivers are run on a single task, hence nothing to do here.
1110c930
<     CALL gather_land_field(conveyance_loss, global_data_1d)
---
>     CALL gather_land_field(water_resources%conveyance_loss, global_data_1d)
1113c933
<     CALL gather_land_field(irrig_eff, global_data_1d)
---
>     CALL gather_land_field(water_resources%irrig_eff, global_data_1d)
1116c936
<     CALL gather_land_field(sfc_water_frac, global_data_1d)
---
>     CALL gather_land_field(water_resources%sfc_water_frac, global_data_1d)
1140c960
<     CASE ( 'gs', 'sthzw', 'zw', 'cv',                           &
---
>     CASE ( 'gs', 't_growth_gb', 'sthzw', 'zw', 'cv',                           &
1156c976,977
<            'lake_h_ice_gb', 'lake_shape_factor_gb', 'latitude', 'longitude')
---
>            'lake_h_ice_gb', 'lake_shape_factor_gb', 'latitude', 'longitude',   &
>            'projection_x_coord', 'projection_y_coord' )
1164,1167c985
<     CASE ( 'canht', 'lai', 't_growth_gb','years_since_harvest', 'harvest_doy', &
<            'l_growth_gb','vpd_growth_gb', 'co2_growth_gb',                     &
<            'pstar_growth_gb', 'xipam_opt','jmax_opt','vcmax_opt',              &
<            't_sum','l_sum','t_night','nt_sum','vpd_sum','co2_sum','pstar_sum')
---
>     CASE ( 'canht', 'lai', 'years_since_harvest', 'harvest_doy', 'f_nsc')
1221a1040,1043
>     CASE ( 'plantNumDensity' )
>       CALL file_write_var(FILE, var_ids(i),                                    &
>                           global_data_3d(:,1:npft,1:nmasst))
> 
1226c1048
<       CALL file_write_var(FILE, var_ids(i), co2_ppmv)
---
>       CALL file_write_var(FILE, var_ids(i), imgn_vars%co2_ppmv)
1229c1051
<       CALL file_write_var(FILE, var_ids(i), co2_change_ppmv)
---
>       CALL file_write_var(FILE, var_ids(i), imgn_vars%co2_change_ppmv)
1232c1054
<       CALL file_write_var(FILE, var_ids(i), dtemp_o)
---
>       CALL file_write_var(FILE, var_ids(i), imgn_vars%dtemp_o)
1235c1057
<       CALL file_write_var(FILE, var_ids(i), fa_ocean)
---
>       CALL file_write_var(FILE, var_ids(i), imgn_vars%fa_ocean)
1241,1263c1063
<       CALL file_write_var(FILE, var_ids(i), ch4_ppbv)
< 
<       ! Cases for river routing variables
<     CASE ( 'rivers_lat_rp' )
<       CALL file_write_var(FILE, var_ids(i), rivers%rivers_lat_rp)
< 
<     CASE ( 'rivers_lon_rp' )
<       CALL file_write_var(FILE, var_ids(i), rivers%rivers_lon_rp)
< 
<     CASE ( 'rivers_sto_rp' )
<       CALL file_write_var(FILE, var_ids(i), rivers%rivers_sto_rp)
< 
<     CASE ( 'rfm_surfstore_rp' )
<       CALL file_write_var(FILE, var_ids(i), rivers%rfm_surfstore_rp)
< 
<     CASE ( 'rfm_substore_rp' )
<       CALL file_write_var(FILE, var_ids(i), rivers%rfm_substore_rp)
< 
<     CASE ( 'rfm_flowin_rp' )
<       CALL file_write_var(FILE, var_ids(i), rivers%rfm_flowin_rp)
< 
<     CASE ( 'rfm_bflowin_rp' )
<       CALL file_write_var(FILE, var_ids(i), rivers%rfm_bflowin_rp)
---
>       CALL file_write_var(FILE, var_ids(i), imgn_vars%ch4_ppbv)
1360a1161
> 
1362,1364c1163,1165
<       CALL log_fatal("write_dump",                                             &
<                      "Unrecognised variable for dump - " //                    &
<                      TRIM(identifiers(i)))
---
>       ! Cases for river routing variables plus log fatal for unknown identifier
>       CALL write_dump_var_rivers( identifiers(i), FILE, var_ids(i) )
> 
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./io/dump: write_dump_var_rivers_mod.F90
diff -r vn7.0copy1_c4/src/./io/file_handling/core/drivers/ascii/file_ascii_generic_sync_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./io/file_handling/core/drivers/ascii/file_ascii_generic_sync_mod.F90
140c140
< USE precision_mod, ONLY: INT32
---
> USE precision_mod, ONLY: int_32
154,156c154,156
< INTEGER(KIND=INT32) :: tmp_unitno=-1
< INTEGER(KIND=INT32) :: unit_32 = -1
< INTEGER(KIND=INT32) :: tmp_error = 1
---
> INTEGER(KIND=int_32) :: tmp_unitno=-1
> INTEGER(KIND=int_32) :: unit_32 = -1
> INTEGER(KIND=int_32) :: tmp_error = 1
168c168
< unit_32 = INT(unitno, KIND=INT32)
---
> unit_32 = INT(unitno, KIND=int_32)
diff -r vn7.0copy1_c4/src/./io/file_handling/timeseries/file_ts_internal_open_file.inc vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./io/file_handling/timeseries/file_ts_internal_open_file.inc
13c13
< USE datetime_mod, ONLY: l_360, l_leap, datetime_to_string
---
> USE datetime_mod, ONLY: l_360, l_leap, datetime_to_string, l_local_solar_time
241a242,250
> 
>   ! Add the attribute of local solar time
>   IF ( l_local_solar_time ) THEN
>     CALL file_def_attr(                                                        &
>       FILE%open_file%fh, FILE%time_index_var_id, "Time Convention",            &
>         "Local Solar Time"                                                     &
>     )
>   END IF
> 
diff -r vn7.0copy1_c4/src/./io/file_handling/timeseries/file_ts_seek_to_datetime.inc vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./io/file_handling/timeseries/file_ts_seek_to_datetime.inc
13c13
< USE precision_mod, ONLY: INT64
---
> USE precision_mod, ONLY: int_64
60c60
< INTEGER(KIND=INT64) :: secs_from_start      ! the requested timestep?
---
> INTEGER(KIND=int_64) :: secs_from_start      ! the requested timestep?
217c217
<   IF ( MOD(secs_from_start, INT(FILE%data_period, INT64)) /= 0 )               &
---
>   IF ( MOD(secs_from_start, INT(FILE%data_period, int_64)) /= 0 )              &
diff -r vn7.0copy1_c4/src/./io/file_handling/timeseries/file_ts_write_var.inc vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./io/file_handling/timeseries/file_ts_write_var.inc
11c11
< USE precision_mod, ONLY: INT64
---
> USE precision_mod, ONLY: int_64
58c58
< INTEGER(KIND=INT64) :: interval_start, interval_end
---
> INTEGER(KIND=int_64) :: interval_start, interval_end
diff -r vn7.0copy1_c4/src/./io/input/time_varying/advance_all.inc vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./io/input/time_varying/advance_all.inc
11c11
< USE precision_mod, ONLY: INT64
---
> USE precision_mod, ONLY: int_64
45c45
< INTEGER(KIND=INT64) :: diff_secs
---
> INTEGER(KIND=int_64) :: diff_secs
123c123
<   IF ( MOD(diff_secs, INT(timestep_len, INT64)) /= 0 )                         &
---
>   IF ( MOD(diff_secs, INT(timestep_len, int_64)) /= 0 )                        &
169c169
<         INT(files(i)%fh%data_period, INT64)                                    &
---
>         INT(files(i)%fh%data_period, int_64)                                   &
215c215
<     IF ( MOD(diff_secs, INT(timestep_len, INT64)) /= 0 )                       &
---
>     IF ( MOD(diff_secs, INT(timestep_len, int_64)) /= 0 )                      &
Only in vn7.0copy1_c4/src/./io/input/time_varying/interpolation: get_required_time_bounds.inc
Only in vn7.0copy1_c4/src/./io/input/time_varying/interpolation: interpolate.inc
diff -r vn7.0copy1_c4/src/./io/input/time_varying/interpolation/interpolation_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./io/input/time_varying/interpolation/interpolation_mod.F90
59,60c59,428
< #include "get_required_time_bounds.inc"
< #include "interpolate.inc"
---
> 
> SUBROUTINE get_required_time_bounds(interp_flags, lower_bound, upper_bound)
> 
> IMPLICIT NONE
> 
> !-----------------------------------------------------------------------------
> ! Description:
> !   Given a list of interpolation flags, returns the common lower bound and
> !   upper bound required to use all the given interpolation schemes in the
> !   same file
> !
> ! Code Owner: Please refer to ModuleLeaders.txt
> ! This file belongs in TECHNICAL
> !
> ! Code Description:
> !   Language: Fortran 90.
> !   This code is written to JULES coding standards v1.
> !-----------------------------------------------------------------------------
> ! Argument types
> CHARACTER(LEN=*), INTENT(IN) :: interp_flags(:)
> 
> ! Return types
> INTEGER, INTENT(OUT) :: lower_bound, upper_bound
> 
> 
> ! Work variables
> LOGICAL :: required_times(-1:2)  ! Array indicating the required times
> INTEGER :: i  ! Loop variable
> 
> !-----------------------------------------------------------------------------
> 
> required_times(:) = .FALSE.
> 
> DO i = 1,SIZE(interp_flags)
> 
>   ! If all the times are already required, we can exit early
>   IF ( ALL(required_times) ) EXIT
> 
>   ! Otherwise, set the required times based on the interpolation flag
>   SELECT CASE ( interp_flags(i) )
>   CASE ( interp_ave_backward )
>     required_times(0:2) = .TRUE.
> 
>   CASE ( interp_ave_centred )
>     required_times(-1:2) = .TRUE.
> 
>   CASE ( interp_ave_forward )
>     required_times(-1:1) = .TRUE.
> 
>   CASE ( interp_instant )
>     required_times(0:1) = .TRUE.
> 
>   CASE ( no_interp_end )
>     required_times(1) = .TRUE.
> 
>   CASE ( no_interp_centred )
>     required_times(0:1) = .TRUE.
> 
>   CASE ( no_interp_start )
>     required_times(0) = .TRUE.
> 
>   CASE DEFAULT
>     CALL log_fatal("get_required_times",                                       &
>                    "Unrecognised interpolation flag - " // interp_flags(i))
>   END SELECT
> 
> END DO
> 
> ! The required lower bound is the first element for which required_times=T
> DO i = -1,2
>   IF ( required_times(i) ) THEN
>     lower_bound = i
>     EXIT
>   END IF
> END DO
> 
> ! The required upper bound is the last element for which required_times=T
> ! So step backwards through the required_times array to detect it
> DO i = 2,-1,-1
>   IF ( required_times(i) ) THEN
>     upper_bound = i
>     EXIT
>   END IF
> END DO
> 
> RETURN
> 
> END SUBROUTINE get_required_time_bounds
> 
> FUNCTION interpolate(DATA, interp_flag, tsteps_in_period, tstep)               &
>                                                      RESULT(interpolated_data)
> 
> USE data_cube_mod, ONLY: data_cube,                                            &
>                           OPERATOR ( * ), OPERATOR ( + ), OPERATOR ( / ),      &
>                           cube_safe_copy, cube_free
> 
> IMPLICIT NONE
> 
> !-----------------------------------------------------------------------------
> ! Description:
> !   Returns data interpolated to the current time as a data cube
> !
> ! Code Owner: Please refer to ModuleLeaders.txt
> ! This file belongs in TECHNICAL
> !
> ! Code Description:
> !   Language: Fortran 90.
> !   This code is written to JULES coding standards v1.
> !-----------------------------------------------------------------------------
> ! Argument types
> #if defined(SUN_FORTRAN)
> TYPE(data_cube), POINTER :: DATA(:)
> #else
> TYPE(data_cube), POINTER, INTENT(IN) :: DATA(:)
> #endif
>                     ! The data to interpolate, a data_cube for each time
>                     ! Marked as a pointer to preserve array indexing
>                     ! The SUN compiler, for whatever reason, doesn't like
>                     ! the INTENT and POINTER attributes together, so we
>                     ! remove the INTENT for it
> CHARACTER(LEN=*), INTENT(IN) :: interp_flag
>                     ! The interpolation scheme to use
> INTEGER, INTENT(IN) :: tsteps_in_period(-1:1)
>                     ! The number of timesteps in the interpolated data
>                     ! for each data timestep
>                     ! I.e. tsteps_in_period(-1) is the number of interpolated
>                     !      (i.e. model) timesteps between data(-1) and data(0)
>                     !      tsteps_in_period(0) is the number of interpolated
>                     !      timesteps between data(0) and data(1)
>                     ! etc...
> INTEGER, INTENT(IN) :: tstep
>                     ! The interpolated (i.e. model) timestep that we want data for
>                     ! This is a number from 0 to (tsteps_in_period(0) - 1)
> 
> 
> ! Return type
> TYPE(data_cube) :: interpolated_data
>                     ! The interpolated data for the current time
> 
> ! Work variables
> REAL :: weights(-1:2)  ! The weights for each time
> 
> ! Used in CASE ( INTERP_AVE_BACKWARD ) and CASE ( INTERP_AVE_FORWARD )
> REAL :: n1, n2  ! The number of timesteps in the first and second intervals
> 
> ! Used in CASE ( INTERP_AVE_CENTRED )
> REAL :: n  ! The number of timesteps in the interval
> 
> ! Used in all INTERP_AVE_* cases
> TYPE(data_cube) :: weighted_data
> TYPE(data_cube) :: numer
> TYPE(data_cube) :: denom
> 
> ! Temporary cubes used for preventing memory leaks
> TYPE(data_cube) :: temp1, temp2, temp3, temp4
> 
> REAL :: t  ! Real version of tstep
> 
> 
> !-----------------------------------------------------------------------------
> 
> ! Reject values that we can't interpolate for - it only makes sense to give
> ! values for times between current and next data
> IF ( tstep < 0 .OR. tsteps_in_period(0) <= tstep )                             &
>   CALL log_fatal("interpolate",                                                &
>                  "tstep to interpolate to is invalid for given data " //       &
>                  "periods")
> 
> 
> SELECT CASE ( interp_flag )
> CASE ( interp_ave_backward )
>   !-----------------------------------------------------------------------------
>   ! Inputs are backward time averages, i.e. time average ending at given time
>   !
>   ! This is a slightly modified version of the scheme in JULES v3.0. It has
>   ! been modified to attempt to provide sensible values for varying length
>   ! data timesteps (e.g. monthly data) - the previous scheme was limited to
>   ! fixed size data timesteps. This extension should be considered experimental.
>   !
>   ! In the case of fixed length timesteps, the new scheme reduces to exactly
>   ! the scheme in JULES v3.0, and so can be safely used in this case.
>   !-----------------------------------------------------------------------------
>   n1 = REAL(tsteps_in_period(0))
>   n2 = REAL(tsteps_in_period(1))
>   t  = REAL(tstep)
> 
>   weights(1) = 1.0 - ( ABS(t + (n2 / n1) * t - n1 + 1.0) / (n1 + n2) )
>   weights(0) = MAX(1.0 - ( (t + (n2 / n1) * t + n1 + 1.0) / (n1 + n2) ), 0.0)
>   weights(2) = MAX(1.0 - ((n1+2.0 * n2 - t - (n2 / n1) * t - 1.0) / (n1 + n2)), 0.0)
> 
>   temp1 = DATA(0) * weights(0)
>   temp2 = DATA(1) * weights(1)
>   temp3 = temp1 + temp2
>   temp4 = DATA(2) * weights(2)
>   weighted_data = temp3 + temp4
>   CALL cube_free(temp1)
>   CALL cube_free(temp2)
>   CALL cube_free(temp3)
>   CALL cube_free(temp4)
> 
>   temp1 = DATA(0) + DATA(2)
>   temp2 = temp1 * 0.5
>   temp3 = DATA(1) * 3.0
>   denom = temp2 + temp3
>   CALL cube_free(temp1)
>   CALL cube_free(temp2)
>   CALL cube_free(temp3)
> 
>   numer = DATA(1) * 4.0
> 
>   temp1 = weighted_data * numer
>   interpolated_data = temp1 / denom
>   CALL cube_free(temp1)
>   CALL cube_free(weighted_data)
>   CALL cube_free(numer)
>   CALL cube_free(denom)
> 
> 
> CASE ( interp_ave_centred )
>   !-----------------------------------------------------------------------------
>   ! Inputs are centred time averages, i.e. time average centred on given time
>   !-----------------------------------------------------------------------------
>   n = REAL(tsteps_in_period(0))
>   t = REAL(tstep)
> 
>   weights(0)  = 1.0 - ( (2.0 * t + 1.0) / (2.0 * n) )
>   weights(1)  = 1.0 - weights(0)
> 
>   temp1 = DATA(0) * weights(0)
>   temp2 = DATA(1) * weights(1)
>   weighted_data = temp1 + temp2
>   CALL cube_free(temp1)
>   CALL cube_free(temp2)
> 
>   IF ( t > n/2 ) THEN
>     temp1 = DATA(0) + DATA(2)
>     temp2 = temp1 * 0.5
>     temp3 = DATA(1) * 3.0
>     denom = temp2 + temp3
>     CALL cube_free(temp1)
>     CALL cube_free(temp2)
>     CALL cube_free(temp3)
> 
>     numer = DATA(1) * 4.0
>   ELSE
>     temp1 = DATA(-1) + DATA(1)
>     temp2 = temp1 * 0.5
>     temp3 = DATA(0) * 3.0
>     denom = temp2 + temp3
>     CALL cube_free(temp1)
>     CALL cube_free(temp2)
>     CALL cube_free(temp3)
> 
>     numer = DATA(0) * 4.0
>   END IF
> 
>   temp1 = weighted_data * numer
>   interpolated_data = temp1 / denom
>   CALL cube_free(temp1)
>   CALL cube_free(weighted_data)
>   CALL cube_free(numer)
>   CALL cube_free(denom)
> 
> 
> CASE ( interp_ave_forward )
>   !-----------------------------------------------------------------------------
>   ! Inputs are forward time averages, i.e. time average starting at given time
>   !
>   ! This is a slightly modified version of the scheme in JULES v3.0. It has
>   ! been modified to attempt to provide sensible values for varying length
>   ! data timesteps (e.g. monthly data) - the previous scheme was limited to
>   ! fixed size data timesteps. This extension should be considered experimental.
>   !
>   ! In the case of fixed length timesteps, the new scheme reduces to exactly
>   ! the scheme in JULES v3.0, and so can be safely used in this case.
>   !-----------------------------------------------------------------------------
>   n1 = REAL(tsteps_in_period(-1))
>   n2 = REAL(tsteps_in_period(0))
>   t  = REAL(tstep)
> 
>   weights(0)  = 1.0 - ( ABS(t + (n1 / n2) * t - n1+1) / (n1 + n2) )
>   weights(-1) = MAX(1.0 - ( (t + (n1 / n2) * t + n1+1) / (n1 + n2) ), 0.0)
>   weights(1)  = MAX(1.0 - ((n1+2 * n2 - t - (n1 / n2) * t-1) / (n1 + n2)), 0.0)
> 
>   temp1 = DATA(-1) * weights(-1)
>   temp2 = DATA(0) * weights(0)
>   temp3 = temp1 + temp2
>   temp4 = DATA(1) * weights(1)
>   weighted_data = temp3 + temp4
>   CALL cube_free(temp1)
>   CALL cube_free(temp2)
>   CALL cube_free(temp3)
>   CALL cube_free(temp4)
> 
> 
>   temp1 = DATA(-1) + DATA(1)
>   temp2 = temp1 * 0.5
>   temp3 = DATA(0) * 3.0
>   denom = temp2 + temp3
>   CALL cube_free(temp1)
>   CALL cube_free(temp2)
>   CALL cube_free(temp3)
> 
>   numer = DATA(0) * 4.0
> 
>   temp1 = weighted_data * numer
>   interpolated_data = temp1 / denom
>   CALL cube_free(temp1)
>   CALL cube_free(weighted_data)
>   CALL cube_free(numer)
>   CALL cube_free(denom)
> 
> 
> CASE ( interp_instant )
>   !-----------------------------------------------------------------------------
>   ! Inputs are instantaneous values at given times - interpolation is linear
>   ! between times
>   !-----------------------------------------------------------------------------
>   ! Calculate the weights based on how far through the time period we are
>   ! We use tstep + 1 because tstep is 0-indexed, and we want to end up with
>   ! weights = [0, 1] when tstep = tsteps_in_period - 1
>   weights(0) = REAL(tsteps_in_period(0) - (tstep+1)) / REAL(tsteps_in_period(0))
>   weights(1) = 1.0 - weights(0)
> 
>   ! Calculate the data to return
>   temp1 = DATA(0) * weights(0)
>   temp2 = DATA(1) * weights(1)
>   interpolated_data = temp1 + temp2
>   CALL cube_free(temp1)
>   CALL cube_free(temp2)
> 
> 
> CASE ( no_interp_end )
>   !-----------------------------------------------------------------------------
>   ! No interpolation, (current) value is valid over time interval ending at
>   ! given time
>   !-----------------------------------------------------------------------------
>   CALL cube_safe_copy(interpolated_data, DATA(1))
> 
> 
> CASE ( no_interp_centred )
>   !-----------------------------------------------------------------------------
>   ! No interpolation, (current) value is valid over time interval centred on
>   ! given time
>   !-----------------------------------------------------------------------------
>   IF ( tstep < (tsteps_in_period(0) / 2) ) THEN
>     ! If we are closer to current data than next data, use the current data
>     CALL cube_safe_copy(interpolated_data, DATA(0))
>   ELSE
>     ! Otherwise use the next data
>     CALL cube_safe_copy(interpolated_data, DATA(1))
>   END IF
> 
> 
> CASE ( no_interp_start )
>   !-----------------------------------------------------------------------------
>   ! No interpolation, (current) value is valid over time interval starting at
>   ! given time
>   !-----------------------------------------------------------------------------
>   CALL cube_safe_copy(interpolated_data, DATA(0))
> 
> 
> CASE DEFAULT
>   CALL log_fatal("interpolate",                                                &
>                  "Unrecognised interpolation flag - " // interp_flag)
> END SELECT
> 
> RETURN
> 
> END FUNCTION interpolate
diff -r vn7.0copy1_c4/src/./io/input/time_varying/seek_all_to_current_datetime.inc vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./io/input/time_varying/seek_all_to_current_datetime.inc
11c11
< USE precision_mod, ONLY: INT64
---
> USE precision_mod, ONLY: int_64
43c43
< INTEGER(KIND=INT64) :: diff_secs
---
> INTEGER(KIND=int_64) :: diff_secs
88c88
<     time_into_period = MOD(diff_secs, INT(files(i)%fh%data_period, INT64))
---
>     time_into_period = MOD(diff_secs, INT(files(i)%fh%data_period, int_64))
171c171
<     IF ( MOD(diff_secs, INT(timestep_len, INT64)) /= 0 )                       &
---
>     IF ( MOD(diff_secs, INT(timestep_len, int_64)) /= 0 )                      &
181c181
<   IF ( MOD(diff_secs, INT(timestep_len, INT64)) /= 0 )                         &
---
>   IF ( MOD(diff_secs, INT(timestep_len, int_64)) /= 0 )                        &
diff -r vn7.0copy1_c4/src/./io/model_interface/check_variable_metadata.inc vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./io/model_interface/check_variable_metadata.inc
31c31
< DO i = 1, n_vars
---
> DO i = 1, n_vars - 1
diff -r vn7.0copy1_c4/src/./io/model_interface/extract_var.inc vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./io/model_interface/extract_var.inc
13c13
<                             lake_vars, chemvars, rivers
---
>                             lake_vars, chemvars, rivers, water_resources
17d16
< USE jules_fields_mod, ONLY: toppdm
18a18
> USE imgn_vars_mod, ONLY: imgn_vars
30,32d29
< USE csigma, ONLY:                                                              &
<   sbcon
< 
43,46c40,42
<   conveyance_loss, demand_accum, irrig_eff, l_water_domestic,                  &
<   l_water_environment, l_water_industry, l_water_irrigation,                   &
<   l_water_livestock, l_water_transfers, sfc_water_frac, use_domestic,          &
<   use_environment, use_industry, use_irrigation, use_livestock, use_transfers
---
>   l_water_domestic, l_water_environment, l_water_industry, l_water_irrigation, &
>   l_water_livestock, l_water_transfers, use_domestic, use_environment,         &
>   use_industry, use_irrigation, use_livestock, use_transfers
58c54
<   grid_area_ij, latitude, longitude
---
>   grid_area_ij, latitude, longitude, projection_x_coord, projection_y_coord
61c57
<   dim_cs1, dim_cslayer, land_pts, nsurft, soil_pts, surft_pts, nsoilt
---
>   dim_cs1, dim_cslayer, land_pts, nsurft, soil_pts, nsoilt
72,74d67
< USE jules_deposition_mod, ONLY:                                                &
<   tracer_field
< 
76c69
<   soil_model_rothc
---
>   soil_model_4pool
100,103c93,94
< USE imogen_progs, ONLY:                                                        &
<   d_land_atmos_co2, d_ocean_atmos, c_emiss_out
< 
< USE jules_rivers_mod, ONLY: nstep_rivers, np_rivers
---
> USE jules_rivers_mod, ONLY: nstep_rivers, np_rivers, n_rivers,                 &
>    calc_outflow_per_river
115a107,108
> USE parallel_mod, ONLY: is_master_task
> 
188c181
< REAL :: co2_tmp(land_pts) ! Used to out put the 1-d co2_mmr variable
---
> REAL :: onedvar_tmp(land_pts) ! Used to out put the 1-d variable
208a202,207
> CASE ( 'projection_x_coord' )
>   cube = cube_from_array(projection_x_coord)
> 
> CASE ( 'projection_y_coord' )
>   cube = cube_from_array(projection_y_coord)
> 
214a214,219
> CASE ( 'rivers_x_coord_rp' )
>   cube = cube_from_array(rivers%rivers_x_coord_rp)
> 
> CASE ( 'rivers_y_coord_rp' )
>   cube = cube_from_array(rivers%rivers_y_coord_rp)
> 
708,763d712
< CASE ( 't_growth' )
<   ! n.b. t_growth is calculated here to make sure it is
<   ! consistent with t_growth_gb after t_growth_gb is updated
<   workspace_land(:) = SUM(progs%t_growth_gb * ainfo%frac_surft(:,1:npft), 2)
<   cube_land = cube_from_array(workspace_land)
<   cube = map_from_land(cube_land)
< 
< CASE ( 'l_growth' )
<   ! n.b. l_growth is calculated here to make sure it is
<   ! consistent with l_growth_gb after l_growth_gb is updated
<   workspace_land(:) = SUM(progs%l_growth_gb * ainfo%frac_surft(:,1:npft), 2)
<   cube_land = cube_from_array(workspace_land)
<   cube = map_from_land(cube_land)
< 
< CASE ( 'co2_growth' )
<   ! n.b. co2_growth is calculated here to make sure it is
<   ! consistent with co2_growth_gb after co2_growth_gb is updated
<   workspace_land(:) = SUM(progs%co2_growth_gb * ainfo%frac_surft(:,1:npft), 2)
<   cube_land = cube_from_array(workspace_land)
<   cube = map_from_land(cube_land)
< 
< CASE ( 'pstar_growth' )
<   ! n.b. pstar_growth is calculated here to make sure it is
<   ! consistent with pstar_growth_gb after pstar_growth_gb is updated
<   workspace_land(:) = SUM(progs%pstar_growth_gb * ainfo%frac_surft(:,1:npft), 2)
<   cube_land = cube_from_array(workspace_land)
<   cube = map_from_land(cube_land)
< 
< CASE ( 'vpd_growth' )
<   ! n.b. vpd_growth is calculated here to make sure it is
<   ! consistent with vpd_growth_gb after vpd_growth_gb is updated
<   workspace_land(:) = SUM(progs%vpd_growth_gb * ainfo%frac_surft(:,1:npft), 2)
<   cube_land = cube_from_array(workspace_land)
<   cube = map_from_land(cube_land)
< 
< CASE ( 'xipam_gb' )
<   ! n.b. xipam_gb is calculated here to make sure it is
<   ! consistent with xipam_opt after xipam_opt is updated
<   workspace_land(:) = SUM(progs%xipam_opt * ainfo%frac_surft(:,1:npft), 2)
<   cube_land = cube_from_array(workspace_land)
<   cube = map_from_land(cube_land)
< 
< CASE ( 'jmax25_gb' )
<   ! n.b. xipam_gb is calculated here to make sure it is
<   ! consistent with jmax_opt after jmax_opt is updated
<   workspace_land(:) = SUM(progs%jmax_opt * ainfo%frac_surft(:,1:npft), 2)
<   cube_land = cube_from_array(workspace_land)
<   cube = map_from_land(cube_land)
< 
< CASE ( 'vcmax25_gb' )
<   ! n.b. xipam_gb is calculated here to make sure it is
<   ! consistent with vcmax_opt after vcmax_opt is updated
<   workspace_land(:) = SUM(progs%vcmax_opt * ainfo%frac_surft(:,1:npft), 2)
<   cube_land = cube_from_array(workspace_land)
<   cube = map_from_land(cube_land)
< 
950c899
<   CASE ( soil_model_rothc )
---
>   CASE ( soil_model_4pool )
1004c953
<   CASE ( soil_model_rothc )
---
>   CASE ( soil_model_4pool )
1177c1126
<     DO j = 1,surft_pts(n)
---
>     DO j = 1,ainfo%surft_pts(n)
1188c1137
<     DO j = 1,surft_pts(n)
---
>     DO j = 1,ainfo%surft_pts(n)
1385,1430d1333
< CASE ( 'gpp_lyr' )
<   cube_land = cube_from_array(trifctltype%gpp_pft_lay)
<   cube = map_from_land(cube_land)
< 
< CASE ( 'wlite_lyr' )
<   cube_land = cube_from_array(trifctltype%wlite_pft_lay)
<       cube = map_from_land(cube_land)
< 
< CASE ( 'apar_lyr' )
<   cube_land = cube_from_array(trifctltype%apar_pft_lay)
<   cube = map_from_land(cube_land)
< 
< CASE ( 'cmpf_lyr' )
<   cube_land = cube_from_array(trifctltype%cmpf_pft_lay)
<   cube = map_from_land(cube_land)
< 
< CASE ( 'vcmax_lyr' )
<   cube_land = cube_from_array(trifctltype%vcmax_pft_lay)
<   cube = map_from_land(cube_land)
< 
< CASE ( 'vcmax25_lyr' )
<   cube_land = cube_from_array(trifctltype%vcmax25_pft_lay)
<   cube = map_from_land(cube_land)
< 
< CASE ( 'wlight_lyr' )
<   cube_land = cube_from_array(trifctltype%wlite_pft_lay)
<   cube = map_from_land(cube_land)
< 
< CASE ( 'wcarb_lyr' )
<   cube_land = cube_from_array(trifctltype%wcarb_pft_lay)
<   cube = map_from_land(cube_land)
< 
< CASE ( 'wmin_lyr' )
<   cube_land = cube_from_array(trifctltype%wmin_pft_lay)
<       cube = map_from_land(cube_land)
< 
< CASE ( 'ej_lyr' )
<     WHERE (trifctltype%cmpf_pft_lay .NE. 0.0d0)
< ! units of ej = mol / m2 / s  
<       trifctltype%ej_pft_lay = trifctltype%gpp_pft_lay * 4.0 / trifctltype%cmpf_pft_lay / 12.0e-3
<     ELSEWHERE
<       trifctltype%ej_pft_lay = 0.0d0
<     ENDWHERE
<     cube_land = cube_from_array(trifctltype%ej_pft_lay)
<     cube = map_from_land(cube_land)
< 
1542,1543c1445,1446
<   co2_tmp(:)=co2_mmr
<   cube_land = cube_from_array(co2_tmp)
---
>   onedvar_tmp(:)=co2_mmr
>   cube_land = cube_from_array(onedvar_tmp)
1577a1481,1492
> CASE ( 'growth_sug_gb' )
>   cube_land = cube_from_array(trifctltype%growth_sug_gb)
>   cube = map_from_land(cube_land)
> 
> CASE ( 'growth_sug' )
>   cube_land = cube_from_array(trifctltype%growth_sug_pft)
>   cube = map_from_land(cube_land)
> 
> CASE ( 'f_nsc' )
>   cube_land = cube_from_array(progs%f_nsc_pft)
>   cube = map_from_land(cube_land)
> 
1593a1509,1512
> CASE ( 'lwp_c' )
>   cube_land = cube_from_array(trifctltype%lwp_c_pft)
>   cube = map_from_land(cube_land)
> 
1615c1534
<   CASE ( soil_model_rothc )
---
>   CASE ( soil_model_4pool )
1743c1662
<     IF ( soil_bgc_model == soil_model_rothc ) THEN
---
>     IF ( soil_bgc_model == soil_model_4pool ) THEN
1869a1789,1800
> CASE ( 'nbp_gb' )
>   cube_land = cube_from_array(trif_vars%npp_n_gb                       -       &
>                               SUM(trif_vars%resp_s_to_atmos_gb(:,:),2) -       &
>                               trif_vars%wp_fast_out_gb                 -       &
>                               trif_vars%wp_med_out_gb                  -       &
>                               trif_vars%wp_slow_out_gb                 -       &
>                               trif_vars%harvest_gb                     -       &
>                               trif_vars%veg_c_fire_emission_gb         -       &
>                               trif_vars%burnt_carbon_dpm               -       &
>                               trif_vars%burnt_carbon_rpm )
>   cube = map_from_land(cube_land)
> 
1888c1819
<   CASE ( soil_model_rothc )
---
>   CASE ( soil_model_4pool )
1899c1830
<   CASE ( soil_model_rothc )
---
>   CASE ( soil_model_4pool )
2106,2107c2037,2038
< CASE ( 't1p5m_ij_clim_imgn' )
<   cube = cube_from_array(imgn_drive%t1p5m_ij_clim)
---
> CASE ( 'tl1_ij_clim_imgn' )
>   cube = cube_from_array(imgn_drive%tl1_ij_clim)
2109,2110c2040,2041
< CASE ( 'rh1p5m_ij_clim_imgn' )
<   cube = cube_from_array(imgn_drive%rh1p5m_ij_clim)
---
> CASE ( 'ql1_ij_clim_imgn' )
>   cube = cube_from_array(imgn_drive%ql1_ij_clim)
2112,2116c2043,2044
< CASE ( 'uwind_ij_clim_imgn' )
<   cube = cube_from_array(imgn_drive%uwind_ij_clim)
< 
< CASE ( 'vwind_ij_clim_imgn' )
<   cube = cube_from_array(imgn_drive%vwind_ij_clim)
---
> CASE ( 'wind_ij_clim_imgn' )
>   cube = cube_from_array(imgn_drive%wind_ij_clim)
2124,2125c2052,2053
< CASE ( 'diurnal_t1p5m_ij_clim_imgn' )
<   cube = cube_from_array(imgn_drive%diurnal_t1p5m_ij_clim)
---
> CASE ( 'diurnal_tl1_ij_clim_imgn' )
>   cube = cube_from_array(imgn_drive%diurnal_tl1_ij_clim)
2133,2137c2061,2062
< CASE ( 't1p5m_ij_patt_imgn' )
<   cube = cube_from_array(imgn_drive%t1p5m_ij_patt)
< 
< CASE ( 'rh1p5m_ij_patt_imgn' )
<   cube = cube_from_array(imgn_drive%rh1p5m_ij_patt)
---
> CASE ( 'tl1_ij_patt_imgn' )
>   cube = cube_from_array(imgn_drive%tl1_ij_patt)
2139,2140c2064,2065
< CASE ( 'uwind_ij_patt_imgn' )
<   cube = cube_from_array(imgn_drive%uwind_ij_patt)
---
> CASE ( 'ql1_ij_patt_imgn' )
>   cube = cube_from_array(imgn_drive%ql1_ij_patt)
2142,2143c2067,2068
< CASE ( 'vwind_ij_patt_imgn' )
<   cube = cube_from_array(imgn_drive%vwind_ij_patt)
---
> CASE ( 'wind_ij_patt_imgn' )
>   cube = cube_from_array(imgn_drive%wind_ij_patt)
2151,2152c2076,2077
< CASE ( 'diurnal_t1p5m_ij_patt_imgn' )
<   cube = cube_from_array(imgn_drive%diurnal_t1p5m_ij_patt)
---
> CASE ( 'diurnal_tl1_ij_patt_imgn' )
>   cube = cube_from_array(imgn_drive%diurnal_tl1_ij_patt)
2160,2164c2085,2086
< CASE ( 't1p5m_ij_anom_imgn' )
<   cube = cube_from_array(imgn_drive%t1p5m_ij_anom)
< 
< CASE ( 'rh1p5m_ij_anom_imgn' )
<   cube = cube_from_array(imgn_drive%rh1p5m_ij_anom)
---
> CASE ( 'tl1_ij_anom_imgn' )
>   cube = cube_from_array(imgn_drive%tl1_ij_anom)
2166,2167c2088,2089
< CASE ( 'uwind_ij_anom_imgn' )
<   cube = cube_from_array(imgn_drive%uwind_ij_anom)
---
> CASE ( 'ql1_ij_anom_imgn' )
>   cube = cube_from_array(imgn_drive%ql1_ij_anom)
2169,2170c2091,2092
< CASE ( 'vwind_ij_anom_imgn' )
<   cube = cube_from_array(imgn_drive%vwind_ij_anom)
---
> CASE ( 'wind_ij_anom_imgn' )
>   cube = cube_from_array(imgn_drive%wind_ij_anom)
2178,2179c2100,2101
< CASE ( 'diurnal_t1p5m_ij_anom_imgn' )
<   cube = cube_from_array(imgn_drive%diurnal_t1p5m_ij_anom)
---
> CASE ( 'diurnal_tl1_ij_anom_imgn' )
>   cube = cube_from_array(imgn_drive%diurnal_tl1_ij_anom)
2347c2269
<     DO j = 1,surft_pts(n)
---
>     DO j = 1,ainfo%surft_pts(n)
2448c2370
<     DO j = 1,surft_pts(n)
---
>     DO j = 1,ainfo%surft_pts(n)
2458c2380
<     DO j = 1,surft_pts(n)
---
>     DO j = 1,ainfo%surft_pts(n)
2761a2684,2694
> CASE ( 'rivers_outflow_rp' )
>   cube = cube_from_array(rivers%rivers_outflow_rp)
> 
> CASE ( 'outflow_per_river' )
>   ! Using workspace rivers (initialised to mdi) although it is of size
>   ! n_rivers < np_rivers. This allows it to be written to the same output file.
>   IF ( is_master_task() ) THEN
>     workspace_rivers(1:n_rivers) = calc_outflow_per_river(rivers)
>   END IF
>   cube = cube_from_array(workspace_rivers)
> 
2988c2921
<   ! Variables available with any multi-pool soil C model (e.g. RothC, ECOSSE).
---
>   ! Variables available with any multi-pool soil C model (e.g. 4-pool, ECOSSE).
3103c3036
<     IF ( soil_bgc_model == soil_model_rothc ) THEN
---
>     IF ( soil_bgc_model == soil_model_4pool ) THEN
3185,3186c3118
<   workspace_land(:) = d_land_atmos_co2
<   cube_land = cube_from_array(workspace_land)
---
>   cube_land = cube_from_array(imgn_vars%d_land_atmos_co2)
3190,3191c3122
<   workspace_land(:) = d_ocean_atmos
<   cube_land = cube_from_array(workspace_land)
---
>   cube_land = cube_from_array(imgn_vars%d_ocean_atmos)
3194,3196c3125,3142
< CASE ( 'c_emiss_out' )
<   workspace_land(:) = c_emiss_out
<   cube_land = cube_from_array(workspace_land)
---
> CASE ( 'imogen_radf' )
>   cube_land = cube_from_array(imgn_vars%imogen_radf)
>   cube = map_from_land(cube_land)
> 
> CASE ( 'dtemp_g' )
>   cube_land = cube_from_array(imgn_vars%dtemp_g)
>   cube = map_from_land(cube_land)
> 
> CASE ( 'c_emiss_data' )
>   cube_land = cube_from_array(imgn_vars%c_emiss_data)
>   cube = map_from_land(cube_land)
> 
> CASE ( 'dctot_co2' )
>   cube_land = cube_from_array(imgn_vars%dctot_co2)
>   cube = map_from_land(cube_land)
> 
> CASE ( 'dctot_ch4' )
>   cube_land = cube_from_array(imgn_vars%dctot_ch4)
3241,3245d3186
<   ! Atmospheric deposition variables.
< CASE ( 'tracer_field' )
<   cube_land = cube_from_array( tracer_field )
<   cube = map_from_land(cube_land)
< 
3248a3190,3194
> 
> CASE ( 't_growth_gb' )
>   cube_land = cube_from_array( progs%t_growth_gb )
>   cube = map_from_land(cube_land)
> 
3251c3197
<   cube_land = cube_from_array( conveyance_loss )
---
>   cube_land = cube_from_array( water_resources%conveyance_loss )
3255c3201
<   cube_land = cube_from_array(demand_accum(:,use_domestic))
---
>   cube_land = cube_from_array(water_resources%demand_accum(:,use_domestic))
3259c3205
<   cube_land = cube_from_array(demand_accum(:,use_environment))
---
>   cube_land = cube_from_array(water_resources%demand_accum(:,use_environment))
3263c3209
<   cube_land = cube_from_array(demand_accum(:,use_industry))
---
>   cube_land = cube_from_array(water_resources%demand_accum(:,use_industry))
3267c3213
<   cube_land = cube_from_array(demand_accum(:,use_irrigation))
---
>   cube_land = cube_from_array(water_resources%demand_accum(:,use_irrigation))
3271c3217
<   cube_land = cube_from_array(demand_accum(:,use_livestock))
---
>   cube_land = cube_from_array(water_resources%demand_accum(:,use_livestock))
3275c3221
<   cube_land = cube_from_array(demand_accum(:,use_transfers))
---
>   cube_land = cube_from_array(water_resources%demand_accum(:,use_transfers))
3279c3225
<   cube_land = cube_from_array( irrig_eff )
---
>   cube_land = cube_from_array( water_resources%irrig_eff )
3286c3232
<   cube_land = cube_from_array( sfc_water_frac )
---
>   cube_land = cube_from_array( water_resources%sfc_water_frac )
3293c3239,3240
<     workspace_land(:) =  workspace_land(:) + demand_accum(:,use_domestic)
---
>     workspace_land(:) =  workspace_land(:)                                     &
>                          + water_resources%demand_accum(:,use_domestic)
3296c3243,3244
<     workspace_land(:) =  workspace_land(:) + demand_accum(:,use_environment)
---
>     workspace_land(:) =  workspace_land(:)                                     &
>                          + water_resources%demand_accum(:,use_environment)
3299c3247,3248
<     workspace_land(:) =  workspace_land(:) + demand_accum(:,use_industry)
---
>     workspace_land(:) =  workspace_land(:)                                     &
>                          + water_resources%demand_accum(:,use_industry)
3302c3251,3252
<     workspace_land(:) =  workspace_land(:) + demand_accum(:,use_irrigation)
---
>     workspace_land(:) =  workspace_land(:)                                     &
>                          + water_resources%demand_accum(:,use_irrigation)
3305c3255,3256
<     workspace_land(:) =  workspace_land(:) + demand_accum(:,use_livestock)
---
>     workspace_land(:) =  workspace_land(:)                                     &
>                          + water_resources%demand_accum(:,use_livestock)
3308c3259,3260
<     workspace_land(:) =  workspace_land(:) + demand_accum(:,use_transfers)
---
>     workspace_land(:) =  workspace_land(:)                                     &
>                          + water_resources%demand_accum(:,use_transfers)
3317,3319c3269,3271
<   ! wrr 	Repeating width ratio (or canyon fraction, W/R)
<   ! hwr 	Height-to-width ratio (H/W)
<   ! hgt 	Building height (H)
---
>   ! wrr   Repeating width ratio (or canyon fraction, W/R)
>   ! hwr   Height-to-width ratio (H/W)
>   ! hgt   Building height (H)
3331a3284,3328
> 
>   ! Atmospheric deposition variables.
>   ! Surface atmospheric concentrations of deposited species
> CASE ( 'deposition_conc' )
>   cube = cube_from_array( chemvars%dep_surfconc_ij )
> 
>   ! Aerodynamic resistance, Ra
> CASE ( 'deposition_ra' )
>   cube = cube_from_array( chemvars%dep_ra_ij )
> 
>   ! Quasi-laminar resistance, Rb
> CASE ( 'deposition_rb' )
>   cube = cube_from_array( chemvars%dep_rb_ij )
> 
>   ! Surface resistance, Rc
> CASE ( 'deposition_rc' )
>   cube = cube_from_array( chemvars%dep_rc_ij )
> 
>   ! Surface resistance, Rc - stomatal component
> CASE ( 'deposition_rc_stom' )
>   cube = cube_from_array( chemvars%dep_rc_stom_ij )
> 
>   ! Surface resistance, Rc - non-stomatal component
> CASE ( 'deposition_rc_nonstom' )
>   cube = cube_from_array( chemvars%dep_rc_nonstom_ij )
> 
>   ! Deposition velocity, vd
> CASE ( 'deposition_vd' )
>   cube = cube_from_array( chemvars%dep_vd_ij )
> 
>   ! Deposition loss rate
> CASE ( 'deposition_lossrate' )
>   cube = cube_from_array( chemvars%dep_loss_rate_ij )
> 
>   ! Deposition flux
> CASE ( 'deposition_flux' )
>   cube = cube_from_array( chemvars%dep_flux_ij )
> 
>   ! Boundary height
> CASE ( 'bl_height' )
>   cube = cube_from_array( jules_vars%zh )
> 
>   ! Atmospheric layer separation
> CASE ( 'level_separation' )
>   cube = cube_from_array( jules_vars%dzl )
diff -r vn7.0copy1_c4/src/./io/model_interface/get_var_attrs.inc vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./io/model_interface/get_var_attrs.inc
20c20
<      soil_model_ecosse, soil_model_rothc, soil_model_1pool,                    &
---
>      soil_model_ecosse, soil_model_4pool, soil_model_1pool,                    &
108c108
<   CASE ( soil_model_ecosse, soil_model_rothc )
---
>   CASE ( soil_model_ecosse, soil_model_4pool )
119c119
<   CASE ( soil_model_ecosse, soil_model_rothc )
---
>   CASE ( soil_model_ecosse, soil_model_4pool )
diff -r vn7.0copy1_c4/src/./io/model_interface/get_var_levs_dims.inc vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./io/model_interface/get_var_levs_dims.inc
145c145
< CASE ( var_type_tracer )
---
> CASE ( var_type_dep_species )
147,149c147,159
<   IF ( PRESENT(dim_names_in) )  dim_names_in(1)  = tracer_dim_name
<   IF ( PRESENT(dim_names_out) ) dim_names_out(1) = tracer_dim_name_out
<   IF ( PRESENT(dim_sizes) )     dim_sizes(1)     = tracer_dim_size
---
>   IF ( PRESENT(dim_names_in) )  dim_names_in(1)  = dep_species_dim_name
>   IF ( PRESENT(dim_names_out) ) dim_names_out(1) = dep_species_dim_name_out
>   IF ( PRESENT(dim_sizes) )     dim_sizes(1)     = dep_species_dim_size
> 
> CASE ( var_type_surft_dep_species )
>   ! Variables with tile and chemical deposited species
>   IF ( PRESENT(ndims) ) ndims = 2
>   IF ( PRESENT(dim_names_in) )                                                 &
>     dim_names_in(1:2) = [ tile_dim_name, dep_species_dim_name ]
>   IF ( PRESENT(dim_names_out) )                                                &
>     dim_names_out(1:2) = [ tile_dim_name_out, dep_species_dim_name_out ]
>   IF ( PRESENT(dim_sizes) )                                                    &
>     dim_sizes(1:2) = [ tile_dim_size, dep_species_dim_size ]
187,196d196
<     CASE ( var_type_canlayer )
< ! Variables per PFT and canopy levels
<       IF ( PRESENT(ndims) ) ndims = 2
<       IF ( PRESENT(dim_names_in) )                                            &
<         dim_names_in(1:2) = (/ pft_dim_name, canopy_dim_name /)
<       IF ( PRESENT(dim_names_out) )                                           &
<         dim_names_out(1:2) = (/ pft_dim_name_out, canopy_dim_name_out /)
<       IF ( PRESENT(dim_sizes) )                                               &
<         dim_sizes(1:2) = (/ pft_dim_size, canopy_dim_size /)
<         
diff -r vn7.0copy1_c4/src/./io/model_interface/is_river_var.inc vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./io/model_interface/is_river_var.inc
38d37
< INTEGER :: i        ! Loop index
diff -r vn7.0copy1_c4/src/./io/model_interface/map_from_land.inc vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./io/model_interface/map_from_land.inc
62c62
< INTEGER :: i, j, l  ! Indexing variables
---
> INTEGER :: i, j, l, k  ! Indexing variables
82c82,95
< data_grid(:,:,:) = mdi
---
> !$OMP PARALLEL DO IF(nlevs > 1) DEFAULT(NONE) SCHEDULE(STATIC)                 &
> !$OMP SHARED( nlevs, data_grid, land_pts, ainfo, data_land, t_i_length,        &
> !$OMP         t_j_length )  PRIVATE( i, j, k, l )
> DO k = 1, nlevs
>   DO j = 1, t_j_length
>     DO i = 1, t_i_length
>       data_grid(i,j,k) = mdi
>     END DO
>   END DO
> 
>   ! Do the mapping
>   DO l = 1,land_pts
>     j = (ainfo%land_index(l) - 1) / t_i_length + 1
>     i = ainfo%land_index(l) - (j-1) * t_i_length
84,89c97,98
< ! Do the mapping
< DO l = 1,land_pts
<   j = (ainfo%land_index(l) - 1) / t_i_length + 1
<   i = ainfo%land_index(l) - (j-1) * t_i_length
< 
<   data_grid(i,j,:) = data_land(l,:)
---
>     data_grid(i,j,k) = data_land(l,k)
>   END DO
90a100
> !$OMP END PARALLEL DO
diff -r vn7.0copy1_c4/src/./io/model_interface/model_interface_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./io/model_interface/model_interface_mod.F90
34c34
< INTEGER, PARAMETER :: identifier_len = 30
---
> INTEGER, PARAMETER :: identifier_len = 29
51c51
<   tracer_dim_name_out       = 'tracer',                                        &
---
>   dep_species_dim_name_out  = 'dep_species',                                   &
60,61c60
<   scalar_dim_name_out       = 'scalar',                                        &
<   canopy_dim_name_out  = 'ilayers'
---
>   scalar_dim_name_out       = 'scalar'
81c80
<   tracer_dim_name   = 'tracer',                                                &
---
>   dep_species_dim_name  = 'dep_species',                                       &
84,85c83
<   nmasst_dim_name    = 'nmasst',                                               &
<   canopy_dim_name  = 'ilayers'
---
>   nmasst_dim_name    = 'nmasst'
105c103
<   tracer_dim_size      = -1,                                                   &
---
>   dep_species_dim_size = -1,                                                   &
108,109c106
<   nmasst_dim_size      = -1,                                                   &
<   canopy_dim_size      = 10
---
>   nmasst_dim_size      = -1
142,143c139,141
<   var_type_tracer         = var_type_soilt_sclayer_scpool+1,                   &
<   var_type_ch4layer       = var_type_tracer+1,                                 &
---
>   var_type_dep_species    = var_type_soilt_sclayer_scpool+1,                   &
>   var_type_surft_dep_species = var_type_dep_species+1,                         &
>   var_type_ch4layer       = var_type_surft_dep_species+1,                      &
149,151c147
<   var_type_nmasst         = var_type_imogen_drive + 1,                         &
<   var_type_canlayer       = var_type_nmasst + 1
<   
---
>   var_type_nmasst         = var_type_imogen_drive + 1
172c168
< INTEGER, PARAMETER :: n_vars = 685
---
> INTEGER, PARAMETER :: n_vars = 673
190c186,187
<     tracer_dim_name_out, ch4layer_dim_name_out, imogen_drive_dim_name_out,     &
---
>     dep_species_dim_name_out, ch4layer_dim_name_out,                           &
>     imogen_drive_dim_name_out,                                                 &
193d189
<     canopy_dim_name_out,                                                       &     
199,200c195
<     sclayer_dim_name, imogen_drive_dim_name, tracer_dim_name,                  &
<     canopy_dim_name,                                                           &
---
>     sclayer_dim_name, imogen_drive_dim_name, dep_species_dim_name,             &
205c200
<     sclayer_dim_size, tracer_dim_size, ch4layer_dim_size,                      &
---
>     sclayer_dim_size, dep_species_dim_size, ch4layer_dim_size,                 &
diff -r vn7.0copy1_c4/src/./io/model_interface/populate_var.inc vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./io/model_interface/populate_var.inc
13c13
<                             lake_vars, chemvars, rivers, rivers_data
---
>                             lake_vars, chemvars, rivers, water_resources
18a19
> USE imgn_vars_mod, ONLY: imgn_vars
21c22
<   dim_cslayer, dim_soil_n_pool, land_pts, nsurft, nsoilt
---
>   dim_cslayer, land_pts, nsurft, nsoilt
24c25
<   grid_area_ij, latitude, longitude
---
>   grid_area_ij, latitude, longitude, projection_x_coord, projection_y_coord
32,34d32
< USE jules_deposition_mod, ONLY:                                                &
<   tracer_field
< 
38,41d35
< USE jules_water_resources_mod, ONLY:                                           &
<   conveyance_loss, demand_rate_domestic, demand_rate_industry,                 &
<   demand_rate_livestock, demand_rate_transfers, irrig_eff, sfc_water_frac
< 
122a117,130
> CASE ( 'projection_x_coord' )
>   IF ( PRESENT(cube) ) THEN
>     CALL cube_get_data(cube, projection_x_coord)
>   ELSE
>     projection_x_coord(:,:) = const_val
>   END IF
> 
> CASE ( 'projection_y_coord' )
>   IF ( PRESENT(cube) ) THEN
>     CALL cube_get_data(cube, projection_y_coord)
>   ELSE
>     projection_y_coord(:,:) = const_val
>   END IF
> 
1924a1933,1940
> CASE ( 'f_nsc' )
>   IF ( PRESENT(cube) ) THEN
>     cube_land = map_to_land(cube)
>     CALL cube_get_data(cube_land, progs%f_nsc_pft(:,:))
>   ELSE
>     progs%f_nsc_pft(:,:) = const_val
>   END IF
> 
2086c2102
< CASE ( 't1p5m_ij_anom_imgn' )
---
> CASE ( 'tl1_ij_anom_imgn' )
2088c2104
<     CALL cube_get_data(cube, imgn_drive%t1p5m_ij_anom)
---
>     CALL cube_get_data(cube, imgn_drive%tl1_ij_anom)
2090c2106
<     imgn_drive%t1p5m_ij_anom(:,:,:) = const_val
---
>     imgn_drive%tl1_ij_anom(:,:,:) = const_val
2093c2109
< CASE ( 'uwind_ij_anom_imgn' )
---
> CASE ( 'wind_ij_anom_imgn' )
2095c2111
<     CALL cube_get_data(cube, imgn_drive%uwind_ij_anom)
---
>     CALL cube_get_data(cube, imgn_drive%wind_ij_anom)
2097,2104c2113
<     imgn_drive%uwind_ij_anom(:,:,:) = const_val
<   END IF
< 
< CASE ( 'vwind_ij_anom_imgn' )
<   IF ( PRESENT(cube) ) THEN
<     CALL cube_get_data(cube, imgn_drive%vwind_ij_anom)
<   ELSE
<     imgn_drive%vwind_ij_anom(:,:,:) = const_val
---
>     imgn_drive%wind_ij_anom(:,:,:) = const_val
2121c2130
< CASE ( 'diurnal_t1p5m_ij_anom_imgn' )
---
> CASE ( 'diurnal_tl1_ij_anom_imgn' )
2123c2132
<     CALL cube_get_data(cube, imgn_drive%diurnal_t1p5m_ij_anom)
---
>     CALL cube_get_data(cube, imgn_drive%diurnal_tl1_ij_anom)
2125c2134
<     imgn_drive%diurnal_t1p5m_ij_anom(:,:,:) = const_val
---
>     imgn_drive%diurnal_tl1_ij_anom(:,:,:) = const_val
2135c2144
< CASE ( 'rh1p5m_ij_anom_imgn' )
---
> CASE ( 'ql1_ij_anom_imgn' )
2137c2146
<     CALL cube_get_data(cube, imgn_drive%rh1p5m_ij_anom)
---
>     CALL cube_get_data(cube, imgn_drive%ql1_ij_anom)
2139c2148
<     imgn_drive%rh1p5m_ij_anom(:,:,:) = const_val
---
>     imgn_drive%ql1_ij_anom(:,:,:) = const_val
2149,2156c2158
< CASE ( 't1p5m_ij_clim_imgn' )
<   IF ( PRESENT(cube) ) THEN
<     CALL cube_get_data(cube, imgn_drive%t1p5m_ij_clim)
<   ELSE
<     imgn_drive%t1p5m_ij_clim(:,:,:) = const_val
<   END IF
< 
< CASE ( 't1p5m_ij_patt_imgn' )
---
> CASE ( 'tl1_ij_clim_imgn' )
2158c2160
<     CALL cube_get_data(cube, imgn_drive%t1p5m_ij_patt)
---
>     CALL cube_get_data(cube, imgn_drive%tl1_ij_clim)
2160c2162
<     imgn_drive%t1p5m_ij_patt(:,:,:) = const_val
---
>     imgn_drive%tl1_ij_clim(:,:,:) = const_val
2163c2165
< CASE ( 'uwind_ij_patt_imgn' )
---
> CASE ( 'tl1_ij_patt_imgn' )
2165c2167
<     CALL cube_get_data(cube, imgn_drive%uwind_ij_patt)
---
>     CALL cube_get_data(cube, imgn_drive%tl1_ij_patt)
2167c2169
<     imgn_drive%uwind_ij_patt(:,:,:) = const_val
---
>     imgn_drive%tl1_ij_patt(:,:,:) = const_val
2170c2172
< CASE ( 'vwind_ij_patt_imgn' )
---
> CASE ( 'wind_ij_patt_imgn' )
2172c2174
<     CALL cube_get_data(cube, imgn_drive%vwind_ij_patt)
---
>     CALL cube_get_data(cube, imgn_drive%wind_ij_patt)
2174c2176
<     imgn_drive%vwind_ij_patt(:,:,:) = const_val
---
>     imgn_drive%wind_ij_patt(:,:,:) = const_val
2191c2193
< CASE ( 'diurnal_t1p5m_ij_patt_imgn' )
---
> CASE ( 'diurnal_tl1_ij_patt_imgn' )
2193c2195
<     CALL cube_get_data(cube, imgn_drive%diurnal_t1p5m_ij_patt)
---
>     CALL cube_get_data(cube, imgn_drive%diurnal_tl1_ij_patt)
2195c2197
<     imgn_drive%diurnal_t1p5m_ij_patt(:,:,:) = const_val
---
>     imgn_drive%diurnal_tl1_ij_patt(:,:,:) = const_val
2205c2207
< CASE ( 'rh1p5m_ij_patt_imgn' )
---
> CASE ( 'ql1_ij_patt_imgn' )
2207c2209
<     CALL cube_get_data(cube, imgn_drive%rh1p5m_ij_patt)
---
>     CALL cube_get_data(cube, imgn_drive%ql1_ij_patt)
2209c2211
<     imgn_drive%rh1p5m_ij_patt(:,:,:) = const_val
---
>     imgn_drive%ql1_ij_patt(:,:,:) = const_val
2219c2221
< CASE ( 'uwind_ij_clim_imgn' )
---
> CASE ( 'wind_ij_clim_imgn' )
2221c2223
<     CALL cube_get_data(cube, imgn_drive%uwind_ij_clim)
---
>     CALL cube_get_data(cube, imgn_drive%wind_ij_clim)
2223,2230c2225
<     imgn_drive%uwind_ij_clim(:,:,:) = const_val
<   END IF
< 
< CASE ( 'vwind_ij_clim_imgn' )
<   IF ( PRESENT(cube) ) THEN
<     CALL cube_get_data(cube, imgn_drive%vwind_ij_clim)
<   ELSE
<     imgn_drive%vwind_ij_clim(:,:,:) = const_val
---
>     imgn_drive%wind_ij_clim(:,:,:) = const_val
2247c2242
< CASE ( 'diurnal_t1p5m_ij_clim_imgn' )
---
> CASE ( 'diurnal_tl1_ij_clim_imgn' )
2249c2244
<     CALL cube_get_data(cube, imgn_drive%diurnal_t1p5m_ij_clim)
---
>     CALL cube_get_data(cube, imgn_drive%diurnal_tl1_ij_clim)
2251c2246
<     imgn_drive%diurnal_t1p5m_ij_clim(:,:,:) = const_val
---
>     imgn_drive%diurnal_tl1_ij_clim(:,:,:) = const_val
2261c2256
< CASE ( 'rh1p5m_ij_clim_imgn' )
---
> CASE ( 'ql1_ij_clim_imgn' )
2263c2258
<     CALL cube_get_data(cube, imgn_drive%rh1p5m_ij_clim)
---
>     CALL cube_get_data(cube, imgn_drive%ql1_ij_clim)
2265c2260
<     imgn_drive%rh1p5m_ij_clim(:,:,:) = const_val
---
>     imgn_drive%ql1_ij_clim(:,:,:) = const_val
2275a2271,2282
>   ! imogen variables
>   !-----------------------------------------------------------------------------
> 
> CASE ( 'dtemp_g' )
>   IF ( PRESENT(cube) ) THEN
>     cube_land = map_to_land(cube)
>     CALL cube_get_data(cube_land, imgn_vars%dtemp_g)
>   ELSE
>     imgn_vars%dtemp_g(:) = const_val
>   END IF
> 
>   !-----------------------------------------------------------------------------
2339a2347,2354
> CASE ( 'rivers_outflow_rp' )
>   IF ( PRESENT(cube) ) THEN
>     cube_land = cube_create([ SIZE(cube%values) ])
>     CALL cube_get_data(cube_land, rivers%rivers_outflow_rp)
>   ELSE
>     rivers%rivers_outflow_rp(:) = const_val
>   END IF
> 
2620c2635
< CASE ( 'tracer_field' )
---
> CASE ( 'deposition_conc' )
2622,2623c2637
<     cube_land = map_to_land(cube)
<     CALL cube_get_data(cube_land, tracer_field)
---
>     CALL cube_get_data(cube, chemvars%dep_surfconc_ij)
2625c2639
<     tracer_field(:,:) = const_val
---
>     chemvars%dep_surfconc_ij(:,:,:) = const_val
2707,2821c2721
<     progs%t_growth_gb(:,:) = const_val
<   END IF
< 
< CASE ( 'l_growth_gb' )
<   IF ( PRESENT(cube) ) THEN
<     cube_land = map_to_land(cube)
<     CALL cube_get_data(cube_land, progs%l_growth_gb)
<   ELSE
<     progs%l_growth_gb(:,:) = const_val
<   END IF
< 
< CASE ( 'vpd_growth_gb' )
<   IF ( PRESENT(cube) ) THEN
<     cube_land = map_to_land(cube)
<     CALL cube_get_data(cube_land, progs%vpd_growth_gb)
<   ELSE
<     progs%vpd_growth_gb(:,:) = const_val
<   END IF
< 
< CASE ( 'co2_growth_gb' )
<   IF ( PRESENT(cube) ) THEN
<     cube_land = map_to_land(cube)
<     CALL cube_get_data(cube_land, progs%co2_growth_gb)
<   ELSE
<     progs%co2_growth_gb(:,:) = const_val
<   END IF
< 
< CASE ( 'pstar_growth_gb' )
<   IF ( PRESENT(cube) ) THEN
<     cube_land = map_to_land(cube)
<     CALL cube_get_data(cube_land, progs%pstar_growth_gb)
<   ELSE
<     progs%pstar_growth_gb(:,:) = const_val
<   END IF
< 
< CASE ( 'xipam_opt' )
<   IF ( PRESENT(cube) ) THEN
<     cube_land = map_to_land(cube)
<     CALL cube_get_data(cube_land, progs%xipam_opt)
<   ELSE
<     progs%xipam_opt(:,:) = const_val
<   END IF
< 
< CASE ( 'vcmax_opt' )
<   IF ( PRESENT(cube) ) THEN
<     cube_land = map_to_land(cube)
<     CALL cube_get_data(cube_land, progs%vcmax_opt)
<   ELSE
<     progs%vcmax_opt(:,:) = const_val
<   END IF
< 
< CASE ( 'jmax_opt' )
<   IF ( PRESENT(cube) ) THEN
<     cube_land = map_to_land(cube)
<     CALL cube_get_data(cube_land, progs%jmax_opt)
<   ELSE
<     progs%jmax_opt(:,:) = const_val
<   END IF
< 
< 
< 
< CASE ( 't_sum' )
<   IF ( PRESENT(cube) ) THEN
<     cube_land = map_to_land(cube)
<     CALL cube_get_data(cube_land, progs%t_sum)
<   ELSE
<     progs%t_sum(:,:) = const_val
<   END IF
< 
< CASE ( 'l_sum' )
<   IF ( PRESENT(cube) ) THEN
<     cube_land = map_to_land(cube)
<     CALL cube_get_data(cube_land, progs%l_sum)
<   ELSE
<     progs%l_sum(:,:) = const_val
<   END IF
< 
< CASE ( 't_night' )
<   IF ( PRESENT(cube) ) THEN
<     cube_land = map_to_land(cube)
<     CALL cube_get_data(cube_land, progs%t_night)
<   ELSE
<     progs%t_night(:,:) = const_val
<   END IF
< 
< CASE ( 'nt_sum' )
<   IF ( PRESENT(cube) ) THEN
<     cube_land = map_to_land(cube)
<     CALL cube_get_data(cube_land, progs%nt_sum)
<   ELSE
<     progs%nt_sum(:,:) = const_val
<   END IF
< 
< CASE ( 'vpd_sum' )
<   IF ( PRESENT(cube) ) THEN
<     cube_land = map_to_land(cube)
<     CALL cube_get_data(cube_land, progs%vpd_sum)
<   ELSE
<     progs%vpd_sum(:,:) = const_val
<   END IF
< 
< CASE ( 'co2_sum' )
<   IF ( PRESENT(cube) ) THEN
<     cube_land = map_to_land(cube)
<     CALL cube_get_data(cube_land, progs%co2_sum)
<   ELSE
<     progs%co2_sum(:,:) = const_val
<   END IF
< 
< CASE ( 'pstar_sum' )
<   IF ( PRESENT(cube) ) THEN
<     cube_land = map_to_land(cube)
<     CALL cube_get_data(cube_land, progs%pstar_sum)
<   ELSE
<     progs%pstar_sum(:,:) = const_val
---
>     progs%t_growth_gb(:) = const_val
2855c2755
<     CALL cube_get_data(cube_land, conveyance_loss)
---
>     CALL cube_get_data(cube_land, water_resources%conveyance_loss)
2857c2757
<     conveyance_loss(:) = const_val
---
>     water_resources%conveyance_loss(:) = const_val
2863c2763
<     CALL cube_get_data(cube_land, demand_rate_domestic)
---
>     CALL cube_get_data(cube_land, water_resources%demand_rate_domestic)
2865c2765
<     demand_rate_domestic(:) = const_val
---
>     water_resources%demand_rate_domestic(:) = const_val
2871c2771
<     CALL cube_get_data(cube_land, demand_rate_industry)
---
>     CALL cube_get_data(cube_land, water_resources%demand_rate_industry)
2873c2773
<     demand_rate_industry(:) = const_val
---
>     water_resources%demand_rate_industry(:) = const_val
2879c2779
<     CALL cube_get_data(cube_land, demand_rate_livestock)
---
>     CALL cube_get_data(cube_land, water_resources%demand_rate_livestock)
2881c2781
<     demand_rate_livestock(:) = const_val
---
>     water_resources%demand_rate_livestock(:) = const_val
2887c2787
<     CALL cube_get_data(cube_land, demand_rate_transfers)
---
>     CALL cube_get_data(cube_land, water_resources%demand_rate_transfers)
2889c2789
<     demand_rate_transfers(:) = const_val
---
>     water_resources%demand_rate_transfers(:) = const_val
2895c2795
<     CALL cube_get_data(cube_land, irrig_eff)
---
>     CALL cube_get_data(cube_land, water_resources%irrig_eff)
2897c2797
<     irrig_eff(:) = const_val
---
>     water_resources%irrig_eff(:) = const_val
2910c2810
<     CALL cube_get_data(cube_land, sfc_water_frac)
---
>     CALL cube_get_data(cube_land, water_resources%sfc_water_frac)
2912c2812
<     sfc_water_frac(:) = const_val
---
>     water_resources%sfc_water_frac(:) = const_val
2996a2897,2909
>   END IF
> 
>   !-----------------------------------------------------------------------------
>   ! Variables for OASIS river coupling.
>   !-----------------------------------------------------------------------------
> CASE ( 'rivers_outflow_number' )
>   IF ( PRESENT(cube) ) THEN
>     CALL cube_get_data(cube, rivers%rivers_outflow_number)
>   ELSE
>     ! The functionality is not available for const_val and does not make
>     ! scientific sense
>     CALL log_fatal("populate_var",                                             &
>                    "cube not present for rivers_outflow_number")
diff -r vn7.0copy1_c4/src/./io/model_interface/variable_metadata.inc vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./io/model_interface/variable_metadata.inc
5819c5819
< ! Variables available with any multi-pool soil C model (e.g. RothC, ECOSSE).
---
> ! Variables available with any multi-pool soil C model (e.g. 4-pool, ECOSSE).
6829c6829
< ! Metadata for c_emiss_out
---
> ! Metadata for c_emiss_data
6833c6833
<     'c_emiss_out',                                                             &
---
>     'c_emiss_data',                                                            &
7042c7042
< ! Metadata for tracer.
---
> ! Metadata for deposition_conc
7046c7046
<     'tracer_field',                                                            &
---
>     'deposition_conc',                                                         &
7048c7048
<     var_type_tracer,                                                           &
---
>     var_type_dep_species,                                                      &
7050c7050
<     "Surface chemical tracer concentrations as mass mixing ratios",            &
---
>     "Surface concentration of deposited species as mass mixing ratios",        &
7988c7988
< ! Metadata for t1p5m_ij_clim_imgn
---
> ! Metadata for tl1_ij_clim_imgn
7992c7992
<     't1p5m_ij_clim_imgn',                                                      &
---
>     'tl1_ij_clim_imgn',                                                        &
8001c8001
< ! Metadata for rh1p5m_ij_clim_imgn
---
> ! Metadata for ql1_ij_clim_imgn
8005c8005
<     'rh1p5m_ij_clim_imgn',                                                     &
---
>     'ql1_ij_clim_imgn',                                                        &
8014c8014
< ! Metadata for uwind_ij_clim_imgn
---
> ! Metadata for wind_ij_clim_imgn
8018c8018
<     'uwind_ij_clim_imgn',                                                      &
---
>     'wind_ij_clim_imgn',                                                       &
8022,8035c8022
<     "imogen uwind climatology",                                                &
< ! Units
<     "m/s"                                                                      &
<   ) /
< !-----------------------------------------------------------------------------
< ! Metadata for vwind_ij_clim_imgn
< !-----------------------------------------------------------------------------
< DATA metadata(621) / var_metadata(                                             &
< ! String identifier
<     'vwind_ij_clim_imgn',                                                      &
< ! Variable type
<     var_type_imogen_drive,                                                     &
< ! Long name
<     "imogen vwind climatology",                                                &
---
>     "imogen wind climatology",                                                 &
8042c8029
< DATA metadata(622) / var_metadata(                                             &
---
> DATA metadata(621) / var_metadata(                                             &
8055c8042
< DATA metadata(623) / var_metadata(                                             &
---
> DATA metadata(622) / var_metadata(                                             &
8066c8053
< ! Metadata for diurnal_t1p5m_ij_clim_imgn
---
> ! Metadata for diurnal_tl1_ij_clim_imgn
8068c8055
< DATA metadata(624) / var_metadata(                                             &
---
> DATA metadata(623) / var_metadata(                                             &
8070c8057
<     'diurnal_t1p5m_ij_clim_imgn',                                              &
---
>     'diurnal_tl1_ij_clim_imgn',                                                &
8081c8068
< DATA metadata(625) / var_metadata(                                             &
---
> DATA metadata(624) / var_metadata(                                             &
8094c8081
< DATA metadata(626) / var_metadata(                                             &
---
> DATA metadata(625) / var_metadata(                                             &
8105c8092
< ! Metadata for t1p5m_ij_anom_imgn
---
> ! Metadata for tl1_ij_anom_imgn
8107c8094
< DATA metadata(627) / var_metadata(                                             &
---
> DATA metadata(626) / var_metadata(                                             &
8109c8096
<     't1p5m_ij_anom_imgn',                                                      &
---
>     'tl1_ij_anom_imgn',                                                        &
8118c8105
< ! Metadata for rh1p5m_ij_anom_imgn
---
> ! Metadata for ql1_ij_anom_imgn
8120c8107
< DATA metadata(628) / var_metadata(                                             &
---
> DATA metadata(627) / var_metadata(                                             &
8122c8109
<     'rh1p5m_ij_anom_imgn',                                                     &
---
>     'ql1_ij_anom_imgn',                                                        &
8131,8144c8118
< ! Metadata for uwind_ij_anom_imgn
< !-----------------------------------------------------------------------------
< DATA metadata(629) / var_metadata(                                             &
< ! String identifier
<     'uwind_ij_anom_imgn',                                                      &
< ! Variable type
<     var_type_imogen_drive,                                                     &
< ! Long name
<     "imogen uwind anomaly",                                                    &
< ! Units
<     "m/s"                                                                      &
<   ) /
< !-----------------------------------------------------------------------------
< ! Metadata for vwind_ij_anom_imgn
---
> ! Metadata for wind_ij_anom_imgn
8146c8120
< DATA metadata(630) / var_metadata(                                             &
---
> DATA metadata(628) / var_metadata(                                             &
8148c8122
<     'vwind_ij_anom_imgn',                                                      &
---
>     'wind_ij_anom_imgn',                                                       &
8152c8126
<     "imogen vwind anomaly",                                                    &
---
>     "imogen wind anomaly",                                                     &
8159c8133
< DATA metadata(631) / var_metadata(                                             &
---
> DATA metadata(629) / var_metadata(                                             &
8172c8146
< DATA metadata(632) / var_metadata(                                             &
---
> DATA metadata(630) / var_metadata(                                             &
8183c8157
< ! Metadata for diurnal_t1p5m_ij_anom_imgn
---
> ! Metadata for diurnal_tl1_ij_anom_imgn
8185c8159
< DATA metadata(633) / var_metadata(                                             &
---
> DATA metadata(631) / var_metadata(                                             &
8187c8161
<     'diurnal_t1p5m_ij_anom_imgn',                                              &
---
>     'diurnal_tl1_ij_anom_imgn',                                                &
8198c8172
< DATA metadata(634) / var_metadata(                                             &
---
> DATA metadata(632) / var_metadata(                                             &
8211c8185
< DATA metadata(635) / var_metadata(                                             &
---
> DATA metadata(633) / var_metadata(                                             &
8222c8196
< ! Metadata for t1p5m_ij_patt_imgn
---
> ! Metadata for tl1_ij_patt_imgn
8224c8198
< DATA metadata(636) / var_metadata(                                             &
---
> DATA metadata(634) / var_metadata(                                             &
8226c8200
<     't1p5m_ij_patt_imgn',                                                      &
---
>     'tl1_ij_patt_imgn',                                                        &
8235c8209
< ! Metadata for rh1p5m_ij_patt_imgn
---
> ! Metadata for ql1_ij_patt_imgn
8237c8211
< DATA metadata(637) / var_metadata(                                             &
---
> DATA metadata(635) / var_metadata(                                             &
8239c8213
<     'rh1p5m_ij_patt_imgn',                                                     &
---
>     'ql1_ij_patt_imgn',                                                        &
8248c8222
< ! Metadata for uwind_ij_patt_imgn
---
> ! Metadata for wind_ij_patt_imgn
8250,8263c8224
< DATA metadata(638) / var_metadata(                                             &
< ! String identifier
<     'uwind_ij_patt_imgn',                                                      &
< ! Variable type
<     var_type_imogen_drive,                                                     &
< ! Long name
<     "imogen uwind pattern",                                                    &
< ! Units
<     "m/s/K"                                                                    &
<   ) /
< !-----------------------------------------------------------------------------
< ! Metadata for vwind_ij_patt_imgn
< !-----------------------------------------------------------------------------
< DATA metadata(639) / var_metadata(                                             &
---
> DATA metadata(636) / var_metadata(                                             &
8265c8226
<     'vwind_ij_patt_imgn',                                                      &
---
>     'wind_ij_patt_imgn',                                                       &
8269c8230
<     "imogen vwind pattern",                                                    &
---
>     "imogen wind pattern",                                                     &
8276c8237
< DATA metadata(640) / var_metadata(                                             &
---
> DATA metadata(637) / var_metadata(                                             &
8289c8250
< DATA metadata(641) / var_metadata(                                             &
---
> DATA metadata(638) / var_metadata(                                             &
8300c8261
< ! Metadata for diurnal_t1p5m_ij_patt_imgn
---
> ! Metadata for diurnal_tl1_ij_patt_imgn
8302c8263
< DATA metadata(642) / var_metadata(                                             &
---
> DATA metadata(639) / var_metadata(                                             &
8304c8265
<     'diurnal_t1p5m_ij_patt_imgn',                                              &
---
>     'diurnal_tl1_ij_patt_imgn',                                                &
8315c8276
< DATA metadata(643) / var_metadata(                                             &
---
> DATA metadata(640) / var_metadata(                                             &
8328c8289
< DATA metadata(644) / var_metadata(                                             &
---
> DATA metadata(641) / var_metadata(                                             &
8341c8302
< DATA metadata(645) / var_metadata(                                             &
---
> DATA metadata(642) / var_metadata(                                             &
8354c8315
< DATA metadata(646) / var_metadata(                                             &
---
> DATA metadata(643) / var_metadata(                                             &
8367c8328
< DATA metadata(647) / var_metadata(                                             &
---
> DATA metadata(644) / var_metadata(                                             &
8380c8341
< DATA metadata(648) / var_metadata(                                             &
---
> DATA metadata(645) / var_metadata(                                             &
8393c8354
< DATA metadata(649) / var_metadata(                                             &
---
> DATA metadata(646) / var_metadata(                                             &
8406c8367
< DATA metadata(650) / var_metadata(                                             &
---
> DATA metadata(647) / var_metadata(                                             &
8419c8380
< DATA metadata(651) / var_metadata(                                             &
---
> DATA metadata(648) / var_metadata(                                             &
8432c8393
< DATA metadata(652) / var_metadata(                                             &
---
> DATA metadata(649) / var_metadata(                                             &
8445c8406
< DATA metadata(653) / var_metadata(                                             &
---
> DATA metadata(650) / var_metadata(                                             &
8458c8419
< DATA metadata(654) / var_metadata(                                             &
---
> DATA metadata(651) / var_metadata(                                             &
8469c8430
< ! Metadata for l_growth_gb
---
> ! Metadata for atmospheric deposition parameters: Aerodynamic resistance, Ra
8471c8432
< DATA metadata(655) / var_metadata(                                             &
---
> DATA metadata(652)/var_metadata(                                               &
8473c8434
<     'l_growth_gb',                                                             &
---
>     'deposition_ra',                                                           &
8475c8436
<     var_type_surface,                                                          &
---
>     var_type_surft,                                                            &
8477c8438
<     "Growth (average) absorbed light for C3 photosynthesis",                   &
---
>     "Aerodynamic resistance (Ra) by surface type",                             &
8479,8480c8440,8441
<     "molPhoton m-2 s-1"                                                        &
<   ) /
---
>     "s m-1"                                                                    &
>   )/
8482c8443
< ! Metadata for vpd_growth_gb
---
> ! Metadata for atmospheric deposition parameters: Quasi-laminar resistance, Rb
8484c8445
< DATA metadata(656) / var_metadata(                                             &
---
> DATA metadata(653)/var_metadata(                                               &
8486c8447
<     'vpd_growth_gb',                                                           &
---
>     'deposition_rb',                                                           &
8488c8449
<     var_type_surface,                                                          &
---
>     var_type_dep_species,                                                      &
8490c8451
<     "Growth (average) vapour pressure deficit for C3 photosynthesis",          &
---
>     "Quasi-laminar resistance (Rb) by deposited chemical species",             &
8492,8493c8453,8454
<     "Pascal"                                                                   &
<   ) / 
---
>     "s m-1"                                                                    &
>   )/
8495c8456
< ! Metadata for co2_growth_gb
---
> ! Metadata for atmospheric deposition parameters: Surface resistance, Rc
8497c8458
< DATA metadata(657) / var_metadata(                                             &
---
> DATA metadata(654)/var_metadata(                                               &
8499c8460
<     'co2_growth_gb',                                                           &
---
>     'deposition_rc',                                                           &
8501c8462
<     var_type_surface,                                                          &
---
>     var_type_surft_dep_species,                                                &
8503c8464
<     "Growth (average) co2 for C3 photosynthesis",                              &
---
>     "Surface resistance (Rc) by surface type and deposited chemical species",  &
8505,8507c8466,8467
<     "Mol mol-1"                                                                &
<   ) / 
< ! Metadata for co2_growth_gb
---
>     "s m-1"                                                                    &
>   )/
8509,8518c8469,8470
< DATA metadata(658) / var_metadata(                                             &
< ! String identifier
<     'pstar_growth_gb',                                                         &
< ! Variable type
<     var_type_surface,                                                          &
< ! Long name
<     "Growth (average) surface pressure for C3 photosynthesis",                 &
< ! Units
<     "Pa"                                                                       &
<   ) / 
---
> ! Metadata for atmospheric deposition parameters:  Surface resistance, Rc
> ! stomatal component
8520c8472
< DATA metadata(659) / var_metadata(                                             &
---
> DATA metadata(655)/var_metadata(                                               &
8522c8474
<     'xipam_opt',                                                               &
---
>     'deposition_rc_stom',                                                      &
8524c8476
<     var_type_surface,                                                          &
---
>     var_type_surft_dep_species,                                                &
8526c8478,8479
<     "Sensitivity of ci/ca ratio to VPD at optimal condition (Pa^1/2)",         &
---
>     "Surface resistance (Rc) - stomatal component, " //                        &
>     "by surface type and deposited chemical species",                          &
8528,8529c8481,8482
<     "Pa^1/2"                                                                   &
<   ) / 
---
>     "s m-1"                                                                    &
>   )/
8531,8540c8484,8485
< DATA metadata(660) / var_metadata(                                             &
< ! String identifier
<     'vcmax_opt',                                                               &
< ! Variable type
<     var_type_surface,                                                          &
< ! Long name
<     "Maximum rate of carboxylation at optimal condition",                      &
< ! Units
<     "mol CO2/m2s"                                                              &
<   ) / 
---
> ! Metadata for atmospheric deposition parameters: Surface resistance, Rc
> ! non-stomatal component
8542c8487
< DATA metadata(661) / var_metadata(                                             &
---
> DATA metadata(656)/var_metadata(                                               &
8544c8489
<     'jmax_opt',                                                                &
---
>     'deposition_rc_nonstom',                                                   &
8546c8491
<     var_type_surface,                                                          &
---
>     var_type_surft_dep_species,                                                &
8548c8493,8494
<     "! Maximum rate of electron transport at optimal condition",               &
---
>     "Surface resistance (Rc) - non-stomatal component, " //                    &
>     "by surface type and deposited chemical species",                          &
8550,8551c8496,8497
<     "mol m-2 s-1"                                                              &
<   ) / 
---
>     "s m-1"                                                                    &
>   )/
8553,8562c8499
< DATA metadata(662) / var_metadata(                                             &
< ! String identifier
<     't_sum',                                                                   &
< ! Variable type
<     var_type_surface,                                                          &
< ! Long name
<     "! Sum of temperature for noon condition",                                 &
< ! Units 
<     "K"                                                                        &
<   ) / 
---
> ! Metadata for atmospheric deposition parameters: Deposition velocity, vd
8564c8501
< DATA metadata(663) / var_metadata(                                             &
---
> DATA metadata(657)/var_metadata(                                               &
8566c8503
<     'l_sum',                                                                   &
---
>     'deposition_vd',                                                           &
8568c8505
<     var_type_surface,                                                          &
---
>     var_type_surft_dep_species,                                                &
8570c8507
<     "! Sum of light for noon condition",                                       &
---
>     "Deposition velocity by surface type and deposited chemical species",      &
8572,8573c8509,8510
<     "mol m-2 s-1"                                                              &
<   ) / 
---
>     "m s-1"                                                                    &
>   )/
8575,8584c8512
< DATA metadata(664) / var_metadata(                                             &
< ! String identifier
<     't_night',                                                                 &
< ! Variable type
<     var_type_surface,                                                          &
< ! Long name
<     "! average temperature for night condition",                               &
< ! Units
<     "K"                                                                        &
<   ) / 
---
> ! Metadata for atmospheric deposition parameters: Deposition loss rate
8586c8514
< DATA metadata(665) / var_metadata(                                             &
---
> DATA metadata(658)/var_metadata(                                               &
8588c8516
<     'nt_sum',                                                                  &
---
>     'deposition_lossrate',                                                     &
8590c8518
<     var_type_surface,                                                          &
---
>     var_type_dep_species,                                                      &
8592c8520
<     "! Sum of temperature for night condition",                                &
---
>     "Deposition loss rate by deposited chemical species",                      &
8594,8595c8522,8523
<     "K"                                                                        &
<   ) / 
---
>     "s-1"                                                                      &
>   )/
8597,8606c8525
< DATA metadata(666) / var_metadata(                                             &
< ! String identifier
<     'vpd_sum',                                                                 &
< ! Variable type
<     var_type_surface,                                                          &
< ! Long name
<     "! Sum of vpd for noon condition",                                         &
< ! Units
<     "Pa"                                                                       &
<   ) /
---
> ! Metadata for atmospheric deposition parameters: Deposition flux
8608c8527
< DATA metadata(667) / var_metadata(                                             &
---
> DATA metadata(659)/var_metadata(                                               &
8610c8529
<     'co2_sum',                                                                 &
---
>     'deposition_flux',                                                         &
8612c8531
<     var_type_surface,                                                          &
---
>     var_type_dep_species,                                                      &
8614c8533
<     "Sum of co2 for noon condition",                                           &
---
>     "Deposition flux by deposited chemical species",                           &
8616,8617c8535,8536
<     "Pa"                                                                       &
<   ) /
---
>     "kg m-3 s-1"                                                               &
>   )/
8619c8538,8540
< DATA metadata(668) / var_metadata(                                             &
---
> ! Metadata for imogen imogen_radf
> !-----------------------------------------------------------------------------
> DATA metadata(660) / var_metadata(                                             &
8621c8542
<     'pstar_sum',                                                               &
---
>     'imogen_radf',                                                             &
8625c8546,8547
<     "Sum of atmospheric pressure for noon condition",                          &
---
>     "Radiative forcing in IMOGEN " //                                          &
>     "(repeated global value)",                                                 &
8627,8628c8549,8550
<     "Pa"                                                                       &
<   ) / 
---
>     "W/m2"                                                                     &
>   ) /
8630c8552
< ! Metadata for t_growth.
---
> ! Metadata for imogen dtemp_g
8632c8554
< DATA metadata(669) / var_metadata(                                             &
---
> DATA metadata(661) / var_metadata(                                             &
8634c8556
<     't_growth',                                                                &
---
>     'dtemp_g',                                                                 &
8638c8560,8561
<     "Gridbox growth temperature",                                              &
---
>     "Global temperature change in IMOGEN " //                                  &
>     "(repeated global value)",                                                 &
8643c8566
< ! Metadata for l_growth.
---
> ! Metadata for imogen dctot_co2
8645c8568
< DATA metadata(670) / var_metadata(                                             &
---
> DATA metadata(662) / var_metadata(                                             &
8647c8570
<     'l_growth',                                                                &
---
>     'dctot_co2',                                                               &
8651c8574,8575
<     "Gridbox growth light",                                                    &
---
>     "Change in C as CO2 in IMOGEN " //                                         &
>     "(repeated global value)",                                                 &
8653,8654c8577,8578
<     "w m-2"                                                                    &
<   ) /
---
>     "kg m-2 per 360days"                                                       &
>  )/
8656c8580
< ! Metadata for co2_growth.
---
> ! Metadata for imogen dctot_ch4
8658c8582
< DATA metadata(671) / var_metadata(                                             &
---
> DATA metadata(663) / var_metadata(                                             &
8660c8584
<     'co2_growth',                                                              &
---
>     'dctot_ch4',                                                               &
8664c8588,8589
<     "Gridbox growth co2 pressure",                                             &
---
>     "Change in C as CH4 in IMOGEN " //                                         &
>     "(repeated global value)",                                                 &
8666c8591
<     "pa"                                                                       &
---
>     "kg m-2 per 360days"                                                       &
8669c8594
< ! Metadata for pstar_growth.
---
> ! Metadata for rivers_outflow_number
8671c8596
< DATA metadata(672) / var_metadata(                                             &
---
> DATA metadata(664) / var_metadata(                                             &
8673c8598
<     'pstar_growth',                                                            &
---
>     'rivers_outflow_number',                                                   &
8676,8679c8601,8602
< ! Long name
<     "Gridbox growth atmosphere pressure",                                      &
< ! Units
<     "pa"                                                                       &
---
> ! Variable is not available for output, so give dummy values for long name and units
>     "", ""                                                                     &
8682c8605
< ! Metadata for vpd_growth.
---
> ! Metadata for outflow_per_river
8684c8607
< DATA metadata(673) / var_metadata(                                             &
---
> DATA metadata(665) / var_metadata(                                             &
8686c8609
<     'vpd_growth',                                                              &
---
>     'outflow_per_river',                                                       &
8688c8611
<     var_type_surface,                                                          &
---
>     var_type_rp,                                                               &
8690c8613
<     "Gridbox growth vpd",                                                      &
---
>     "River outflow into the ocean for each river",                             &
8692c8615
<     "pa"                                                                       &
---
>     "kg s-1"                                                                   &
8695c8618
< ! Metadata for xipam_gb.
---
> ! Metadata for rivers_outflow_rp
8697c8620
< DATA metadata(674) / var_metadata(                                             &
---
> DATA metadata(666) / var_metadata(                                             &
8699c8622
<     'xipam_gb',                                                                &
---
>     'rivers_outflow_rp',                                                       &
8701c8624
<     var_type_surface,                                                          &
---
>     var_type_rp,                                                               &
8703c8626
<     "Gridbox growth Sensitivity of ci/ca ratio to VPD ",                       & 
---
>     "River outflow on river routing grid",                                     &
8705c8628
<     "Pa^1/2 "                                                                  &
---
>     "kg s-1"                                                                   &
8708c8631
< ! Metadata for jmax25_gb.
---
> ! Metadata for projection_x_coord
8710c8633
< DATA metadata(675) / var_metadata(                                             &
---
> DATA metadata(667) / var_metadata(                                             &
8712c8635
<     'jmax25_gb',                                                               &
---
>     'projection_x_coord',                                                      &
8716,8718c8639,8641
<     "Gridbox Growth Maximum rate of electron transport normalirsed at 25 degrees" ,  & 
< ! Units
<     "mol m-2 s-1"                                                              &
---
>     "Projection coordinate in the x direction",                                &
> ! Units are unknown - they can vary between grids. Make dimensionless.
>     "1"                                                                        &
8721c8644
< ! Metadata for vcmax25_gb.
---
> ! Metadata for projection_y_coord
8723c8646
< DATA metadata(676) / var_metadata(                                             &
---
> DATA metadata(668) / var_metadata(                                             &
8725c8648
<     'vcmax25_gb',                                                              &
---
>     'projection_y_coord',                                                      &
8729,8731c8652,8654
<     "Gridbox Growth Maximum rate of carboxylation normalise at 25 degrees" ,   & 
< ! Units
<     "mol CO2/m2s"                                                              &
---
>     "Projection coordinate in the y direction",                                &
> ! Units are unknown - they can vary between grids. Make dimensionless.
>     "1"                                                                        &
8734,8773c8657,8658
< ! Metadata for gpp_lyr
< !-----------------------------------------------------------------------------
< DATA metadata(677)/var_metadata(                                              &
< ! String identifier
<     'gpp_lyr',                                                                &
< ! Variable type
<     var_type_canlayer,                                                        &
< ! Long name
<     "PFT gross primary productivity layer profile",                           &
< ! Units
<     "kg m-2 s-1"                                                              &
<   )/  
< !-----------------------------------------------------------------------------
< ! Metadata for apar_lyr
< !-----------------------------------------------------------------------------
< DATA metadata(678)/var_metadata(                                              &
< ! String identifier
<     'apar_lyr',                                                               &
< ! Variable type
<     var_type_canlayer,                                                        &
< ! Long name
<     "PFT absorbed PAR layer profile",                                         &
< ! Units
<     "W m-2"                                                                   &
<   )/  
< !-----------------------------------------------------------------------------
< ! Metadata for cmpf_lyr
< !-----------------------------------------------------------------------------
< DATA metadata(679)/var_metadata(                                              &
< ! String identifier
<     'cmpf_lyr',                                                               &
< ! Variable type
<     var_type_canlayer,                                                        &
< ! Long name
<     "PFT CO2 compensation point correction factor layer profile",             &
< ! Units
<     "Unitless"                                                                &
<   )/  
< !-----------------------------------------------------------------------------
< ! Metadata for ej_lyr
---
> ! Metadata for rivers_x_coord_rp
> ! Not available for input.
8775,8788c8660
< DATA metadata(680)/var_metadata(                                              &
< ! String identifier
<     'ej_lyr',                                                                 &
< ! Variable type
<     var_type_canlayer,                                                        &
< ! Long name
<     "PFT electron transport layer profile",                                   &
< ! Units
<     "mol m-2 s-1"                                                             &
<   )/  
< !-----------------------------------------------------------------------------
< ! Metadata for wlite_lyr
< !-----------------------------------------------------------------------------
< DATA metadata(681)/var_metadata(                                              &
---
> DATA metadata(669) / var_metadata(                                             &
8790c8662
<     'wlite_lyr',                                                             &
---
>     'rivers_x_coord_rp',                                                       &
8792c8664
<     var_type_canlayer,                                                        &
---
>     var_type_rp,                                                               &
8794,8797c8666,8669
<     "PFT Light-limited gross photosynthetic-rate profile",                    &
< ! Units
<     "mol CO2 m-2 s-1"                                                         &
<   )/  
---
>     "Projection coordinate in the x direction for river points",               &
> ! Units are unknown - they can vary between grids. Make dimensionless.
>     "1"                                                                        &
>   ) /
8799c8671,8672
< ! Metadata for wmin_lyr
---
> ! Metadata for rivers_y_coord_rp
> ! Not available for input.
8801c8674
< DATA metadata(682)/var_metadata(                                              &
---
> DATA metadata(670) / var_metadata(                                             &
8803c8676
<     'wmin_lyr',                                                               &
---
>     'rivers_y_coord_rp',                                                       &
8805c8678
<     var_type_canlayer,                                                        &
---
>     var_type_rp,                                                               &
8807,8810c8680,8683
<     "PFT Minimum of gross photosynthetic-rates profile",                      &
< ! Units
<     "mol CO2 m-2 s-1"                                                         &
<   )/  
---
>     "Projection coordinate in the y direction for river points",               &
> ! Units are unknown - they can vary between grids. Make dimensionless.
>     "1"                                                                        &
>   ) /
8812c8685
< ! Metadata for vcmax_lyr
---
> ! Metadata for f_nsc
8814c8687
< DATA metadata(683)/var_metadata(                                              &
---
> DATA metadata(671) / var_metadata(                                             &
8816c8689
<     'vcmax_lyr',                                                               &
---
>     'f_nsc',                                                                   &
8818c8691
<     var_type_canlayer,                                                        &
---
>     var_type_pft,                                                              &
8820c8693
<     "PFT vcmax per layer profile",                      &
---
>     "PFT Non-structural carbohydrate mass fraction",                           &
8822,8823c8695,8696
<     "mol CO2 m-2 s-1"                                                         &
<   )/  
---
>     "kg kg-1"                                                                  &
>   ) /
8825c8698
< ! Metadata for vcmax25_lyr
---
> ! Metadata for growth_sug
8827c8700
< DATA metadata(684)/var_metadata(                                              &
---
> DATA metadata(672) / var_metadata(                                             &
8829c8702
<     'vcmax25_lyr',                                                               &
---
>     'growth_sug',                                                              &
8831c8704
<     var_type_canlayer,                                                        &
---
>     var_type_pft,                                                              &
8833c8706
<     "PFT vcmax25 per layer profile",                      &
---
>     "PFT Net growth of structural carbon pool",                                &
8835,8836c8708,8709
<     "mol CO2 m-2 s-1"                                                         &
<   )/  
---
>     "kg m-2 s-1"                                                               &
>   ) /
8838c8711
< ! Metadata for wcarb_lyr
---
> ! Metadata for canopy water potential
8840c8713
< DATA metadata(685)/var_metadata(                                              &
---
> DATA metadata(673) / var_metadata(                                             &
8842c8715
<     'wcarb_lyr',                                                               &
---
>     'lwp_c',                                                                   &
8844c8717
<     var_type_canlayer,                                                        &
---
>     var_type_pft,                                                              &
8846c8719
<     "PFT carbon limited photosynthesis rate per layer profile",                      &
---
>     "PFT Canopy water potential",                                              &
8848,8849c8721,8722
<     "mol CO2 m-2 s-1"                                                         &
<   )/ 
---
>     "MPa"                                                                      &
>   ) /
diff -r vn7.0copy1_c4/src/./io/output/internal_open_output_file.inc vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./io/output/internal_open_output_file.inc
14c14,15
< USE mpi, ONLY: mpi_comm_world, mpi_info_null
---
> USE mpi, ONLY: mpi_info_null
> USE jules_vars_mod, ONLY: mpi_local_comm
26a28,29
> USE model_grid_mod, ONLY: l_coord_latlon
> 
33c36
< !-----------------------------------------------------------------------------
---
> !------------------------------------------------------------------------------
44c47
< !-----------------------------------------------------------------------------
---
> !------------------------------------------------------------------------------
80,83c83,90
< TYPE(data_cube) :: lat_cube, lon_cube, land_frac_cube  ! Cubes for lat/lon data
< REAL :: point_lat, point_lon  ! Real values for lat/lon of single point
<                               ! for ASCII files
< INTEGER :: lat_id, lon_id, land_frac_id  ! Id of lat/lon variable in file for NetCDF files
---
> TYPE(data_cube) :: lat_cube, lon_cube, land_frac_cube, xcoord_cube, ycoord_cube
>   ! Cubes for coordinate and land fraction data.
> 
> REAL :: point_lat, point_lon, point_xcoord, point_ycoord
>   ! Real values for coordinates of single point for ASCII files.
> 
> INTEGER :: lat_id, lon_id, land_frac_id, xcoord_id, ycoord_id
>   ! IDs of coordinate and land_frac variables in file for NetCDF files
100,106c107,115
<                                     output_period, .FALSE.,                    &
<     ! If is_time_template = T, file_name will be used as a time template
<                                       is_time_template, file_name,             &
<     ! If is_time_template = F, file_names and file_times will be used
<     ! So we give a single file name starting at the start of the file (i.e. one
<     ! file for all output)
<                                       [ file_name ], [ file_start ])
---
>                             output_period, .FALSE.,                            &
>                             ! If is_time_template = T, file_name will be used
>                             ! as a time template
>                             is_time_template, file_name,                       &
>                             ! If is_time_template = F, file_names and
>                             ! file_times will be used. We give a single file
>                             ! name starting at the start of the file (i.e. one
>                             ! file for all output)
>                             [ file_name ], [ file_start ])
110,118c119,130
<                                   output_period, .FALSE.,                      &
<   ! If is_time_template = T, file_name will be used as a time template
<                                     is_time_template, file_name,               &
<   ! If is_time_template = F, file_names and file_times will be used
<   ! So we give a single file name starting at the start of the file (i.e. one
<   ! file for all output)
<                                     [ file_name ], [ file_start ],             &
<   ! Pass MPI variables to file_ts_open so that parallel I/O will be used
<                                     mpi_comm_world, mpi_info_null)
---
>                           output_period, .FALSE.,                              &
>                           ! If is_time_template = T, file_name will be used
>                           ! as a time template
>                           is_time_template, file_name,                         &
>                           ! If is_time_template = F, file_names and
>                           ! file_times will be used. We give a single file
>                           ! name starting at the start of the file (i.e. one
>                           ! file for all output)
>                           [ file_name ], [ file_start ],                       &
>                           ! Pass MPI variables to file_ts_open so that
>                           ! parallel I/O will be used.
>                           mpi_local_comm, mpi_info_null)
147,148c159,160
< ! Get the latitude and longitude data cubes, choose the correct variable for
< ! the required grid.
---
> ! Get coordinate data cubes, choosing the correct variable for the required
> ! grid.
158a171,175
>   IF ( .NOT. l_coord_latlon ) THEN
>     ! Get projection coordinate values.
>     xcoord_cube = extract_var(get_var_id('rivers_x_coord_rp'))
>     ycoord_cube = extract_var(get_var_id('rivers_y_coord_rp'))
>   END IF
162c179,186
<   IF ( l_land_frac ) land_frac_cube = extract_var(get_var_id('land_fraction'))
---
>   IF ( l_land_frac ) THEN
>     land_frac_cube = extract_var(get_var_id('land_fraction'))
>   END IF
>   IF ( .NOT. l_coord_latlon ) THEN
>     ! Get projection coordinate values.
>     xcoord_cube = extract_var(get_var_id('projection_x_coord'))
>     ycoord_cube = extract_var(get_var_id('projection_y_coord'))
>   END IF
182a207,216
>   ! Populate projection coordinates.
>   IF ( .NOT. l_coord_latlon ) THEN
>     CALL cube_get_data(xcoord_cube, point_xcoord)
>     CALL cube_get_data(ycoord_cube, point_ycoord)
>     CALL file_ts_def_attr(out_file, attr_global, 'projection_x_coord',         &
>                           point_xcoord)
>     CALL file_ts_def_attr(out_file, attr_global, 'projection_y_coord',         &
>                           point_ycoord)
>   END IF
> 
185,192c219,222
<   CALL internal_define_var(                                                    &
<     out_file, defined_dims, get_var_id('latitude'), 'latitude', .FALSE., lat_id&
<   )
< 
<   CALL internal_define_var(                                                    &
<     out_file, defined_dims, get_var_id('longitude'), 'longitude', .FALSE., lon_id &
<   )
< 
---
>   CALL internal_define_var( out_file, defined_dims, get_var_id('latitude'),    &
>                             'latitude', .FALSE., lat_id )
>   CALL internal_define_var( out_file, defined_dims, get_var_id('longitude'),   &
>                             'longitude', .FALSE., lon_id )
194,197c224,226
<     CALL internal_define_var(                                                  &
<        out_file, defined_dims, get_var_id('land_fraction'), 'land_fraction',   &
<        .FALSE., land_frac_id                                                   &
<        )
---
>     CALL internal_define_var( out_file, defined_dims,                          &
>                               get_var_id('land_fraction'), 'land_fraction',    &
>                              .FALSE., land_frac_id )
200,201c229,240
<   ! No default case, so that using a format other than those defined is a definite
<   ! error
---
>   ! Populate projection coordinates.
>   IF ( .NOT. l_coord_latlon ) THEN
>     CALL internal_define_var( out_file, defined_dims,                          &
>                               get_var_id('projection_x_coord'),                &
>                              'projection_x_coord', .FALSE., xcoord_id )
>     CALL internal_define_var( out_file, defined_dims,                          &
>                               get_var_id('projection_y_coord'),                &
>                              'projection_y_coord', .FALSE., ycoord_id )
>   END IF
> 
>   ! No default case, so that using a format other than those defined is a
>   ! definite error.
216,217c255,256
<   ! Add the CF convention "cell_methods" attribute to indicate whether the field
<   ! type of output
---
>   ! Add the CF convention "cell_methods" attribute to indicate the field type
>   ! of output.
254c293
< ! Fill the latitude and longitude if we need to
---
> ! Fill the coordinate variables if we need to
262a302
> 
265c305
<     ! the master task
---
>     ! the master task.
267,279c307,320
<       CALL file_ts_write_var(                                                  &
<         out_file, lat_id, lat_cube,                                            &
<       ! Subgrid information (for writing a slab of the output grid in
<       ! parallel mode)
<               .FALSE.                                                          &
<             )
<       CALL file_ts_write_var(                                                  &
<         out_file, lon_id, lon_cube,                                            &
<       ! Subgrid information (for writing a slab of the output grid in
<       ! parallel mode)
<               .FALSE.                                                          &
<             )
<     END IF
---
>       ! For all these calls we pass .FALSE. to cover subgrid information (for
>       ! writing a slab of the output grid in parallel mode).
>       CALL file_ts_write_var( out_file, lat_id, lat_cube,                      &
>                               .FALSE. )
>       CALL file_ts_write_var( out_file, lon_id, lon_cube,                      &
>                               .FALSE. )
>       IF ( .NOT. l_coord_latlon ) THEN
>         CALL file_ts_write_var( out_file, xcoord_id, xcoord_cube,              &
>                                 .FALSE. )
>         CALL file_ts_write_var( out_file, ycoord_id, ycoord_cube,              &
>                                 .FALSE. )
>       END IF
>     END IF  !  is_master_task
> 
282,293c323,328
<     CALL file_ts_write_var(                                                    &
<       out_file, lat_id, lat_cube,                                              &
<     ! Subgrid information (for writing a slab of the output grid in
<     ! parallel mode)
<             use_subgrid, subgrid                                               &
<           )
<     CALL file_ts_write_var(                                                    &
<       out_file, lon_id, lon_cube,                                              &
<     ! Subgrid information (for writing a slab of the output grid in
<     ! parallel mode)
<             use_subgrid, subgrid                                               &
<           )
---
>     ! For all these calls we pass subgrid information (use_subgrid and subgrid)
>     ! to allow writing a slab of the output grid in parallel mode.
>     CALL file_ts_write_var( out_file, lat_id, lat_cube,                        &
>                             use_subgrid, subgrid )
>     CALL file_ts_write_var( out_file, lon_id, lon_cube,                        &
>                             use_subgrid, subgrid )
296,301c331,338
<       CALL file_ts_write_var(                                                  &
<          out_file, land_frac_id, land_frac_cube,                               &
<          ! Subgrid information
<          ! (for writing a slab of the output grid in parallel mode)
<          use_subgrid, subgrid                                                  &
<          )
---
>       CALL file_ts_write_var( out_file, land_frac_id, land_frac_cube,          &
>                               use_subgrid, subgrid )
>     END IF
>     IF ( .NOT. l_coord_latlon ) THEN
>       CALL file_ts_write_var( out_file, xcoord_id, xcoord_cube,                &
>                               use_subgrid, subgrid )
>       CALL file_ts_write_var( out_file, ycoord_id, ycoord_cube,                &
>                               use_subgrid, subgrid )
316c353,359
< IF ( l_land_frac ) CALL cube_free(land_frac_cube)
---
> IF ( l_land_frac ) THEN
>   CALL cube_free(land_frac_cube)
> END IF
> IF ( .NOT. l_coord_latlon ) THEN
>   CALL cube_free(xcoord_cube)
>   CALL cube_free(ycoord_cube)
> END IF
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./io: rivers-standalone
diff -r vn7.0copy1_c4/src/./params/cable/cable_maths_constants_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./params/cable/cable_maths_constants_mod.F90
1c1,9
< MODULE cable_maths_constants_mod
---
> !******************************************************************************
> ! This source code is part of the Community Atmosphere Biosphere Land Exchange
> ! (CABLE) model. This work is licensed under the CSIRO Open Source Software
> ! License Agreement (variation of the BSD / MIT License).You may not use this
> ! this file except in compliance with this License.
> ! A copy of the License (CSIRO_BSD_MIT_License_v2.0_CABLE.txt) can be found
> ! at https://github.com/CABLE-LSM/CABLE/blob/main/
> !******************************************************************************
> MODULE cable_math_constants_mod
3,7c11
< IMPLICIT NONE
< 
< PUBLIC
< 
< !-----------------------------------------------------------------------------
---
> !------------------------------------------------------------------------------
9c13
< !   CABLE mathematical constants
---
> !   Mathematical constants used in CABLE.
11,13c15,28
< ! Code Owner: Please refer to ModuleLeaders.txt
< ! This file belongs in CABLE SCIENCE
< !-----------------------------------------------------------------------------
---
> ! This MODULE is USEd in:
> !     surf_couple_radiation_mod.F90 (JULES),
> !     cable_cbm.F90 (ESM1.5),
> !     cable_rad_driver.F90 (ESM1.5),
> !     cbl_model_driver_offline.F90 (CABLE),
> !     cable_canopy.F90 (CABLE),
> !     cable_gw_hydro.F90 (CABLE),
> !     cbl_sinbet.F90 (CABLE)
> !
> ! Module specific documentation:https://trac.nci.org.au/trac/cable/wiki/TBC
> ! Where it fits in the model flow:https://trac.nci.org.au/trac/cable/wiki/TBC
> !------------------------------------------------------------------------------
> 
> IMPLICIT NONE
14a30
> PUBLIC
15a32,33
> REAL, PARAMETER :: pi    = 3.1415927
> REAL, PARAMETER :: pi180 = pi / 180.0 ! radians / degree
diff -r vn7.0copy1_c4/src/./params/cable/cable_other_constants_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./params/cable/cable_other_constants_mod.F90
0a1,7
> !******************************************************************************
> ! This source code is part of the Community Atmosphere Biosphere Land Exchange
> ! (CABLE) model. This work is licensed under the CSIRO Open Source Software
> ! License Agreement (variation of the BSD / MIT License).You may not use this
> ! this file except in compliance with this License. A copy of the License is
> ! available at https://trac.nci.org.au/trac/cable/wiki/license.
> !******************************************************************************
3,6d9
< IMPLICIT NONE
< 
< PUBLIC
< 
11,12c14,17
< ! Code Owner: Please refer to ModuleLeaders.txt
< ! This file belongs in CABLE SCIENCE
---
> ! This MODULE is USEd throughout CABLE
> !
> ! Module specific documentation:https://trac.nci.org.au/trac/cable/wiki/TBC
> ! Where it fits in the model flow:https://trac.nci.org.au/trac/cable/wiki/TBC
13a19,29
> !CABLE science not yet in JAC uses msn to describe number of snow layers
> USE grid_constants_mod_cbl, ONLY: nrb, nsl, nsCs, nvCs, msn => nsnl
> 
> IMPLICIT NONE
> 
> PUBLIC
> 
> REAL, PARAMETER :: gauss_w(nrb)=[0.308,0.514,0.178 ] ! Gaussian integ. weights
> 
> REAL, PARAMETER :: rad_thresh = 0.001 ! min. zenithal angle for downward SW
> REAL, PARAMETER :: lai_thresh = 0.001 ! min. LAI to be considered as vegetated
17c33
<                        !   near infrared)
---
>                        ! near infrared)
19,20c35
<                        !   (above divided into direct / diffuse)
<   nrb = 3,           & ! number of radiation bands normally in use
---
>                        ! (above divided into direct / diffuse)
22,23c37
<   msn = 3,           & ! max # snow layers
<   r_2  = SELECTED_REAL_KIND(12, 50),                                           &
---
>   r_2  = SELECTED_REAL_KIND(12, 50), &!this will be removed
26,28d39
<   nsl = 6,           & ! number of soil layers
<   nscs = 2,          & ! number of soil carbon stores
<   nvcs = 3,          & ! number of vegetation carbon stores
36,40c47,51
< REAL, PARAMETER :: gauss_w(nrb)=[0.308,0.514,0.178 ] ! Gaussian integ. weights
< REAL, PARAMETER :: rad_thresh = 0.001
<                         ! minimum zenithal angle for downward SW radiation
< REAL, PARAMETER :: lai_thresh = 0.001
<                         ! threshold for minimum significant LAI
---
> ! minimum (cosine)zenith angle of sun signalling sunrise
> REAL, PARAMETER :: coszen_tols = 1.0e-4
> 
> REAL, PARAMETER :: z0surf_min = 1.0e-7 ! min. roughness of bare soil surface
> !H!REAL, PARAMETER :: z0snow_min = 1.e-7 ! min. roughness of bare snow surface
diff -r vn7.0copy1_c4/src/./params/cable/cable_phys_constants_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./params/cable/cable_phys_constants_mod.F90
0a1,7
> !******************************************************************************
> ! This source code is part of the Community Atmosphere Biosphere Land Exchange
> ! (CABLE) model. This work is licensed under the CSIRO Open Source Software
> ! License Agreement (variation of the BSD / MIT License).You may not use this
> ! this file except in compliance with this License. A copy of the License is
> ! available at https://trac.nci.org.au/trac/cable/wiki/license.
> !******************************************************************************
3,6d9
< IMPLICIT NONE
< 
< PUBLIC
< 
11,13c14,81
< ! Code Owner: Please refer to ModuleLeaders.txt
< ! This file belongs in CABLE SCIENCE
< !-----------------------------------------------------------------------------
---
> ! This MODULE is USEd throughout CABLE.
> !
> ! Module specific documentation:https://trac.nci.org.au/trac/cable/wiki/TBC
> ! Where it fits in the model flow:https://trac.nci.org.au/trac/cable/wiki/TBC
> !******************************************************************************
> 
> IMPLICIT NONE
> 
> PUBLIC
> 
> REAL, PARAMETER :: tfrz   = 273.16        ! Temp (K) corresp. to 0 C
> REAL, PARAMETER :: sboltz = 5.67e-8       ! Stefan-Boltz. const (W/m2/K4)
> REAL, PARAMETER :: emsoil = 1.0           ! soil emissivity
> REAL, PARAMETER :: emleaf = 1.0           ! leaf emissivity
> REAL, PARAMETER :: capp   = 1004.64    ! air spec. heat (J/kg/K)
> REAL, PARAMETER :: hl = 2.5014e6       ! latent heat of vaporization (J/s/m2)
> !Below are constants used in CABLE model which are not as yet used in JAC-6.2
> REAL, PARAMETER :: hlf = 0.334e6          ! latent heat of fusion
> REAL, PARAMETER :: hls = 2.8350e6         ! latent heatOFsublimation (J/kg)
> REAL, PARAMETER :: dheat  = 21.5e-6       ! molecular diffusivity for heat
> REAL, PARAMETER :: grav   = 9.8086        ! gravity acceleration (m/s2)
> REAL, PARAMETER :: rgas   = 8.3143        ! universal gas const  (J/mol/K)
> REAL, PARAMETER :: rmair  = 0.02897       ! molecular wt: dry air (kg/mol)
> REAL, PARAMETER :: rmh2o  = 0.018016      ! molecular wt: water (kg/mol)
> REAL, PARAMETER :: cgsnow = 2090.0        ! specific heat capacity for snow
> REAL, PARAMETER :: cs_rho_ice = 1.9341e6  !heat capacity * density ice
> REAL, PARAMETER :: cs_rho_wat = 4.218e6   ! heat capacity * density  water
> REAL, PARAMETER :: csice = 2.100e3        ! specific heat capacity for ice
> REAL, PARAMETER :: cswat = 4.218e3        ! specific heat capacity water
> REAL, PARAMETER :: density_liq = 1000.0   ! density of liquid water
> REAL, PARAMETER :: density_ice = 921.0    ! denisty of ice
> 
> ! Teten coefficients
> REAL, PARAMETER :: tetena = 6.106         ! Magnus Tetans (Murray 1967)
> REAL, PARAMETER :: tetenb = 17.27
> REAL, PARAMETER :: tetenc = 237.3
> ! mrd561 the parameters for sat above ice
> REAL, PARAMETER :: tetena_ice = 6.1078    ! ??? refs?
> REAL, PARAMETER :: tetenb_ice = 21.875
> REAL, PARAMETER :: tetenc_ice = 265.5
> 
> ! Aerodynamic parameters, diffusivities, water density:
> REAL, PARAMETER :: vonk   = 0.40          ! von Karman constant
> REAL, PARAMETER :: a33    = 1.25          ! inertial sublayer sw/us
> REAL, PARAMETER :: csw    = 0.50          ! canopy sw decay (Weil theory)
> REAL, PARAMETER :: ctl    = 0.40          ! Wagga wheat (RDD 1992-Challenges)
> REAL, PARAMETER :: apol   = 0.70          ! Polhausen coeff: one-sided plate
> REAL, PARAMETER :: prandt = 0.71          ! Prandtl number: visc/diffh
> REAL, PARAMETER :: schmid = 0.60          ! Schmidt number: visc/diffw
> REAL, PARAMETER :: diffwc = 1.60          ! diffw/diffc = H2O/CO2 diffusivity
> REAL, PARAMETER :: rhow   = 1000.0        ! liquid water density   [kg/m3]
> REAL, PARAMETER :: crd = 0.3              ! element drag coefficient
> REAL, PARAMETER :: csd = 0.003            ! substrate drag coefficient
> 
> !jhan:hardwire for now. note beta2 = crd/csd
> REAL, PARAMETER ::  beta2 = 0.3/0.003     ! ratio cr/cs
> REAL, PARAMETER ::  ccd   = 15.0          ! constant in d/h equation
> REAL, PARAMETER ::  ccw_c = 2.0           ! ccw=(zw-d)/(h-d)
> REAL, PARAMETER ::  usuhm = 0.3           ! (max of us/uh)
> 
> ! Turbulence parameters:
> REAL, PARAMETER :: zetmul = 0.4     ! if niter=2, final zeta=zetmul*zetar(2)
>                                     ! niter=4 ATM see cable_define_types.F90
> REAL, PARAMETER :: zeta0  = 0.0     ! initial value of za/L
> REAL, PARAMETER :: zetneg = -15.0   ! negative limit on za/L when niter>=3
> REAL, PARAMETER :: zetpos = 1.0     ! positive limit on za/L when niter>=3
> REAL, PARAMETER :: zdlin  = 1.0     ! height frac of d below which TL linear
> REAL, PARAMETER :: umin   = 0.1     ! guarantees convergence, was 0.01
15c83,84
< ! Will be added to as required.
---
> !model parameter shared across subroutines -> cable_phys_constants
> REAL, PARAMETER :: snow_depth_thresh = 1.0
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./params/cable: grid_constants_cbl.F90
diff -r vn7.0copy1_c4/src/./params/imogen/imogen_anlg_vals.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./params/imogen/imogen_anlg_vals.F90
51,56c51,57
<   dir_patt = '',                                                               &
<               ! Directory containing the patterns
<   dir_clim = '',                                                               &
<               ! Directory containing initialising climatology.
<   dir_anom = ''
<               ! Directory containing prescribed anomalies
---
>   file_patt = '',                                                              &
>               ! File containing the patterns
>   file_clim = '',                                                              &
>               ! File containing initialising climatology.
>   file_base_anom = ''
>               ! File containing prescribed anomalies ("name")
>               ! Actual filename is in the form "name_year.nc"
61,62c62,63
<                                  t_ocean_init,dir_patt,                        &
<                                  dir_clim, dir_anom,                           &
---
>                                  t_ocean_init,file_patt,                       &
>                                  file_clim, file_base_anom,                    &
diff -r vn7.0copy1_c4/src/./params/imogen/imogen_constants.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./params/imogen/imogen_constants.F90
32,33d31
< INTEGER, PARAMETER :: n_imogen_land = 1631
<             ! Number of land points in the IMOGEN grid
39c37
< REAL, PARAMETER :: conv = 0.471
---
> REAL, PARAMETER :: conv_gtc_to_ppm = 0.471
43,46d40
< CHARACTER(LEN=4), PARAMETER :: drive_month(12) = ['/jan','/feb','/mar','/apr', &
<                                                   '/may','/jun','/jul','/aug', &
<                                                   '/sep','/oct','/nov','/dec']
<             ! Month labels for reading in files
diff -r vn7.0copy1_c4/src/./params/imogen/imogen_run.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./params/imogen/imogen_run.F90
34c34
<   co2_init_ppmv = 286.085,                                                     &
---
>   co2_init_ppmv = rmdi,                                                        &
49,51d48
<   file_points_order = '',                                                      &
<               ! File containing the mapping of points in the
<               ! IMOGEN grid to the JULES grid
54,55c51,52
<   file_non_co2_vals = '',                                                      &
<               ! If used, file containing non-CO2 values
---
>   file_non_co2_radf = '',                                                      &
>               ! If required, file containing non-CO2 radiative forcing
57c54
<               ! If used, file containing CO2 values
---
>               ! If used, file containing CO2 atm concentrations
72,76c69,70
<   include_non_co2 = .TRUE.,                                                    &
<               ! Are adjustments to non-CO2 values allowed?
<   file_non_co2 = .FALSE.,                                                      &
<               ! If true, then non-CO2 radiative forcings are
<               ! contained within a file.
---
>   include_non_co2_radf = .TRUE.,                                               &
>               ! Are adjustments to radiative forcing from non-CO2 allowed?
83,84c77,87
<   wgen = .FALSE.
<               ! Is the weather generator switched on.
---
>   l_drive_with_global_temps = .FALSE.
>               ! Drive with annual mean global temperatures
>               ! This takes the patterns and makes the driving data by
>               ! combining the global temperatures and the patterns
>               ! also need CO2 concentrations as an input to JULES
>               ! (c_emissions=.FALSE.) There are no feedbacks.
>               ! (land_feed_co2=.FALSE.,land_feed_ch4=.FALSE.,ocean_feed=.FALSE.)
>               ! include_non_co2_radf=.FALSE., include_co2=.FALSE.,
>               ! anom=.TRUE.,anlg=.FALSE.
>               ! need a filename for the time series of global mean temperatures
>               ! and for the co2 concentrations.
91c94
<   initial_co2_ch4_year = 1860,                                                 &
---
>   initial_co2_ch4_year = imdi,                                                 &
109,112c112,114
<                            include_non_co2, land_feed_co2, land_feed_ch4,      &
<                            ocean_feed, wgen, anom, anlg, nyr_non_co2,          &
<                            file_non_co2, file_non_co2_vals, file_ch4_n2o,      &
<                            file_points_order,                                  &
---
>                            include_non_co2_radf, land_feed_co2, land_feed_ch4, &
>                            ocean_feed, anom, anlg, nyr_non_co2,                &
>                            file_non_co2_radf, file_ch4_n2o,                    &
115c117
<                            fch4_ref, tau_ch4_ref, ch4_ppbv_ref
---
>                            l_drive_with_global_temps
diff -r vn7.0copy1_c4/src/./params/standalone/chemistry_constants_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./params/standalone/chemistry_constants_mod.F90
24a25,27
> ! No. of molecules in 1 mole
> REAL, PARAMETER :: avogadro = 6.022e23
> 
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./params/standalone: free_tracers_inputs_jls_mod.F90
diff -r vn7.0copy1_c4/src/./params/standalone/precision_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./params/standalone/precision_mod.F90
26c26
<   REAL32 = SELECTED_REAL_KIND(6, 37),                                          &
---
>   real_32 = SELECTED_REAL_KIND(6, 37),                                         &
28c28
<   REAL64 = SELECTED_REAL_KIND(15, 307),                                        &
---
>   real_64 = SELECTED_REAL_KIND(15, 307),                                       &
30c30
<   INT32 = SELECTED_INT_KIND(9),                                                &
---
>   int_32 = SELECTED_INT_KIND(9),                                               &
32c32
<   INT64 = SELECTED_INT_KIND(15)
---
>   int_64 = SELECTED_INT_KIND(15)
diff -r vn7.0copy1_c4/src/./params/standalone/um_types.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./params/standalone/um_types.F90
12,13c12,13
< USE precision_mod, ONLY: REAL32, REAL64,                                       &
<                           integer32 => INT32, integer64 => INT64
---
> USE precision_mod, ONLY: real_32, real_64,                                     &
>                           integer_32 => int_32, integer_64 => int_64
20,21c20,21
< INTEGER, PARAMETER :: logical64 = integer64
< INTEGER, PARAMETER :: logical32 = integer32
---
> INTEGER, PARAMETER :: logical_64 = integer_64
> INTEGER, PARAMETER :: logical_32 = integer_32
24c24
< INTEGER, PARAMETER :: real_jlslsm = REAL32
---
> INTEGER, PARAMETER :: real_jlslsm = real_32
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science: deposition
diff -r vn7.0copy1_c4/src/./science/fire/canadian_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/fire/canadian_mod.F90
75c75
< ! A number very close to zero to preven nasty underflows. Defined here to be
---
> ! A number very close to zero to prevent nasty underflows. Defined here to be
diff -r vn7.0copy1_c4/src/./science/fire/fire_timestep_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/fire/fire_timestep_mod.F90
8c8
<                          current_time, current_month, timestep_len, land_pts)
---
>                          current_time, current_month, timestep, land_pts)
42c42
< REAL(KIND=real_jlslsm), INTENT(IN)    :: timestep_len
---
> REAL(KIND=real_jlslsm), INTENT(IN)    :: timestep
66c66
< IF ( current_time < timestep_len) THEN
---
> IF ( current_time < NINT(timestep) ) THEN
diff -r vn7.0copy1_c4/src/./science/fire/inferno_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/fire/inferno_mod.F90
552,553c552,554
< USE jules_soil_biogeochem_mod, ONLY: soil_bgc_model, soil_model_rothc,         &
<                                      soil_model_1pool
---
> USE jules_soil_biogeochem_mod, ONLY: soil_bgc_model, soil_model_4pool,         &
>                                      soil_model_1pool, z_burn_max, l_layeredc
> USE jules_soil_mod, ONLY: dzsoil
574a576,583
> REAL(KIND=real_jlslsm) ::                                                      &
>   z2,                                                                          &
>    ! depth of bottom of soil layer for soil C burnt calculation
>   z1,                                                                          &
>    ! depth of top of soil layer for soil C burnt calculation
>   prop_cs_burnt
>    ! proportion of soil carbon burnt
> 
582a592,593
> c_soil_dpm_gb(:) = 0.0
> c_soil_rpm_gb(:) = 0.0
586,587c597,600
< ! In future a layered soil model could pass the near-surface soil C only.
< IF ( soil_bgc_model == soil_model_rothc ) THEN
---
> IF ( soil_bgc_model == soil_model_4pool ) THEN
> 
>   c_soil_dpm_gb(:) = 0.0
>   c_soil_rpm_gb(:) = 0.0
591,596c604,622
<     c_soil_dpm_gb(i) = 0.0
<     c_soil_rpm_gb(i) = 0.0
< 
<     DO n = 1,dim_cslayer
<       c_soil_dpm_gb(i) = c_soil_dpm_gb(i) + cs_pool_soilt(i,m,n,1)
<       c_soil_rpm_gb(i) = c_soil_rpm_gb(i) + cs_pool_soilt(i,m,n,2)
---
>     z2 = 0.0
>     DO n=1,dim_cslayer
>       IF ( l_layeredc ) THEN
>         z1 = z2
>         z2 = z2 + dzsoil(n)
>         prop_cs_burnt = 0.0
>         IF ( z2 <  z_burn_max ) THEN
>           prop_cs_burnt = 1.0
>         ELSE IF ( z2 >= z_burn_max .AND. z1 <  z_burn_max ) THEN
>           prop_cs_burnt = (z_burn_max - z1) / (z2 - z1)
>         END IF
>       ELSE
>         prop_cs_burnt = 1.0
>       END IF
> 
>       c_soil_dpm_gb(i) = c_soil_dpm_gb(i) + cs_pool_soilt(i,m,n,1) *           &
>                                                                   prop_cs_burnt
>       c_soil_rpm_gb(i) = c_soil_rpm_gb(i) + cs_pool_soilt(i,m,n,2) *           &
>                                                                   prop_cs_burnt
diff -r vn7.0copy1_c4/src/./science/params/ccarbon_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/params/ccarbon_mod.F90
23a24,25
> REAL(KIND=real_jlslsm), PARAMETER :: m_water = 18.01528
>                                          ! molecular weight of H20 in g/mol
diff -r vn7.0copy1_c4/src/./science/params/deposition_species_io_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/params/deposition_species_io_mod.F90
1d0
< #if !defined(UM_JULES)
14a14,25
> !-----------------------------------------------------------------------------
> ! Description:
> !   Module containing input species and parameters for the deposition model,
> !     and code for checking their values.
> !
> ! Code Owner: Please refer to ModuleLeaders.txt
> ! This file belongs in BIOGENIC FLUXES.
> !
> ! Code Description:
> !   Language: Fortran 90.
> !-----------------------------------------------------------------------------
> 
16d26
< USE max_dimensions, ONLY: ndep_species_max, ntype_max
18c28,38
< USE um_types, ONLY: real_jlslsm
---
> USE deposition_output_arrays_mod, ONLY: deposition_output_array_real
> 
> USE jules_deposition_mod,   ONLY: ndry_dep_species
> 
> USE jules_print_mgr,  ONLY: jules_print, jules_message, newline
> 
> USE errormessagelength_mod, ONLY: errormessagelength
> 
> USE max_dimensions,         ONLY: ndep_species_max, ntype_max
> 
> USE um_types,               ONLY: real_jlslsm
39,43d58
<   ch4_scaling_io,                                                              &
<     ! Scaling applied to CH4 soil uptake (dimensionless).
<     ! Originally this was used to match the value from the IPCC TAR.
<   cuticle_o3_io,                                                               &
<     ! Constant for calculation of cuticular resistance for ozone (s m-1).
45a61,62
>   dep_species_rmm_io,                                                          &
>     ! Relative molecular mass (g mol-1).
49c66
<   r_tundra_io,                                                                 &
---
>   r_tundra_io
51,52d67
<   r_wet_soil_o3_io
<     ! Wet soil surface resistance for ozone (s m-1).
59,61d73
<   ch4dd_tundra_io(4),                                                          &
<     ! Coefficients of cubic polynomial relating CH4 loss for tundra to
<     ! temperature.
65,73d76
<   h2dd_c_io(ntype_max),                                                        &
<     ! Constant in quadratic function relating hydrogen deposition to soil
<     ! moisture, for each surface type (s m-1).
<   h2dd_m_io(ntype_max),                                                        &
<     ! Coefficient of first order term in quadratic function relating hydrogen
<     ! deposition to soil moisture, for each surface type (s m-1).
<   h2dd_q_io(ntype_max),                                                        &
<     ! Coefficient of second order term in quadratic function relating
<     ! hydrogen deposition to soil moisture, for each surface type (s m-1).
75c78,105
<     ! Surface resistance used in tundra region for each surface type (s m-1).
---
>     ! Standard surface resistance used for each surface type (s m-1).
> 
> #if defined(UM_JULES)
> ! TYPE structure to hold all deposition i/o parameters/variables
> ! For use in coupled/UM-JULES applications
> TYPE :: deposition_io_data_type
>     ! Species-specific parameters/variables
>   REAL(KIND=real_jlslsm) :: ch4_scaling_io
>   REAL(KIND=real_jlslsm) :: ch4_mml_io
>   REAL(KIND=real_jlslsm) :: ch4dd_tundra_io(4)
>   REAL(KIND=real_jlslsm) :: ch4_up_flux_io(ntype_max)
>   REAL(KIND=real_jlslsm) :: cuticle_o3_io
>   REAL(KIND=real_jlslsm) :: h2dd_c_io(ntype_max)
>   REAL(KIND=real_jlslsm) :: h2dd_m_io(ntype_max)
>   REAL(KIND=real_jlslsm) :: h2dd_q_io(ntype_max)
>   REAL(KIND=real_jlslsm) :: r_wet_soil_o3_io
>     ! Parameters/variables with species dimension
>   REAL(KIND=real_jlslsm) :: dd_ice_coeff_io(ndep_species_max, 3)
>   REAL(KIND=real_jlslsm) :: diffusion_coeff_io(ndep_species_max)
>   REAL(KIND=real_jlslsm) :: dep_species_rmm_io(ndep_species_max)
>   REAL(KIND=real_jlslsm) :: diffusion_corr_io(ndep_species_max)
>   REAL(KIND=real_jlslsm) :: r_tundra_io(ndep_species_max)
>   REAL(KIND=real_jlslsm) :: rsurf_std_io(ntype_max, ndep_species_max)
>   CHARACTER(LEN=10)      :: dep_species_name_io(ndep_species_max)
> END TYPE deposition_io_data_type
> 
> TYPE (deposition_io_data_type) :: deposition_io_data_all
> #endif
78c108
< ! Namelist.
---
> ! Namelist
81d110
<   ch4_scaling_io, ch4dd_tundra_io, cuticle_o3_io,                              &
83,84c112
<   diffusion_corr_io, h2dd_c_io, h2dd_m_io, h2dd_q_io,                          &
<   r_tundra_io, r_wet_soil_o3_io, rsurf_std_io
---
>   diffusion_corr_io, r_tundra_io, rsurf_std_io, dep_species_rmm_io
86c114
< CHARACTER(LEN=*), PARAMETER, PRIVATE :: ModuleName='DEPOSITION_SPECIES_IO'
---
> CHARACTER(LEN=*), PARAMETER, PRIVATE :: ModuleName='DEPOSITION_SPECIES_IO_MOD'
90,91c118
< !#############################################################################
< 
---
> !-----------------------------------------------------------------------------
93c120
< USE jules_print_mgr, ONLY: jules_print
---
> !-----------------------------------------------------------------------------
96a124
> !Arguments
101,102d128
< CHARACTER(LEN=50000) :: lineBuffer
< 
106,107c132,134
< WRITE(lineBuffer,"(2A)")' dep_species_name_io = ',dep_species_name_io
< CALL jules_print(RoutineName,lineBuffer)
---
> ! Common to all species
> WRITE(jules_message,'(2A)') ' dep_species_name_io = ',dep_species_name_io
> CALL jules_print(RoutineName,jules_message)
109,110c136,137
< WRITE(lineBuffer,"(A,G11.4E2)")' ch4_scaling = ',ch4_scaling_io
< CALL jules_print(RoutineName,lineBuffer)
---
> WRITE(jules_message,'(A,G11.4E2)') ' diffusion_coeff_io = ',diffusion_coeff_io
> CALL jules_print(RoutineName,jules_message)
112,113c139,140
< WRITE(lineBuffer,*)' ch4dd_tundra_io = ',ch4dd_tundra_io(:)
< CALL jules_print(RoutineName,lineBuffer)
---
> WRITE(jules_message,'(A,G11.4E2)') ' dep_species_rmm_io = ',dep_species_rmm_io
> CALL jules_print(RoutineName,jules_message)
115,116c142,143
< WRITE(lineBuffer,"(A,G11.4E2)")' cuticle_o3_io = ',cuticle_o3_io
< CALL jules_print(RoutineName,lineBuffer)
---
> WRITE(jules_message,'(A,G11.4E2)') ' diffusion_corr_io = ',diffusion_corr_io
> CALL jules_print(RoutineName,jules_message)
118,119c145,147
< WRITE(lineBuffer,"(A,G11.4E2)")' r_wet_soil_o3_io = ',r_wet_soil_o3_io
< CALL jules_print(RoutineName,lineBuffer)
---
> WRITE(jules_message,'(A)') ' rsurf_std_io = '
> CALL jules_print(RoutineName,jules_message)
> CALL deposition_output_array_real(ntype_max, rsurf_std_io(:))
121,122c149,150
< WRITE(lineBuffer,"(A,G11.4E2)")' diffusion_coeff_io = ',diffusion_coeff_io
< CALL jules_print(RoutineName,lineBuffer)
---
> WRITE(jules_message,'(A,G11.4E2)') ' r_tundra_io    = ',r_tundra_io
> CALL jules_print(RoutineName,jules_message)
124,125c152,154
< WRITE(lineBuffer,"(A,G11.4E2)")' diffusion_corr_io = ',diffusion_corr_io
< CALL jules_print(RoutineName,lineBuffer)
---
> WRITE(jules_message,'(A,3(G11.4E2,1X))') ' dd_ice_coeff_io  = ',               &
>   dd_ice_coeff_io(:)
> CALL jules_print(RoutineName,jules_message)
127,128c156,157
< WRITE(lineBuffer,*)' dd_ice_coeff_io = ',dd_ice_coeff_io(:)
< CALL jules_print(RoutineName,lineBuffer)
---
> CALL jules_print(RoutineName,                                                  &
>                  '- - - - - - end of namelist - - - - - -')
130,131c159
< WRITE(lineBuffer,*)' h2dd_c_io = ',h2dd_c_io(:)
< CALL jules_print(RoutineName,lineBuffer)
---
> END SUBROUTINE print_nlist_jules_deposition_species
133,134c161,164
< WRITE(lineBuffer,*)' h2dd_m_io = ',h2dd_c_io(:)
< CALL jules_print(RoutineName,lineBuffer)
---
> #if defined(UM_JULES)
> !-----------------------------------------------------------------------------
> SUBROUTINE read_nml_jules_deposition_species (unitnumber)
> !-----------------------------------------------------------------------------
136,137c166,167
< WRITE(lineBuffer,*)' h2dd_q_io = ',h2dd_c_io(:)
< CALL jules_print(RoutineName,lineBuffer)
---
> ! Description:
> !  Read the DEPOSITION_SPECIES namelist
139,140c169,172
< WRITE(lineBuffer,*)' rsurf_std_io = ',rsurf_std_io(:)
< CALL jules_print(RoutineName,lineBuffer)
---
> USE setup_namelist,   ONLY: setup_nml_type
> USE missing_data_mod, ONLY: rmdi
> USE check_iostat_mod, ONLY: check_iostat
> USE UM_parcore,       ONLY: mype
142,143c174,175
< CALL jules_print(RoutineName,                                                  &
<                  '- - - - - - end of namelist - - - - - -')
---
> USE parkind1,         ONLY: jprb, jpim
> USE yomhook,          ONLY: lhook, dr_hook
145c177
< END SUBROUTINE print_nlist_jules_deposition_species
---
> IMPLICIT NONE
147c179,180
< !#############################################################################
---
> ! Subroutine arguments
> INTEGER, INTENT(IN) :: unitnumber
149c182,321
< END MODULE deposition_species_io_mod
---
> INTEGER :: my_comm
> INTEGER :: mpl_nml_type
> INTEGER :: errorstatus
> INTEGER :: icode
> INTEGER :: ispecies
> REAL(KIND=jprb) :: zhook_handle
> 
> CHARACTER(LEN=*), PARAMETER ::                                                 &
>   RoutineName='READ_NML_JULES_DEPOSITION_SPECIES'
> 
> CHARACTER(LEN=errormessagelength) :: iomessage
> 
> INTEGER(KIND=jpim), PARAMETER :: zhook_in  = 0
> INTEGER(KIND=jpim), PARAMETER :: zhook_out = 1
> 
> ! set number of each type of variable in my_namelist_species type
> INTEGER, PARAMETER :: no_of_types = 2
> INTEGER, PARAMETER :: n_int       = 0
> INTEGER, PARAMETER :: n_real      = 3+4+ntype_max
> INTEGER, PARAMETER :: n_log       = 0
> INTEGER, PARAMETER :: n_chars     = 10
> 
> ! SPICE NAG compiler gave error with 2 'my_namelist' TYPES in module
> TYPE :: my_namelist_species
>   SEQUENCE
>     ! Parameters/variables with species dimension
>   REAL(KIND=real_jlslsm) :: dd_ice_coeff_io(3)
>   REAL(KIND=real_jlslsm) :: diffusion_coeff_io
>   REAL(KIND=real_jlslsm) :: dep_species_rmm_io
>   REAL(KIND=real_jlslsm) :: diffusion_corr_io
>   REAL(KIND=real_jlslsm) :: r_tundra_io
>   REAL(KIND=real_jlslsm) :: rsurf_std_io(ntype_max)
>   CHARACTER(LEN=10)      :: dep_species_name_io
> END TYPE my_namelist_species
> 
> TYPE (my_namelist_species) :: my_nml
> 
> IF (lhook) CALL dr_hook(ModuleName//':'//RoutineName,zhook_in,zhook_handle)
> 
> !-----------------------------------------------------------------------------
> ! All PEs - set IO status as needed for tests
> 
> CALL gc_get_communicator(my_comm, icode)
> 
> CALL setup_nml_type(no_of_types, mpl_nml_type,                                 &
>                     n_real_in = n_real, n_chars_in = n_chars)
> 
> ! Based on UM routine rcf_readnl_ideal_free_tracer
> IF (mype == 0) THEN
>   ! Continue to read the jules_deposition_species namelists
>   ! until end of file or other error code
>   REWIND(UNIT=unitnumber)
>   CALL jules_print(RoutineName,                                                &
>                'Check assignment to deposition_io_data_all')
> END IF
> 
> DO ispecies = 1,ndry_dep_species
> 
>   ! Only reads namelist on PE 0
>   IF (mype == 0) THEN
> 
>     ! Initialise namelist to missing data
>     ! - need to do this each time before reading
>     dep_species_name_io              = 'unset'
>     dd_ice_coeff_io(:)               = rmdi
>     diffusion_coeff_io               = rmdi
>     dep_species_rmm_io               = rmdi
>     diffusion_corr_io                = rmdi
>     r_tundra_io                      = rmdi
>     rsurf_std_io(:)                  = rmdi
> 
>     ! Read namelist
>     READ (UNIT = unitnumber, NML = jules_deposition_species,                   &
>           IOSTAT = errorstatus, IOMSG = iomessage)
>     CALL check_iostat(errorstatus, 'namelist jules_deposition_species',        &
>           iomessage)
>   END IF
> 
>   IF (mype == 0) THEN
>     ! Print namelist just read in
>     WRITE(jules_message,'(A,2I6)')    ' species index    = ',                  &
>           ispecies, mype
>     CALL jules_print(RoutineName,jules_message)
> 
>     CALL print_nlist_jules_deposition_species()
> 
>     ! Copy to my_nml
>     my_nml % dep_species_name_io     = dep_species_name_io
>     my_nml % dd_ice_coeff_io         = dd_ice_coeff_io
>     my_nml % diffusion_coeff_io      = diffusion_coeff_io
>     my_nml % dep_species_rmm_io      = dep_species_rmm_io
>     my_nml % diffusion_corr_io       = diffusion_corr_io
>     my_nml % r_tundra_io             = r_tundra_io
>     my_nml % rsurf_std_io            = rsurf_std_io
> 
>   END IF
> 
>   ! copy to other PEs
>   CALL mpl_bcast(my_nml,1,mpl_nml_type,0,my_comm,icode)
> 
>   IF (mype /= 0) THEN
> 
>     ! Copy namelist back
>     dd_ice_coeff_io                  = my_nml % dd_ice_coeff_io
>     diffusion_coeff_io               = my_nml % diffusion_coeff_io
>     dep_species_rmm_io               = my_nml % dep_species_rmm_io
>     diffusion_corr_io                = my_nml % diffusion_corr_io
>     r_tundra_io                      = my_nml % r_tundra_io
>     rsurf_std_io                     = my_nml % rsurf_std_io
>     dep_species_name_io              = my_nml % dep_species_name_io
> 
>   END IF
> 
>   ! All PEs copy namelist info into structure deposition_io_data_all
> 
>   ! Variables that have a value for every species
>   ! (even if not necessarily used for all species).
>   deposition_io_data_all % dep_species_name_io(ispecies) =                     &
>       dep_species_name_io
>   deposition_io_data_all % dd_ice_coeff_io(ispecies,:)   =                     &
>       dd_ice_coeff_io(:)
>   deposition_io_data_all % diffusion_coeff_io(ispecies)  =                     &
>       diffusion_coeff_io
>   deposition_io_data_all % dep_species_rmm_io(ispecies)  =                     &
>       dep_species_rmm_io
>   deposition_io_data_all % diffusion_corr_io(ispecies)   =                     &
>       diffusion_corr_io
>   deposition_io_data_all % r_tundra_io(ispecies)         =                     &
>       r_tundra_io
>   deposition_io_data_all % rsurf_std_io(:,ispecies)      =                     &
>       rsurf_std_io(:)
> 
> END DO ! Loop over ispecies
> 
> CALL mpl_type_free(mpl_nml_type,icode)
> 
> IF (lhook) CALL dr_hook(ModuleName//':'//RoutineName,zhook_out,zhook_handle)
> 
> RETURN
> END SUBROUTINE read_nml_jules_deposition_species
150a323,326
> 
> ! ------------------------------------------------------------------------------
> 
> END MODULE deposition_species_io_mod
diff -r vn7.0copy1_c4/src/./science/params/deposition_species_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/params/deposition_species_mod.F90
1d0
< #if !defined(UM_JULES)
16a16,25
> USE jules_deposition_mod,                                                      &
>                     ONLY: dry_dep_model_jules, dry_dep_model_ukca,             &
>                           dry_dep_model, dep_rnull
> 
> USE deposition_output_arrays_mod, ONLY: deposition_output_array_real
> 
> #if defined (UM_JULES)
> USE UM_ParCore, ONLY: mype
> #endif
> 
36,37c45,46
<   ch4_mml, ch4_scaling, ch4dd_tundra, cuticle_o3, dd_ice_coeff,                &
<   dep_species_name, diffusion_corr, diffusion_coeff,                           &
---
>   ch4_mml, ch4_scaling, ch4dd_tundra, ch4_up_flux, cuticle_o3, dd_ice_coeff,   &
>   dep_species_name, diffusion_corr, diffusion_coeff, dep_species_rmm,          &
50,56d58
< REAL(KIND=real_jlslsm), PARAMETER ::                                           &
<   ch4_mml = 1.008e5
<     ! Factor to convert methane flux (ug m-2 h-1) to dry deposition velocity
<     ! (m s-1). ch4_mml = 3600 * 0.016 * 1.0E9 * 1.75E-6, where
<     ! 0.016 = molar mass of methane (kg), 1.0E9 converts ug -> kg, and
<     ! 1.75E-6 = assumed CH4 volumetric mixing ratio
< 
75c77
<   ch4_scaling
---
>   ch4_scaling,                                                                 &
77a80,84
>   ch4_mml
>     ! Factor to convert methane flux (ug m-2 h-1) to dry deposition velocity
>     ! (m s-1). ch4_mml = 3600 * 0.016 * 1.0E9 * 1.75E-6, where
>     ! 0.016 = molar mass of methane (kg), 1.0E9 converts ug -> kg, and
>     ! 1.75E-6 = assumed CH4 volumetric mixing ratio
99a107,108
>   ch4_up_flux(:),                                                              &
>     ! CH4 uptake flux, in ug m-2 hr-1
104,105c113,118
<     ! Diffusion coefficient for each species (m2 s-1).
<     ! A value < 0 is used to indicate that a species does not dry deposit -
---
>     ! Diffusion coefficient for each species (m2 s-1), where available.
>     ! A value of -1.0 indicates the diffusion coefficient should be derived
>     ! from that of water
>   dep_species_rmm(:),                                                          &
>     ! Relative molecular mass of each species (g mol-1).
>     ! All secies should have a positive value -
113,114c126,127
<     ! Standard value of surface resistance for each surface type and tracer
<     ! species (s m-1).
---
>     ! Standard value of surface resistance for each surface type and
>     ! deposited chemical species (s m-1).
127,132c140,142
< SUBROUTINE deposition_species_alloc(ntype,ndry_dep_species,                    &
<                               l_deposition, dry_dep_model)
< 
< !No USE statements other than Dr Hook
< USE parkind1,    ONLY: jprb, jpim
< USE yomhook,     ONLY: lhook, dr_hook
---
> !-----------------------------------------------------------------------------
> SUBROUTINE deposition_species_alloc(ntype, ndry_dep_species, l_deposition)
> !-----------------------------------------------------------------------------
134c144,145
< USE ereport_mod, ONLY: ereport
---
> USE parkind1,       ONLY: jprb, jpim
> USE yomhook,        ONLY: lhook, dr_hook
136,137c147
< !Not ideal
< USE jules_deposition_mod,     ONLY: dry_dep_ukca_jules
---
> USE ereport_mod,    ONLY: ereport
142c152
< INTEGER, INTENT(IN) :: ntype,ndry_dep_species
---
> INTEGER, INTENT(IN) :: ntype, ndry_dep_species
146,152d155
< INTEGER, INTENT(IN) :: dry_dep_model
< 
< !Local variables
< INTEGER :: temp_size, temp_tiles, temp_layers
< 
< INTEGER :: errcode
< 
163,164d165
< errcode = 101
< 
169a171,202
>   ! Deposition parameters through namelists.
>   ! NOTE: Only using dep_species_name for dry_dep_model = dry_dep_model_ukca
>   ! as species-dependent deposition parameter values hard-wired into
>   ! deposition routines: deposition_initialisation_ukca_aerod and
>   ! deposition_initialisation_ukca_surfddr.
> 
>   ALLOCATE( dd_ice_coeff(ndry_dep_species, 3))
>   ALLOCATE( diffusion_coeff(ndry_dep_species))
>   ALLOCATE( dep_species_rmm(ndry_dep_species))
>   ALLOCATE( diffusion_corr(ndry_dep_species))
>   ALLOCATE( r_tundra(ndry_dep_species))
>   ALLOCATE( rsurf_std(ntype, ndry_dep_species))
> 
>   ! Always allocate space for CH4 parameters, even if not used.
>   ALLOCATE( ch4_up_flux(ntype))
> 
>   ! Always allocate space for H2 parameters, even if not used.
>   ALLOCATE( h2dd_c(ntype))
>   ALLOCATE( h2dd_m(ntype))
>   ALLOCATE( h2dd_q(ntype))
> 
>   ch4_up_flux(:)        = 0.0
>   dd_ice_coeff(:,:)     = 0.0
>   dep_species_name(:)   = ''
>   diffusion_coeff(:)    = 0.0
>   dep_species_rmm(:)    = 0.0
>   diffusion_corr(:)     = 0.0
>   r_tundra(:)           = 0.0
>   rsurf_std(:,:)        = 0.0
>   h2dd_c(:)             = 0.0
>   h2dd_m(:)             = 0.0
>   h2dd_q(:)             = 0.0
171,200d203
<   ! Model-dependent variables.
<   SELECT CASE ( dry_dep_model )
<   CASE ( dry_dep_ukca_jules )
<     ! Deposition parameters.
<     ALLOCATE( dd_ice_coeff(ndry_dep_species,3))
<     ALLOCATE( diffusion_coeff(ndry_dep_species))
<     ALLOCATE( diffusion_corr(ndry_dep_species))
<     ALLOCATE( r_tundra(ndry_dep_species))
<     ALLOCATE( rsurf_std(ntype,ndry_dep_species))
< 
<     ! Always allocate space for H2 parameters, even if not used.
<     ALLOCATE( h2dd_c(ntype))
<     ALLOCATE( h2dd_m(ntype))
<     ALLOCATE( h2dd_q(ntype))
< 
<     dd_ice_coeff(:,:)   = 0.0
<     dep_species_name(:) = ""
<     diffusion_coeff(:)  = 0.0
<     diffusion_corr(:)   = 0.0
<     r_tundra(:)         = 0.0
<     rsurf_std(:,:)      = 0.0
<     h2dd_c(:)           = 0.0
<     h2dd_m(:)           = 0.0
<     h2dd_q(:)           = 0.0
< 
<   CASE DEFAULT
<     CALL ereport ("Invalid value for dry_dep_model. ", errcode,                &
<                    "deposition_species_alloc.")
< 
<   END SELECT
208,210c211
< 
< SUBROUTINE check_jules_deposition_species()
< 
---
> SUBROUTINE check_jules_deposition_species(ntype)
216c217
< USE ereport_mod, ONLY: ereport
---
> USE ereport_mod,          ONLY: ereport
218c219,220
< USE missing_data_mod, ONLY: rmdi
---
> USE missing_data_mod,     ONLY: rmdi
> USE jules_print_mgr,      ONLY: jules_print, jules_message
221a224,226
> !Arguments
> INTEGER, INTENT(IN) :: ntype
> 
234c239
< ! Some of these variables are coded with a deafult value, but safer to check
---
> ! Some of these variables are coded with a default value, but safer to check
242c247
<                 "Missing value for dep_species_name." )
---
>                 'Missing value for dep_species_name_io.' )
250c255
<                   "Duplicate species names." )
---
>                   'Duplicate species names.' )
253a259,267
> ! Only need dep_species_name for dry_dep_model = dry_dep_model_ukca
> ! as species-dependent deposition parameter values hard-wired into
> ! deposition routines: deposition_initialisation_ukca_aerod and
> ! deposition_initialisation_ukca_surfddr.
> 
> IF (dry_dep_model == dry_dep_model_ukca) THEN
>   RETURN
> END IF
> 
256a271
> ! Checking diffusion_coeff
260c275,281
<                 "Missing value for diffusion_coeff." )
---
>                 'Missing value for diffusion_coeff_io.' )
> END IF
> IF ( ANY( diffusion_coeff(:) < -1.0 ) ) THEN
>   errorstatus = 1   ! a fatal error
>   CALL ereport( RoutineName, errorstatus,                                      &
>                 'Value must be -1 or greater than zero for ' //                &
>                 'diffusion_coeff_io.' )
262a284,296
> ! Checking dep_species_rmm
> IF ( ANY( ABS( dep_species_rmm(:) - rmdi ) < EPSILON(1.0) ) ) THEN
>   errorstatus = 1   ! a fatal error
>   CALL ereport( RoutineName, errorstatus,                                      &
>                 'Missing value for dep_species_rmm_io.' )
> END IF
> IF ( ANY( dep_species_rmm(:) < 0.0 ) ) THEN
>   errorstatus = 1   ! a fatal error
>   CALL ereport( RoutineName, errorstatus,                                      &
>                 'Value must be greater than zero for dep_species_rmm_io.' )
> END IF
> 
> ! Checking rsurf_std
266c300,305
<                 "Missing value for rsurf_std." )
---
>                 'Missing value for rsurf_std.' )
> END IF
> IF ( ANY( rsurf_std(:,:) < 0.0 ) .OR. ANY( rsurf_std(:,:) > dep_rnull ) ) THEN
>   errorstatus = 1   ! a fatal error
>   CALL ereport( RoutineName, errorstatus,                                      &
>                 'Below minimum or above maximum value for rsurf_std.' )
275d313
< 
276a315
>     ! Check on ch4_scaling
280c319
<                     "Missing value for ch4_scaling." )
---
>                     'Missing value for ch4_scaling.' )
281a321,339
>     IF ( ch4_scaling < 0.0 ) THEN
>       errorstatus = 1   ! a fatal error
>       CALL ereport( RoutineName, errorstatus,                                  &
>                     'Value must be greater than zero for ch4_scaling_io.' )
>     END IF
> 
>     ! Check on ch4_mml
>     IF ( ABS( ch4_mml - rmdi ) < EPSILON(1.0) ) THEN
>       errorstatus = 1   ! a fatal error
>       CALL ereport( RoutineName, errorstatus,                                  &
>                     'Missing value for ch4_mml.' )
>     END IF
>     IF ( ch4_mml < 0.0 ) THEN
>       errorstatus = 1   ! a fatal error
>       CALL ereport( RoutineName, errorstatus,                                  &
>                     'Value must be greater than zero for ch4_mml_io.' )
>     END IF
> 
>     ! Check on ch4dd_tundra
285c343,355
<                     "Missing value for ch4dd_tundra." )
---
>                     'Missing value for ch4dd_tundra.' )
>     END IF
> 
>     ! Check on ch4_up_flux
>     IF ( ANY( ABS( ch4_up_flux(:) - rmdi ) < EPSILON(1.0) ) ) THEN
>       errorstatus = 1   ! a fatal error
>       CALL ereport( RoutineName, errorstatus,                                  &
>                     'Missing value for ch4_up_flux.' )
>     END IF
>     IF ( ANY( ch4_up_flux(:) < 0.0 ) ) THEN
>       errorstatus = 1   ! a fatal error
>       CALL ereport( RoutineName, errorstatus,                                  &
>                     'Value must be zero or positive for ch4_up_flux_io.' )
288a359
>     ! Check on h2dd_c, h2dd_m, h2dd_q
292c363
<                     "Missing value for h2dd_c." )
---
>                     'Missing value for h2dd_c.' )
297c368
<                     "Missing value for h2dd_m." )
---
>                     'Missing value for h2dd_m.' )
302c373
<                     "Missing value for h2dd_q." )
---
>                     'Missing value for h2dd_q.' )
305a377
>     ! Check on cuticle_o3
309c381
<                     "Missing value for cuticle_o3." )
---
>                     'Missing value for cuticle_o3.' )
310a383,389
>     IF ( cuticle_o3 < 0.0 .OR. cuticle_o3 > dep_rnull ) THEN
>       errorstatus = 1   ! a fatal error
>       CALL ereport( RoutineName, errorstatus,                                  &
>                     'Below minimum or above maximum value for cuticle_o3.' )
>     END IF
> 
>     ! Check on r_wet_soil_o3
314c393,398
<                     "Missing value for r_wet_soil_o3." )
---
>                     'Missing value for r_wet_soil_o3.' )
>     END IF
>     IF ( r_wet_soil_o3 < 0.0 .OR. r_wet_soil_o3 > dep_rnull ) THEN
>       errorstatus = 1   ! a fatal error
>       CALL ereport( RoutineName, errorstatus,                                  &
>                     'Below minimum or above maximum value for r_wet_soil_o3.' )
337c421
<   CASE ( 'HNO3', 'HONO2', 'ISON' )
---
>   CASE ( 'HNO3', 'HONO2', 'ISON', 'SO2', 'HCl', 'HOCl', 'HBr', 'HOBr' )
342c426
<                     "Missing value for dd_ice_coeff for species=" //           &
---
>                     'Missing value for dd_ice_coeff for species=' //           &
351,352c435,436
<                     "dd_ice_coeff is provided for a species for which " //     &
<                     " it is not required. Species=" //                         &
---
>                     'dd_ice_coeff is provided for a species for which ' //     &
>                     ' it is not required. Species=' //                         &
363c447
<   CASE ( 'NO2', 'O3', 'PAN', 'PPAN', 'MPAN', 'ONITU' )
---
>   CASE ( 'NO2', 'O3', 'PAN', 'PPAN', 'MPAN', 'ONITU', 'NH3', 'SO2' )
368c452
<                     "Missing value for diffusion_corr for species=" //         &
---
>                     'Missing value for diffusion_corr for species=' //         &
370a455,459
>     IF ( diffusion_corr(i) < 0.0 ) THEN
>       errorstatus = 1   ! a fatal error
>       CALL ereport( RoutineName, errorstatus,                                  &
>                     'Value must be positive for diffusion_corr_io.' )
>     END IF
377,378c466,467
<                     "diffusion_corr is provided for a species for which " //   &
<                     " it is not required. Species=" //                         &
---
>                     'diffusion_corr is provided for a species for which ' //   &
>                     ' it is not required. Species=' //                         &
389c478
<   CASE ( 'CO', 'NO2', 'O3', 'PAN', 'PPAN', 'MPAN', 'ONITU' )
---
>   CASE ( 'CO', 'NO2', 'O3', 'PAN', 'PPAN', 'MPAN', 'ONITU', 'H2' )
394c483
<                     "Missing value for r_tundra for species=" //               &
---
>                     'Missing value for r_tundra for species=' //               &
396a486,491
>     IF ( r_tundra(i) < 0.0 .OR. r_tundra(i) > dep_rnull ) THEN
>       errorstatus = 1   ! a fatal error
>       CALL ereport( RoutineName, errorstatus,                                  &
>                     'Below minimum or above maximum value for r_tundra ' //    &
>                     'for species=' // TRIM(dep_species_name(i)) )
>     END IF
403,404c498,499
<                     "r_tundra is provided for a species for which " //         &
<                     " it is not required. Species=" //                         &
---
>                     'r_tundra is provided for a species for which ' //         &
>                     ' it is not required. Species=' //                         &
415d509
< #endif
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/params: deposition_species_specific_io_mod.F90
diff -r vn7.0copy1_c4/src/./science/params/ecosse_param_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/params/ecosse_param_mod.F90
79c79
<     decomp_wrate_min_rothc  = 0.2,                                             &
---
>     decomp_wrate_min_smith  = 0.2,                                             &
81,82c81,82
<       ! when RothC form is used.
<     decomp_wrate_min_jules = 0.2
---
>       ! when Smith et al., 2010 form is used.
>     decomp_wrate_min_clark = 0.2
89,90c89,90
<   decomp_temp_coeff_rothc(3) =  [ 47.9, 106.0, 18.3 ]
<     ! Constants in RothC decomposition rate temperature modifier.
---
>   decomp_temp_coeff_smith(3) =  [ 47.9, 106.0, 18.3 ]
>     ! Constants in Smith et al., 2010 C decomposition rate temperature modifier.
103c103
<     ! when RothC form is used.
---
>     ! when Smith et al., 2010 form is used.
169c169
<     ! Note that the RothC code calls this lit_cn.
---
>     ! Note that the 4-pool soil C code calls this lit_cn.
diff -r vn7.0copy1_c4/src/./science/params/nvegparm_io_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/params/nvegparm_io_mod.F90
17,18c17
< USE max_dimensions, ONLY:                                                      &
<   nnvg_max
---
> USE max_dimensions, ONLY: nnvg_max
30d28
<   albsnf_nvgu_io(nnvg_max) = rmdi,                                             &
32a31
>   albsnf_nvgu_io(nnvg_max) = rmdi,                                             &
33a33,34
>   ch_nvg_io(nnvg_max) = rmdi,                                                  &
>   emis_nvg_io(nnvg_max) = rmdi,                                                &
36,37d36
<   z0_nvg_io(nnvg_max) = rmdi,                                                  &
<   ch_nvg_io(nnvg_max) = rmdi,                                                  &
39,42c38,40
<   emis_nvg_io(nnvg_max) = rmdi,                                                &
<   z0hm_nvg_io(nnvg_max) = rmdi,                                                &
<   z0hm_classic_nvg_io(nnvg_max) = rmdi
< 
---
>   z0_nvg_io(nnvg_max) = rmdi,                                                  &
>   z0hm_classic_nvg_io(nnvg_max) = rmdi,                                        &
>   z0hm_nvg_io(nnvg_max) = rmdi
48,53c46,50
<                           albsnc_nvg_io,albsnf_nvgu_io,                        &
<                           albsnf_nvg_io, albsnf_nvgl_io,                       &
<                           catch_nvg_io,gs_nvg_io,infil_nvg_io,                 &
<                           z0_nvg_io,ch_nvg_io,vf_nvg_io,                       &
<                           emis_nvg_io,z0hm_nvg_io,                             &
<                           z0hm_classic_nvg_io
---
>                           albsnc_nvg_io, albsnf_nvg_io,                        &
>                           albsnf_nvgl_io, albsnf_nvgu_io,                      &
>                           catch_nvg_io, ch_nvg_io, emis_nvg_io,                &
>                           gs_nvg_io, infil_nvg_io, vf_nvg_io,                  &
>                           z0_nvg_io, z0hm_nvg_io, z0hm_classic_nvg_io
70a68,71
> WRITE(lineBuffer,*)' albsnf_nvgl_io = ',albsnf_nvgl_io
> CALL jules_print('nvegparm_io',lineBuffer)
> WRITE(lineBuffer,*)' albsnf_nvgu_io = ',albsnf_nvgu_io
> CALL jules_print('nvegparm_io',lineBuffer)
73c74
< WRITE(lineBuffer,*)' gs_nvg_io = ',gs_nvg_io
---
> WRITE(lineBuffer,*)' ch_nvg_io = ',ch_nvg_io
75c76
< WRITE(lineBuffer,*)' infil_nvg_io = ',infil_nvg_io
---
> WRITE(lineBuffer,*)' emis_nvg_io = ',emis_nvg_io
77c78
< WRITE(lineBuffer,*)' z0_nvg_io = ',z0_nvg_io
---
> WRITE(lineBuffer,*)' gs_nvg_io = ',gs_nvg_io
79c80
< WRITE(lineBuffer,*)' ch_nvg_io = ',ch_nvg_io
---
> WRITE(lineBuffer,*)' infil_nvg_io = ',infil_nvg_io
83c84,86
< WRITE(lineBuffer,*)' emis_nvg_io = ',emis_nvg_io
---
> WRITE(lineBuffer,*)' z0_nvg_io = ',z0_nvg_io
> CALL jules_print('nvegparm_io',lineBuffer)
> WRITE(lineBuffer,*)' z0hm_classic_nvg_io = ',z0hm_classic_nvg_io
131d133
<   REAL(KIND=real_jlslsm) :: albsnf_nvgu_io(nnvg_max)
133a136
>   REAL(KIND=real_jlslsm) :: albsnf_nvgu_io(nnvg_max)
134a138,139
>   REAL(KIND=real_jlslsm) :: ch_nvg_io(nnvg_max)
>   REAL(KIND=real_jlslsm) :: emis_nvg_io(nnvg_max)
137,138d141
<   REAL(KIND=real_jlslsm) :: z0_nvg_io(nnvg_max)
<   REAL(KIND=real_jlslsm) :: ch_nvg_io(nnvg_max)
140,141c143
<   REAL(KIND=real_jlslsm) :: emis_nvg_io(nnvg_max)
<   REAL(KIND=real_jlslsm) :: z0hm_nvg_io(nnvg_max)
---
>   REAL(KIND=real_jlslsm) :: z0_nvg_io(nnvg_max)
142a145
>   REAL(KIND=real_jlslsm) :: z0hm_nvg_io(nnvg_max)
159,170c162,172
<   my_nml % albsnc_nvg_io   = albsnc_nvg_io
<   my_nml % albsnf_nvgu_io  = albsnf_nvgu_io
<   my_nml % albsnf_nvg_io   = albsnf_nvg_io
<   my_nml % albsnf_nvgl_io  = albsnf_nvgl_io
<   my_nml % catch_nvg_io    = catch_nvg_io
<   my_nml % gs_nvg_io       = gs_nvg_io
<   my_nml % infil_nvg_io    = infil_nvg_io
<   my_nml % z0_nvg_io       = z0_nvg_io
<   my_nml % ch_nvg_io       = ch_nvg_io
<   my_nml % vf_nvg_io       = vf_nvg_io
<   my_nml % emis_nvg_io     = emis_nvg_io
<   my_nml % z0hm_nvg_io     = z0hm_nvg_io
---
>   my_nml % albsnc_nvg_io       = albsnc_nvg_io
>   my_nml % albsnf_nvg_io       = albsnf_nvg_io
>   my_nml % albsnf_nvgl_io      = albsnf_nvgl_io
>   my_nml % albsnf_nvgu_io      = albsnf_nvgu_io
>   my_nml % catch_nvg_io        = catch_nvg_io
>   my_nml % ch_nvg_io           = ch_nvg_io
>   my_nml % emis_nvg_io         = emis_nvg_io
>   my_nml % gs_nvg_io           = gs_nvg_io
>   my_nml % infil_nvg_io        = infil_nvg_io
>   my_nml % vf_nvg_io           = vf_nvg_io
>   my_nml % z0_nvg_io           = z0_nvg_io
171a174
>   my_nml % z0hm_nvg_io         = z0hm_nvg_io
178,189c181,191
<   albsnc_nvg_io   = my_nml % albsnc_nvg_io
<   albsnf_nvgu_io  = my_nml % albsnf_nvgu_io
<   albsnf_nvg_io   = my_nml % albsnf_nvg_io
<   albsnf_nvgl_io  = my_nml % albsnf_nvgl_io
<   catch_nvg_io    = my_nml % catch_nvg_io
<   gs_nvg_io       = my_nml % gs_nvg_io
<   infil_nvg_io    = my_nml % infil_nvg_io
<   z0_nvg_io       = my_nml % z0_nvg_io
<   ch_nvg_io       = my_nml % ch_nvg_io
<   vf_nvg_io       = my_nml % vf_nvg_io
<   emis_nvg_io     = my_nml % emis_nvg_io
<   z0hm_nvg_io     = my_nml % z0hm_nvg_io
---
>   albsnc_nvg_io       = my_nml % albsnc_nvg_io
>   albsnf_nvg_io       = my_nml % albsnf_nvg_io
>   albsnf_nvgl_io      = my_nml % albsnf_nvgl_io
>   albsnf_nvgu_io      = my_nml % albsnf_nvgu_io
>   catch_nvg_io        = my_nml % catch_nvg_io
>   ch_nvg_io           = my_nml % ch_nvg_io
>   emis_nvg_io         = my_nml % emis_nvg_io
>   gs_nvg_io           = my_nml % gs_nvg_io
>   infil_nvg_io        = my_nml % infil_nvg_io
>   vf_nvg_io           = my_nml % vf_nvg_io
>   z0_nvg_io           = my_nml % z0_nvg_io
190a193
>   z0hm_nvg_io         = my_nml % z0hm_nvg_io
208,211c211,214
<   albsnc_nvg,   albsnf_nvgu,  albsnf_nvg,                                      &
<   albsnf_nvgl,  catch_nvg,    gs_nvg,                                          &
<   infil_nvg,    z0_nvg,       ch_nvg,                                          &
<   vf_nvg,       emis_nvg,     l_z0_nvg
---
>   albsnc_nvg,   albsnf_nvg,   albsnf_nvgl,                                     &
>   albsnf_nvgu,  catch_nvg,    ch_nvg,                                          &
>   emis_nvg,     gs_nvg,       infil_nvg,                                       &
>   vf_nvg,       z0_nvg,       l_z0_nvg
232d234
< albsnf_nvgu(:)                      = albsnf_nvgu_io(1:nnvg)
234a237
> albsnf_nvgu(:)                      = albsnf_nvgu_io(1:nnvg)
235a239,240
> ch_nvg(:)                           = ch_nvg_io(1:nnvg)
> emis_nvg(:)                         = emis_nvg_io(1:nnvg)
238,239d242
< z0_nvg(:)                           = z0_nvg_io(1:nnvg)
< ch_nvg(:)                           = ch_nvg_io(1:nnvg)
241,242c244
< emis_nvg(:)                         = emis_nvg_io(1:nnvg)
< z0h_z0m(npft+1:npft + nnvg)         = z0hm_nvg_io(1:nnvg)
---
> z0_nvg(:)                           = z0_nvg_io(1:nnvg)
243a246
> z0h_z0m(npft+1:npft + nnvg)         = z0hm_nvg_io(1:nnvg)
diff -r vn7.0copy1_c4/src/./science/params/nvegparm_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/params/nvegparm_mod.F90
74,85c74,85
< ALLOCATE( albsnc_nvg(nnvg))
< ALLOCATE( albsnf_nvgu(nnvg))
< ALLOCATE( albsnf_nvg(nnvg))
< ALLOCATE( albsnf_nvgl(nnvg))
< ALLOCATE( catch_nvg(nnvg))
< ALLOCATE( emis_nvg(nnvg))
< ALLOCATE( gs_nvg(nnvg))
< ALLOCATE( infil_nvg(nnvg))
< ALLOCATE( z0_nvg(nnvg))
< ALLOCATE( ch_nvg(nnvg))
< ALLOCATE( vf_nvg(nnvg))
< ALLOCATE( l_z0_nvg(nnvg))
---
> ALLOCATE( albsnc_nvg(nnvg) )
> ALLOCATE( albsnf_nvgu(nnvg) )
> ALLOCATE( albsnf_nvg(nnvg) )
> ALLOCATE( albsnf_nvgl(nnvg) )
> ALLOCATE( catch_nvg(nnvg) )
> ALLOCATE( emis_nvg(nnvg) )
> ALLOCATE( gs_nvg(nnvg) )
> ALLOCATE( infil_nvg(nnvg) )
> ALLOCATE( z0_nvg(nnvg) )
> ALLOCATE( ch_nvg(nnvg) )
> ALLOCATE( vf_nvg(nnvg) )
> ALLOCATE( l_z0_nvg(nnvg) )
109d108
< USE missing_data_mod, ONLY: rmdi
111d109
< USE jules_print_mgr,  ONLY: jules_print, jules_message, newline
122c120
< INTEGER :: ERROR  ! Error indicator
---
> INTEGER :: errorstatus = 0
124a123,184
> ! In LFRic if options are not required they have a zero size.
> IF ( SIZE( albsnc_nvg(:) ) > 0 )                                               &
>    CALL check_jules_nml_values_real ( albsnc_nvg(:), 'albsnc_nvg', nnvg,       &
>    0.0, 1.0, RoutineName, errorstatus )
> IF ( SIZE( albsnf_nvgu(:) ) > 0 )                                              &
>    CALL check_jules_nml_values_real ( albsnf_nvgu(:), 'albsnf_nvgu', nnvg,     &
>    0.0, 1.0, RoutineName, errorstatus )
> IF ( SIZE( albsnf_nvg(:) ) > 0 )                                               &
>    CALL check_jules_nml_values_real ( albsnf_nvg(:), 'albsnf_nvg', nnvg,       &
>    0.0, 1.0, RoutineName, errorstatus )
> IF ( SIZE( albsnf_nvgl(:) ) > 0 )                                              &
>    CALL check_jules_nml_values_real ( albsnf_nvgl(:), 'albsnf_nvgl', nnvg,     &
>    0.0, 1.0, RoutineName, errorstatus )
> IF ( SIZE( catch_nvg(:) ) > 0 )                                                &
>    CALL check_jules_nml_values_real ( catch_nvg(:), 'catch_nvg', nnvg,         &
>    0.0, HUGE(1.0), RoutineName, errorstatus )
> IF ( SIZE( emis_nvg(:) ) > 0 )                                                 &
>    CALL check_jules_nml_values_real ( emis_nvg(:), 'emis_nvg', nnvg,           &
>    0.0, 1.0, RoutineName, errorstatus )
> IF ( SIZE( gs_nvg(:) ) > 0 )                                                   &
>    CALL check_jules_nml_values_real ( gs_nvg(:), 'gs_nvg', nnvg,               &
>    0.0, HUGE(1.0), RoutineName, errorstatus )
> IF ( SIZE( infil_nvg(:) ) > 0 )                                                &
>    CALL check_jules_nml_values_real ( infil_nvg(:), 'infil_nvg', nnvg,         &
>    0.0, HUGE(1.0), RoutineName, errorstatus )
> IF ( SIZE( z0_nvg(:) ) > 0 )                                                   &
>    CALL check_jules_nml_values_real ( z0_nvg(:), 'z0_nvg', nnvg,               &
>    0.0, HUGE(1.0), RoutineName, errorstatus )
> IF ( SIZE( ch_nvg(:) ) > 0 )                                                   &
>    CALL check_jules_nml_values_real ( ch_nvg(:), 'ch_nvg', nnvg,               &
>    0.0, HUGE(1.0), RoutineName, errorstatus )
> IF ( SIZE( vf_nvg(:) ) > 0 )                                                   &
>    CALL check_jules_nml_values_real ( vf_nvg(:), 'vf_nvg', nnvg,               &
>    0.0, 1.0, RoutineName, errorstatus )
> IF ( SIZE( z0h_z0m(npft+1:) ) > 0 )                                            &
>    CALL check_jules_nml_values_real ( z0h_z0m(npft+1:), 'z0hm_nvg', nnvg,      &
>    0.0, HUGE(1.0), RoutineName, errorstatus )
> IF ( SIZE( z0h_z0m_classic(npft+1:) ) > 0 )                                    &
>    CALL check_jules_nml_values_real ( z0h_z0m_classic(npft+1:),                &
>    'z0hm_classic_nvg', nnvg, 0.0, HUGE(1.0), RoutineName, errorstatus )
> 
> IF ( errorstatus > 0 )                                                         &
>    CALL ereport(RoutineName, errorstatus,                                      &
>    ' Error(s) were found in jules_nvegparm - see job.out for details')
> 
> END SUBROUTINE check_jules_nvegparm
> 
> 
> SUBROUTINE check_jules_nml_values_real ( var, var_name, var_size,  min_value,  &
>    max_value, RoutineName, errorstatus )
> 
> USE jules_print_mgr, ONLY: jules_print, jules_message
> USE jules_surface_types_mod, ONLY: soil, npft
> USE missing_data_mod, ONLY: rmdi
> 
> IMPLICIT NONE
> 
> INTEGER                :: var_size, errorstatus
> REAL(KIND=real_jlslsm) :: var(var_size), min_value, max_value
> CHARACTER(LEN=*)       :: var_name, RoutineName
> LOGICAL                :: soil_chck(var_size)
> 
126,129c186,189
< ! Check that all required variables were present in the namelist.
< ! The namelist variables were initialised to rmdi.
< ! Some configurations don't need all parameters (e.g. albsnc_nvg) but for now
< ! we insist on getting all parameters (and that there are not rmdi!).
---
> ! The namelist variables should be initialised to rmdi and will still be
> ! rmdi if they are attached to science options when not required (UM/JULES).
> ! Specific checks to ensure that these required variables are not rmdi can be
> ! found in check_compatible_options.
131,171d190
< ERROR = 0
< IF ( ANY( ABS( albsnf_nvg(:) - rmdi ) < EPSILON(1.0) ) ) THEN
<   ERROR = 1
<   CALL jules_print(RoutineName, "No value for albsnf_nvg")
< END IF
< IF ( ANY( ABS( catch_nvg(:) - rmdi ) < EPSILON(1.0) ) ) THEN
<   ERROR = 1
<   CALL jules_print(RoutineName, "No value for catch_nvg")
< END IF
< IF ( ANY( ABS( gs_nvg(:) - rmdi ) < EPSILON(1.0) ) ) THEN
<   ERROR = 1
<   CALL jules_print(RoutineName, "No value for gs_nvg")
< END IF
< IF ( ANY( ABS( infil_nvg(:) - rmdi ) < EPSILON(1.0) ) ) THEN
<   ERROR = 1
<   CALL jules_print(RoutineName, "No value for infil_nvg")
< END IF
< IF ( ANY( ABS( z0_nvg(:) - rmdi ) < EPSILON(1.0) ) ) THEN
<   ERROR = 1
<   CALL jules_print(RoutineName, "No value for z0_nvg")
< END IF
< IF ( ANY( ABS( ch_nvg(:) - rmdi ) < EPSILON(1.0) ) ) THEN
<   ERROR = 1
<   CALL jules_print(RoutineName, "No value for ch_nvg")
< END IF
< IF ( ANY( ABS( vf_nvg(:) - rmdi ) < EPSILON(1.0) ) ) THEN
<   ERROR = 1
<   CALL jules_print(RoutineName, "No value for vf_nvg")
< END IF
< IF ( ANY( ABS( emis_nvg(:) - rmdi ) < EPSILON(1.0) ) ) THEN
<   ERROR = 1
<   CALL jules_print(RoutineName, "No value for emis_nvg")
< END IF
< IF ( ANY( ABS( z0h_z0m(npft+1:) - rmdi ) < EPSILON(1.0) ) ) THEN
<   ERROR = 1
<   CALL jules_print(RoutineName, "No value for z0hm_nvg")
< END IF
< IF ( ANY( ABS( z0h_z0m_classic(npft+1:) - rmdi ) < EPSILON(1.0) ) ) THEN
<   ERROR = 1
<   CALL jules_print(RoutineName, "No value for z0hm_classic_nvg")
< END IF
173,181c192,215
< IF ( ERROR /= 0 )                                                              &
<   CALL ereport(RoutineName, ERROR,                                             &
<                  "Variable(s) missing from namelist - see job.out for " //     &
<                  "error message(s)")
< 
< ERROR = 0
< IF ( ANY( vf_nvg(:) > 1.0 ) ) THEN
<   ERROR = 1
<   CALL jules_print(RoutineName, "At least one value of vf_nvg > 1.0")
---
> IF ( ANY( ABS( var(:) - rmdi ) > EPSILON(1.0) ) ) THEN
>   IF ( ANY( var(:) > max_value ) ) errorstatus = 2
>   IF ( ANY( var(:) < min_value ) ) THEN
>     ! Need to account for albsnf_nvg(soil) = -1 for ancil
>     IF ( var_name == 'albsnf_nvg' ) THEN
>       soil_chck(:) = ( var(:) < min_value )
>       SELECT CASE ( COUNT( soil_chck(:) ) )
>       CASE ( 1 )
>         IF ( .NOT. ABS ( var(soil-npft) + 1.0 ) < EPSILON(1.0) ) THEN
>           errorstatus = 3
>         END IF
>       CASE DEFAULT
>         errorstatus = 3
>       END SELECT
>     ELSE
>       errorstatus = 3
>     END IF
>   END IF
>   IF ( errorstatus > 1 ) THEN
>     WRITE(jules_message,*) TRIM(var_name) // ' is out of range: ', var(:)
>     CALL jules_print(RoutineName, jules_message)
>     ! Reset to fail value after printing message
>     errorstatus = 1
>   END IF
183,191d216
< IF ( ANY( vf_nvg(:) < 0.0 ) ) THEN
<   ERROR = 1
<   CALL jules_print(RoutineName, "At least one value of vf_nvg < 0.0")
< END IF
< 
< IF ( ERROR /= 0 )                                                              &
<    CALL ereport(RoutineName, ERROR,                                            &
<                   "Variable(s) outside of allowed range - see job.out for " // &
<                   "error message(s)")
193c218
< END SUBROUTINE check_jules_nvegparm
---
> END SUBROUTINE check_jules_nml_values_real
diff -r vn7.0copy1_c4/src/./science/params/pftparm_io_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/params/pftparm_io_mod.F90
62d61
<   beta_c3c4_io(npft_max) = rmdi,                                               &       
83,85d81
<   eagamma_io(npft_max) = rmdi,                                                 &
<   eakc_io(npft_max) = rmdi,                                                    &
<   eako_io(npft_max) = rmdi,                                                    & 
101c97
<   gamma25_io(npft_max) = rmdi,                                                 &
---
>   sug_g0_io(npft_max) = rmdi,                                                  &
105a102
>   sug_grec_io(npft_max) = rmdi,                                                &
111d107
<   kc25_io(npft_max) = rmdi,                                                    &
115d110
<   ko25_io(npft_max) = rmdi,                                                    &
142a138
>   sug_yg_io(npft_max) = rmdi,                                                  &
145,146c141,144
<   z0v_io(npft_max) = rmdi
< 
---
>   z0v_io(npft_max) = rmdi,                                                     &
>   sox_a_io(npft_max) = rmdi,                                                   &
>   sox_p50_io(npft_max) = rmdi,                                                 &
>   sox_rp_min_io(npft_max) = rmdi
161,175c159,172
<   avg_ba_io,       beta_c3c4_io,     b_wl_io,                                  &
<   c3_io,           can_struct_a_io,  catch0_io,                                &
<   ccleaf_max_io,   ccleaf_min_io,    ccwood_max_io,                            &
<   ccwood_min_io,   ci_st_io,         dcatch_dlai_io,                           & 
<   deact_jmax_io,   deact_vcmax_io,   dfp_dcuo_io,                              &     
<   dgl_dm_io,       dgl_dt_io,        dqcrit_io,                                &      
<   ds_jmax_io,      ds_vcmax_io,      dust_veg_scj_io,                          &
<   dz0v_dh_io,      eagamma_io,       eakc_io,                                  &        
<   eako_io,         emis_pft_io,      eta_sl_io,                                &     
<   f0_io,           fef_bc_io,        fef_ch4_io,                               &    
<   fef_co_io,       fef_co2_io,       fef_nox_io,                               &     
<   fef_oc_io,       fef_so2_io,       fd_io,                                    &         
<   fire_mort_io,    fl_o3_ct_io,      fsmc_of_io,                               &
<   fsmc_p0_io,      g1_stomata_io,    g_leaf_0_io,                              &
<   glmin_io,        gamma25_io,       gpp_st_io,                                &  
---
>   avg_ba_io,       b_wl_io,          c3_io,                                    &
>   can_struct_a_io, catch0_io,        ccleaf_max_io,                            &
>   ccleaf_min_io,   ccwood_max_io,    ccwood_min_io,                            &
>   ci_st_io,        dcatch_dlai_io,   deact_jmax_io,                            &
>   deact_vcmax_io,  dfp_dcuo_io,      dgl_dm_io,                                &
>   dgl_dt_io,       dqcrit_io,        ds_jmax_io,                               &
>   ds_vcmax_io,     dust_veg_scj_io,  dz0v_dh_io,                               &
>   emis_pft_io,     eta_sl_io,        f0_io,                                    &
>   fef_bc_io,       fef_ch4_io,       fef_co_io,                                &
>   fef_co2_io,      fef_nox_io,       fef_oc_io,                                &
>   fef_so2_io,      fd_io,            fire_mort_io,                             &
>   fl_o3_ct_io,     fsmc_of_io,       fsmc_p0_io,                               &
>   sug_g0_io,       g1_stomata_io,    g_leaf_0_io,                              &
>   glmin_io,        gpp_st_io,        sug_grec_io,                              &
177,189c174,187
<   infil_f_io,      jv25_ratio_io,    kc25_io,                                  &   
<   ko25_io,         kext_io,          kn_io,                                    &
<   knl_io,          kpar_io,          lai_alb_lim_io,                           &
<   lma_io,          mef_io,           neff_io,                                  &
<   nl0_io,          nmass_io,         nr_io,                                    &
<   nr_nl_io,        ns_nl_io,         nsw_io,                                   &
<   omega_io,        omegal_io,        omegau_io,                                &
<   omnir_io,        omnirl_io,        omniru_io,                                &
<   orient_io,       q10_leaf_io,      r_grow_io,                                &
<   rootd_ft_io,     sigl_io,          tef_io,                                   &
<   tleaf_of_io,     tlow_io,          tupp_io,                                  &
<   vint_io,         vsl_io,           z0hm_pft_io,                              &
<   z0hm_classic_pft_io,  z0v_io
---
>   infil_f_io,      jv25_ratio_io,    kext_io,                                  &
>   kn_io,           knl_io,           kpar_io,                                  &
>   lai_alb_lim_io,  lma_io,           mef_io,                                   &
>   neff_io,         nl0_io,           nmass_io,                                 &
>   nr_io,           nr_nl_io,         ns_nl_io,                                 &
>   nsw_io,          omega_io,         omegal_io,                                &
>   omegau_io,       omnir_io,         omnirl_io,                                &
>   omniru_io,       orient_io,        q10_leaf_io,                              &
>   r_grow_io,       rootd_ft_io,      sigl_io,                                  &
>   tef_io,          tleaf_of_io,      tlow_io,                                  &
>   tupp_io,         vint_io,          vsl_io,                                   &
>   sug_yg_io,       z0hm_pft_io,      z0hm_classic_pft_io,                      &
>   z0v_io,          sox_a_io,         sox_p50_io,                               &
>   sox_rp_min_io
243,244d240
< WRITE(lineBuffer,*)' beta_c3c4_io = ',beta_c3c4_io
< CALL jules_print('pftparm_io',lineBuffer)
285,290d280
< WRITE(lineBuffer,*)' eagamma_io = ',eagamma_io
< CALL jules_print('pftparm_io',lineBuffer)
< WRITE(lineBuffer,*)' eakc_io = ',eakc_io
< CALL jules_print('pftparm_io',lineBuffer)
< WRITE(lineBuffer,*)' eako_io = ',eako_io
< CALL jules_print('pftparm_io',lineBuffer)
321c311
< WRITE(lineBuffer,*)' gamma25_io = ',gamma25_io
---
> WRITE(lineBuffer,*)' sug_g0_io = ',sug_g0_io
330a321,322
> WRITE(lineBuffer,*)' sug_grec_io = ',sug_grec_io
> CALL jules_print('pftparm_io',lineBuffer)
341,342d332
< WRITE(lineBuffer,*)' kc25_io = ',kc25_io
< CALL jules_print('pftparm_io',lineBuffer)
349,350d338
< WRITE(lineBuffer,*)' ko25_io = ',ko25_io
< CALL jules_print('pftparm_io',lineBuffer)
398a387,388
> WRITE(lineBuffer,*)' sug_yg_io = ',sug_yg_io
> CALL jules_print('pftparm_io',lineBuffer)
402a393,398
> WRITE(lineBuffer,*)' sox_a_io = ',sox_a_io
> CALL jules_print('pftparm_io',lineBuffer)
> WRITE(lineBuffer,*)' sox_p50_io = ',sox_p50_io
> CALL jules_print('pftparm_io',lineBuffer)
> WRITE(lineBuffer,*)' sox_rp_min_io = ',sox_rp_min_io
> CALL jules_print('pftparm_io',lineBuffer)
439c435
< INTEGER, PARAMETER :: n_real = 95 * npft_max
---
> INTEGER, PARAMETER :: n_real = 101 * npft_max
464d459
<   REAL(KIND=real_jlslsm) :: beta_c3c4_io(npft_max)
485,487d479
<   REAL(KIND=real_jlslsm) :: eagamma_io(npft_max)
<   REAL(KIND=real_jlslsm) :: eakc_io(npft_max)
<   REAL(KIND=real_jlslsm) :: eako_io(npft_max)
502c494
<   REAL(KIND=real_jlslsm) :: gamma25_io(npft_max)
---
>   REAL(KIND=real_jlslsm) :: sug_g0_io(npft_max)
506a499
>   REAL(KIND=real_jlslsm) :: sug_grec_io(npft_max)
512d504
<   REAL(KIND=real_jlslsm) :: kc25_io(npft_max)
516d507
<   REAL(KIND=real_jlslsm) :: ko25_io(npft_max)
543a535
>   REAL(KIND=real_jlslsm) :: sug_yg_io(npft_max)
546a539,541
>   REAL(KIND=real_jlslsm) :: sox_a_io(npft_max)
>   REAL(KIND=real_jlslsm) :: sox_p50_io(npft_max)
>   REAL(KIND=real_jlslsm) :: sox_rp_min_io(npft_max)
584d578
<   my_nml % beta_c3c4_io     = beta_c3c4_io
605,607d598
<   my_nml % eagamma_io     = eagamma_io
<   my_nml % eakc_io        = eakc_io
<   my_nml % eako_io        = eako_io
623c614
<   my_nml % gamma25_io     = gamma25_io
---
>   my_nml % sug_g0_io      = sug_g0_io
627a619
>   my_nml % sug_grec_io    = sug_grec_io
633d624
<   my_nml % kc25_io        = kc25_io
637d627
<   my_nml % ko25_io        = ko25_io
665a656
>   my_nml % sug_yg_io      = sug_yg_io
668a660,662
>   my_nml % sox_a_io       = sox_a_io
>   my_nml % sox_p50_io     = sox_p50_io
>   my_nml % sox_rp_min_io  = sox_rp_min_io
694d687
<   beta_c3c4_io    = my_nml % beta_c3c4_io
715,717d707
<   eagamma_io      = my_nml % eagamma_io
<   eakc_io         = my_nml % eakc_io
<   eako_io         = my_nml % eako_io
733d722
<   gamma25_io      = my_nml % gamma25_io
734a724
>   sug_g0_io       = my_nml % sug_g0_io
737a728
>   sug_grec_io     = my_nml % sug_grec_io
743d733
<   kc25_io         = my_nml % kc25_io
748d737
<   ko25_io         = my_nml % ko25_io
775a765
>   sug_yg_io       = my_nml % sug_yg_io
778a769,771
>   sox_a_io        = my_nml % sox_a_io
>   sox_p50_io      = my_nml % sox_p50_io
>   sox_rp_min_io   = my_nml % sox_rp_min_io
806,833c799,826
<   avg_ba,          beta_c3c4,        b_wl,                                     &
<   c3,              can_struct_a,     catch0,                                   &
<   ccleaf_max,      ccleaf_min,       ccwood_max,                               &
<   ccwood_min,      ci_st,            dcatch_dlai,                              &
<   deact_jmax,      deact_vcmax,      dfp_dcuo,                                 &
<   dgl_dm,          dgl_dt,           dqcrit,                                   &
<   ds_jmax,         ds_vcmax,         dust_veg_scj,                             &
<   dz0v_dh,         eagamma,          eakc,                                     &
<   eako,            emis_pft,         eta_sl,                                   &
<   f0,              fd,               fef_bc,                                   &
<   fef_ch4,         fef_co,           fef_co2,                                  & 
<   fef_nox,         fef_oc,           fef_so2,                                  &
<   fire_mort,       fl_o3_ct,         fsmc_of,                                  &
<   fsmc_p0,         gamma25,          g1_stomata,                               &
<   g_leaf_0,        glmin,            gpp_st,                                   &
<   gsoil_f,         hw_sw,            ief,                                      &		  
<   infil_f,         jv25_ratio,       kc25,                                     &
<   kext,            kn,               knl,                                      &
<   ko25,            kpar,             lai_alb_lim,                              &
<   lma,             mef,              neff,                                     &
<   nl0,             nmass,            nr,                                       &
<   nr_nl,           ns_nl,            nsw,                                      &
<   omega,           omegal,           omegau,                                   &
<   omnir,           omnirl,           omniru,                                   &
<   orient,          q10_leaf,         r_grow,                                   &
<   rootd_ft,        sigl,             tef,                                      &
<   tleaf_of,        tlow,             tupp,                                     &
<   vint,            vsl,              z0v
---
>   avg_ba,          b_wl,             c3,                                       &
>   can_struct_a,    catch0,           ccleaf_max,                               &
>   ccleaf_min,      ccwood_max,       ccwood_min,                               &
>   ci_st,           dcatch_dlai,      deact_jmax,                               &
>   deact_vcmax,     dfp_dcuo,         dgl_dm,                                   &
>   dgl_dt,          dqcrit,           ds_jmax,                                  &
>   ds_vcmax,        dust_veg_scj,     dz0v_dh,                                  &
>   emis_pft,        eta_sl,           f0,                                       &
>   fd,              fef_bc,           fef_ch4,                                  &
>   fef_co,          fef_co2,          fef_nox,                                  &
>   fef_oc,          fef_so2,          fire_mort,                                &
>   fl_o3_ct,        fsmc_of,          fsmc_p0,                                  &
>   sug_g0,          g1_stomata,       g_leaf_0,                                 &
>   glmin,           gpp_st,           sug_grec,                                 &
>   gsoil_f,         hw_sw,            ief,                                      &
>   infil_f,         jv25_ratio,       kext,                                     &
>   kn,              knl,              kpar,                                     &
>   lai_alb_lim,     lma,              mef,                                      &
>   neff,            nl0,              nmass,                                    &
>   nr,              nr_nl,            ns_nl,                                    &
>   nsw,             omega,            omegal,                                   &
>   omegau,          omnir,            omnirl,                                   &
>   omniru,          orient,           q10_leaf,                                 &
>   r_grow,          rootd_ft,         sigl,                                     &
>   tef,             tleaf_of,         tlow,                                     &
>   tupp,            vint,             vsl,                                      &
>   sug_yg,          z0v,              sox_a,                                    &
>   sox_p50,         sox_rp_min
879d871
< beta_c3c4(:)    = beta_c3c4_io(1:npft)
887,889d878
< eagamma(:)      = eagamma_io(1:npft)
< eakc(:)         = eakc_io(1:npft)
< eako(:)         = eako_io(1:npft)
892d880
< gamma25(:)      = gamma25_io(1:npft)
895d882
< kc25(:)         = kc25_io(1:npft)
898d884
< ko25(:)         = ko25_io(1:npft)
979a966,976
> 
> ! SUGAR parameters
> sug_g0(:)       = sug_g0_io(1:npft)
> sug_grec(:)     = sug_grec_io(1:npft)
> sug_yg(:)       = sug_yg_io(1:npft)
> 
> ! SOX parameters
> sox_a(:)        = sox_a_io(1:npft)
> sox_p50(:)      = sox_p50_io(1:npft)
> sox_rp_min(:)   = sox_rp_min_io(1:npft)
> 
diff -r vn7.0copy1_c4/src/./science/params/pftparm_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/params/pftparm_mod.F90
156c156
< ,jv25_ratio(:)                                                                 &
---
> ,jv25_ratio(:)
159,181d158
< !---------------------------------------------------------------------------
< ! Parameters for the pmodel.
< !---------------------------------------------------------------------------
< ,beta_c3c4(:)                                                                  &
<                  ! Unit cost ratio for C3/C4 plants.
<                  ! unitless
< ,eagamma(:)                                                                    &
<                  ! Activation energy for gammastar
< ,eakc(:)                                                                       &
<                  ! Activation energy for carboxylase                          
<                  ! (J mol-1) 
< ,eako(:)                                                                       &
<                  ! Activation energy for oxygenase
<                  ! (J mol-1).  
< ,gamma25(:)                                                                    &
<                  ! stomata conductance at 25 deg C
< 		! (pascal)                                               
< ,kc25(:)                                                                       &
<                  ! Michaelis-Menten const carboxylase, 25 deg C               
<                  ! (pascal).
< ,ko25(:)
<                  ! Michaelis-Menten const oxygenase, 25 deg C
<                  ! (pascal).
359a337,359
> !-----------------------------------------------------------------------------
> ! Parameters for SUGAR
> !-----------------------------------------------------------------------------
> REAL(KIND=real_jlslsm), ALLOCATABLE ::                                         &
>  sug_grec(:)                                                                   &
>                  ! Turnover of structural carbon into NSC (KgC/m2/s)
> ,sug_g0(:)                                                                     &
>                  ! Specific structural C growth rate (KgC/m2/s)
> ,sug_yg(:)
>                  ! Growth yield fraction
> 
> !-----------------------------------------------------------------------------
> ! Parameters for SOX
> !-----------------------------------------------------------------------------
> REAL(KIND=real_jlslsm), ALLOCATABLE ::                                         &
>  sox_a(:)                                                                      &
>                  ! The shape parameter in the xylem vulnerability curve.
> ,sox_p50(:)                                                                    &
>                  ! Xlem water potential at which xylem hydraulic
>                  ! conductance is half its maximum value. (MPa)
> ,sox_rp_min(:)
>                  ! Plant minimum hydraulic resistance. (m2 s MPa/mol)
> 
437d436
< ALLOCATE( beta_c3c4(npft))
445,447d443
< ALLOCATE( eagamma(npft))
< ALLOCATE( eakc(npft))
< ALLOCATE( eako(npft))
450d445
< ALLOCATE( gamma25(npft))
453,454d447
< ALLOCATE( kc25(npft))
< ALLOCATE( ko25(npft))
469d461
< beta_c3c4(:)    = 0.0
477,479d468
< eagamma(:)      = 0.0
< eakc(:)         = 0.0
< eako(:)         = 0.0
482d470
< gamma25(:)      = 0.0
485,486d472
< kc25(:)         = 0.0
< ko25(:)         = 0.0
625a612,629
> 
> ! SUGAR parameters
> ALLOCATE( sug_grec(npft))
> ALLOCATE( sug_g0(npft))
> ALLOCATE( sug_yg(npft))
> 
> sug_grec(:) = 0.0
> sug_g0(:)   = 0.0
> sug_yg(:)   = 0.0
> 
> ! SOX parameters
> ALLOCATE( sox_a(npft))
> ALLOCATE( sox_p50(npft))
> ALLOCATE( sox_rp_min(npft))
> 
> sox_a(:)      = 0.0
> sox_p50(:)    = 0.0
> sox_rp_min(:) = 0.0
diff -r vn7.0copy1_c4/src/./science/params/veg3_param_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/params/veg3_param_mod.F90
121,123d120
< #if ! defined(UM_JULES)
< USE model_time_mod,           ONLY: timestep_len => timestep
< #endif
diff -r vn7.0copy1_c4/src/./science/radiation/albpft_jls_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/radiation/albpft_jls_mod.F90
188c188,189
< REAL(KIND=real_jlslsm) :: exp_hla, exp_minus_hla, exp_minus_kla
---
> REAL(KIND=real_jlslsm) :: exp_hla, exp_minus_hla, exp_minus_kla,               &
>         exp_k_dlai_min_la
232c233,234
< !$OMP         alpa_arr, omegal_arr, alpal_arr, omegau_arr,alpau_arr)           &
---
> !$OMP         alpa_arr, omegal_arr, alpal_arr, omegau_arr,alpau_arr,           &
> !$OMP         exp_k_dlai_min_la)                                               &
302a305,311
>     ! If albpft_call is 0, then either there's no scaling to albedo obs,
>     ! or this is the first call in that process to make a first guess:
>     IF (albpft_call == 0 ) THEN
>       om   = omega_arr(band)
>       alpl = alpa_arr(band)
>     END IF
> 
307,313c316
<       ! If albpft_call is 0, then either there's no scaling to albedo obs,
<       ! or this is the first call in that process to make a first guess:
<       IF (albpft_call == 0 ) THEN
<         om   = omega_arr(band)
<         alpl = alpa_arr(band)
< 
<       ELSE IF ( albpft_call == 1 ) THEN
---
>       IF ( albpft_call == 1 ) THEN
544a548
>             exp_k_dlai_min_la = EXP(k * (dlai - la))
557c561
<             dabeer_dla(i) = (EXP(-k * (la - dlai)) - exp_minus_kla) / dlai
---
>             dabeer_dla(i) = (exp_k_dlai_min_la - exp_minus_kla) / dlai
563c567
<             fsun(l,n,i) = exp_minus_kla * (EXP(k * dlai) - 1.0) / (k * dlai)
---
>             fsun(l,n,i) = (exp_k_dlai_min_la - exp_minus_kla) / (k * dlai)
diff -r vn7.0copy1_c4/src/./science/radiation/calc_direct_albsoil_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/radiation/calc_direct_albsoil_mod.F90
10,12d9
< USE parkind1,                 ONLY: jprb, jpim
< USE yomhook,                  ONLY: lhook, dr_hook
< 
15,16d11
< CHARACTER(LEN=*), PARAMETER, PRIVATE :: ModuleName='CALC_DIRECT_ALBSOIL_MOD'
< 
37,42d31
< INTEGER(KIND=jpim), PARAMETER :: zhook_in  = 0
< INTEGER(KIND=jpim), PARAMETER :: zhook_out = 1
< REAL(KIND=jprb)               :: zhook_handle
< 
< CHARACTER(LEN=*), PARAMETER :: RoutineName='CALC_DIRECT_ALBSOIL'
< 
44,45d32
< IF (lhook) CALL dr_hook(ModuleName//':'//RoutineName,zhook_in,zhook_handle)
< 
61d47
< IF (lhook) CALL dr_hook(ModuleName//':'//RoutineName,zhook_out,zhook_handle)
64d49
< 
66,67d50
< 
< 
diff -r vn7.0copy1_c4/src/./science/radiation/canyonalb_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/radiation/canyonalb_mod.F90
169d168
<   WRITE(jules_message,*)
173,174d171
<   WRITE(jules_message,'(5(2x,f6.3))') coszz, hwr, albwl, albrd, albcan
<   CALL jules_print('canyonalb',jules_message,level = PrNorm)
diff -r vn7.0copy1_c4/src/./science/radiation/Jin11_osa_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/radiation/Jin11_osa_mod.F90
311,312d310
< END DO
< !$OMP END DO
314,316c312
< ! rrr, the fresnel reflectance for at each point, for the broadband refm:
< !$OMP DO SCHEDULE(STATIC)
< DO ipt = 1, nd_points
---
>   ! rrr, the fresnel reflectance for at each point, for the broadband refm:
321,322d316
< END DO
< !$OMP END DO NOWAIT
324,327c318,319
< ! the foam/whitecap fraction. (Eq 16 of Jin 2011, from Koepke 1984,
< ! doi:10.1364/AO.23.001816)
< !$OMP DO SCHEDULE(STATIC)
< DO ipt = 1, nd_points
---
>   ! the foam/whitecap fraction. (Eq 16 of Jin 2011, from Koepke 1984,
>   ! doi:10.1364/AO.23.001816)
339d330
<   END DO
341,342c332
<   ! fresnel reflection, at current solar zenith angle and wavelength:
<   DO ipt = 1, nd_points
---
>     ! fresnel reflection, at current solar zenith angle and wavelength:
347,348d336
<   END DO
< 
350,351c338
<   ! This gives the direct surface albedo (eq 1 in Jin 2011):
<   DO ipt = 1, nd_points
---
>     ! This gives the direct surface albedo (eq 1 in Jin 2011):
353d339
<   END DO
355,356c341
<   ! and this is the surface diffuse (Eq 5a in Jin 2011):
<   DO ipt = 1, nd_points
---
>     ! and this is the surface diffuse (Eq 5a in Jin 2011):
358c343,344
<                     s_df_fit(3) * refm(iwl) + s_df_fit(4) * sigma(ipt) * refm(iwl)
---
>                     s_df_fit(3) * refm(iwl) + s_df_fit(4) * sigma(ipt) *       &
>                     refm(iwl)
393d378
<     END DO
395,396c380
<     ! now combine to give the diffuse sub-surface/water leaving albedo:
<     DO ipt = 1, nd_points
---
>       ! now combine to give the diffuse sub-surface/water leaving albedo:
416,418c400
<   END DO
<   ! then diffuse:
<   DO ipt = 1, nd_points
---
>     ! then diffuse:
424,425c406
< !$OMP END DO
< 
---
> !$OMP END DO NOWAIT
465,469c446
<         END DO
<       END DO
<       ! add the values up:
<       DO iwl = 1, n_band_subsample
<         DO ipt = 1, nd_points
---
>           ! add the values up:
477,478d453
<       END DO
<       DO ipt = 1, nd_points
1136d1110
< END DO
1138d1111
< DO ipt = 1, nd_points
diff -r vn7.0copy1_c4/src/./science/radiation/jules_land_albedo_jls_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/radiation/jules_land_albedo_jls_mod.F90
41c41
<         l_lice_point,                                                          &
---
>         l_lice_point, l_lice_surft,                                            &
91c91
<   nsoilt, l_lice_surft, rad_nband
---
>   nsoilt, rad_nband
186a187
> LOGICAL, INTENT(IN) :: l_lice_surft(ntype)
325,326c326,335
< DO n = 1,ntype
<   DO l = 1,land_pts
---
> !$OMP PARALLEL DEFAULT(NONE) PRIVATE(j, l, n, n_surft_pft, band, i, k)         &
> !$OMP SHARED(ntype, land_pts, albsnc, nsurft, alb_surft, alb_type, alb_snow,   &
> !$OMP        snowdep_surft, snowdepth_surft, can_model, cansnowtile,           &
> !$OMP        l_snowdep_surf, snow_surft, rho_snow_const, surft_pts, npft,      &
> !$OMP        surft_index, lai, lai_pft, lai_alb_lim, lai_alb_lim_sn,           &
> !$OMP        l_aggregate, rad_nband, albobs_scaling_surft, l_albedo_obs,       &
> !$OMP        pfield, albobs_sc_ij)
> DO n = 1, ntype
> !$OMP DO SCHEDULE(STATIC)
>   DO l = 1, land_pts
329a339
> !$OMP END DO NOWAIT
331,333c341,344
< DO n = 1,nsurft
<   DO band = 1,4
<     DO l = 1,land_pts
---
> DO band = 1, 4
>   DO n = 1, nsurft
> !$OMP DO SCHEDULE(STATIC)
>     DO l = 1, land_pts
335a347
> !$OMP END DO NOWAIT
338,340c350,353
< DO n = 1,ntype
<   DO band = 1,4
<     DO l = 1,land_pts
---
> DO band = 1, 4
>   DO n = 1, ntype
> !$OMP DO SCHEDULE(STATIC)
>     DO l = 1, land_pts
343a357
> !$OMP END DO NOWAIT
348,349c362,369
< snowdep_surft(:,:) = snowdepth_surft(:,:)
< DO n = 1,nsurft
---
> DO n = 1, nsurft
> !$OMP DO SCHEDULE(STATIC)
>   DO l = 1, land_pts
>     snowdep_surft(l,n) = snowdepth_surft(l,n)
>   END DO
> !$OMP END DO
> END DO
> DO n = 1, nsurft
351c371,372
<     DO l = 1,land_pts
---
> !$OMP DO SCHEDULE(STATIC)
>     DO l = 1, land_pts
353a375
> !$OMP END DO
367c389,390
<   DO j = 1,surft_pts(n)
---
> !$OMP DO SCHEDULE(STATIC)
>   DO j = 1, surft_pts(n)
374a398
> !$OMP END DO NOWAIT
377d400
< 
381c404,412
<   albobs_scaling_surft = 1.0
---
>   DO k = 1, rad_nband
>     DO j = 1, ntype
> !$OMP DO SCHEDULE(STATIC)
>       DO l = 1, land_pts
>         albobs_scaling_surft(l,j,k) = 1.0
>       END DO
> !$OMP END DO NOWAIT
>     END DO
>   END DO
383c414,423
< albobs_sc_ij    = rmdi
---
> DO k = 1, 2
>   DO n = 1, nsurft
> !$OMP DO SCHEDULE(STATIC)
>     DO i = 1, pfield
>       albobs_sc_ij(i,n,k) = rmdi
>     END DO
> !$OMP END DO NOWAIT
>   END DO
> END DO
> !$OMP END PARALLEL
520,521c560,566
<     albsfm_vis(:) = 0.0
<     albsfm_nir(:) = 0.0
---
> !$OMP PARALLEL DO SCHEDULE(STATIC) IF(land_pts>1) DEFAULT(NONE) PRIVATE(l)     &
> !$OMP SHARED(land_pts, albsfm_vis, albsfm_nir)
>     DO l = 1, land_pts
>       albsfm_vis(l) = 0.0
>       albsfm_nir(l) = 0.0
>     END DO
> !$OMP END PARALLEL DO
531a577,579
> !$OMP PARALLEL DO SCHEDULE(STATIC) IF(land_pts>1) DEFAULT(NONE) PRIVATE(l)     &
> !$OMP SHARED(land_pts, albsfm_vis, albsfm_nir, albobs_vis_gb, albobs_nir_gb,   &
> !$OMP        albsfsc, l_lice_point)
537a586
> !$OMP END PARALLEL DO
559a609,612
> !$OMP PARALLEL DO SCHEDULE(STATIC) DEFAULT(NONE) PRIVATE(j, l)                 &
> !$OMP SHARED(n, surft_pts, surft_index, soil, band, alb_type, albsoil_soilt,   &
> !$OMP        m, disaggregate_albsoil, albsfsc, albsnf_nvgl, albsnf_nvgu, npft, &
> !$OMP        albobs_scaling_surft, albsnf_nvg)
593a647
> !$OMP END PARALLEL DO
599a654,655
> !$OMP PARALLEL DO SCHEDULE(STATIC) DEFAULT(NONE) PRIVATE(j, l)                 &
> !$OMP SHARED(n, surft_pts, surft_index, alb_type, band, l_hapke_soil, cosz_gb)
607a664
> !$OMP END PARALLEL DO
616a674,675
> !$OMP PARALLEL DEFAULT(NONE) PRIVATE(l, n, band)                               &
> !$OMP SHARED(npft, land_pts, albobs_scaling_surft, albsfsc)
618a678
> !$OMP DO SCHEDULE(STATIC)
621a682
> !$OMP END DO NOWAIT
623a685
> !$OMP END PARALLEL
1565c1627,1638
<   albobs_sc_ij(:,:,:)=1.0
---
> !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i, k, n)                                  &
> !$OMP SHARED(nsurft, pfield, albobs_sc_ij)
>   DO k = 1, 2
>     DO n = 1, nsurft
> !$OMP DO SCHEDULE(STATIC)
>       DO i = 1, pfield
>         albobs_sc_ij(i,n,k) = 1.0
>       END DO
> !$OMP END DO NOWAIT
>     END DO
>   END DO
> !$OMP END PARALLEL
diff -r vn7.0copy1_c4/src/./science/radiation/jules_ssi_albedo_jls_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/radiation/jules_ssi_albedo_jls_mod.F90
53c53,54
<   sea_index, ssi_index, sice_index_ncat, sice_frac_ncat,                       &
---
>   sea_index, ssi_index, sice_index_ncat, sice_frac_ncat, sice_pts_ncat,        &
>   sea_pts,                                                                     &
69d69
< USE ancil_info, ONLY: sea_pts, sice_pts_ncat
88c88
<      nice_use
---
>      nice_use,                                                                 &
89a90
>      sea_pts
219c220,221
<   sice_index_ncat(t_i_length * t_j_length,nice)
---
>   sice_index_ncat(t_i_length * t_j_length,nice),                               &
>   sice_pts_ncat(nice)
243c245
< INTEGER :: band, n, j, l, ll           ! Loops over points
---
> INTEGER :: band, n, j, l, ll, i, k      ! Loops over points
298,303c300,314
<   saos_bb(:,:) = 0.0
<   DO j = 1, n_points
<     IF (flandg(j) <  1.0) THEN
<       saos_bb(j, 1) = 0.026 / (cosz(j)**1.7 + 0.065)                           &
<           +0.15 * (cosz(j) - 0.1) * (cosz(j) - 0.5) * (cosz(j) - 1.0)
<       saos_bb(j,2) = adifc
---
>   DO j = 1, 2
> !$OMP PARALLEL DO SCHEDULE(STATIC) DEFAULT(NONE) PRIVATE(i)                    &
> !$OMP SHARED(n_points, saos_bb, j)
>     DO i = 1, n_points
>       saos_bb(i,j) = 0.0
>     END DO
> !$OMP END PARALLEL DO
>   END DO
> !$OMP PARALLEL DO SCHEDULE(STATIC) DEFAULT(NONE) PRIVATE(i)                    &
> !$OMP SHARED(n_points, saos_bb, flandg, cosz)
>   DO i = 1, n_points
>     IF (flandg(i) <  1.0) THEN
>       saos_bb(i, 1) = 0.026 / (cosz(i)**1.7 + 0.065)                           &
>           +0.15 * (cosz(i) - 0.1) * (cosz(i) - 0.5) * (cosz(i) - 1.0)
>       saos_bb(i,2) = adifc
305a317
> !$OMP END PARALLEL DO
307c319,328
<   saos = 0.0
---
>   DO k = 1, n_band_dim
>     DO j = 1, 2
> !$OMP PARALLEL DO SCHEDULE(STATIC) DEFAULT(NONE) PRIVATE(i)                    &
> !$OMP SHARED(n_points, j, k, saos)
>       DO i = 1, n_points
>         saos(i,j,k) = 0.0
>       END DO
> !$OMP END PARALLEL DO
>     END DO
>   END DO
337c358,362
<   saos_bb(:,:) = 0.0
---
>   DO j = 1, 2
>     DO i = 1, n_points
>       saos_bb(i,j) = 0.0
>     END DO
>   END DO
348c373,379
<   saos = 0.0
---
>   DO k = 1, n_band_dim
>     DO j = 1, 2
>       DO i = 1,n_points
>         saos(i,j,k) = 0.0
>       END DO
>     END DO
>   END DO
404c435,441
<     saos = 0.0
---
>     DO k = 1, n_band_dim
>       DO j = 1, 2
>         DO i = 1,n_points
>           saos(i,j,k) = 0.0
>         END DO
>       END DO
>     END DO
417c454,460
<     saos = 0.0
---
>     DO k = 1, n_band_dim
>       DO j = 1, 2
>         DO i = 1,n_points
>           saos(i,j,k) = 0.0
>         END DO
>       END DO
>     END DO
434c477,483
<   saos(:,:,:) = fixed_sea_albedo
---
>   DO k = 1, n_band_dim
>     DO j = 1, 2
>       DO i = 1,n_points
>         saos(i,j,k) = fixed_sea_albedo
>       END DO
>     END DO
>   END DO
441c490,496
<   saos(:,:,:) = fixed_sea_albedo
---
>   DO k = 1, n_band_dim
>     DO j = 1, 2
>       DO i = 1,n_points
>         saos(i,j,k) = fixed_sea_albedo
>       END DO
>     END DO
>   END DO
496,498c551,563
< sa_sice (:,:)   = 0.0
< alb_sicat(:,:,:) = 0.0
< penabs_rad_frac(:,:,:) = 0.0
---
> DO j = 1, 4
>   DO i = 1, n_points
>     sa_sice (i,j)   = 0.0
>   END DO
> END DO
> DO k = 1, 4
>   DO j = 1, nice_use
>     DO i = 1, t_i_length * t_j_length
>       alb_sicat(i,j,k) = 0.0
>       penabs_rad_frac(i,j,k) = 0.0
>     END DO
>   END DO
> END DO
diff -r vn7.0copy1_c4/src/./science/river_routing/overbank_update_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/river_routing/overbank_update_mod.F90
33,36d32
< USE planet_constants_mod, ONLY: planet_radius
< 
< USE conversions_mod, ONLY: pi_over_180
< 
38,39c34
<    np_rivers,                                                                  &
<    nstep_rivers, rivers_dx, rivers_dlat
---
>    np_rivers, nstep_rivers, rivers_length
43c38
<    l_riv_hypsometry, use_rosgen,                                               &
---
>    overbank_hypsometric, overbank_simple, overbank_simple_rosgen,              &
45c40
<    riv_a, riv_b, riv_c, riv_f, ent_ratio,                                      &
---
>    overbank_model, riv_a, riv_b, riv_c, riv_f, ent_ratio,                      &
64c59,60
< REAL(KIND=real_jlslsm) :: dt, dx
---
> REAL(KIND=real_jlslsm) :: dt
>        ! River timestep length (s).
79c75
< ! rivers model timestep (s)
---
> ! Calculate rivers model timestep length.
82,88d77
< ! horizontal gridsize (m)
< IF (rivers_dx <= 0) THEN
<   dx = planet_radius * ( ABS( rivers_dlat ) * pi_over_180 )
< ELSE
<   dx = rivers_dx
< END IF
< 
93a83,84
> 
>   ! Initialisation.
95c86
<   riv_width(ip) = 0.0
---
>   frac_fplain_rp(ip) = 0.0
96a88
>   ! Remove any negative flow value.
99c91,93
<   IF ( l_riv_hypsometry .OR. use_rosgen ) THEN
---
>   ! Calculate river flow depth, if required.
>   IF ( overbank_model == overbank_simple_rosgen .OR.                           &
>        overbank_model == overbank_hypsometric ) THEN
108,109c102,103
<   frac_fplain_rp(ip) = 0.0
<   IF ( l_riv_hypsometry ) THEN
---
>   SELECT CASE ( overbank_model )
>   CASE ( overbank_hypsometric )
120c114
<   ELSE
---
>   CASE ( overbank_simple, overbank_simple_rosgen )
122,123c116,118
<     ! Calculate as estimated river width divided by (north-south cell extent),
<     ! (i.e. assuming that river channel runs straight W-E)
---
>     ! Calculate inundated fraction as estimated river width divided by
>     ! north-south cell extent (i.e. assuming that river channel runs
>     !straight W-E).
128,136c123,132
<     IF ( use_rosgen .AND. rfm_rivflow_rp(ip) > qbf(ip) ) THEN
<       ! If river above bankfull and using Rosgen entrenchment ratio option.
<       ! This assumes linear interpolation between (width=wbf, depth=dbf) and
<       ! (width=ent_ratio*wbf, depth=2*dbf) (from definition of Rosgen
<       ! entrenchment ratio)
< 
<       riv_width(ip) = wbf(ip) + ( ( wbf(ip) * (ent_ratio-1.0)                  &
<                                   * (riv_depth(ip) - dbf(ip)) ) / dbf(ip) )
<     END IF
---
>     IF ( overbank_model == overbank_simple_rosgen ) THEN
>       IF ( rfm_rivflow_rp(ip) > qbf(ip) ) THEN
>         ! River is above bankfull and using Rosgen entrenchment ratio option.
>         ! This assumes linear interpolation between (width=wbf, depth=dbf) and
>         ! (width=ent_ratio*wbf, depth=2*dbf) (from definition of Rosgen
>         ! entrenchment ratio)
>         riv_width(ip) = wbf(ip) + ( ( wbf(ip) * (ent_ratio-1.0)                &
>                                       * (riv_depth(ip) - dbf(ip)) ) / dbf(ip) )
>       END IF
>     END IF  !  overbank_simple_rosgen
139c135,136
<       frac_fplain_rp(ip) = MAX( MIN(riv_width(ip) / dx , 1.0 ) , 0.0 )
---
>       frac_fplain_rp(ip) = MAX( MIN(riv_width(ip) / rivers_length , 1.0 ) ,    &
>                                 0.0 )
142c139
<   END IF  !  l_riv_hypsometry
---
>   END SELECT  !  overbank_model
diff -r vn7.0copy1_c4/src/./science/river_routing/rivers_regrid_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/river_routing/rivers_regrid_mod.F90
1,2c1,2
< !###############################################################################
< !###############################################################################
---
> !##############################################################################
> !##############################################################################
6c6
< !-----------------------------------------------------------------------------
---
> !------------------------------------------------------------------------------
8c8
< !   Contains river routing regridding/remapping functions for standalone
---
> !   Contains river routing regridding/remapping functions for standalone JULES.
16c16
< !-----------------------------------------------------------------------------
---
> !------------------------------------------------------------------------------
21a22,26
> PRIVATE  !  private scope by default
> PUBLIC get_xy_pos, calc_grid_index, landpts_to_rivpts,                         &
>        calc_map_river_to_land_points, rivpts_to_landpts,                       &
>        twod_to_rp, rp_to_twod
> 
24,31c29,31
< !###############################################################################
< ! subroutine rivers_get_xy_pos
< !
< ! Internal procedure in module grid_utils
< !    Given a point number and the extents (size) of a 2-D (xy) grid, returns
< !    the x and y indices (coords) of the point. All coords are relative to (1,1)
< !    at bottom left of grid, with numbering running left to right, bottom to
< !    top.
---
> !##############################################################################
> 
> SUBROUTINE get_xy_pos( i, nx, ny, ix, iy )
33c33,39
< SUBROUTINE rivers_get_xy_pos( i, nx, ny, ix, iy )
---
> !------------------------------------------------------------------------------
> ! Description:
> !    Given a point number and the extents (size) of a 2-D (xy) grid, returns
> !    the x and y indices (coords) of the point. All coords are relative to
> !    (1,1) at bottom left of grid, with numbering running left to right,
> !    bottom to top.
> !------------------------------------------------------------------------------
37c43,45
< ! Scalar arguments with intent (in)
---
> !------------------------------------------------------------------------------
> ! Scalar arguments with INTENT(IN):
> !------------------------------------------------------------------------------
47c55,57
< ! Scalars with intent (out)
---
> !------------------------------------------------------------------------------
> ! Scalar arguments with INTENT(OUT):
> !------------------------------------------------------------------------------
49a60,62
> !end of header
> !------------------------------------------------------------------------------
> 
51,52c64,65
< iy = ( i - 1 ) / nx + 1
< ix = i - (iy-1) * nx
---
> iy = (i - 1) / nx + 1
> ix = i - (iy - 1) * nx
61,62c74,75
< END SUBROUTINE rivers_get_xy_pos
< !###############################################################################
---
> RETURN
> END SUBROUTINE get_xy_pos
63a77
> !##############################################################################
65,72c79,84
< !###############################################################################
< ! subroutine rivers_remap_match
< ! Computes regridding between land points and main model grid where both
< ! grids overlap (i.e. rivers_regrid=False)
< SUBROUTINE rivers_remap_match(                                                 &
< !  imported rivers arrays with intent(in)
<      ir_land_grid, il_river_grid, rivers_lat_rp, rivers_lon_rp )
< !-----------------------------------------------------------------------------
---
> SUBROUTINE calc_map_river_to_land_points( global_land_pts,                     &
>                                  x_coord_of_land, y_coord_of_land,             &
>                                  rivers_x_coord_rp, rivers_y_coord_rp,         &
>                                  map_river_to_land_points )
> 
> !------------------------------------------------------------------------------
75,81c87,90
< !   Computes remapping between land points and river routing grid
< !
< !   If the "main" model grid is 2-D, this target grid is the 2-D grid.
< !   If the "main" grid is a vector (in offline applications of JULES this is
< !   possible if points from a larger grid have been compressed - e.g. land
< !   points selected from a larger grid.), the target grid is the larger grid,
< !   across which the points are to be scattered.
---
> !   Computes mapping between land points and river points.
> !   Only used when rivers_regrid=F.
> !   For each river point, this identifies a land point (if it exists) with
> !   the same coordinate values, and returns the number of that point.
86c95
< USE jules_rivers_mod, ONLY: np_rivers
---
> USE jules_rivers_mod, ONLY: l_trivial_mapping, np_rivers
89,93c98
< USE atm_land_sea_mask, ONLY: global_land_pts => atmos_number_of_landpts
< USE um_latlon_mod, ONLY: latitude_of_land_pts => latitude,                     &
<                          longitude_of_land_pts => longitude
< USE um_parallel_mod, ONLY: is_master_task,                                     &
<                            gather_land_field => gather_land2d_field
---
> USE um_parallel_mod, ONLY: is_master_task
95,97c100
< USE model_grid_mod, ONLY: global_land_pts, latitude_of_land_pts,               &
<     longitude_of_land_pts
< USE parallel_mod, ONLY: is_master_task, gather_land_field
---
> USE parallel_mod, ONLY: is_master_task
102,108c105,110
< REAL(KIND=real_jlslsm), ALLOCATABLE :: global_lat_of_land_pts(:)
< REAL(KIND=real_jlslsm), ALLOCATABLE :: global_lon_of_land_pts(:)
< 
< INTEGER, INTENT(IN OUT) :: il_river_grid(:)
< INTEGER, INTENT(IN OUT) :: ir_land_grid(:)
< REAL, INTENT(IN OUT) :: rivers_lat_rp(:)
< REAL, INTENT(IN OUT) :: rivers_lon_rp(:)
---
> !------------------------------------------------------------------------------
> ! Scalar arguments with INTENT(IN):
> !------------------------------------------------------------------------------
> INTEGER, INTENT(IN) ::                                                         &
>   global_land_pts
>     ! The number of land points in the full model grid.
110c112,123
< ! Local scalar variables.
---
> !------------------------------------------------------------------------------
> ! Array arguments with INTENT(IN):
> !------------------------------------------------------------------------------
> REAL(KIND=real_jlslsm), INTENT(IN) ::                                          &
>   x_coord_of_land(global_land_pts),                                            &
>     ! x coordinates of land points.
>   y_coord_of_land(global_land_pts),                                            &
>     ! y coordinates of land points.
>   rivers_x_coord_rp(np_rivers),                                                &
>     ! x coordinates of river points.
>   rivers_y_coord_rp(np_rivers)
>     ! y coordinates of river points.
112,113c125,129
< INTEGER :: l      !  loop counter (land point)
< INTEGER :: ip     !  work
---
> !------------------------------------------------------------------------------
> ! Array arguments with INTENT(OUT):
> !------------------------------------------------------------------------------
> INTEGER, INTENT(OUT) :: map_river_to_land_points(:)
>   ! List of coincident land point numbers, on river points.
116c132,141
< ! Compute full land_pts grid lat/lon
---
> ! Local scalar variables.
> !------------------------------------------------------------------------------
> INTEGER ::                                                                     &
>   iland, l, rp,                                                                &
>     ! Loop counters and indices
>   nmatch
>     ! Counter of locations for which a trivial mapping applies, i.e the n-th
>     ! river point matches the n-th land point.
> 
> !end of header
120,125d144
<   ALLOCATE(global_lat_of_land_pts(global_land_pts))
<   ALLOCATE(global_lon_of_land_pts(global_land_pts))
< ELSE
<   ALLOCATE(global_lat_of_land_pts(1))
<   ALLOCATE(global_lon_of_land_pts(1))
< END IF
127,128c146,174
< global_lat_of_land_pts(:) = 0.0
< global_lon_of_land_pts(:) = 0.0
---
>   ! Initialise with zero to show that there is no matching land point.
>   map_river_to_land_points(:) = 0
> 
>   ! Initialise index so first loop will start at first land point, and
>   ! initialise counter of points with trivial mapping.
>   iland = 0
>   nmatch = 0
> 
>   DO rp = 1,np_rivers
>     ! Search all land points to find a match. A river point without matching
>     ! land retains the initial value set above.
>     DO l = 1,global_land_pts
>       ! We start at the land point next to the last match found (from previous
>       ! river point).
>       iland = iland + 1
>       IF ( iland > global_land_pts ) THEN
>         ! Continue the search from the first land point.
>         iland = 1
>       END IF
>       IF ( rivers_x_coord_rp(rp) == x_coord_of_land(iland) .AND.               &
>            rivers_y_coord_rp(rp) == y_coord_of_land(iland) ) THEN
>         map_river_to_land_points(rp) = iland
>         ! Check for trivial mapping.
>         IF ( rp == iland ) THEN
>           nmatch = nmatch + 1
>         END IF
>         EXIT  ! leave land point loop
>       END IF
>     END DO  !  l (land points)
130,131c176
< CALL gather_land_field(latitude_of_land_pts, global_lat_of_land_pts)
< CALL gather_land_field(longitude_of_land_pts, global_lon_of_land_pts)
---
>   END DO  !  rp (river points)
133,136c178,182
< !------------------------------------------------------------------------------
< ! Compute remap between land points and full river grid
< !         general case, covers all grid types when rivers_regrid=False
< !------------------------------------------------------------------------------
---
>   ! If the numbers of river and land points are equal, and all have a trivial
>   ! mapping (they occur in the same order), set flag.
>   IF ( np_rivers == global_land_pts .AND. nmatch == np_rivers ) THEN
>     l_trivial_mapping = .TRUE.
>   END IF
138,149c184
< IF ( is_master_task() ) THEN
<   DO l = 1,global_land_pts
<     DO ip = 1,np_rivers
<       IF (rivers_lat_rp(ip) == global_lat_of_land_pts(l) .AND.                 &
<          rivers_lon_rp(ip) == global_lon_of_land_pts(l)) THEN
<         il_river_grid(ip) = l
<         ir_land_grid(l) = ip
<         EXIT
<       END IF
<     END DO
<   END DO
< END IF
---
> END IF  !  is_master_task
151,152c186,192
< DEALLOCATE(global_lat_of_land_pts)
< DEALLOCATE(global_lon_of_land_pts)
---
> RETURN
> END SUBROUTINE calc_map_river_to_land_points
> 
> !##############################################################################
> 
> SUBROUTINE calc_grid_index( npts, nx, ny, dx, dy, frac_toler, x1, y1, x_coord, &
>                             y_coord, grid_index )
154,160d193
< END SUBROUTINE rivers_remap_match
< !###############################################################################
< !###############################################################################
< ! subroutine rivers_remap_unmatch
< ! Setup initial arrays for regridding between land points and main model grid
< ! where both grids DO NOT overlap
< SUBROUTINE rivers_remap_unmatch(ir_land_grid)
162d194
< !
164c196,197
< !
---
> !   Calculate the mapping of land points to a 2D grid, returning an index
> !   of location in the grid.
166d198
< ! Modules used:
168,171c200,201
< USE jules_rivers_mod, ONLY:                                                    &
< !  imported scalars with intent(in) - defining grid
<      nx_grid, reg_dlat, reg_dlon, reg_lon1, reg_lat1,                          &
<      rivers_reglatlon, rivers_regrid
---
> ! Modules used:
> USE ereport_mod, ONLY: ereport
173,183c203,205
< #if defined(UM_JULES)
< USE atm_land_sea_mask, ONLY: global_land_pts => atmos_number_of_landpts
< USE um_latlon_mod, ONLY: latitude_of_land_pts => latitude,                     &
<                          longitude_of_land_pts => longitude
< USE um_parallel_mod, ONLY: is_master_task,                                     &
<                            gather_land_field => gather_land2d_field
< #else
< USE model_grid_mod, ONLY: global_land_pts, latitude_of_land_pts,               &
<     longitude_of_land_pts
< USE parallel_mod, ONLY: is_master_task, gather_land_field
< #endif
---
> USE jules_print_mgr, ONLY:                                                     &
>    jules_message,                                                              &
>    jules_print
187,195d208
< REAL(KIND=real_jlslsm), ALLOCATABLE :: global_lat_of_land_pts(:)
< REAL(KIND=real_jlslsm), ALLOCATABLE :: global_lon_of_land_pts(:)
< INTEGER, INTENT(IN OUT) :: ir_land_grid(:)
< 
< 
< ! Local scalar variables.
< 
< INTEGER :: l      !  loop counter (land point)
< INTEGER :: i,j    !  work
198c211
< ! Compute full land_pts grid lat/lon
---
> ! Scalar arguments with INTENT(IN):
200,213c213,248
< 
< IF ( is_master_task() ) THEN
<   ALLOCATE(global_lat_of_land_pts(global_land_pts))
<   ALLOCATE(global_lon_of_land_pts(global_land_pts))
< ELSE
<   ALLOCATE(global_lat_of_land_pts(1))
<   ALLOCATE(global_lon_of_land_pts(1))
< END IF
< 
< global_lat_of_land_pts(:) = 0.0
< global_lon_of_land_pts(:) = 0.0
< 
< CALL gather_land_field(latitude_of_land_pts, global_lat_of_land_pts)
< CALL gather_land_field(longitude_of_land_pts, global_lon_of_land_pts)
---
> INTEGER, INTENT(IN) ::                                                         &
>   npts,                                                                        &
>     ! The number of points.
>   nx,                                                                          &
>     ! Number of columns in grid.
>   ny
>     ! Number of rows in grid.
> 
> REAL(KIND=real_jlslsm), INTENT(IN) ::                                          &
>   dx,                                                                          &
>     ! Gridbox size in x.
>   dy,                                                                          &
>     ! Gridbox size in y.
>   frac_toler,                                                                  &
>     ! Tolerance (fraction of a gridbox) when testing whether points lie on
>     ! grid.
>   x1,                                                                          &
>     ! x coordinate of point in "SW" (lower left) corner of grid.
>   y1
>     ! y coordinate of point in "SW" (lower left) corner of grid.
> 
> !------------------------------------------------------------------------------
> ! Array arguments with INTENT(IN):
> !------------------------------------------------------------------------------
> REAL(KIND=real_jlslsm), INTENT(IN) ::                                          &
>   x_coord(npts),                                                               &
>     ! x coordinates of points.
>   y_coord(npts)
>     ! y coordinates of points.
> 
> !------------------------------------------------------------------------------
> ! Array arguments with INTENT(OUT):
> !------------------------------------------------------------------------------
> INTEGER, INTENT(OUT) :: grid_index(:)
>   ! List of indices for the grid. For every input point, this is the location
>   ! in a 2-D grid, counting row-wise from the bottom left.
216,217c251
< ! Precalculate landpoints mapping to full 2D grid if river grid and land
< ! grids do not coincide
---
> ! Local scalar variables.
219,226c253,293
< IF ( is_master_task() ) THEN
<   IF ( rivers_regrid .AND. rivers_reglatlon ) THEN
< 
<     DO l = 1,global_land_pts
<       i = NINT( (global_lon_of_land_pts(l) - reg_lon1) / reg_dlon ) + 1
<       j = NINT( (global_lat_of_land_pts(l) - reg_lat1) / reg_dlat ) + 1
<       ir_land_grid(l) = (j-1) * nx_grid + i
<     END DO
---
> INTEGER ::                                                                     &
>   errcode,                                                                     &
>     ! Error code.
>   i, j,                                                                        &
>     ! Locations on grid.
>   l
>     ! Loop counter.
> 
> REAL(KIND=real_jlslsm) ::                                                      &
>   one_minus_toler, nx_plus_toler, ny_plus_toler,                               &
>     ! Constants.
>   rix, riy
>     ! Locations on grid.
> 
> CHARACTER(LEN=*), PARAMETER :: RoutineName='CALC_GRID_INDEX'
> 
> !end of header
> !------------------------------------------------------------------------------
> 
> ! Initialise to zero to indicate that points are not in grid.
> grid_index(:) = 0
> 
> ! Calculate some constants.
> one_minus_toler = 1.0  - frac_toler
> nx_plus_toler   = nx + frac_toler
> ny_plus_toler   = ny + frac_toler
> 
> DO l = 1,npts
> 
>   ! Calculate location on grid.
>   rix = (x_coord(l) - x1) / dx + 1.0
>   riy = (y_coord(l) - y1) / dy + 1.0
> 
>   ! Raise an error if this location lies beyond the edge of the grid.
>   IF ( rix < one_minus_toler .OR. rix > nx_plus_toler .OR.                     &
>        riy < one_minus_toler .OR. riy > ny_plus_toler ) THEN
>     WRITE(jules_message,'(a,f0.3,tr1,f0.3)' )                                  &
>       'Location lies beyond edge of grid: ', x_coord(l), y_coord(l)
>     errcode = 101  !  a hard error
>     CALL ereport(RoutineName, errcode, jules_message)
>   END IF
227a295,305
>   ! Check that this location lies on the grid - raise an error if the location
>   ! does not match the expected grid to within a non-negligible fraction of a
>   ! gridbox. Essentially we are checking that this location appears to be
>   ! "sufficiently close" to the grid (where "sufficiently close" seeks to
>   ! make allowance for the finite precision of the calculation).
>   IF ( ABS( rix - NINT(rix) ) > frac_toler .OR.                                &
>        ABS( riy - NINT(riy) ) > frac_toler ) THEN
>     WRITE(jules_message,'(a,f0.3,tr1,f0.3)' )                                  &
>       'Location does not sit on the grid: ', x_coord(l), y_coord(l)
>     errcode = 101  !  a hard error
>     CALL ereport(RoutineName, errcode, jules_message)
229d306
< END IF
231,232c308,312
< DEALLOCATE(global_lat_of_land_pts)
< DEALLOCATE(global_lon_of_land_pts)
---
>   ! Calculate location on the grid.
>   ! Note that the use of NINT here means this is a relatively forgiving
>   ! calculation - it "snaps" to the nearest grid location.
>   i = NINT(rix)
>   j = NINT(riy)
234,235c314,315
< END SUBROUTINE rivers_remap_unmatch
< !###############################################################################
---
>   ! Calculate index.
>   grid_index(l) = (j-1) * nx + i
237,239c317
< !###############################################################################
< ! subroutine landpts_to_rivpts
< ! Handles regridding/remapping/no change of variables from landpts to rivpts
---
> END DO
241,242c319,327
< SUBROUTINE landpts_to_rivpts( land_pts, var_land, riv_pts, var_riv,il_river_grid, &
<                               ir_land_grid, rivers_index_rp )
---
> RETURN
> END SUBROUTINE calc_grid_index
> 
> !##############################################################################
> 
> SUBROUTINE landpts_to_rivpts( land_pts, riv_pts,                               &
>                               map_river_to_land_points, global_land_index,     &
>                               rivers_index_rp, var_land,                       &
>                               var_riv )
247c332,333
< !   invokes regridding/remapping/no change for a given input variable.
---
> !   invokes regridding or remapping for a given input variable.
> !------------------------------------------------------------------------------
250c336
<      rivers_regrid
---
>    l_trivial_mapping, rivers_regrid
254,258c340,344
< INTEGER, INTENT(IN) :: land_pts  !  a vector length
< INTEGER, INTENT(IN) :: riv_pts  !  a vector length
< INTEGER, INTENT(IN OUT) :: il_river_grid(:)
< INTEGER, INTENT(IN OUT) :: ir_land_grid(:)
< INTEGER, INTENT(IN OUT) :: rivers_index_rp(:)
---
> !------------------------------------------------------------------------------
> ! Scalar arguments with INTENT(IN):
> !------------------------------------------------------------------------------
> INTEGER, INTENT(IN) :: land_pts  ! Number of land points.
> INTEGER, INTENT(IN) :: riv_pts   ! Number of river points.
259a346,354
> !------------------------------------------------------------------------------
> ! Array arguments with INTENT(IN):
> !------------------------------------------------------------------------------
> INTEGER, INTENT(IN) :: map_river_to_land_points(:)
>   ! List of coincident land point numbers, on river points.
> INTEGER, INTENT(IN) :: global_land_index(:)
>   ! List of indices for the land model grid.
> INTEGER, INTENT(IN) :: rivers_index_rp(:)
>   ! Index of points where routing is calculated.
261d355
< ! Array arguments with intent(in)
263c357
<                                           ! input variable on land_pts
---
>   ! Input variable on land_pts.
265c359,361
< ! Array arguments with intent(out)
---
> !------------------------------------------------------------------------------
> ! Array arguments with INTENT(OUT):
> !------------------------------------------------------------------------------
267c363
<                                           ! output variable on riv_pts
---
>   ! Output variable on riv_pts.
269c365,367
< ! Local counter
---
> !------------------------------------------------------------------------------
> ! Local scalar variables.
> !------------------------------------------------------------------------------
270a369,372
>   ! Local counter
> 
> !end of header
> !------------------------------------------------------------------------------
272d373
< ! If regridding required, call routine
275c376,378
<   CALL rivers_regrid_from_land( land_pts, var_land, riv_pts, var_riv, ir_land_grid, rivers_index_rp )
---
>   ! Call regridding routine.
>   CALL regrid_land_to_rivers_ctl( land_pts, riv_pts, global_land_index,        &
>                                 rivers_index_rp, var_land,  var_riv )
277,278c380
<   ! If not regridding, translate between global_land and river point vectors
< ELSE IF (land_pts /= riv_pts) THEN
---
> ELSE IF ( l_trivial_mapping ) THEN
279a382
>   ! Land and river points occur in the same order, simply copy values.
281,283c384
<     IF (il_river_grid(ip) > 0) THEN
<       var_riv(ip) = var_land(il_river_grid(ip))
<     END IF
---
>     var_riv(ip)  = var_land(ip)
286d386
<   ! If grids identical, including land/riv points in same order, no regrid
288a389,391
>   ! Translate from land points to river points.
>   ! A river point that does not match to a land point has
>   ! map_river_to_land_points=0 and hence does nothing here.
290c393,395
<     var_riv(ip)  = var_land(ip)
---
>     IF (map_river_to_land_points(ip) > 0) THEN
>       var_riv(ip) = var_land(map_river_to_land_points(ip))
>     END IF
294a400
> RETURN
297,299c403
< !###############################################################################
< ! subroutine rivpts_to_landpts
< ! Handles regridding/remapping/no change of variables from landpts to rivpts
---
> !##############################################################################
301,302c405,407
< SUBROUTINE rivpts_to_landpts( riv_pts, var_riv, land_pts, var_land, il_river_grid, &
<                               ir_land_grid, rivers_index_rp )
---
> SUBROUTINE rivpts_to_landpts( land_pts, riv_pts, map_river_to_land_points,     &
>                               global_land_index, rivers_index_rp,              &
>                               var_riv, var_land )
307c412,413
< !   invokes regridding/remapping/no change for a given input variable.
---
> !   invokes regridding or remapping for a given input variable.
> !------------------------------------------------------------------------------
309c415
< USE jules_rivers_mod, ONLY: rivers_regrid
---
> USE jules_rivers_mod, ONLY: l_trivial_mapping, rivers_regrid
313,317c419,423
< INTEGER, INTENT(IN) :: riv_pts  !  a vector length
< INTEGER, INTENT(IN) :: land_pts  !  a vector length
< INTEGER, INTENT(IN OUT) :: il_river_grid(:)
< INTEGER, INTENT(IN OUT) :: ir_land_grid(:)
< INTEGER, INTENT(IN OUT) :: rivers_index_rp(:)
---
> !------------------------------------------------------------------------------
> ! Scalar arguments with INTENT(IN):
> !------------------------------------------------------------------------------
> INTEGER, INTENT(IN) :: land_pts  ! Number of land points.
> INTEGER, INTENT(IN) :: riv_pts   ! Number of river points.
318a425,433
> !------------------------------------------------------------------------------
> ! Array arguments with INTENT(IN):
> !------------------------------------------------------------------------------
> INTEGER, INTENT(IN) :: map_river_to_land_points(:)
>   ! List of land point numbers for river points.
> INTEGER, INTENT(IN) :: global_land_index(:)
>   ! List of indices for the land model grid.
> INTEGER, INTENT(IN) :: rivers_index_rp(:)
>   ! Index of points where routing is calculated.
320d434
< ! Array arguments with intent(in)
322c436
<                                          ! input variable on riv_pts
---
>   ! Input variable on riv_pts.
324c438,440
< ! Array arguments with intent(out)
---
> !------------------------------------------------------------------------------
> ! Array arguments with INTENT(OUT):
> !------------------------------------------------------------------------------
326c442
<                                          ! output variable on land_pts
---
>   ! output variable on land_pts.
328c444,446
< ! Local counter
---
> !------------------------------------------------------------------------------
> ! Local scalar variables.
> !------------------------------------------------------------------------------
329a448,451
>   ! Local counter
> 
> !end of header
> !------------------------------------------------------------------------------
331d452
< ! If regridding required, call routine
334,335c455,457
<   CALL rivers_regrid_to_land( riv_pts, var_riv, land_pts, var_land,            &
<                               ir_land_grid, rivers_index_rp )
---
>   ! Call regridding routine.
>   CALL regrid_rivers_to_land_ctl( land_pts, riv_pts, global_land_index,        &
>                                   rivers_index_rp, var_riv, var_land )
337,338c459
<   ! If not regridding, translate between global_land and river point vectors
< ELSE IF (land_pts /= riv_pts) THEN
---
> ELSE IF ( l_trivial_mapping ) THEN
339a461
>   ! Land and river points occur in the same order, simply copy values.
341,343c463
<     IF (il_river_grid(ip) > 0) THEN
<       var_land(il_river_grid(ip)) = var_riv(ip)
<     END IF
---
>     var_land(ip) = var_riv(ip)
346d465
<   ! If grids identical, including land/riv points in same order, no regrid
348a468,470
>   ! Translate from river points to land points.
>   ! A river point that does not match to a land point has
>   ! map_river_to_land_points=0 and hence does nothing here.
350c472,474
<     var_land(ip) = var_riv(ip)
---
>     IF (map_river_to_land_points(ip) > 0) THEN
>       var_land(map_river_to_land_points(ip)) = var_riv(ip)
>     END IF
354a479
> RETURN
357,359c482,486
< !###############################################################################
< ! subroutine rivers_regrid_from_land
< ! Handles regridding of runoff from "main" to rivers grids.
---
> !##############################################################################
> 
> SUBROUTINE regrid_land_to_rivers_ctl( land_pts, riv_pts, global_land_index,    &
>                                       rivers_index_rp, runoff_land,            &
>                                       runoff_riv )
361,362d487
< SUBROUTINE rivers_regrid_from_land( land_pts, runoff_land, riv_pts,            &
<                                     runoff_riv, ir_land_grid, rivers_index_rp)
366a492
> !------------------------------------------------------------------------------
370c496
<      nx_rivers,ny_rivers, nx_grid, ny_grid
---
>      nx_rivers,ny_rivers, nx_land_grid, ny_land_grid
374,377c500,504
< INTEGER, INTENT(IN) :: land_pts  !  a vector length
< INTEGER, INTENT(IN) :: riv_pts  !  a vector length
< INTEGER, INTENT(IN OUT) :: ir_land_grid(:)
< INTEGER, INTENT(IN OUT) :: rivers_index_rp(:)
---
> !------------------------------------------------------------------------------
> ! Scalar arguments with INTENT(IN):
> !------------------------------------------------------------------------------
> INTEGER, INTENT(IN) :: land_pts  ! Number of land points.
> INTEGER, INTENT(IN) :: riv_pts   ! Number of river points.
379c506,512
< ! Array arguments with intent(in)
---
> !------------------------------------------------------------------------------
> ! Array arguments with INTENT(IN):
> !------------------------------------------------------------------------------
> INTEGER, INTENT(IN) :: global_land_index(:)
>   ! List of indices for the land model grid.
> INTEGER, INTENT(IN) :: rivers_index_rp(:)
>   ! Index of points where routing is calculated.
384c517,519
< ! Array arguments with intent(out)
---
> !------------------------------------------------------------------------------
> ! Array arguments with INTENT(OUT):
> !------------------------------------------------------------------------------
387a523,525
> !------------------------------------------------------------------------------
> ! Local scalar variables.
> !------------------------------------------------------------------------------
390c528,531
< REAL(KIND=real_jlslsm) :: runoff_grid(nx_grid,ny_grid)
---
> !------------------------------------------------------------------------------
> ! Local array variables.
> !------------------------------------------------------------------------------
> REAL(KIND=real_jlslsm) :: runoff_grid(nx_land_grid,ny_land_grid)
392a534,536
> !end of header
> !------------------------------------------------------------------------------
> 
396c540
<   CALL rivers_get_xy_pos( ir_land_grid(l), nx_grid, ny_grid, ix, iy )
---
>   CALL get_xy_pos( global_land_index(l), nx_land_grid, ny_land_grid, ix, iy )
401,402c545,546
< maxlin = ( nx_grid + nx_rivers ) * ( ny_grid + ny_rivers )
< CALL rivers_route_regrid ( maxlin, runoff_grid, runoff_out )
---
> maxlin = ( nx_land_grid + nx_rivers ) * ( ny_land_grid + ny_rivers )
> CALL regrid_land_to_rivers( maxlin, runoff_grid, runoff_out )
406c550
<   CALL rivers_get_xy_pos(rivers_index_rp(ip),nx_rivers,ny_rivers,ix,iy)
---
>   CALL get_xy_pos(rivers_index_rp(ip),nx_rivers,ny_rivers,ix,iy)
410c554,555
< END SUBROUTINE rivers_regrid_from_land
---
> RETURN
> END SUBROUTINE regrid_land_to_rivers_ctl
412,414c557,561
< !###############################################################################
< ! subroutine rivers_regrid_to_land
< ! Handles regridding of runoff from rivers to "main" grids.
---
> !##############################################################################
> 
> SUBROUTINE regrid_rivers_to_land_ctl( land_pts, riv_pts, global_land_index,    &
>                                       rivers_index_rp, runoff_riv,             &
>                                       runoff_land )
416,417d562
< SUBROUTINE rivers_regrid_to_land( riv_pts, runoff_riv, land_pts, runoff_land,  &
<                                   ir_land_grid, rivers_index_rp )
420c565
< !   Regrids runoff from a source grid to a target grid (the rivers grid).
---
> !   Regrids runoff from a source grid to a target grid (the land grid).
421a567
> !------------------------------------------------------------------------------
425c571
<      nx_rivers,ny_rivers, nx_grid, ny_grid
---
>      nx_rivers,ny_rivers, nx_land_grid, ny_land_grid
429,432c575,587
< INTEGER, INTENT(IN) :: land_pts  !  a vector length
< INTEGER, INTENT(IN) :: riv_pts  !  a vector length
< INTEGER, INTENT(IN OUT) :: ir_land_grid(:)
< INTEGER, INTENT(IN OUT) :: rivers_index_rp(:)
---
> !------------------------------------------------------------------------------
> ! Scalar arguments with INTENT(IN):
> !------------------------------------------------------------------------------
> INTEGER, INTENT(IN) :: land_pts  ! Number of land points.
> INTEGER, INTENT(IN) :: riv_pts   ! Number of river points.
> 
> !------------------------------------------------------------------------------
> ! Array arguments with INTENT(IN):
> !------------------------------------------------------------------------------
> INTEGER, INTENT(IN) :: global_land_index(:)
>   ! List of indices for the land model grid.
> INTEGER, INTENT(IN) :: rivers_index_rp(:)
>   ! Index of points where routing is calculated.
434d588
< ! Array arguments with intent(in)
436c590
< !  runoff rate on rivers grid (kg m-2 s-1)
---
>   ! Runoff rate on rivers grid (kg m-2 s-1).
438c592,594
< ! Array arguments with intent(out)
---
> !------------------------------------------------------------------------------
> ! Array arguments with INTENT(OUT):
> !------------------------------------------------------------------------------
440c596
< !  runoff rate on model grid (kg m-2 s-1)
---
>   ! Runoff rate on model grid (kg m-2 s-1).
441a598,600
> !------------------------------------------------------------------------------
> ! Local scalar variables.
> !------------------------------------------------------------------------------
444c603,606
< REAL(KIND=real_jlslsm) :: runoff_grid(nx_grid,ny_grid)
---
> !------------------------------------------------------------------------------
> ! Local array variables.
> !------------------------------------------------------------------------------
> REAL(KIND=real_jlslsm) :: runoff_grid(nx_land_grid,ny_land_grid)
446a609,611
> !end of header
> !------------------------------------------------------------------------------
> 
450c615
<   CALL rivers_get_xy_pos(rivers_index_rp(ip),nx_rivers,ny_rivers,ix,iy)
---
>   CALL get_xy_pos(rivers_index_rp(ip),nx_rivers,ny_rivers,ix,iy)
455,456c620,621
< maxlin = ( nx_grid + nx_rivers ) * ( ny_grid + ny_rivers )
< CALL rivers_route_regrid_invert ( maxlin, runoff_out, runoff_grid )
---
> maxlin = ( nx_land_grid + nx_rivers ) * ( ny_land_grid + ny_rivers )
> CALL regrid_rivers_to_land( maxlin, runoff_out, runoff_grid )
460c625
<   CALL rivers_get_xy_pos( ir_land_grid(l), nx_grid, ny_grid, ix, iy )
---
>   CALL get_xy_pos( global_land_index(l), nx_land_grid, ny_land_grid, ix, iy )
464c629,630
< END SUBROUTINE rivers_regrid_to_land
---
> RETURN
> END SUBROUTINE regrid_rivers_to_land_ctl
466,468c632
< !###############################################################################
< ! subroutine rivers_route_regrid
< ! Handles regridding of runoff from "main" to rivers grids.
---
> !##############################################################################
470c634
< SUBROUTINE rivers_route_regrid( maxlin, runoff_grid, runoff_out )
---
> SUBROUTINE regrid_land_to_rivers( maxlin, runoff_grid, runoff_out )
473c637,638
< !   Regrids runoff from a source grid to a target grid (the rivers grid).
---
> !   Regrids runoff from a source grid (the model grid) to a target grid (the
> !   rivers grid).
481,482c646,649
<      nx_rivers,ny_rivers,rivers_dlat,rivers_dlon,rivers_lat1,rivers_lon1       &
<      , nx_grid, ny_grid, reg_dlat, reg_dlon, reg_lat1, reg_lon1
---
>      nx_rivers, ny_rivers, rivers_dlat=>rivers_dy, rivers_dlon=>rivers_dx,     &
>      rivers_lat1=>rivers_y1, rivers_lon1=>rivers_x1, nx_land_grid,             &
>      ny_land_grid, reg_dlat=>land_dy, reg_dlon=>land_dx,                       &
>      reg_lat1=>y1_land_grid, reg_lon1=>x1_land_grid
488c655,657
< ! Scalar arguments with intent(in)
---
> !------------------------------------------------------------------------------
> ! Scalar arguments with INTENT(IN)
> !------------------------------------------------------------------------------
492,494c661,664
< ! Array arguments with intent(in)
< 
< REAL(KIND=real_jlslsm), INTENT(IN) :: runoff_grid(nx_grid,ny_grid)
---
> !------------------------------------------------------------------------------
> ! Array arguments with INTENT(IN)
> !------------------------------------------------------------------------------
> REAL(KIND=real_jlslsm), INTENT(IN) :: runoff_grid(nx_land_grid,ny_land_grid)
497,498c667,669
< ! Array arguments with intent(out)
< 
---
> !------------------------------------------------------------------------------
> ! Array arguments with INTENT(OUT)
> !------------------------------------------------------------------------------
501a673
> !------------------------------------------------------------------------------
503c675
< 
---
> !------------------------------------------------------------------------------
517a690
> !------------------------------------------------------------------------------
519c692
< 
---
> !------------------------------------------------------------------------------
530c703
< REAL(KIND=real_jlslsm) :: sourcelat(ny_grid+1)
---
> REAL(KIND=real_jlslsm) :: sourcelat(ny_land_grid+1)
534c707
< REAL(KIND=real_jlslsm) :: sourcelon(nx_grid+1)
---
> REAL(KIND=real_jlslsm) :: sourcelon(nx_land_grid+1)
539c712
<                         !  latitudes of edges of target (mrivers) gridboxes.
---
>                         !  latitudes of edges of target (rivers) gridboxes.
552c725
< LOGICAL :: mask_srce(nx_grid,ny_grid)
---
> LOGICAL :: mask_srce(nx_land_grid,ny_land_grid)
573c746
< IF ( REAL(nx_grid) * reg_dlon > 359.9 ) THEN
---
> IF ( REAL(nx_land_grid) * reg_dlon > 359.9 ) THEN
586a760,763
> ! Note that in standalone JULES we are recalculating coordinates which were
> ! originally read from an ancillary file, which generally results in values
> ! that are slightly different from those read in. This could make a difference
> ! for high resolution runs with large grids.
588c765
< DO ix = 1,nx_grid+1
---
> DO ix = 1,nx_land_grid+1
591c768
< DO iy = 1,ny_grid+1
---
> DO iy = 1,ny_land_grid+1
618,622c795,799
< CALL pre_areaver( nx_grid, sourcelon, ny_grid, sourcelat                       &
<                  ,cyclic_srce, nx_grid, want, mask_srce                        &
<                  ,nx_rivers, targetlon, ny_rivers, targetlat                   &
<                  ,cyclic_targ, spherical, maxl, count_targ, base_targ          &
<                  ,index_srce, weight )
---
> CALL pre_areaver( nx_land_grid, sourcelon, ny_land_grid, sourcelat,            &
>                   cyclic_srce, nx_land_grid, want, mask_srce,                  &
>                   nx_rivers, targetlon, ny_rivers, targetlat,                  &
>                   cyclic_targ, spherical, maxl, count_targ, base_targ,         &
>                   index_srce, weight )
628,632c805,809
< CALL do_areaver( nx_grid, ny_grid, nx_grid                                     &
<                 ,invert_srce, runoff_grid, nx_rivers, ny_rivers                &
<                 ,count_targ, base_targ, nx_rivers, want, mask_targ             &
<                 ,index_srce, weight, adjust, runoff_out, nx_grid, 2            &
<                 ,adjust_targ )
---
> CALL do_areaver( nx_land_grid, ny_land_grid, nx_land_grid,                     &
>                  invert_srce, runoff_grid, nx_rivers, ny_rivers,               &
>                  count_targ, base_targ, nx_rivers, want, mask_targ,            &
>                  index_srce, weight, adjust, runoff_out, nx_land_grid, 2,      &
>                  adjust_targ )
634,635c811,812
< END SUBROUTINE rivers_route_regrid
< !###############################################################################
---
> RETURN
> END SUBROUTINE regrid_land_to_rivers
637,639c814,816
< !###############################################################################
< ! subroutine rivers_route_regrid_invert
< ! Handles regridding of runoff from "main" to rivers grids.
---
> !##############################################################################
> 
> SUBROUTINE regrid_rivers_to_land( maxlin, runoff_out, runoff_grid )
641d817
< SUBROUTINE rivers_route_regrid_invert( maxlin, runoff_out, runoff_grid )
644c820,821
< !   Regrids runoff from a source grid to a target grid (the rivers grid).
---
> !   Regrids runoff from a source grid (the river grid) to a target grid
> !   (the model grid).
646,647d822
< !   Inverse of rivers_route_regrid
< !
648a824
> 
653,654c829,832
<      nx_rivers,ny_rivers,rivers_dlat,rivers_dlon,rivers_lat1,rivers_lon1       &
<      , nx_grid, ny_grid, reg_dlat, reg_dlon, reg_lat1, reg_lon1
---
>      nx_rivers, ny_rivers, rivers_dlat=>rivers_dy, rivers_dlon=>rivers_dx,     &
>      rivers_lat1=>rivers_y1, rivers_lon1=>rivers_x1, nx_land_grid,             &
>      ny_land_grid, reg_dlat=>land_dy, reg_dlon=>land_dx,                       &
>      reg_lat1=>y1_land_grid, reg_lon1=>x1_land_grid
660,661c838,840
< ! Scalar arguments with intent(in)
< 
---
> !------------------------------------------------------------------------------
> ! Scalar arguments with INTENT(IN)
> !------------------------------------------------------------------------------
664,665c843,845
< ! Array arguments with intent(in)
< 
---
> !------------------------------------------------------------------------------
> ! Array arguments with INTENT(IN)
> !------------------------------------------------------------------------------
669,671c849,852
< ! Array arguments with intent(out)
< 
< REAL(KIND=real_jlslsm), INTENT(OUT) :: runoff_grid(nx_grid,ny_grid)
---
> !------------------------------------------------------------------------------
> ! Array arguments with INTENT(OUT)
> !------------------------------------------------------------------------------
> REAL(KIND=real_jlslsm), INTENT(OUT) :: runoff_grid(nx_land_grid,ny_land_grid)
673a855
> !------------------------------------------------------------------------------
675c857
< 
---
> !------------------------------------------------------------------------------
690a873
> !------------------------------------------------------------------------------
692,693c875,876
< 
< INTEGER :: count_targ(nx_grid,ny_grid)
---
> !------------------------------------------------------------------------------
> INTEGER :: count_targ(nx_land_grid,ny_land_grid)
696c879
< INTEGER :: base_targ(nx_grid,ny_grid)
---
> INTEGER :: base_targ(nx_land_grid,ny_land_grid)
711c894
< REAL(KIND=real_jlslsm) :: targetlat(ny_grid+1)
---
> REAL(KIND=real_jlslsm) :: targetlat(ny_land_grid+1)
715c898
< REAL(KIND=real_jlslsm) :: targetlon(nx_grid+1)
---
> REAL(KIND=real_jlslsm) :: targetlon(nx_land_grid+1)
720c903
< REAL(KIND=real_jlslsm) :: adjust_targ(nx_grid,ny_grid)
---
> REAL(KIND=real_jlslsm) :: adjust_targ(nx_land_grid,ny_land_grid)
726c909
< LOGICAL :: mask_targ(nx_grid,ny_grid)
---
> LOGICAL :: mask_targ(nx_land_grid,ny_land_grid)
743c926
< IF ( REAL(nx_grid) * reg_dlon > 359.9 ) THEN
---
> IF ( REAL(nx_land_grid) * reg_dlon > 359.9 ) THEN
764c947
< DO ix = 1,nx_grid+1
---
> DO ix = 1,nx_land_grid+1
767c950
< DO iy = 1,ny_grid+1
---
> DO iy = 1,ny_land_grid+1
783,786c966,969
< CALL pre_areaver( nx_rivers, sourcelon, ny_rivers, sourcelat, cyclic_srce      &
<                  ,nx_rivers, want, mask_srce, nx_grid, targetlon, ny_grid      &
<                  ,targetlat, cyclic_targ, spherical, maxl, count_targ          &
<                  ,base_targ, index_srce, weight )
---
> CALL pre_areaver( nx_rivers, sourcelon, ny_rivers, sourcelat, cyclic_srce,     &
>                   nx_rivers, want, mask_srce, nx_land_grid, targetlon,         &
>                   ny_land_grid, targetlat, cyclic_targ, spherical, maxl,       &
>                   count_targ, base_targ, index_srce, weight )
792,795c975,1015
< CALL do_areaver( nx_rivers, ny_rivers, nx_rivers, invert_srce, runoff_out      &
<                 ,nx_grid, ny_grid, count_targ, base_targ, nx_grid, want        &
<                 ,mask_targ, index_srce, weight, adjust, runoff_grid            &
<                 ,nx_rivers, 2, adjust_targ )
---
> CALL do_areaver( nx_rivers, ny_rivers, nx_rivers, invert_srce, runoff_out,     &
>                  nx_land_grid, ny_land_grid, count_targ, base_targ,            &
>                  nx_land_grid, want, mask_targ, index_srce, weight, adjust,    &
>                  runoff_grid, nx_rivers, 2, adjust_targ )
> 
> RETURN
> END SUBROUTINE regrid_rivers_to_land
> !##############################################################################
> 
> SUBROUTINE twod_to_rp( field_2d, field_rp, rivers )
> !------------------------------------------------------------------------------
> ! Description:
> !   Converts from a 2D global grid to a 1D rivers grid
> !   with no remapping or interpolation.
> !
> !------------------------------------------------------------------------------
> ! Modules used:
> USE jules_rivers_mod, ONLY: nx_rivers, ny_rivers, np_rivers, rivers_type
> 
> IMPLICIT NONE
> 
> REAL, INTENT(IN) :: field_2d(nx_rivers,ny_rivers)
>                         !  Input 2D global field
> REAL, INTENT(OUT) :: field_rp(np_rivers)
>                         !  Output 1D river points field
> TYPE(rivers_type), INTENT(IN) :: rivers
>                         !  Extra river information
> 
> ! Local scalar variables
> 
> INTEGER :: ip            !  loop counter
> INTEGER :: ilon          !  longitude index
> INTEGER :: ilat          !  latitude index
> 
> DO ip = 1,np_rivers
>   ilon = rivers%rivers_ilon_rp(ip)
>   ilat = rivers%rivers_ilat_rp(ip)
>   field_rp(ip) = field_2d(ilon,ilat)
> END DO
> 
> END SUBROUTINE twod_to_rp
797d1016
< END SUBROUTINE rivers_route_regrid_invert
798a1018,1053
> 
> SUBROUTINE rp_to_twod( field_rp, field_2d, rivers )
> !------------------------------------------------------------------------------
> ! Description:
> !   Converts from a 1D rivers grid to a 2D global grid
> !   with no remapping or interpolation.
> !
> !------------------------------------------------------------------------------
> ! Modules used:
> USE jules_rivers_mod, ONLY: nx_rivers, ny_rivers, np_rivers, rivers_type
> 
> IMPLICIT NONE
> 
> REAL, INTENT(IN) :: field_rp(np_rivers)
>                         !  Input 1D river points field
> REAL, INTENT(OUT) :: field_2d(nx_rivers,ny_rivers)
>                         !  Output 2D global field
> TYPE(rivers_type), INTENT(IN) :: rivers
>                         !  Extra river information
> 
> ! Local scalar variables
> 
> INTEGER :: ip            !  loop counter
> INTEGER :: ilon          !  longitude index
> INTEGER :: ilat          !  latitude index
> 
> field_2d(:,:) = 0.0
> 
> DO ip = 1,np_rivers
>   ilon = rivers%rivers_ilon_rp(ip)
>   ilat = rivers%rivers_ilat_rp(ip)
>   field_2d(ilon,ilat) = field_rp(ip)
> END DO
> 
> END SUBROUTINE rp_to_twod
> 
diff -r vn7.0copy1_c4/src/./science/river_routing/rivers_route_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/river_routing/rivers_route_mod.F90
19c19
< !-----------------------------------------------------------------------------
---
> !------------------------------------------------------------------------------
29,37c29,33
< !###############################################################################
< ! subroutine rivers_drive
< ! Driver routine for runoff routing by a kinematic wave model.
< 
< SUBROUTINE rivers_drive( global_land_pts, sub_runoffin, surf_runoffin,         &
<                          runoff_out, rivflow, riverout_rgrid,                  &
<                        !  imported rivers arrays
<                          rivers)
< !-------------------------------------------------------------------------------
---
> !##############################################################################
> 
> SUBROUTINE rivers_route_rp(rivers)
> 
> !------------------------------------------------------------------------------
40c36
< !   Perform the routing of surface and sub-surface runoff defined on landpts
---
> !   Perform the routing of surface and sub-surface runoff defined on riverpts
42,43c38,39
< !   This routine regrids the total surface runoff to the river grid and passes
< !   it to the RFM or TRIP routines to be routed.
---
> !   This passes the total surface runoff in the river grid to the RFM or TRIP
> !   routines to be routed.
45c41
< !-------------------------------------------------------------------------------
---
> !------------------------------------------------------------------------------
52,55d47
< USE rivers_regrid_mod, ONLY:                                                   &
< !  imported procedures
<      landpts_to_rivpts, rivpts_to_landpts
< 
70,92c62,64
< !-------------------------------------------------------------------------------
< ! Scalar arguments with intent(in)
< INTEGER, INTENT(IN) :: global_land_pts
<                              ! Size of GLOBAL runoff arrays on land points
< ! Array arguments with intent(in)
< REAL(KIND=real_jlslsm), INTENT(IN) :: sub_runoffin(global_land_pts)
<                              ! Average rate of sub surface runoff since
<                              ! last rivers call on land_pts in kg m-2 s-1
< REAL(KIND=real_jlslsm), INTENT(IN) :: surf_runoffin(global_land_pts)
<                              ! Average rate of surface runoff since last
<                              ! rivers call on land_pts in kg m-2 s-1
< 
< ! Array arguments with intent(out)
< REAL(KIND=real_jlslsm), INTENT(OUT) :: runoff_out(global_land_pts)
<                              ! Total runoff diagnostic on land_pts
<                              ! in kg m-2 s-1
< REAL(KIND=real_jlslsm), INTENT(OUT) :: rivflow(global_land_pts)
<                              ! River flow diagnostic on land_pts
<                              ! in kg m-2 s-1
< REAL(KIND=real_jlslsm), INTENT(OUT) :: riverout_rgrid(np_rivers)
<                              ! River outflow into the ocean on river grid
<                              ! in kg s-1
< 
---
> !------------------------------------------------------------------------------
> ! Arguments with INTENT(IN OUT)
> !------------------------------------------------------------------------------
94a67
> !------------------------------------------------------------------------------
96c69,70
< INTEGER :: l, ip             !  loop counter
---
> !------------------------------------------------------------------------------
> INTEGER :: ip                !  loop counter
97a72
> !------------------------------------------------------------------------------
98a74
> !------------------------------------------------------------------------------
103,130c79
< !-------------------------------------------------------------------------------
< ! Initialisation
< !-------------------------------------------------------------------------------
< DO ip = 1, np_rivers
<   rivers%rflow_rp(ip)    = 0.0
<   baseflow(ip)   = 0.0
<   riverout_rgrid(ip) = 0.0
<   rivers%rrun_sub_surf_rp(ip) = 0.0
<   rivers%rrun_surf_rp(ip) = 0.0
< END DO
< 
< DO l = 1, global_land_pts
<   rivflow(l)    = 0.0
<   runoff_out(l) = 0.0
< END DO
< 
< !-------------------------------------------------------------------------------
< ! Regrid surface and subsurface runoff from land points to rivers points
< !-------------------------------------------------------------------------------
< CALL landpts_to_rivpts( global_land_pts, sub_runoffin,                         &
<                         np_rivers, rivers%rrun_sub_surf_rp,                    &
<                         rivers%il_river_grid, rivers%ir_land_grid,             &
<                         rivers%rivers_index_rp )
< CALL landpts_to_rivpts( global_land_pts, surf_runoffin,                        &
<                         np_rivers, rivers%rrun_surf_rp,rivers%il_river_grid,   &
<                         rivers%ir_land_grid, rivers%rivers_index_rp )
< 
< !-------------------------------------------------------------------------------
---
> !------------------------------------------------------------------------------
132c81
< !-------------------------------------------------------------------------------
---
> !------------------------------------------------------------------------------
137c86
<                          rivers%rflow_rp, baseflow, riverout_rgrid,            &
---
>                          rivers%rflow_rp, baseflow,                            &
142c91
<                           rivers%rflow_rp, baseflow, riverout_rgrid,           &
---
>                           rivers%rflow_rp, baseflow, rivers%rivers_outflow_rp, &
152c101
< !-------------------------------------------------------------------------------
---
> !------------------------------------------------------------------------------
164,174c113
< !-------------------------------------------------------------------------------
< !   Regrid from rivers to land grid
< !------------------------------------------------------------------------------
< CALL rivpts_to_landpts( np_rivers, rivers%rflow_rp, global_land_pts, rivflow,  &
<                         rivers%il_river_grid, rivers%ir_land_grid,             &
<                         rivers%rivers_index_rp )
< CALL rivpts_to_landpts( np_rivers, rivers%rrun_rp, global_land_pts,            &
<                         runoff_out, rivers%il_river_grid, rivers%ir_land_grid, &
<                         rivers%rivers_index_rp )
< 
< END SUBROUTINE rivers_drive
---
> END SUBROUTINE rivers_route_rp
176c115
< !###############################################################################
---
> !##############################################################################
180c119
< !-----------------------------------------------------------------------------
---
> !------------------------------------------------------------------------------
191c130
< !-----------------------------------------------------------------------------
---
> !------------------------------------------------------------------------------
211c150,152
< ! Array arguments with intent(in)
---
> !------------------------------------------------------------------------------
> ! Array arguments with INTENT(IN)
> !------------------------------------------------------------------------------
214c155,158
< ! Array arguments with intent(in)
---
> 
> !------------------------------------------------------------------------------
> ! Array arguments with INTENT(OUT)
> !------------------------------------------------------------------------------
217,220c161,164
< ! Local arrays
< REAL(KIND=real_jlslsm), ALLOCATABLE :: global_rivers_var_on_landpts(:)
<           ! River routing output variable defined on global model land points
< ! Local variables
---
> 
> !------------------------------------------------------------------------------
> ! Local scalar variables
> !------------------------------------------------------------------------------
224c168,172
< TYPE(rivers_type), INTENT(IN OUT) :: rivers
---
> !------------------------------------------------------------------------------
> ! Local array variables
> !------------------------------------------------------------------------------
> REAL(KIND=real_jlslsm), ALLOCATABLE :: global_rivers_var_on_landpts(:)
>           ! River routing output variable defined on global model land points
226c174,176
< !-------------------------------------------------------------------------------
---
> TYPE(rivers_type), INTENT(IN) :: rivers
> 
> !------------------------------------------------------------------------------
232c182
< !-------------------------------------------------------------------------------
---
> !------------------------------------------------------------------------------
255c205
< !-------------------------------------------------------------------------------
---
> !------------------------------------------------------------------------------
259,262c209,212
<   CALL rivpts_to_landpts( np_rivers, global_var_riv,                           &
<                           global_land_pts, global_rivers_var_on_landpts,       &
<                           rivers%il_river_grid, rivers%ir_land_grid,           &
<                           rivers%rivers_index_rp )
---
>   CALL rivpts_to_landpts( global_land_pts, np_rivers,                          &
>                           rivers%map_river_to_land_points,                     &
>                           rivers%global_land_index, rivers%rivers_index_rp,    &
>                           global_var_riv, global_rivers_var_on_landpts )
266c216
< !-------------------------------------------------------------------------------
---
> !------------------------------------------------------------------------------
270c220
< DEALLOCATE(global_rivers_var_on_landpts)!,rivers%il_river_grid, rivers%ir_land_grid)
---
> DEALLOCATE(global_rivers_var_on_landpts)
274c224
< !###############################################################################
---
> !##############################################################################
278c228
< !-----------------------------------------------------------------------------
---
> !------------------------------------------------------------------------------
290c240
< !-----------------------------------------------------------------------------
---
> !------------------------------------------------------------------------------
307a258,272
> !------------------------------------------------------------------------------
> ! Array arguments with INTENT(IN)
> !------------------------------------------------------------------------------
> REAL(KIND=real_jlslsm), INTENT(IN) :: rivers_adj_on_landpts(:)
> 
> TYPE(rivers_type), INTENT(IN) :: rivers
> 
> !------------------------------------------------------------------------------
> ! Local scalar variables.
> !------------------------------------------------------------------------------
> INTEGER :: ip ! array indices
> 
> !------------------------------------------------------------------------------
> ! Local array variables.
> !------------------------------------------------------------------------------
310d274
< REAL(KIND=real_jlslsm), INTENT(IN) :: rivers_adj_on_landpts(:)
314d277
< INTEGER :: ip ! array indices
316c279
< TYPE(rivers_type), INTENT(IN OUT) :: rivers
---
> !------------------------------------------------------------------------------
332c295
<   !-------------------------------------------------------------------------------
---
>   !----------------------------------------------------------------------------
334,337c297,302
<   !-------------------------------------------------------------------------------
<   CALL landpts_to_rivpts( global_land_pts, global_rivers_adj_on_landpts,       &
<                           np_rivers, rivers_adj_rgrid,rivers%il_river_grid,    &
<                           rivers%ir_land_grid, rivers%rivers_index_rp  )
---
>   !----------------------------------------------------------------------------
>   CALL landpts_to_rivpts( global_land_pts, np_rivers,                          &
>                           rivers%map_river_to_land_points,                     &
>                           rivers%global_land_index, rivers%rivers_index_rp,    &
>                           global_rivers_adj_on_landpts,                        &
>                           rivers_adj_rgrid )
339c304
<   !-------------------------------------------------------------------------------
---
>   !----------------------------------------------------------------------------
341c306
<   !-------------------------------------------------------------------------------
---
>   !----------------------------------------------------------------------------
352c317
< !###############################################################################
---
> !##############################################################################
diff -r vn7.0copy1_c4/src/./science/river_routing/rivers_route_rfm_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/river_routing/rivers_route_rfm_mod.F90
67,69c67
< SUBROUTINE rivers_route_rfm( sfc_runoff, sub_sfc_runoff,                       &
<                              outflow, baseflow, riverout_rgrid,                &
<                             !  imported river arrays
---
> SUBROUTINE rivers_route_rfm( sfc_runoff, sub_sfc_runoff, outflow, baseflow,    &
74,76c72,74
<        nstep_rivers, np_rivers, river_mouth, rivers_dlat, rivers_first         &
<        ,rivers_dx, runoff_factor, a_thresh, cland, criver, cbland, cbriver     &
<        ,retl, retr, rfm_land, rfm_river, rfm_sea,                              &
---
>        nstep_rivers, np_rivers, river_mouth                                    &
>        ,rivers_first, rivers_length, runoff_factor, cland, criver, cbland      &
>        ,cbriver, retl, retr, rfm_land, rfm_river, rfm_sea,                     &
82,85d79
< USE planet_constants_mod, ONLY: planet_radius  ! the Earth's radius (m)
< 
< USE conversions_mod, ONLY: pi_over_180
< 
110,111d103
< REAL(KIND=real_jlslsm), INTENT(IN OUT) :: riverout_rgrid(np_rivers)
<        ! River outflow into the ocean on river grid (kg s-1)
158c150
< ! rivers model timestep(s)
---
> ! Calculate rivers model timestep length.
161,167d152
< ! horizontal gridsize (m)
< IF (rivers_dx <= 0) THEN
<   dx = planet_radius * (ABS(rivers_dlat) * pi_over_180)
< ELSE
<   dx = rivers_dx
< END IF
< 
169,172c154,157
< rivertheta    = criver  * dt / dx
< landtheta     = cland   * dt / dx
< sublandtheta  = cbland  * dt / dx
< subrivertheta = cbriver * dt / dx
---
> rivertheta    = criver  * dt / rivers_length
> landtheta     = cland   * dt / rivers_length
> sublandtheta  = cbland  * dt / rivers_length
> subrivertheta = cbriver * dt / rivers_length
246c231
<   IF (landtype == rfm_land) THEN  !land
---
>   IF (landtype == rfm_land) THEN  !Gridcell is land
277c262
<   ELSE IF (landtype == rfm_river) THEN  !river
---
>   ELSE IF (landtype == rfm_river) THEN  !Gridcell is river
317,318c302,303
<   IF ( rivers%rivers_next_rp(ip) == -river_mouth ) THEN
<     riverout_rgrid(ip) = rivers%rfm_rivflow_rp(ip)  * rho_water
---
>   IF ( rivers%rivers_next_rp(ip) == river_mouth ) THEN
>     rivers%rivers_outflow_rp(ip) = rivers%rfm_rivflow_rp(ip)  * rho_water
337d321
<   ! HL: N.B. Add option to select what output units required for river flow
diff -r vn7.0copy1_c4/src/./science/river_routing/rivers_route_trip_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/river_routing/rivers_route_trip_mod.F90
44,46c44,47
<                               riverout_rgrid,rivers_next_rp,rivers_seq_rp,     &
<                               rivers_sto_rp ,rivers_boxareas_rp, rivers_lat_rp,&
<                               rivers_lon_rp )
---
>                               rivers_outflow_rp, rivers_next_rp,               &
>                               rivers_seq_rp, rivers_sto_rp ,                   &
>                               rivers_boxareas_rp,                              &
>                               rivers_lat_rp, rivers_lon_rp )
52d52
< 
82,83c82,83
<     ,riverout_rgrid(np_rivers)
<      ! River outflow into the ocean on river grid (kg s-1)
---
>     ,rivers_outflow_rp(np_rivers)
>      ! River outflow into the ocean (kg s-1)
86,87c86,90
< INTEGER, INTENT(IN OUT) :: rivers_next_rp(:)
< INTEGER, INTENT(IN OUT) :: rivers_seq_rp(:)
---
> INTEGER, INTENT(IN)     :: rivers_next_rp(:)
> INTEGER, INTENT(IN)     :: rivers_seq_rp(:)
> REAL,    INTENT(IN)     :: rivers_boxareas_rp(:)
> REAL,    INTENT(IN)     :: rivers_lat_rp(:)
> REAL,    INTENT(IN)     :: rivers_lon_rp(:)
89,91d91
< REAL,    INTENT(IN OUT) :: rivers_boxareas_rp(:)
< REAL,    INTENT(IN OUT) :: rivers_lat_rp(:)
< REAL,    INTENT(IN OUT) :: rivers_lon_rp(:)
95c95
<      ip,iseq
---
>      ip, iseq
114a115
> CHARACTER(LEN=*), PARAMETER :: RoutineName='RIVERS_ROUTE_TRIP'
126,128c127,129
<   outflow(ip)        = 0.0
<   baseflow(ip)       = 0.0
<   riverout_rgrid(ip) = 0.0
---
>   outflow(ip)           = 0.0
>   baseflow(ip)          = 0.0
>   rivers_outflow_rp(ip) = 0.0
189c190
< ! Catch all outflow going into the sea and save it in riverout_rgrid.
---
> ! Catch all outflow going into the sea and save it in rivers_outflow_rp.
194,195c195,196
<   IF ( rivers_next_rp(ip) == -river_mouth ) THEN
<     riverout_rgrid(ip) = outflow(ip)
---
>   IF ( rivers_next_rp(ip) == river_mouth ) THEN
>     rivers_outflow_rp(ip) = outflow(ip)
diff -r vn7.0copy1_c4/src/./science/river_routing/rivers_route_utils_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/river_routing/rivers_route_utils_mod.F90
56,57c56,57
< !     Driver routine that calls procedures that calculates distance
< !     between gridpoints.
---
> !     Driver routine that calls a procedure to calculate distances between
> !     gridpoints, given latitude and longitude.
63c63,64
<      inland_drainage, river_mouth, rivers_dlat, rivers_dlon,                   &
---
>      inland_drainage, river_mouth, rivers_dlat=>rivers_dy,                     &
>      rivers_dlon=>rivers_dx,                                                   &
100a102,104
> ! Note that it is assumed that rivers_dx and rivers_dy are increments of
> ! latitude and longitude (not some other coordinate system).
> 
110c114
<   ELSE IF ( jp == -river_mouth .OR. jp == -inland_drainage ) THEN
---
>   ELSE IF ( jp == river_mouth .OR. jp == inland_drainage ) THEN
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/river_routing/um: lake_evap_apply_soil_mod.F90
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/river_routing/um: lake_evap_global_avg_mod.F90
diff -r vn7.0copy1_c4/src/./science/river_routing/um/riv_intctl-riv_ic1a_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/river_routing/um/riv_intctl-riv_ic1a_mod.F90
24,28c24
< USE riv_rout_mod_1A, ONLY: riv_rout_1A
< 
< USE umPrintMgr, ONLY:                                                          &
<     umPrint,                                                                   &
<     umMessage
---
> USE riv_rout_1a_wrapper_mod, ONLY: riv_rout_1a_wrapper
43,44c39,40
< g_p_field, g_r_field, n_proc,                                                  &
< gather_pe_trip,land_points,land_index,                                         &
---
> g_p_field, g_r_field,                                                          &
> land_points, n_wtrac_jls, land_index,                                          &
49c45
< flandg, riv_step, riv_vel, riv_mcoef,                                          &
---
> flandg, riv_step,                                                              &
51c47,49
< delta_phi, first_entry,                                                        &
---
> twatstor_wtrac,                                                                &
> ! Used for UM-RFM implementation
> delta_phi,                                                                     &
54c52
< ! IN/OUT accumulated runoff
---
> ! IN accumulated runoff
55a54
> tot_surf_runoff_gb_wtrac, tot_sub_runoff_gb_wtrac,                             &
60c59
< inlandout_atmos,inlandout_riv,                                                 &
---
> inlandout_atmos,inlandout_riv, inlandout_atmos_wtrac,                          &
62c61,62
< dsm_levels,acc_lake_evap,smvcst,smvcwt,smcl,sthu)
---
> dsm_levels, acc_lake_evap, smvcst, smvcwt, smcl, sthu,                         &
> acc_lake_evap_wtrac, smcl_wtrac, sthu_wtrac)
74d73
< USE water_constants_mod, ONLY: rho_water
77d75
< USE global_2d_sums_mod, ONLY: global_2d_sums
83,84c81,82
< USE jules_soil_mod, ONLY: dzsoil
< IMPLICIT NONE
---
> USE water_constants_mod, ONLY: rho_water
> USE jules_soil_mod,      ONLY: dzsoil
85a84,86
> USE jules_water_tracers_mod,  ONLY: l_wtrac_jls
> USE lake_evap_global_avg_mod, ONLY: lake_evap_global_avg
> USE lake_evap_apply_soil_mod, ONLY: lake_evap_apply_soil
86a88
> IMPLICIT NONE
89,90c91,92
<  row_length                                                                    &
<                            ! NO. OF COLUMNS IN ATMOSPHERE
---
>   row_length                                                                   &
>                             ! No. of columns in atmosphere
92c94
<                            ! NO. OF ROWS IN ATMOSPHERE
---
>                             ! No. of rows in atmosphere
94c96
<                            ! number of points on a row
---
>                             ! No. of points on a global row
96c98
<                            ! NUMBER OF global rows
---
>                             ! No. of global rows
98c100
<                            ! number of landpoints
---
>                             ! No. of landpoints
100c102
<                            ! no. of columns in river grid
---
>                             ! No. of columns in river grid
102c104
<                            ! no. of rows in river grid
---
>                             ! No. of rows in river grid
104c106
<                            ! global river row length
---
>                             ! No. of global river row length
106,111c108,112
<                            ! GLOBAL river rows
< , gather_pe_trip                                                               &
<                            ! pe River routing to be run on
< , n_proc                                                                       &
<                            ! Total number of processors
< , dsm_levels               ! no. of deep soil moisture levels
---
>                             ! No. of global river rows
> , dsm_levels                                                                   &
>                             ! No. of deep soil moisture levels
> , n_wtrac_jls
>                             ! No. of water tracers used in JULES
114,115c115,116
<  g_p_field                                                                     &
<                             ! IN size of global ATMOS field
---
>   g_p_field                                                                    &
>                             ! IN Size of global ATMOS field
118c119,120
< , land_index (land_points)  ! IN index of land to global points
---
> , land_index (land_points)
>                             ! IN Index of land to global points
122c124
<                              !IN Surf RUNOFF on land pts(KG/M2/S)
---
>                             ! IN Surf RUNOFF on land pts(KG/M2/S)
124c126,148
<                              ! IN Subsurf.RUNOFF (KG/M2/S)
---
>                             ! IN Subsurf.RUNOFF (KG/M2/S)
> ,smvcwt(land_points)                                                           &
>                             ! IN Volumetric wilting point (used to remove
>                             ! global lake evap from soil moisture store)
> ,smvcst(land_points)                                                           &
>                             ! IN Volumetric saturation point(used to remove
>                             ! global lake evap from soil moisture store)
> ,xua(0:global_row_length)                                                      &
>                             ! IN Atmosphere UV longitude coords
> ,yua(global_rows)                                                              &
>                             ! IN Atmosphere latitude coords
> ,xpa(global_row_length+1)                                                      &
>                             ! IN Atmosphere longitude coords
> ,ypa(global_rows)                                                              &
>                             ! IN Atmosphere latitude coords
> ,xva(global_row_length+1)                                                      &
>                             ! IN Atmosphere longitude coords
> ,yva(0:global_rows)                                                            &
>                             ! IN Atmosphere latitude coords
> ,a_boxareas(row_length, rows)                                                  &
>                             ! IN ATMOS gridbox areas
> ,flandg(row_length, rows)
>                             ! IN Land fraction on global field.
126,150c150
< ! Water conservation
< ! Remove global lake evaporation from soil moisture store
<      , smvcwt(land_points)                                                     &
< !                            ! IN Volumetric wilting point
< 
<      , smvcst(land_points)                                                     &
< !                            ! IN Volumetric saturation point
<      ,xua(0:global_row_length)                                                 &
<                                   ! IN Atmosphere UV longitude coords
<      ,yua(global_rows)                                                         &
<                                   ! IN Atmosphere latitude coords
<      ,xpa(global_row_length+1)                                                 &
<                                   ! IN Atmosphere longitude coords
<      ,ypa(global_rows)                                                         &
<                                   ! IN Atmosphere latitude coords
<      ,xva(global_row_length+1)                                                 &
<                                   ! IN Atmosphere longitude coords
<      ,yva(0:global_rows)                                                       &
<                                   ! IN Atmosphere latitude coords
<      ,a_boxareas(row_length, rows)                                             &
<                                   !IN ATMOS gridbox areas
<      ,flandg(row_length, rows)
<                                   ! IN Land fraction on global field.
< 
<      ! ********* NOT USED *********!
---
> ! *** The following are used for the UM-RFM Implmentation ***
174,175c174
< 
< ! ********* NOT USED *********!
---
> ! *** End of fields only used for the UM-RFM implementation
178,179c177,178
< trivdir(river_row_length, river_rows)                                          &
<                                          ! IN river direction
---
>  trivdir(river_row_length, river_rows)                                         &
>                             ! IN river direction
181,185c180
<                                          ! IN river sequence
< ,riv_vel                                                                       &
<                             ! IN river velocity
< ,riv_mcoef                                                                     &
<                             ! IN meandering coefficient
---
>                             ! IN river sequence
188a184,190
> REAL(KIND=real_jlslsm), INTENT(IN) ::                                          &
>  tot_surf_runoff_gb_wtrac(land_points,n_wtrac_jls)                             &
>                             ! IN Surf water tracer runoff on land pts (kg/m2/s)
> ,tot_sub_runoff_gb_wtrac(land_points,n_wtrac_jls)
>                             ! IN Subsurf. water tracer runoff (kg/m2/s)
> 
> 
190c192,196
< ! water store(Kg)
---
>                             ! IN OUT water store(Kg)
> 
> REAL(KIND=real_jlslsm), INTENT(IN OUT) :: twatstor_wtrac(river_row_length,     &
>                                                       river_rows, n_wtrac_jls)
>                             ! IN OUT water tracer store(Kg)
194c200
< !                                 ! for regridding runoff from ATMOS.
---
>                             !    for regridding runoff from ATMOS.
197,198c203,204
< riverout_atmos(row_length,rows)                                                &
<      ! river flow out from each  gridbox(KG/m2/S)
---
>  riverout_atmos(row_length,rows)                                               &
>                             ! river flow out from each  gridbox(KG/m2/S)
200,201c206
<            ! river flow out from TRIP grid to ocean (Kg/s)
< 
---
>                             ! river flow out from TRIP grid to ocean (Kg/s)
203,204c208
<      ! gridbox outflow river grid (Kg/s)
< 
---
>                             ! gridbox outflow river grid (Kg/s)
206c210
<      ! gridbox runoff river grid(Kg/s)
---
>                             ! gridbox runoff river grid(Kg/s)
210,211c214,215
<      ,inlandout_riv(river_row_length,river_rows)                               &
<            !TRIP OUTFLOW FROM INLAND BASINS ON TRIP GRID Kg/s
---
> ,inlandout_riv(river_row_length,river_rows)                                    &
>                             ! Outflow from inland basins on TRIP grid Kg/s
213,214c217,218
<      ,inlandout_atmos(row_length,rows)
<            ! TRIP OUTFLOW FROM  INLAND BASINS ON atmos GRID Kg/m2/s
---
> ,inlandout_atmos(row_length,rows)
>                             ! Outflow from inland basins on ATMOS grid Kg/m2/s
217c221,224
< ! Logical to detect first entry to routing code
---
> REAL(KIND=real_jlslsm), INTENT(OUT) ::                                         &
>  inlandout_atmos_wtrac(row_length,rows,n_wtrac_jls)
>                             ! Water tracer outflow from inland basins on
>                             !  ATMOS grid (kg/m2/s)
219c226,229
< LOGICAL, INTENT(IN) ::  first_entry
---
> REAL(KIND=real_jlslsm), INTENT(IN) ::                                          &
>  acc_lake_evap(row_length,rows)
>                             ! Accumulated lake evap over
>                             ! river routing timestep (Kg/m2)
221c231,234
< ! local variables
---
> REAL(KIND=real_jlslsm), INTENT(IN) ::                                          &
>  acc_lake_evap_wtrac(row_length,rows,n_wtrac_jls)
>                             ! Accumulated water tracer lake evap over
>                             ! river routing timestep (Kg/m2)
223,224c236,242
< INTEGER ::                                                                     &
<  i,j,l
---
> REAL(KIND=real_jlslsm), INTENT(IN OUT) ::                                      &
>   sthu(land_points)                                                            &
>                             ! Unfrozen soil moisture content of
>                             !    bottom layer as a frac of saturation
>  ,smcl(land_points)
>                             ! Total soil moisture contents
>                             !      of bottom layer (kg/m2).
226,229c244,252
< INTEGER ::                                                                     &
<  info                                                                          &
<                           ! Return code from MPP
< , icode                   ! Return code :0 Normal Exit :>0 Error
---
> REAL(KIND=real_jlslsm), INTENT(IN OUT) ::                                      &
>   sthu_wtrac(land_points,1,dsm_levels,n_wtrac_jls)                             &
>                             ! Unfrozen soil moisture content as a frac of
>                             ! saturation. (Note, unlike the water equivalent,
>                             ! this is the full field for all soil levels)
> , smcl_wtrac(land_points,1,dsm_levels,n_wtrac_jls)
>                             ! Water tracer total soil moisture contents
>                             ! (kg/m2). (Note, unlike the water equivalent,
>                             ! this is the full field for all soil levels)
231,245c254
< CHARACTER(LEN=errormessagelength) ::                                           &
<  CMessage         ! Error message if return code >0
< CHARACTER(LEN=*) :: RoutineName
< PARAMETER ( RoutineName='RIV_INTCTL_1A')
< 
< LOGICAL ::                                                                     &
<  invert_trip                                                                   &
<                          ! TRUE WHEN ROW INVERSION IS REQ
< , regrid                                                                       &
<                          ! TRUE if TRIP grid different to ATMOS
< , cyclic_trip                                                                  &
<                          ! TRUE WHEN THE TRIP MODEL HAS CYCLIC
< , global_trip            ! TRUE WHEN TRIP GRID SURFACE IS SPHER
< PARAMETER(invert_trip = .FALSE.,cyclic_trip = .TRUE.,                          &
< global_trip = .TRUE.,regrid = .TRUE.)
---
> ! local variables
247,253c256
< REAL(KIND=real_jlslsm), INTENT(IN OUT) ::                                      &
<   sthu(land_points)                                                            &
<                         ! Frozen soil moisture content of
< !                            !    bottom layer as a frac of saturation
<      , smcl(land_points)
<                              ! Total soil moisture contents
< !                            !      of bottom layer (kg/m2).
---
> INTEGER :: i,j,l,i_wt
255,258c258,259
< REAL(KIND=real_jlslsm), INTENT(IN) ::                                          &
<  acc_lake_evap(row_length,rows)
< !                                    ! Accumulated lake evap over
< !                                    ! river routing timestep (Kg/m2)
---
> INTEGER :: n_wt             ! No. of water fields passed into
>                             !  lake_evap_global_avg
260,274c261,282
< REAL(KIND=real_jlslsm) ::                                                      &
<  smvcst_g(row_length,rows)                                                     &
< !                                    ! SMVCST on global grid
<      ,smvcwt_g(row_length,rows)                                                &
< !                                    ! SMVCWT on global grid
<      ,smcl_dsm_g(row_length,rows)                                              &
< !                                    ! SMCL on DSM_LEVELS LAYER
< !                                    ! on global grid
<      ,sthu_dsm_g(row_length,rows)                                              &
< !                                    ! STHU on DSM_LEVELS LAYER
< !                                    ! on global grid
<      ,surf_runoffin(row_length,rows)                                           &
<                                      ! TOTAL RATE OF RUNOFF (KG/M2/S)
<      ,sub_runoffin(row_length,rows)
< !                                    ! TOTAL RATE OF RUNOFF (KG/M2/S)
---
> INTEGER ::                                                                     &
>  info                                                                          &
>                             ! Return code from MPP
> , icode                     ! Return code :0 Normal Exit :>0 Error
> 
> INTEGER :: mask_for_lake_evap_corr(row_length,rows)
>                             ! Mask used to apply the lake evaporation to soil
>                             ! = 1 apply to point, = 0 do not apply
> 
> REAL(KIND=real_jlslsm) :: total_soil_area
>                             ! Global sum of soil area over which to apply
>                             !  the lake evaporation correction
> 
> REAL(KIND=real_jlslsm) ::  acc_lake_evap_avg(1)
>                             ! Globally accumulated total lake evaporation
>                             !  averaged over total_soil_area
>                             ! (Array size 1 needed so that both water and water
>                             !  tracers can use routine lake_evap_global_avg)
> 
> REAL(KIND=real_jlslsm) ::  acc_lake_evap_avg_wtrac(n_wtrac_jls)
>                             ! Global accumulated total lake evaporation
>                             ! for water tracers averaged over total_soil_area
277,278c285,325
<  acc_lake_evap_avg
<  ! Global daily accumulated total lake evaporation
---
>  smvcst_ij(row_length,rows)                                                    &
>                             ! SMVCST on local ij grid
> ,smvcwt_ij(row_length,rows)                                                    &
>                             ! SMVCWT on local ij grid
> ,smcl_dsm_ij(row_length,rows)                                                  &
>                             ! SMCL on dsm_levels layer on local ij grid
> ,sthu_dsm_ij(row_length,rows)                                                  &
>                             ! STHU on dsm_levels layer on local ij grid
> ,soil_sat_ij(row_length,rows)
>                             ! Soil saturation point (in kg/m2) on local ij grid
> 
> 
> REAL(KIND=real_jlslsm), ALLOCATABLE ::                                         &
>  smcl_dsm_ij_wtrac(:,:)                                                        &
>                             ! Water tracer SMCL on dsm_levels layer on
>                             !  local ij grid
> ,sthu_dsm_ij_wtrac(:,:)
>                             ! Water tracer STHU on dsm_levels layer on
>                             ! local ij grid
> 
> 
> ! Water tracer diagnostics:
> ! These are not currently output from this routine so are dummy fields.
> ! If they are required in the future, they will require an additional
> ! n_wtrac_jls dimension and initialising to zero.
> REAL(KIND=real_jlslsm), ALLOCATABLE ::                                         &
>  riverout_atmos_wtrac_dum(:,:)                                                 &
>                             ! Water tracer river flow out from each atmos
>                             !  gridbox (kg/m2/s). Equivalent to (26,004)
> ,riverout_rgrid_wtrac_dum(:,:)                                                 &
>                             ! Water tracer river flow out from TRIP grid
>                             !  to ocean (kg/s). Equivalent to (26,005)
> ,box_outflow_wtrac_dum(:,:)                                                    &
>                             ! Water tracer gridbox outflow on river grid (kg/s)
>                             ! Equivalent to (26,002)
> ,box_inflow_wtrac_dum(:,:)                                                     &
>                             ! Water tracer gridbox runoff on river grid(kg/s)
>                             ! Equivalent to (26,003)
> ,inlandout_riv_wtrac_dum(:,:)
>                             ! Water tracer outflow from inland basins on
>                             ! TRIP grid (kg/s). Equivalent to (26,006)
281,284c328,329
< ! land mask for global regridding weights calculation
< 
< REAL(KIND=real_jlslsm) :: acc_lake_evap_avg_g = 0, tot_landarea_g = 0
< REAL(KIND=real_jlslsm) :: sum_r(row_length, rows, 2), sum_all(2)
---
>                             ! land mask for global regridding weights
>                             ! calculation
287,289c332,337
< ! use this rather than first entry because of continuation runs
< ! and the need to recalculate concerns and gather land fractions
< ! on first fun
---
>                             ! TRUE if this is the first entry to river routing
> 
> CHARACTER(LEN=errormessagelength) :: CMessage
>                             ! Error message if return code >0
> 
> CHARACTER(LEN=*),PARAMETER :: RoutineName = 'RIV_INTCTL_1A'
295,298d342
< ! gather the TRIP variables to PE0 and call the TRIP river routing
< ! 1. Gather coupling fields from distributed processors onto a single
< !    processor for input to river routing routines.
< 
303,304c347,350
< sum_r = 0.0
< sum_all = 0.0
---
> !-------------------------------------------------------------------------
> !  1. Remove amount of lake evaporation from deep soil layer to conserve
> !     moisture
> !-------------------------------------------------------------------------
306,312c352
< ! *******************************************************************
< DO j = 1,rows
<   DO i = 1,row_length
<     surf_runoffin(i,j) = 0.0
<     sub_runoffin(i,j) = 0.0
<   END DO
< END DO
---
> ! Copy soil fields to full fields array
315,318c355,360
<     smvcst_g(i,j) = 0.0
<     smvcwt_g(i,j) = 0.0
<     smcl_dsm_g(i,j) = 0.0
<     sthu_dsm_g(i,j) = 0.0
---
>     smvcst_ij(i,j) = 0.0
>     smvcwt_ij(i,j) = 0.0
>     smcl_dsm_ij(i,j) = 0.0
>     sthu_dsm_ij(i,j) = 0.0
>     mask_for_lake_evap_corr(i,j) = 0
>     soil_sat_ij(i,j) = 0.0
322d363
< ! Copy land points output back to full fields array.
326,327d366
<   surf_runoffin(i,j) = tot_surf_runoff_gb(l)
<   sub_runoffin(i,j)  = tot_sub_runoff_gb(l)
332,335c371,377
<   smvcst_g(i,j)      = smvcst(l)
<   smvcwt_g(i,j)      = smvcwt(l)
<   smcl_dsm_g(i,j)    = smcl(l)
<   sthu_dsm_g(i,j)    = sthu(l)
---
>   smvcst_ij(i,j)      = smvcst(l)
>   smvcwt_ij(i,j)      = smvcwt(l)
>   smcl_dsm_ij(i,j)    = smcl(l)
>   sthu_dsm_ij(i,j)    = sthu(l)
> 
>   ! Calculate soil saturation point in kg/m2
>   soil_sat_ij(i,j)    = smvcst_ij(i,j) * rho_water * dzsoil(dsm_levels)
337a380,410
> ! Set mask of gridboxes of where to apply the lake evaporation correction.
> ! This applies to both normal water & water tracers.
> WHERE ( sthu_dsm_ij(:,:) * smvcst_ij(:,:) >  smvcwt_ij(:,:) )                  &
>                          mask_for_lake_evap_corr(:,:) = 1
> 
> 
> ! Calculate the global average lake evaporation accumulated over river routing
> ! timestep
> 
> total_soil_area = 0.0
> 
> n_wt = 1  ! No. of water fields
> CALL lake_evap_global_avg(row_length, rows, global_row_length, global_rows,    &
>                           n_wt, mask_for_lake_evap_corr,                       &
>                           a_boxareas, flandg, acc_lake_evap, 'water',          &
>                           total_soil_area, acc_lake_evap_avg)
> 
> ! Remove global average lake evaporation from deepest soil layer
> 
> CALL lake_evap_apply_soil                                                      &
>                (row_length, rows, land_points, land_index,                     &
>                 mask_for_lake_evap_corr, soil_sat_ij,                          &
>                 acc_lake_evap_avg(1), 'water',                                 &
>                 sthu_dsm_ij, smcl_dsm_ij, sthu, smcl)
> 
> 
> !-------------------------------------------------------------------------
> ! 2. Now do river routing
> !-------------------------------------------------------------------------
> 
> ! If first call to this routine, then gather land fraction to a global field
356,371c429
< ! first get number of river grid points on this proc
< 
< ! Calculate the water required to be removed from the soil to
< ! take account of lake evaporation
< 
< ! Calculate the global total lake evaporation accumulated over a day:
< 
< acc_lake_evap_avg = 0.0
< 
< DO j = 1, rows
<   DO i = 1, row_length
< 
<     IF (sthu_dsm_g(i,j) * smvcst_g(i,j) >  smvcwt_g(i,j))                      &
<           sum_r(i,j,1) =  a_boxareas(i,j) * flandg(i,j)
< 
<     sum_r(i,j,2)= acc_lake_evap(i,j) * a_boxareas(i,j) * flandg(i,j)
---
> ! River routing
373,419c431,435
<   END DO
< END DO
< 
< ! calculate global landarea and acc_lake_evap_avg sums
< CALL global_2d_sums(sum_r, row_length, rows, 0, 0, 2, sum_all)
< 
< tot_landarea_g = sum_all(1)
< acc_lake_evap_avg_g = sum_all(2)
< 
< acc_lake_evap_avg = acc_lake_evap_avg_g / tot_landarea_g
< 
< ! Apply water correction:
< 
< DO j = 1, rows
<   DO i = 1, row_length
<     IF (sthu_dsm_g(i,j) * smvcst_g(i,j) >  smvcwt_g(i,j)) THEN
< 
<       smcl_dsm_g(i,j) = smcl_dsm_g(i,j) - acc_lake_evap_avg
<       sthu_dsm_g(i,j) = sthu_dsm_g(i,j) - acc_lake_evap_avg                    &
<             / (smvcst_g(i,j) * rho_water * dzsoil(dsm_levels))
< 
<       IF (sthu_dsm_g(i,j) <  0.0) THEN
<         CALL umPrint('*warning layer 4 unfr soil moisture frac<0' ,            &
<             src='riv_intctl-riv_ic1a')
<         WRITE(umMessage,'(2(F8.2))')STHU_DSM_g(i,j),STHU_DSM_g(i,j)            &
<              +acc_lake_evap_avg
<         CALL umPrint(umMessage,src='riv_intctl-riv_ic1a')
<       END IF
< 
<       IF (smcl_dsm_g(i,j) <  0.0) THEN
<         CALL umPrint('*warning layer 4 unfrozen soil moisture frac<0' ,        &
<             src='riv_intctl-riv_ic1a')
<         WRITE(umMessage,'(2(F8.2))') smcl_DSM_g(i,j), smcl_DSM_g(i,j)          &
<              +acc_lake_evap_avg
<         CALL umPrint(umMessage,src='riv_intctl-riv_ic1a')
<       END IF
<     END IF
<   END DO
< END DO
< 
< 
< 
< CALL riv_rout_1a(global_row_length, global_rows, surf_runoffin,                &
<       sub_runoffin, row_length, rows, invert_atmos, xua, yva,                  &
<       river_row_length, river_rows, flandg, regrid, riv_vel,                   &
<       riv_mcoef, riv_step, cyclic_trip, a_boxareas, global_trip,               &
<       invert_trip, twatstor, riverout_rgrid, trivdir, trivseq,                 &
---
> CALL riv_rout_1a_wrapper(global_row_length, global_rows, land_points,          &
>       land_index, tot_surf_runoff_gb, tot_sub_runoff_gb,                       &
>       row_length, rows, invert_atmos, xua, yva,                                &
>       river_row_length, river_rows, flandg, riv_step, a_boxareas,              &
>       twatstor, riverout_rgrid, trivdir, trivseq,                              &
424c440
< WHERE (flandg == 1.0) riverout_atmos = 0.0
---
> first = .FALSE.
426,432c442,466
< ! Copy full fields array back to land points:
< DO l = 1, land_points
<   j=(land_index(l) - 1) / row_length + 1
<   i = land_index(l) - (j-1) * row_length
<   smcl(l) = smcl_dsm_g(i,j)
<   sthu(l) = sthu_dsm_g(i,j)
< END DO
---
> !------------------------------------------------------------------------
> ! Repeat steps 1 and 2 for water tracers if present
> !------------------------------------------------------------------------
> 
> IF (l_wtrac_jls) THEN
> 
>   ! Set up required water tracer fields
> 
>   ! Currently, there are no water tracer diagnostics output from this
>   ! routine.  So set fields to dummy fields.
>   ALLOCATE(riverout_atmos_wtrac_dum(row_length,rows))
>   ALLOCATE(riverout_rgrid_wtrac_dum(river_row_length,river_rows))
>   ALLOCATE(box_outflow_wtrac_dum(river_row_length,river_rows))
>   ALLOCATE(box_inflow_wtrac_dum(river_row_length,river_rows))
>   ALLOCATE(inlandout_riv_wtrac_dum(river_row_length,river_rows))
> 
>   ALLOCATE(smcl_dsm_ij_wtrac(row_length,rows))
>   ALLOCATE(sthu_dsm_ij_wtrac(row_length,rows))
> 
>   DO j = 1, rows
>     DO i = 1, row_length
>       smcl_dsm_ij_wtrac(i,j) = 0.0
>       sthu_dsm_ij_wtrac(i,j) = 0.0
>     END DO
>   END DO
434c468,522
< first = .FALSE.
---
>   ! Calculate the global average lake evaporation accumulated over river routing
>   ! timestep
>   ! (Pass all water tracers into this routine so global_2d_sums only needs to
>   !  be called once)
>   n_wt = n_wtrac_jls  ! No. of water fields
>   CALL lake_evap_global_avg(row_length, rows, global_row_length, global_rows,  &
>                             n_wt, mask_for_lake_evap_corr,                     &
>                             a_boxareas, flandg, acc_lake_evap_wtrac, 'wtrac',  &
>                             total_soil_area, acc_lake_evap_avg_wtrac)
> 
>   DO i_wt = 1, n_wtrac_jls
> 
>     ! Set up water tracer soil fields on ij grid
>     DO l = 1, land_points
>       j=(land_index(l) - 1) / row_length + 1
>       i = land_index(l) - (j-1) * row_length
> 
>       smcl_dsm_ij_wtrac(i,j)    = smcl_wtrac(l,1,dsm_levels,i_wt)
>       sthu_dsm_ij_wtrac(i,j)    = sthu_wtrac(l,1,dsm_levels,i_wt)
>     END DO
> 
>     ! Remove water tracer lake evaporation from water tracer in deep soil layer
>     CALL lake_evap_apply_soil                                                  &
>                (row_length, rows, land_points, land_index,                     &
>                 mask_for_lake_evap_corr, soil_sat_ij,                          &
>                 acc_lake_evap_avg_wtrac(i_wt), 'wtrac',                        &
>                 sthu_dsm_ij_wtrac, smcl_dsm_ij_wtrac,                          &
>                 sthu_wtrac(:,1,dsm_levels,i_wt),                               &
>                 smcl_wtrac(:,1,dsm_levels,i_wt))
> 
>     ! Call river routing routine with water tracer inflows and outflows
>     CALL riv_rout_1a_wrapper(global_row_length, global_rows, land_points,      &
>       land_index,                                                              &
>       tot_surf_runoff_gb_wtrac(:,i_wt), tot_sub_runoff_gb_wtrac(:,i_wt),       &
>       row_length, rows, invert_atmos, xua, yva,                                &
>       river_row_length, river_rows, flandg, riv_step, a_boxareas,              &
>       twatstor_wtrac(:,:,i_wt), riverout_rgrid_wtrac_dum(:,:),                 &
>       trivdir, trivseq,                                                        &
>       box_outflow_wtrac_dum(:,:), box_inflow_wtrac_dum(:,:),                   &
>       riverout_atmos_wtrac_dum(:,:),                                           &
>       inlandout_riv_wtrac_dum(:,:), inlandout_atmos_wtrac(:,:,i_wt),           &
>       global_river_row_length, global_river_rows, land_frac, first, cmessage)
> 
>   END DO   ! i_wt
> 
>   DEALLOCATE(sthu_dsm_ij_wtrac)
>   DEALLOCATE(smcl_dsm_ij_wtrac)
> 
>   DEALLOCATE(inlandout_riv_wtrac_dum)
>   DEALLOCATE(box_inflow_wtrac_dum)
>   DEALLOCATE(box_outflow_wtrac_dum)
>   DEALLOCATE(riverout_rgrid_wtrac_dum)
>   DEALLOCATE(riverout_atmos_wtrac_dum)
> 
> END IF     ! l_wtrac_jls
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/river_routing/um: riv_rout_1a_wrapper_mod.F90
diff -r vn7.0copy1_c4/src/./science/river_routing/um/riv_rout-river1a_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/river_routing/um/riv_rout-river1a_mod.F90
31,32c31,32
<      yva, river_row_length, river_rows, frac, regrid, ru,                      &
<      ratmed, dt, cyclic_trip, gridbox_areas, global_trip, invert_trip,         &
---
>      yva, river_row_length, river_rows, frac, regrid,                          &
>      dt, gridbox_areas,                                                        &
59a60
> USE jules_rivers_mod, ONLY: rivers_speed, rivers_meander
130c131
<      ! land seak fraction across all processes
---
>      ! land sea fraction across all processes
158c159
<      , regrid                                                                  &
---
>      , regrid
160,164d160
<      , cyclic_trip                                                             &
<      ! indicates if trips grid is cyclic
<      , global_trip                                                             &
<      ! indicates if atmos grid is cyclic
<      , invert_trip
170,174c166
<      ru                                                                        &
<      ! effective river flow velocity (m/s)
<      , ratmed                                                                  &
<      ! river meander ratio
<      , dt
---
>        dt
424c416
<   WRITE(umMessage, '(A,F6.4)') 'Meandering Ratio  = ', ratmed
---
>   WRITE(umMessage, '(A,F6.4)') 'Meandering Ratio  = ', rivers_meander
426c418,419
<   WRITE(umMessage, '(A,F6.4,A)') 'Effective Velocity ru =', ru, ' (m/s)'
---
>   WRITE(umMessage, '(A,F6.4,A)') 'Effective Velocity ru =', rivers_speed,      &
>       ' (m/s)'
433c426
< CALL routedbl(runoff_trip, ru, ratmed, ndev, dt                                &
---
> CALL routedbl(runoff_trip, rivers_speed, rivers_meander, ndev, dt              &
diff -r vn7.0copy1_c4/src/./science/river_routing/um/setarea_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/river_routing/um/setarea_mod.F90
22a23
> USE conversions_mod, ONLY: pi
35a37,39
> USE ereport_mod, ONLY: ereport
> USE jules_rivers_mod, ONLY: trip_globe_shape, globe_spherical, globe_ellipsoidal
> USE planet_constants_mod, ONLY: planet_radius
49a54,60
> REAL(KIND=real_jlslsm)  :: dlat, dlon
> REAL(KIND=real_jlslsm)  :: len_lat
> REAL(KIND=real_jlslsm)  :: lat_degrees
> REAL(KIND=real_jlslsm)  :: lat_rad
> REAL(KIND=real_jlslsm)  :: len_lon
> INTEGER                 :: errcode
> 
54d64
< 
56,61d65
< DO j = 1, jmax
<   IF ((j + j_offset) <= 90) THEN
<     atmp = arealat1(INT(ABS(91.0 - (j + j_offset)))) * 1.0e06
<   ELSE
<     atmp = arealat1(INT(ABS((j + j_offset) - 90.0))) * 1.0e06
<   END IF
63,64c67,82
<   DO i = 1, nx
<     area(i,j) = atmp
---
> SELECT CASE ( trip_globe_shape )
> 
> CASE ( globe_spherical )
>   ! UM-TRIP is only capable of handling 1 degree data from south to north
>   dlat = pi / 180.0
>   dlon = dlat
>   len_lat = planet_radius * dlat
> 
>   DO j = 1, jmax
>     lat_degrees = -90.5 + REAL(j + j_offset)
>     lat_rad = lat_degrees * pi / 180.0
>     len_lon = planet_radius * COS(lat_rad) * dlon
>     atmp = len_lat * len_lon
>     DO i = 1, nx
>       area(i,j) = atmp
>     END DO
66c84,102
< END DO
---
> 
> CASE ( globe_ellipsoidal )
>   DO j = 1, jmax
>     IF ((j + j_offset) <= 90) THEN
>       atmp = arealat1(INT(ABS(91.0 - (j + j_offset)))) * 1.0e06
>     ELSE
>       atmp = arealat1(INT(ABS((j + j_offset) - 90.0))) * 1.0e06
>     END IF
>     DO i = 1, nx
>       area(i,j) = atmp
>     END DO
>   END DO
> 
> CASE DEFAULT
>   errcode = 151
>   CALL ereport(RoutineName, errcode,                                           &
>      "Unsupported trip_globe_shape")
> END SELECT
> 
diff -r vn7.0copy1_c4/src/./science/river_routing/um/um_riv_to_jules_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/river_routing/um/um_riv_to_jules_mod.F90
54,56c54,56
<   a_thresh, np_rivers, river_mouth, rivers_dlat, rivers_dlon, rivers_rfm       &
<   ,rivers_first, rivers_dx, i_river_vn                                         &
<   ,rivers_regrid, sea, rfm_land, rfm_river, rfm_sea                            &
---
>   a_thresh, np_rivers, river_mouth, rivers_dlat=>rivers_dy                     &
>   ,rivers_dlon=>rivers_dx, rivers_rfm, rivers_first, rivers_length             &
>   ,i_river_vn, rivers_regrid, sea, rfm_land, rfm_river, rfm_sea                &
122c122,124
< INTEGER, ALLOCATABLE :: mapfr(:,:)                   ! map full to river
---
> INTEGER, ALLOCATABLE :: grid_riv_pt_number(:,:)
>   ! Map full river grid to river points. For each location on the grid, this
>   ! is the river point number.
155c157,158
< ! rivers_dx is read from namelist jules_rivers_props in standalone mode;
---
> ! In standalone mode rivers_length is read from namelist jules_rivers_props or
> ! calculated if not given.
158c161
< rivers_dx = planet_radius * delta_phi
---
> rivers_length = planet_radius * delta_phi
172c175,176
<     ALLOCATE( mapfr(global_river_row_length,global_river_rows), STAT = ERROR )
---
>     ALLOCATE( grid_riv_pt_number(global_river_row_length,global_river_rows),   &
>               STAT = ERROR )
185a190,191
>     ALLOCATE(rivers_data%rivers_outflow_rp(np_rivers),  STAT = ERROR )
>     error_sum = error_sum + ERROR
188c194
<     ALLOCATE(rivers_data%il_river_grid(np_rivers),      STAT = ERROR )
---
>     ALLOCATE(rivers_data%map_river_to_land_points(np_rivers), STAT = ERROR )
208,209c214,215
<       rivers_data%rfm_land_rp(ip)      = 0
<       rivers_data%rfm_iarea_rp(ip)     = 0
---
>       rivers_data%rfm_land_rp(ip)       = 0
>       rivers_data%rfm_iarea_rp(ip)      = 0
211,217c217,223
<       rivers_data%rfm_flowobs1_rp(ip)  = 0.0
<       rivers_data%rfm_surfstore_rp(ip) = 0.0
<       rivers_data%rfm_substore_rp(ip)  = 0.0
<       rivers_data%rfm_flowin_rp(ip)    = 0.0
<       rivers_data%rfm_bflowin_rp(ip)   = 0.0
<       rivers_data%rfm_rivflow_rp(ip)   = 0.0
<       rivers_data%rfm_baseflow_rp(ip)  = 0.0
---
>       rivers_data%rfm_flowobs1_rp(ip)   = 0.0
>       rivers_data%rfm_surfstore_rp(ip)  = 0.0
>       rivers_data%rfm_substore_rp(ip)   = 0.0
>       rivers_data%rfm_flowin_rp(ip)     = 0.0
>       rivers_data%rfm_bflowin_rp(ip)    = 0.0
>       rivers_data%rfm_rivflow_rp(ip)    = 0.0
>       rivers_data%rfm_baseflow_rp(ip)   = 0.0
220c226
<       rivers_data%il_river_grid(ip)    = 0
---
>       rivers_data%map_river_to_land_points(ip) = 0
221a228
>       rivers_data%rivers_outflow_rp(ip) = 0.0
226,227c233,234
<     rivers%il_river_grid => rivers_data%il_river_grid
<     rivers%ir_land_grid => rivers_data%ir_land_grid
---
>     rivers%map_river_to_land_points => rivers_data%map_river_to_land_points
>     rivers%global_land_index => rivers_data%global_land_index
240a248
>     rivers%rivers_outflow_rp => rivers_data%rivers_outflow_rp
244c252
<         mapfr(i,j) = 0
---
>         grid_riv_pt_number(i,j) = 0
283c291
<       mapfr(i,j) = l      ! full 2D rivgrid to rivpts
---
>       grid_riv_pt_number(i,j) = l      ! full 2D rivgrid to rivpts
365c373
<           rivers%rivers_next_rp(l) = -river_mouth
---
>           rivers%rivers_next_rp(l) = river_mouth
368c376
<           IF ( mapfr(inext, jnext) > 0 ) THEN
---
>           IF ( grid_riv_pt_number(inext, jnext) > 0 ) THEN
374c382
<               rivers%rivers_next_rp(l) = mapfr(inext,jnext)
---
>               rivers%rivers_next_rp(l) = grid_riv_pt_number(inext,jnext)
377c385
<               rivers%rivers_next_rp(l) = -river_mouth
---
>               rivers%rivers_next_rp(l) = river_mouth
382c390
<             rivers%rivers_next_rp(l) = -river_mouth
---
>             rivers%rivers_next_rp(l) = river_mouth
412c420
<     !    -9 : a river mouth (value = -1*river_mouth)
---
>     !    -9 : a river mouth (value = river_mouth)
421c429
<     DEALLOCATE(mapfr)
---
>     DEALLOCATE(grid_riv_pt_number)
490,501c498,517
<   CALL rivpts_to_landpts( np_rivers, rivers%rfm_flowin_rp, global_land_pts,    &
<                           flowin_lp, rivers%il_river_grid, rivers%ir_land_grid,&
<                           rivers%rivers_index_rp)
<   CALL rivpts_to_landpts( np_rivers, rivers%rfm_bflowin_rp, global_land_pts,   &
<                           bflowin_lp, rivers%il_river_grid,                    &
<                           rivers%ir_land_grid, rivers%rivers_index_rp)
<   CALL rivpts_to_landpts( np_rivers, rivers%rfm_surfstore_rp, global_land_pts, &
<                           surfstore_lp, rivers%il_river_grid,                  &
<                           rivers%ir_land_grid, rivers%rivers_index_rp)
<   CALL rivpts_to_landpts( np_rivers, rivers%rfm_substore_rp, global_land_pts,  &
<                           substore_lp, rivers%il_river_grid,                   &
<                           rivers%ir_land_grid, rivers%rivers_index_rp)
---
>   CALL rivpts_to_landpts( global_land_pts, np_rivers,                          &
>                           rivers%map_river_to_land_points,                     &
>                           rivers%global_land_index,                            &
>                           rivers%rivers_index_rp,                              &
>                           rivers%rfm_flowin_rp, flowin_lp )
>   CALL rivpts_to_landpts( global_land_pts, np_rivers,                          &
>                           rivers%map_river_to_land_points,                     &
>                           rivers%global_land_index,                            &
>                           rivers%rivers_index_rp,                              &
>                           rivers%rfm_bflowin_rp, bflowin_lp )
>   CALL rivpts_to_landpts( global_land_pts, np_rivers,                          &
>                           rivers%map_river_to_land_points,                     &
>                           rivers%global_land_index,                            &
>                           rivers%rivers_index_rp,                              &
>                           rivers%rfm_surfstore_rp, surfstore_lp )
>   CALL rivpts_to_landpts( global_land_pts, np_rivers,                          &
>                           rivers%map_river_to_land_points ,                    &
>                           rivers%global_land_index,                            &
>                           rivers%rivers_index_rp,                              &
>                           rivers%rfm_substore_rp, substore_lp )
diff -r vn7.0copy1_c4/src/./science/snow/canopysnow_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/snow/canopysnow_mod.F90
21c21,22
< SUBROUTINE canopysnow ( land_pts, surft_pts, timestep, cansnowtile,            &
---
> SUBROUTINE canopysnow ( land_pts, surft_pts, n_wtrac_jls,                      &
>                         timestep, cansnowtile,                                 &
23,24c24,27
<                         unload_backgrnd_surft,                                 &
<                         melt_surft, snow_can, snowfall, graupfall )
---
>                         unload_backgrnd_surft, melt_surft,                     &
>                         con_snow_wtrac, ls_snow_wtrac, ls_graup_wtrac,         &
>                         snow_can, snow_can_wtrac,                              &
>                         snowfall, graupfall, snowfall_wtrac, graupfall_wtrac )
34a38,40
> USE jules_science_fixes_mod, ONLY: l_fix_neg_snow
> USE jules_water_tracers_mod, ONLY: l_wtrac_jls, wtrac_calc_ratio_fn_jules
> 
48c54
<   surft_pts
---
>   surft_pts,                                                                   &
49a56,57
>   n_wtrac_jls
>     !  Number of water tracers.
74c82
<   unload_backgrnd_surft(land_pts)
---
>   unload_backgrnd_surft(land_pts),                                             &
75a84,89
>   con_snow_wtrac(land_pts,n_wtrac_jls),                                        &
>     ! Water tracer convective snowfall rate (kg/m2/s).
>   ls_snow_wtrac(land_pts,n_wtrac_jls),                                         &
>     ! Water tracer large-scale frozen precip fall rate (kg/m2/s).
>   ls_graup_wtrac(land_pts,n_wtrac_jls)
>     ! Water tracer large-scale graupel fall rate (kg/m2/s).
81c95
<   snow_can(land_pts)
---
>   snow_can(land_pts),                                                          &
82a97,98
>   snow_can_wtrac(land_pts,n_wtrac_jls)
>     ! Water tracer canopy snow load (kg/m2).
90c106
<   graupfall(land_pts)
---
>   graupfall(land_pts),                                                         &
91a108,111
>   snowfall_wtrac(land_pts,n_wtrac_jls),                                        &
>     ! Water tracer frozen precip reaching the ground in timestep (kg/m2).
>   graupfall_wtrac(land_pts,n_wtrac_jls)
>     ! Water tracer graupel reaching the ground in timestep (kg/m2).
99c119
<   k
---
>   k,                                                                           &
100a121,122
>   i_wt
>     ! Water tracer index
103c125
<   intercept,                                                                   &
---
>   intercept(surft_pts),                                                        &
105c127
<  unload
---
>   unload(surft_pts)
107a130,145
> REAL(KIND=real_jlslsm) ::                                                      &
>   intercept_wtrac,                                                             &
>     ! Water tracer snow intercepted by canopy in timestep (kg/m2).
>   unload_wtrac,                                                                &
>     ! Water tracer canopy snow unloaded in timestep (kg/m2).
>   ratio_snowfall,                                                              &
>     ! Ratio of water tracer to water for snow fall
>   ratio_snow_can
>     ! Ratio of water tracer to water for canopy snow
> 
> REAL(KIND=real_jlslsm), ALLOCATABLE ::                                         &
>   snowfall_old(:),                                                             &
>     ! Initial snowfall
>   snow_can_old(:)
>     ! Initial canopy snow load
> 
120,123c158,169
< !$OMP PARALLEL DO                                                              &
< !$OMP SCHEDULE(STATIC)                                                         &
< !$OMP DEFAULT(NONE)                                                            &
< !$OMP PRIVATE(k,i,intercept,unload)                                            &
---
>   ! Allocate temporary fields for water tracers use
>   IF (l_wtrac_jls) THEN
>     ALLOCATE(snowfall_old(surft_pts))
>     ALLOCATE(snow_can_old(surft_pts))
>   ELSE
>     ALLOCATE(snowfall_old(1))
>     ALLOCATE(snow_can_old(1))
>   END IF
> 
> !$OMP PARALLEL DEFAULT(NONE)                                                   &
> !$OMP PRIVATE(k,i,i_wt,ratio_snowfall,ratio_snow_can,intercept_wtrac,          &
> !$OMP         unload_wtrac)                                                    &
126c172,189
< !$OMP        unload_backgrnd_surft,snowinterceptfact,snowunloadfact)
---
> !$OMP        unload_backgrnd_surft,snowinterceptfact,snowunloadfact,           &
> !$OMP        intercept,unload,snowfall_old,snow_can_old,l_wtrac_jls,           &
> !$OMP        snowfall_wtrac,ls_snow_wtrac,ls_graup_wtrac, con_snow_wtrac,      &
> !$OMP        graupfall_wtrac,snow_can_wtrac,n_wtrac_jls, l_fix_neg_snow)
>   IF (l_wtrac_jls) THEN
>     ! If water tracers, save initial values of some fields for use later on.
>     ! (Note, these 'old' fields have size surft_pts)
> !$OMP DO SCHEDULE(STATIC)
>     DO k = 1,surft_pts
>       i = surft_index(k)
>       snowfall_old(k) = ( ls_snow(i) - ls_graup(i) + con_snow(i) ) * timestep
>       snow_can_old(k) = snow_can(i)
>     END DO
> !$OMP END DO
>   END IF
> 
> 
> !$OMP DO SCHEDULE(STATIC)
131c194
<     intercept    = snowinterceptfact * (catch_snow(i) - snow_can(i))           &
---
>     intercept(k) = snowinterceptfact * (catch_snow(i) - snow_can(i))           &
133c196
<     unload       = snowunloadfact * melt_surft(i) * timestep                   &
---
>     unload(k)    = snowunloadfact * melt_surft(i) * timestep                   &
143,145c206,223
<     unload      = MAX( MIN( unload, snow_can(i) ), 0.0 )
<     snow_can(i) = snow_can(i) + intercept - unload
<     snowfall(i) = snowfall(i) + graupfall(i) - intercept + unload
---
>     IF (l_fix_neg_snow) THEN
>       ! Ensure the interception and the unloading are non-negative
>       ! and ensure that the final canopy snow amount does not exceed
>       ! the canopy capacity.
>       intercept(k) = MAX(0.0, intercept(k))
>       unload(k)    = MAX(0.0, unload(k))
>       snow_can(i) = snow_can(i) + intercept(k) - unload(k)
>       IF (snow_can(i) > catch_snow(i)) THEN
>         unload(k) = unload(k) + (snow_can(i) - catch_snow(i))
>         snow_can(i) = catch_snow(i)
>       END IF
>     ELSE
>       ! Do not limit the interception and limit the unloading based
>       ! solely on the existing canopy amounts.
>       unload(k)      = MAX( MIN( unload(k), snow_can(i) ), 0.0 )
>       snow_can(i) = snow_can(i) + intercept(k) - unload(k)
>     END IF
>     snowfall(i) = snowfall(i) + graupfall(i) - intercept(k) + unload(k)
147c225,267
< !$OMP END PARALLEL DO
---
> !$OMP END DO
> 
>   IF (l_wtrac_jls) THEN
>     ! Repeat for water tracers
>     DO i_wt = 1, n_wtrac_jls
> !$OMP DO SCHEDULE(STATIC)
>       DO k = 1,surft_pts
>         i = surft_index(k)
>         snowfall_wtrac(i,i_wt)  = ( ls_snow_wtrac(i,i_wt) -                    &
>                                   ls_graup_wtrac(i,i_wt) +                     &
>                                   con_snow_wtrac(i,i_wt) ) * timestep
>         graupfall_wtrac(i,i_wt) = ls_graup_wtrac(i,i_wt) * timestep
> 
>         ! Calculate water tracer to water ratio for snowfall to scale
>         ! intercept for water tracers. (Use snowfall value on input to routine.)
>         ratio_snowfall          = wtrac_calc_ratio_fn_jules(i_wt,              &
>                                   snowfall_wtrac(i,i_wt), snowfall_old(k))
>         intercept_wtrac         = intercept(k) * ratio_snowfall
> 
>         ! Calculate water tracer to water ratio for canopy snow to scale
>         ! unload for water tracers. (Use snow_can value on input to routine.)
>         ratio_snow_can          = wtrac_calc_ratio_fn_jules(i_wt,              &
>                                   snow_can_wtrac(i,i_wt), snow_can_old(k))
>         unload_wtrac            = unload(k) * ratio_snow_can
> 
>         unload_wtrac            = MAX( MIN( unload_wtrac,                      &
>                                        snow_can_wtrac(i,i_wt) ), 0.0 )
>         snow_can_wtrac(i,i_wt) = snow_can_wtrac(i,i_wt) +                      &
>                                  intercept_wtrac - unload_wtrac
>         snowfall_wtrac(i,i_wt) = snowfall_wtrac(i,i_wt) +                      &
>                                  graupfall_wtrac(i,i_wt) -                     &
>                                  intercept_wtrac + unload_wtrac
> 
>       END DO
> !$OMP END DO
>     END DO
>   END IF ! l_wtrac_jls
> 
> !$OMP END PARALLEL
> 
>   DEALLOCATE(snow_can_old)
>   DEALLOCATE(snowfall_old)
> 
150,153c270,271
< !$OMP PARALLEL DO                                                              &
< !$OMP SCHEDULE(STATIC)                                                         &
< !$OMP DEFAULT(NONE)                                                            &
< !$OMP PRIVATE(k,i)                                                             &
---
> !$OMP PARALLEL DEFAULT(NONE)                                                   &
> !$OMP PRIVATE(k,i,i_wt)                                                        &
155c273,275
< !$OMP        graupfall,ls_graup)
---
> !$OMP        graupfall,ls_graup,snowfall_wtrac,ls_snow_wtrac,con_snow_wtrac,   &
> !$OMP        graupfall_wtrac,ls_graup_wtrac,n_wtrac_jls,l_wtrac_jls)
> !$OMP DO SCHEDULE(STATIC)
161c281,296
< !$OMP END PARALLEL DO
---
> !$OMP END DO
> 
>   IF (l_wtrac_jls) THEN
>     DO i_wt = 1, n_wtrac_jls
> !$OMP DO SCHEDULE(STATIC)
>       DO k = 1,surft_pts
>         i = surft_index(k)
>         snowfall_wtrac(i,i_wt)  = ( ls_snow_wtrac(i,i_wt) +                    &
>                                   con_snow_wtrac(i,i_wt) ) * timestep
>         graupfall_wtrac(i,i_wt) = ls_graup_wtrac(i,i_wt) * timestep
>       END DO
> !$OMP END DO
>     END DO
>   END IF
> 
> !$OMP END PARALLEL
diff -r vn7.0copy1_c4/src/./science/snow/relayersnow_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/snow/relayersnow_mod.F90
21c21
< SUBROUTINE relayersnow( land_pts, surft_pts, surft_index,                      &
---
> SUBROUTINE relayersnow( land_pts, surft_pts, n_wtrac_jls, surft_index,         &
23,25c23,25
<                         tsnow0, nsnow, ds, rgrain, rgrainl, sice,              &
<                         rho_snow_grnd, sliq, tsnow, rho_snow,                  &
<                         snowdepth )
---
>                         tsnow0, sice0_wtrac, nsnow, ds, rgrain, rgrainl, sice, &
>                         rho_snow_grnd, sliq, tsnow, sice_wtrac, sliq_wtrac,    &
>                         rho_snow, snowdepth )
54a55,56
> USE jules_water_tracers_mod, ONLY: l_wtrac_jls
> 
68c70
<   surft_pts
---
>   surft_pts,                                                                   &
69a72,73
>   n_wtrac_jls
>     ! Number of water tracers
90c94
<   tsnow0(land_pts)
---
>   tsnow0(land_pts),                                                            &
91a96,98
>   sice0_wtrac(land_pts,n_wtrac_jls)
>      ! Water tracer ice content of fresh snow (kg/m2).
>      ! Where nsnow=0, sice0 is the mass of the snowpack.
112c119
<   tsnow(land_pts,nsmax)
---
>   tsnow(land_pts,nsmax),                                                       &
113a121,124
>   sice_wtrac(land_pts,nsmax,n_wtrac_jls),                                      &
>     ! Water tracer ice content of snow layers (kg/m2).
>   sliq_wtrac(land_pts,nsmax,n_wtrac_jls)
>     ! Water tracer liquid content of snow layers (kg/m2).
147c158
<   old
---
>   old,                                                                         &
148a160,161
>   i_wt
>     ! Water tracer index.
180a194,200
> REAL(KIND=real_jlslsm), ALLOCATABLE ::                                         &
>   s_wtrac(:,:),                                                                &
>     ! Water tracer ice content before adjustment (kg/m2).
>   w_wtrac(:,:)
>     ! Water tracer liquid content before adjustment (kg/m2).
> 
> 
193a214,222
> ! Allocate water tracer working arrays
> IF (l_wtrac_jls) THEN
>   ALLOCATE(s_wtrac(0:nsmax,n_wtrac_jls))
>   ALLOCATE(w_wtrac(0:nsmax,n_wtrac_jls))
> ELSE
>   ALLOCATE(s_wtrac(1,1))
>   ALLOCATE(w_wtrac(1,1))
> END IF
> 
285c314
< !$OMP         r,s,w,u,errcode,errmsg)
---
> !$OMP         r,s,w,u,errcode,errmsg,i_wt,s_wtrac,w_wtrac)
322a352,364
>     IF (l_wtrac_jls) THEN
>       ! Repeat for water tracers
>       DO i_wt = 1, n_wtrac_jls
>         s_wtrac(0,i_wt) = sice0_wtrac(i,i_wt)
>         w_wtrac(0,i_wt) = 0.0
> 
>         DO n = 1,nold(i)
>           s_wtrac(n,i_wt) = sice_wtrac(i,n,i_wt)
>           w_wtrac(n,i_wt) = sliq_wtrac(i,n,i_wt)
>         END DO
>       END DO
>     END IF ! l_wtrac_jls
> 
332a375,384
>     IF (l_wtrac_jls) THEN
>       ! Repeat for water tracers
>       DO i_wt = 1,n_wtrac_jls
>         DO n = 1, nsmax
>           sice_wtrac(i,n,i_wt) = 0.0
>           sliq_wtrac(i,n,i_wt) = 0.0
>         END DO
>       END DO
>     END IF     ! l_wtrac_jls
> 
372a425,435
> 
>             IF (l_wtrac_jls) THEN
>               ! Repeat for water tracers
>               DO i_wt = 1,n_wtrac_jls
>                 sice_wtrac(i,new,i_wt) = sice_wtrac(i,new,i_wt)                &
>                                          + s_wtrac(old,i_wt) * wt
>                 sliq_wtrac(i,new,i_wt) = sliq_wtrac(i,new,i_wt)                &
>                                          + w_wtrac(old,i_wt) * wt
>               END DO
>             END IF     ! l_wtrac_jls
> 
402a466,476
> 
>             IF (l_wtrac_jls) THEN
>               ! Repeat for water tracers
>               DO i_wt = 1,n_wtrac_jls
>                 sice_wtrac(i,new,i_wt) = sice_wtrac(i,new,i_wt)                &
>                                          + s_wtrac(old,i_wt) * wt
>                 sliq_wtrac(i,new,i_wt) = sliq_wtrac(i,new,i_wt)                &
>                                          + w_wtrac(old,i_wt) * wt
>               END DO
>             END IF     ! l_wtrac_jls
> 
486a561,570
> 
>     IF (l_wtrac_jls) THEN
>       ! Repeat for water tracers
>       DO i_wt = 1,n_wtrac_jls
>         DO n = nsnow(i) + 1, nsmax
>           sice_wtrac(i,n,i_wt)      = 0.0
>           sliq_wtrac(i,n,i_wt)      = 0.0
>         END DO
>       END DO
>     END IF     ! l_wtrac_jls
490a575,578
> 
> ! Deallocate water tracer working arrays
> DEALLOCATE(w_wtrac)
> DEALLOCATE(s_wtrac)
diff -r vn7.0copy1_c4/src/./science/snow/snow_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/snow/snow_mod.F90
21c21
< SUBROUTINE snow ( land_pts, timestep, stf_hf_snow_melt, nsurft,                &
---
> SUBROUTINE snow ( land_pts, timestep, stf_hf_snow_melt, nsurft, n_wtrac_jls,   &
24c24
<                   hcaps1_soilt, hcons, melt_surft,                             &
---
>                   hcaps1_soilt, hcons, melt_surft, snowinc_surft,              &
27c27,28
<                   smvcst1_soilt, rgrain, rgrainl, rho_snow_grnd, sice,         &
---
>                   smvcst1_soilt, con_snow_wtrac, ei_surft_wtrac,               &
>                   rgrain, rgrainl, rho_snow_grnd, sice,                        &
29c30,34
<                   tsnow, nsnow, ds, hf_snow_melt, lying_snow,                  &
---
>                   tsnow, nsnow, con_rain_wtrac, ls_rain_wtrac,                 &
>                   ls_snow_wtrac, ls_graup_wtrac, melt_surft_wtrac,             &
>                   snow_grnd_wtrac, snow_surft_wtrac, sice_wtrac,               &
>                   sliq_wtrac,                                                  &
>                   ds, hf_snow_melt, lying_snow,                                &
32c37,38
<                   dhf_surf_minus_soil,                                         &
---
>                   dhf_surf_minus_soil, snow_melt_wtrac,                        &
>                   lake_snow_melt_wtrac,                                        &
37c43
<                   l_lice_point,                                                &
---
>                   l_lice_point, l_lice_surft,                                  &
40c46,47
<                   non_lake_frac, lake_h_mxl_gb, lake_depth_gb)
---
>                   non_lake_frac, lake_h_mxl_gb, lake_depth_gb                  &
>                   )
44a52
> 
71c79
< USE jules_surface_types_mod, ONLY: lake
---
> USE jules_surface_types_mod, ONLY: lake, ntype
78a87,90
> USE jules_water_tracers_mod, ONLY: l_wtrac_jls, wtrac_calc_ratio_fn_jules
> USE wtrac_snow_mod,          ONLY: wtrac_sn_type, wtrac_alloc_snow,            &
>                                    wtrac_dealloc_snow
> 
105a118,119
>   n_wtrac_jls,                                                                 &
>     ! Number of water tracers
119a134,140
>   snowinc_surft(land_pts,nsurft),                                              &
>     ! Total increment to snow from the surface scheme, including sublimation
>     ! and melting (kg m-2 TS-1).
>     ! Using the increment, rather than the rate times the timestep allows
>     ! the mass of snow to be reduced to 0, whereas using the rate can
>     ! result in very small presisting amounts of snow because of rounding
>     ! errors.
139c160
<   smvcst1_soilt(land_pts,nsoilt)
---
>   smvcst1_soilt(land_pts,nsoilt),                                              &
140a162,165
>   con_snow_wtrac(land_pts,n_wtrac_jls),                                        &
>     ! Water tracer convective snowfall rate (kg/m2/s).
>   ei_surft_wtrac(land_pts,nsurft,n_wtrac_jls)
>     ! Water tracer sublimation of snow (kg/m2/s).
191c216
<   lake_depth_gb(land_pts)
---
>   lake_depth_gb(land_pts),                                                     &
192a218,238
>   con_rain_wtrac(land_pts,n_wtrac_jls),                                        &
>     ! Water tracer convective rainfall rate (kg/m2/s).
>   ls_snow_wtrac(land_pts,n_wtrac_jls),                                         &
>     ! Water tracer large-scale frozen precip fall rate (kg/m2/s).
>   ls_graup_wtrac(land_pts,n_wtrac_jls),                                        &
>     ! Water tracer large-scale graupel fall rate (kg/m2/s).
>   ls_rain_wtrac(land_pts,n_wtrac_jls),                                         &
>     ! Water tracer large-scale rainfall rate (kg/m2/s).
>   melt_surft_wtrac(land_pts,nsurft,n_wtrac_jls),                               &
>     ! Surface or canopy water tracer snowmelt rate (kg/m2/s).
>     ! On output, this is the total melt rate for the tile
>     ! (i.e. sum of  melt on canopy and ground).
>   snow_grnd_wtrac(land_pts,nsurft,n_wtrac_jls),                                &
>     ! Water tracer snow content beneath canopy (kg/m2).
>   snow_surft_wtrac(land_pts,nsurft,n_wtrac_jls),                               &
>     ! Water tracer snow mass content(kg/m2).
>   sice_wtrac(land_pts,nsurft,nsmax,n_wtrac_jls),                               &
>     ! Water tracer ice content of snow layers (kg/m2).
>   sliq_wtrac(land_pts,nsurft,nsmax,n_wtrac_jls)
>     ! Water tracer liquid content of snow layers (kg/m2).
> 
217c263
<   dhf_surf_minus_soil(land_pts)
---
>   dhf_surf_minus_soil(land_pts),                                               &
218a265,268
>   snow_melt_wtrac(land_pts,n_wtrac_jls),                                       &
>     ! GBM water tracer snowmelt (kg/m2/s).
>   lake_snow_melt_wtrac(land_pts,n_wtrac_jls)
>     ! Water tracer snowmelt on the lake tile when using FLake (kg/m2/s).
227a278
> LOGICAL, INTENT(IN) :: l_lice_surft(ntype)
245c296
<   n_can
---
>   n_can,                                                                       &
246a298,302
>   i_wt,                                                                        &
>     ! Water tracer loop counter
>   n_wt
>     ! Actual or dummy pointer to array defined only when running with water
>     ! tracers
313a370,374
> REAL(KIND=real_jlslsm) :: snow_ratio    ! Ratio of water tracer to water
> 
> TYPE(wtrac_sn_type) :: wtrac_sn         ! Water tracer working arrays
> 
> 
322a384,386
> ! Allocate water tracer arrays and initialise GBM fields
> CALL wtrac_alloc_snow(land_pts, nsurft, nsmax, n_wtrac_jls, wtrac_sn)
> 
385c449
< !$OMP PRIVATE(i)                                                               &
---
> !$OMP PRIVATE(i,i_wt)                                                          &
389,390c453,454
< !$OMP        infil_ground_ls_gbm)
< 
---
> !$OMP        infil_ground_ls_gbm,l_wtrac_jls,ls_graup_wtrac,ls_snow_wtrac,     &
> !$OMP        lake_snow_melt_wtrac,snow_melt_wtrac,n_wtrac_jls)
406a471,481
> IF (l_wtrac_jls) THEN
>   DO i_wt = 1, n_wtrac_jls
> !$OMP DO SCHEDULE(STATIC)
>     DO i = 1, land_pts
>       snow_melt_wtrac(i,i_wt)      = 0.0
>       lake_snow_melt_wtrac(i,i_wt) = 0.0
>     END DO
> !$OMP END DO
>   END DO
> END IF !l_wtrac_jls
> 
414a490,500
>   ! Repeat for water tracers
>   IF (l_wtrac_jls) THEN
>     DO i_wt = 1, n_wtrac_jls
> !$OMP DO SCHEDULE(STATIC)
>       DO i = 1, land_pts
>         ls_graup_wtrac(i,i_wt) = 0.0
>       END DO
> !$OMP END DO
>     END DO
>   END IF
> 
422a509,520
>   ! Repeat for water tracers
>   IF (l_wtrac_jls) THEN
>     DO i_wt = 1, n_wtrac_jls
> !$OMP DO SCHEDULE(STATIC)
>       DO i = 1, land_pts
>         ls_snow_wtrac(i,i_wt)  = MAX(0.0,                                      &
>                               ls_snow_wtrac(i,i_wt) - ls_graup_wtrac(i,i_wt) )
>         ls_graup_wtrac(i,i_wt) = 0.0
>       END DO
> !$OMP END DO
>     END DO
>   END IF
426a525,545
> ! Calculate surface melt for water tracers
> IF (l_wtrac_jls) THEN
> !$OMP PARALLEL DEFAULT(NONE)                                                   &
> !$OMP PRIVATE(k,i,n,i_wt,snow_ratio)                                           &
> !$OMP SHARED(surft_pts,surft_index,snow_surft_wtrac,snow_surft,melt_surft,     &
> !$OMP        melt_surft_wtrac,n_wtrac_jls,nsurft)
>   DO i_wt = 1, n_wtrac_jls
>     DO n = 1,nsurft
> !$OMP DO SCHEDULE(STATIC)
>       DO k = 1,surft_pts(n)
>         i = surft_index(k,n)
>         snow_ratio = wtrac_calc_ratio_fn_jules(i_wt,                           &
>                            snow_surft_wtrac(i,n,i_wt),snow_surft(i,n))
>         melt_surft_wtrac(i,n,i_wt) = melt_surft(i,n) * snow_ratio
>       END DO
> !$OMP END DO
>     END DO
>   END DO
> !$OMP END PARALLEL
> END IF ! l_wtrac_jls
> 
438,441c557,558
< !$OMP PARALLEL DO                                                              &
< !$OMP SCHEDULE(STATIC)                                                         &
< !$OMP DEFAULT(NONE)                                                            &
< !$OMP PRIVATE(k,i)                                                             &
---
> !$OMP PARALLEL DEFAULT(NONE)                                                   &
> !$OMP PRIVATE(k,i,i_wt)                                                        &
443c560,562
< !$OMP        ei_surft,melt_surft,timestep,n)
---
> !$OMP        timestep,snowinc_surft,n,l_wtrac_jls,wtrac_sn,snow_surft_wtrac,   &
> !$OMP        snow_grnd_wtrac,ei_surft_wtrac,n_wtrac_jls,melt_surft_wtrac)
> !$OMP DO SCHEDULE(STATIC)
452,453c571
<       snow_can(i,n) = snow_can(i,n) -                                          &
<                      ( ei_surft(i,n) + melt_surft(i,n) ) * timestep
---
>       snow_can(i,n) = snow_can(i,n) + snowinc_surft(i,n)
456c574,596
< !$OMP END PARALLEL DO
---
> !$OMP END DO NOWAIT
> 
>     IF (l_wtrac_jls) THEN
>       ! Repeat for water tracers
>       DO i_wt = 1, n_wtrac_jls
> !$OMP DO SCHEDULE(STATIC)
>         DO k = 1,surft_pts(n)
>           i = surft_index(k,n)
>           wtrac_sn%snow_can(i,n,i_wt) = snow_surft_wtrac(i,n,i_wt)
>           wtrac_sn%snowmass(i,i_wt)   = snow_grnd_wtrac(i,n,i_wt)
> 
>           !---------------------------------------------------------------------
>           ! Subtract sublimation and melt of canopy snow.
>           !---------------------------------------------------------------------
>           wtrac_sn%snow_can(i,n,i_wt) = wtrac_sn%snow_can(i,n,i_wt) -          &
>                ( ei_surft_wtrac(i,n,i_wt) + melt_surft_wtrac(i,n,i_wt) )       &
>                 * timestep
> 
>         END DO
> !$OMP END DO
>       END DO
>     END IF  ! l_wtrac_jls
> !$OMP END PARALLEL
463,467c603,607
< !$OMP PARALLEL DO                                                              &
< !$OMP SCHEDULE(STATIC)                                                         &
< !$OMP DEFAULT(NONE)                                                            &
< !$OMP PRIVATE(k,i)                                                             &
< !$OMP SHARED(surft_pts,surft_index,snowmass,snow_surft,n)
---
> !$OMP PARALLEL DEFAULT(NONE)                                                   &
> !$OMP PRIVATE(k,i,i_wt)                                                        &
> !$OMP SHARED(surft_pts,surft_index,snowmass,snow_surft,n,l_wtrac_jls,wtrac_sn, &
> !$OMP        snow_surft_wtrac,n_wtrac_jls)
> !$OMP DO SCHEDULE(STATIC)
472c612,626
< !$OMP END PARALLEL DO
---
> !$OMP END DO NOWAIT
> 
>     IF (l_wtrac_jls) THEN
>       ! Repeat for water tracers
>       DO i_wt = 1, n_wtrac_jls
> !$OMP DO SCHEDULE(STATIC)
>         DO k = 1,surft_pts(n)
>           i = surft_index(k,n)
>           wtrac_sn%snowmass(i,i_wt) = snow_surft_wtrac(i,n,i_wt)
>         END DO
> !$OMP END DO
>       END DO
>     END IF ! l_wtrac_jls
> !$OMP END PARALLEL
> 
477c631
< !$OMP PRIVATE(ns,i)                                                            &
---
> !$OMP PRIVATE(ns,i,i_wt)                                                       &
479c633,634
< !$OMP        l_snow_albedo,l_embedded_snow,rgrainl,rgrainl_sl,n)
---
> !$OMP        l_snow_albedo,l_embedded_snow,rgrainl,rgrainl_sl,n,               &
> !$OMP        l_wtrac_jls,n_wtrac_jls,wtrac_sn,sice_wtrac,sliq_wtrac)
489a645,659
>   IF (l_wtrac_jls) THEN
>     ! Repeat for water tracers
>     DO i_wt = 1, n_wtrac_jls
>       DO ns = 1, nsmax
> !$OMP DO SCHEDULE(STATIC)
>         DO i = 1, land_pts
>           wtrac_sn%sice_sl(i,ns,i_wt) = sice_wtrac(i,n,ns,i_wt)
>           wtrac_sn%sliq_sl(i,ns,i_wt) = sliq_wtrac(i,n,ns,i_wt)
>         END DO
> !$OMP END DO NOWAIT
>       END DO
>     END DO
> 
>   END IF
> 
514c684,692
<   CALL canopysnow ( land_pts, surft_pts(n), timestep, cansnowtile(n),          &
---
>   ! Set tile pointer for water tracers
>   IF (l_wtrac_jls) THEN
>     n_wt = n
>   ELSE
>     n_wt = 1    ! Dummy pointer
>   END IF
> 
>   CALL canopysnow ( land_pts, surft_pts(n), n_wtrac_jls,                       &
>                     timestep, cansnowtile(n),                                  &
517c695,700
<                     melt_surft(:,n), snow_can(:,n), snowfall, graupfall )
---
>                     melt_surft(:,n), con_snow_wtrac,                           &
>                     ls_snow_wtrac, ls_graup_wtrac,                             &
>                     snow_can(:,n), wtrac_sn%snow_can(:,n_wt,:),                &
>                     snowfall, graupfall, wtrac_sn%snowfall,                    &
>                     wtrac_sn%graupfall)
> 
539,542c722,723
< !$OMP PARALLEL DO                                                              &
< !$OMP SCHEDULE(STATIC)                                                         &
< !$OMP DEFAULT(NONE)                                                            &
< !$OMP PRIVATE(k,i)                                                             &
---
> !$OMP PARALLEL DEFAULT(NONE)                                                   &
> !$OMP PRIVATE(k,i,i_wt)                                                        &
545c726,728
< !$OMP        infil_ground_con_gbm,infil_ground_ls_gbm)
---
> !$OMP        infil_ground_con_gbm,infil_ground_ls_gbm,                         &
> !$OMP        l_wtrac_jls,ls_rain_wtrac,con_rain_wtrac,wtrac_sn,n_wtrac_jls)
> !$OMP DO SCHEDULE(STATIC)
564c747,781
< !$OMP END PARALLEL DO
---
> !$OMP END DO NOWAIT
> 
>     IF (l_wtrac_jls) THEN
>       ! Repeat for water tracers
>       DO i_wt = 1, n_wtrac_jls
> !$OMP DO SCHEDULE(STATIC)
>         DO k = 1,surft_pts(n)
>           i = surft_index(k,n)
> 
>           ! Where there is snow on the ground direct rainfall into
>           !infiltration.
>           IF (nsnow(i,n) > 0) THEN
>             wtrac_sn%infiltration(i,i_wt)  = ( ls_rain_wtrac(i,i_wt) +         &
>                                    con_rain_wtrac(i,i_wt) ) * timestep
>             wtrac_sn%infil_rate_con_gbm(i,i_wt) =                              &
>                                    wtrac_sn%infil_rate_con_gbm(i,i_wt) +       &
>                                    tile_frac(i,n) * con_rain_wtrac(i,i_wt)
>             wtrac_sn%infil_rate_ls_gbm(i,i_wt)  =                              &
>                                    wtrac_sn%infil_rate_ls_gbm(i,i_wt) +        &
>                                    tile_frac(i,n) * ls_rain_wtrac(i,i_wt)
>           ELSE
>             wtrac_sn%infiltration(i,i_wt)         = 0.0
>             wtrac_sn%infil_ground_con_gbm(i,i_wt) =                            &
>                                    wtrac_sn%infil_ground_con_gbm(i,i_wt) +     &
>                                    tile_frac(i,n) * con_rain_wtrac(i,i_wt)
>             wtrac_sn%infil_ground_ls_gbm(i,i_wt)  =                            &
>                                    wtrac_sn%infil_ground_ls_gbm(i,i_wt) +      &
>                                    tile_frac(i,n) * ls_rain_wtrac(i,i_wt)
>           END IF
>         END DO
> !$OMP END DO NOWAIT
>       END DO
>     END IF  ! l_wtrac_jls
> !$OMP END PARALLEL
> 
566,570c783,787
< !$OMP PARALLEL DO                                                              &
< !$OMP SCHEDULE(STATIC)                                                         &
< !$OMP DEFAULT(NONE)                                                            &
< !$OMP PRIVATE(k,i)                                                             &
< !$OMP SHARED(surft_pts,surft_index,infiltration,n)
---
> !$OMP PARALLEL DEFAULT(NONE)                                                   &
> !$OMP PRIVATE(k,i,i_wt)                                                        &
> !$OMP SHARED(surft_pts,surft_index,infiltration,n,l_wtrac_jls,wtrac_sn,        &
> !$OMP        n_wtrac_jls)
> !$OMP DO SCHEDULE(STATIC)
575c792,805
< !$OMP END PARALLEL DO
---
> !$OMP END DO NOWAIT
> 
>     IF (l_wtrac_jls) THEN
>       ! Repeat for water tracers
>       DO i_wt = 1, n_wtrac_jls
> !$OMP DO SCHEDULE(STATIC)
>         DO k = 1,surft_pts(n)
>           i = surft_index(k,n)
>           wtrac_sn%infiltration(i,i_wt) = 0.0
>         END DO
> !$OMP END DO NOWAIT
>       END DO
>     END IF ! l_wtrac_jls
> !$OMP END PARALLEL
611,613c841,843
<     CALL snowpack ( n, land_pts, surft_pts(n), timestep, cansnowtile(n),       &
<                   nsnow(:,n), surft_index(:,n), nsurft, csnow, ei_surft(:,n),  &
<                   hcaps1_soilt(:,m), hcon_lake, infiltration,                  &
---
>     CALL snowpack ( n, land_pts, surft_pts(n), n_wtrac_jls, timestep,          &
>                   cansnowtile(n), nsnow(:,n), surft_index(:,n), nsurft, csnow, &
>                   ei_surft(:,n), hcaps1_soilt(:,m), hcon_lake, infiltration,   &
616,618c846,849
<                   tile_frac, smvcst1_soilt(:,m), ds_sl,                        &
<                   melt_surft(:,n), sice_sl, sliq_sl, snomlt_sub_htf,           &
<                   snowdepth(:,n), snowmass, tsnow_sl,                          &
---
>                   tile_frac, smvcst1_soilt(:,m), ei_surft_wtrac,               &
>                   wtrac_sn%infiltration, ds_sl,                                &
>                   melt_surft(:,n), snowinc_surft(:,n), sice_sl, sliq_sl,       &
>                   snomlt_sub_htf, snowdepth(:,n), snowmass, tsnow_sl,          &
619a851,852
>                   melt_surft_wtrac, wtrac_sn%sice_sl, wtrac_sn%sliq_sl,        &
>                   wtrac_sn%snowfall, wtrac_sn%snowmass,                        &
621c854
<                   sf_diag, non_lake_frac,                                      &
---
>                   wtrac_sn%sice0, sf_diag, non_lake_frac,                      &
623c856
<                   l_lice_point,                                                &
---
>                   l_lice_point, l_lice_surft,                                  &
627,629c860,862
<     CALL snowpack ( n, land_pts, surft_pts(n), timestep, cansnowtile(n),       &
<                   nsnow(:,n), surft_index(:,n), nsurft, csnow, ei_surft(:,n),  &
<                   hcaps1_soilt(:,m), hcons, infiltration,                      &
---
>     CALL snowpack ( n, land_pts, surft_pts(n), n_wtrac_jls, timestep,          &
>                   cansnowtile(n), nsnow(:,n), surft_index(:,n), nsurft, csnow, &
>                   ei_surft(:,n), hcaps1_soilt(:,m), hcons, infiltration,       &
632,634c865,868
<                   tile_frac, smvcst1_soilt(:,m), ds_sl,                        &
<                   melt_surft(:,n), sice_sl, sliq_sl, snomlt_sub_htf,           &
<                   snowdepth(:,n), snowmass, tsnow_sl,                          &
---
>                   tile_frac, smvcst1_soilt(:,m), ei_surft_wtrac,               &
>                   wtrac_sn%infiltration, ds_sl,                                &
>                   melt_surft(:,n), snowinc_surft(:,n), sice_sl, sliq_sl,       &
>                   snomlt_sub_htf, snowdepth(:,n), snowmass, tsnow_sl,          &
635a870,871
>                   melt_surft_wtrac, wtrac_sn%sice_sl, wtrac_sn%sliq_sl,        &
>                   wtrac_sn%snowfall, wtrac_sn%snowmass,                        &
637c873
<                   sf_diag, non_lake_frac,                                      &
---
>                   wtrac_sn%sice0, sf_diag, non_lake_frac,                      &
639c875
<                   l_lice_point,                                                &
---
>                   l_lice_point, l_lice_surft,                                  &
673c909
<     CALL relayersnow ( land_pts, surft_pts(n), surft_index(:,n),               &
---
>     CALL relayersnow ( land_pts, surft_pts(n), n_wtrac_jls, surft_index(:,n),  &
675c911
<                        snowmass, tsnow0, nsnow(:,n), ds_sl,                    &
---
>                        snowmass, tsnow0, wtrac_sn%sice0, nsnow(:,n), ds_sl,    &
678,679c914,916
<                        tsnow_sl, rho_snow_sl,                                  &
<                        snowdepth(:,n) )
---
>                        tsnow_sl, wtrac_sn%sice_sl, wtrac_sn%sliq_sl,           &
>                        rho_snow_sl, snowdepth(:,n) )
> 
688c925
< !$OMP PRIVATE(k,i,ns)                                                          &
---
> !$OMP PRIVATE(k,i,ns,i_wt)                                                     &
694c931,933
< !$OMP        l_flake_model, lake)
---
> !$OMP        l_flake_model,lake,l_wtrac_jls,snow_grnd_wtrac,snow_surft_wtrac,  &
> !$OMP        sice_wtrac,sliq_wtrac,lake_snow_melt_wtrac,snow_melt_wtrac,       &
> !$OMP        wtrac_sn,melt_surft_wtrac,n_wtrac_jls)
703a943,954
>     IF (l_wtrac_jls) THEN
>       ! Repeat for water tracers
>       DO i_wt = 1, n_wtrac_jls
> !$OMP DO SCHEDULE(STATIC)
>         DO k = 1,surft_pts(n)
>           i = surft_index(k,n)
>           snow_grnd_wtrac(i,n,i_wt)  = wtrac_sn%snowmass(i,i_wt)
>           snow_surft_wtrac(i,n,i_wt) = wtrac_sn%snow_can(i,n,i_wt)
>         END DO
> !$OMP END DO
>       END DO
>     END IF ! l_wtrac_jls
710a962,972
>     IF (l_wtrac_jls) THEN
>       ! Repeat for water tracers
>       DO i_wt = 1, n_wtrac_jls
> !$OMP DO SCHEDULE(STATIC)
>         DO k = 1,surft_pts(n)
>           i = surft_index(k,n)
>           snow_surft_wtrac(i,n,i_wt) = wtrac_sn%snowmass(i,i_wt)
>         END DO
> !$OMP END DO
>       END DO
>     END IF ! l_wtrac_jls
725a988,1001
>   IF (l_wtrac_jls) THEN
>     ! Repeat for water tracers
>     DO i_wt = 1, n_wtrac_jls
>       DO ns = 1, nsmax
> !$OMP DO SCHEDULE(STATIC)
>         DO i = 1, land_pts
>           sice_wtrac(i,n,ns,i_wt) = wtrac_sn%sice_sl(i,ns,i_wt)
>           sliq_wtrac(i,n,ns,i_wt) = wtrac_sn%sliq_sl(i,ns,i_wt)
>         END DO
> !$OMP END DO NOWAIT
>       END DO
>     END DO
>   END IF ! l_wtrac_jls
> 
758a1035,1056
> 
>   IF (l_wtrac_jls) THEN
>     ! Repeat for water tracers
>     ! (lying_snow equivalent isn't calculated here as diagnostic only)
>     DO i_wt = 1, n_wtrac_jls
> !$OMP DO SCHEDULE(STATIC)
>       DO k = 1,surft_pts(n)
>         i = surft_index(k,n)
>         IF ((l_flake_model) .AND. (n == lake)) THEN
>           ! Exclude snowmelt on the lake from gridbox snowmelt so that it
>           ! doesn't affect soil calculations.
>           lake_snow_melt_wtrac(i,i_wt) =                                       &
>                             tile_frac(i,n) * melt_surft_wtrac(i,n,i_wt)
>         ELSE
>           ! Snow melt.
>           snow_melt_wtrac(i,i_wt) = snow_melt_wtrac(i,i_wt)                    &
>                             + tile_frac(i,n) * melt_surft_wtrac(i,n,i_wt)
>         END IF
>       END DO
> !$OMP END DO
>     END DO
>   END IF ! l_wtrac_jls
763a1062,1066
> !$OMP PARALLEL DEFAULT(NONE)                                                   &
> !$OMP PRIVATE(i,i_wt)                                                          &
> !$OMP SHARED(land_pts,non_lake_frac,snow_melt,l_wtrac_jls,snow_melt_wtrac,     &
> !$OMP        n_wtrac_jls)
> !$OMP DO SCHEDULE(STATIC)
768a1072,1086
> !$OMP END DO
> 
>   IF (l_wtrac_jls) THEN
>     ! Repeat for water tracers
>     DO i_wt = 1, n_wtrac_jls
> !$OMP DO SCHEDULE(STATIC)
>       DO i = 1,land_pts
>         IF (non_lake_frac(i) > EPSILON(0.0)) THEN
>           snow_melt_wtrac(i,i_wt) = snow_melt_wtrac(i,i_wt) / non_lake_frac(i)
>         END IF
>       END DO
> !$OMP END DO
>     END DO
>   END IF ! l_wtrac_jls
> !$OMP END PARALLEL
900,901c1218
< !$OMP PARALLEL DO                                                              &
< !$OMP SCHEDULE(STATIC)                                                         &
---
> !$OMP PARALLEL                                                                 &
903,904c1220,1224
< !$OMP PRIVATE(i)                                                               &
< !$OMP SHARED(land_pts,con_rain,infil_ground_con_gbm,ls_rain,infil_ground_ls_gbm)
---
> !$OMP PRIVATE(i,i_wt)                                                          &
> !$OMP SHARED(land_pts,con_rain,infil_ground_con_gbm,ls_rain,                   &
> !$OMP infil_ground_ls_gbm,l_wtrac_jls,n_wtrac_jls,con_rain_wtrac,              &
> !$OMP ls_rain_wtrac,wtrac_sn)
> !$OMP DO SCHEDULE(STATIC)
909c1229,1242
< !$OMP END PARALLEL DO
---
> !$OMP END DO
> 
>   IF (l_wtrac_jls) THEN
>     DO i_wt = 1, n_wtrac_jls
> !$OMP DO SCHEDULE(STATIC)
>       DO i = 1,land_pts
>         con_rain_wtrac(i,i_wt) = wtrac_sn%infil_ground_con_gbm(i,i_wt)
>         ls_rain_wtrac(i,i_wt)  = wtrac_sn%infil_ground_ls_gbm(i,i_wt)
>       END DO
> !$OMP END DO
>     END DO
>   END IF
> 
> !$OMP END PARALLEL
911a1245,1247
> ! Deallocate water tracer working arrays
> CALL wtrac_dealloc_snow(wtrac_sn)
> 
912a1249
> 
diff -r vn7.0copy1_c4/src/./science/snow/snowpack_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/snow/snowpack_mod.F90
24,26c24,26
< SUBROUTINE snowpack ( surft_n, land_pts, surft_pts, timestep, cansnowtile,     &
<                       nsnow, surft_index, nsurft, csnow, ei_surft,             &
<                       hcaps1_soilt, hcons, infiltration, ksnow,                &
---
> SUBROUTINE snowpack ( surft_n, land_pts, surft_pts, n_wtrac_jls, timestep,     &
>                       cansnowtile, nsnow, surft_index, nsurft, csnow,          &
>                       ei_surft, hcaps1_soilt, hcons, infiltration, ksnow,      &
28,30c28,34
<                       surf_htf_surft, tile_frac, smvcst1_soilt, ds,            &
<                       melt_surft, sice, sliq, snomlt_sub_htf, snowdepth,       &
<                       snowmass, tsnow, t_soil1_soilt, tsurf_elev_surft,        &
---
>                       surf_htf_surft, tile_frac, smvcst1_soilt,                &
>                       ei_surft_wtrac, infiltration_wtrac, ds,                  &
>                       melt_surft, snowinc_surft, sice, sliq, snomlt_sub_htf,   &
>                       snowdepth, snowmass, tsnow,                              &
>                       t_soil1_soilt, tsurf_elev_surft,                         &
>                       melt_surft_wtrac, sice_wtrac, sliq_wtrac,                &
>                       snowfall_wtrac, snowmass_wtrac,                          &
32c36
<                       sf_diag, non_lake_frac,                                  &
---
>                       sice0_wtrac, sf_diag, non_lake_frac,                     &
34c38
<                       l_lice_point,                                            &
---
>                       l_lice_point, l_lice_surft,                              &
55,56d58
< USE ancil_info, ONLY: l_lice_surft
< 
61c63
< USE jules_surface_types_mod, ONLY: lake
---
> USE jules_surface_types_mod, ONLY: lake, ntype
86a89,90
> USE jules_water_tracers_mod, ONLY: l_wtrac_jls, wtrac_calc_ratio_fn_jules
> 
106c110,113
<   surft_pts      ! Number of tile points.
---
>   surft_pts,                                                                   &
>                  ! Number of tile points.
>   n_wtrac_jls
>                  ! Number of water tracers.
127a135,136
>   snowinc_surft(land_pts),                                                     &
>     ! Total snow increment over the time step (kg m-2 TS-1)
157c166
<   lake_depth_gb(land_pts)
---
>   lake_depth_gb(land_pts),                                                     &
158a168,172
>   ei_surft_wtrac(land_pts,nsurft,n_wtrac_jls),                                 &
>     ! Water tracer sublimation of snow for all tiles (kg/m2/s).
>     ! (Note, unlike the water equivalent, this is the full field for all tiles.)
>   infiltration_wtrac(land_pts,n_wtrac_jls)
>     ! Water tracer content in rainfall infiltrating into snowpack (kg/m2).
184c198
<   tsurf_elev_surft(land_pts)
---
>   tsurf_elev_surft(land_pts),                                                  &
185a200,210
>   melt_surft_wtrac(land_pts,nsurft,n_wtrac_jls),                               &
>     ! Water tracer surface snowmelt rate for all tiles (kg/m2/s).
>     ! (Note, unlike the water equivalent, this is the full field for all tiles)
>   sice_wtrac(land_pts,nsmax,n_wtrac_jls),                                      &
>     ! Water tracer ice content of snow layers (kg/m2).
>   sliq_wtrac(land_pts,nsmax,n_wtrac_jls),                                      &
>     ! Water tracer liquid content of snow layers (kg/m2).
>   snowfall_wtrac(land_pts,n_wtrac_jls),                                        &
>     ! Water tracer content of frozen precip reaching the ground (kg/m2).
>   snowmass_wtrac(land_pts,n_wtrac_jls)
>     ! Water tracer content in snow mass on the ground (kg/m2).
202c227
<   rho_snow(land_pts,nsmax)
---
>   rho_snow(land_pts,nsmax),                                                    &
203a229,231
>   sice0_wtrac(land_pts,n_wtrac_jls)
>     ! Water tracer ice content of fresh snow (kg/m2).
>     ! Where nsnow=0, sice0 is the mass of the snowpack.
206a235
> LOGICAL, INTENT(IN) :: l_lice_surft(ntype)
228c257
<   n
---
>   n,                                                                           &
229a259,260
>   i_wt
>     ! Water tracer index.
258c289
<   dzsoilw
---
>   dzsoilw,                                                                     &
259a291,296
>   ratio_snowmass,                                                              &
>   ratio_sice,                                                                  &
>   ratio_sliq,                                                                  &
>     ! Water tracer to water ratios
>   submelt_wtrac
>     ! Amount of water tracer snow that is melted or liquid that is frozen
275c312
<   r(nsmax)
---
>   r(nsmax),                                                                    &
276a314,319
>   dsice_wtrac(n_wtrac_jls),                                                    &
>     ! Melt of water tracer snow beneath canopy (kg/m2/s)
>   can_melt_wtrac(n_wtrac_jls),                                                 &
>     ! Melt of water tracer snow on the canopy (kg/m2/s).
>   win_wtrac(n_wtrac_jls)
>     ! Water tracer entering layer (kg/m2).
294c337
< !$OMP PRIVATE(i,k,n,asoil,can_melt,coldsnow,dsice,g_snow_surf,rho_temp,        &
---
> !$OMP PRIVATE(i,k,n,i_wt,asoil,can_melt,coldsnow,dsice,g_snow_surf,rho_temp,   &
296c339,340
< !$OMP         r, tile_frac_lake_adj)
---
> !$OMP         r, tile_frac_lake_adj,ratio_snowmass,ratio_sice,ratio_sliq,      &
> !$OMP         submelt_wtrac,win_wtrac,dsice_wtrac,can_melt_wtrac)
345a390,395
>         IF (l_wtrac_jls) THEN
>           ! Repeat for water tracers
>           DO i_wt = 1, n_wtrac_jls
>             snowfall_wtrac(i,i_wt) = 0.0
>           END DO
>         END IF
351a402,408
>     IF (l_wtrac_jls) THEN
>       ! Repeat for water tracers
>       DO i_wt = 1,n_wtrac_jls
>         snowmass_wtrac(i,i_wt) = snowmass_wtrac(i,i_wt)+snowfall_wtrac(i,i_wt)
>       END DO
>     END IF
> 
356,357c413,424
<       snowmass(i) = snowmass(i) -                                              &
<                     ( ei_surft(i) + melt_surft(i) ) * timestep
---
>       snowmass(i) = snowmass(i) + snowinc_surft(i)
> 
>       IF (l_wtrac_jls) THEN
>         ! Repeat for water tracers
>         DO i_wt = 1,n_wtrac_jls
>           snowmass_wtrac(i,i_wt) = snowmass_wtrac(i,i_wt) -                    &
>                                   ( ei_surft_wtrac(i,surft_n,i_wt)             &
>                                     + melt_surft_wtrac(i,surft_n,i_wt) )       &
>                                   * timestep
>         END DO
>       END IF
> 
358a426
> 
427a496,511
>         ! Update water tracers first, so ratio calculation can use snowmass
>         ! before is it updated
>         IF (l_wtrac_jls) THEN
>           DO i_wt = 1,n_wtrac_jls
>             ratio_snowmass           = wtrac_calc_ratio_fn_jules(i_wt,         &
>                                         snowmass_wtrac(i,i_wt), snowmass(i))
>             submelt_wtrac            = MIN(ratio_snowmass * submelt,           &
>                                            snowmass_wtrac(i,i_wt) / timestep)
>             snowmass_wtrac(i,i_wt)   = snowmass_wtrac(i,i_wt)                  &
>                                       - submelt_wtrac * timestep
>             melt_surft_wtrac(i,surft_n,i_wt) =                                 &
>                                        melt_surft_wtrac(i,surft_n,i_wt)        &
>                                       + submelt_wtrac
>           END DO
>         END IF      ! l_wtrac_jls
> 
451a536,540
>       IF (l_wtrac_jls) THEN
>         DO i_wt = 1,n_wtrac_jls
>           sice0_wtrac(i,i_wt)  = snowmass_wtrac(i,i_wt)
>         END DO
>       END IF   ! l_wtrac_jls
471a561,566
>       IF (l_wtrac_jls) THEN
>         ! Repeat for water tracersw
>         DO i_wt = 1,n_wtrac_jls
>           can_melt_wtrac(i_wt) = melt_surft_wtrac(i,surft_n,i_wt)
>         END DO
>       END IF    ! l_wtrac_jls
473a569,574
>       IF (l_wtrac_jls) THEN
>         ! Repeat for water tracers
>         DO i_wt = 1,n_wtrac_jls
>           can_melt_wtrac(i_wt) = 0.0
>         END DO
>       END IF    ! l_wtrac_jls
536a638,650
> 
>         ! Update water tracers first, so ratio calculation can use sice before
>         ! it is updated
>         IF (l_wtrac_jls) THEN
>           DO i_wt = 1,n_wtrac_jls
>             ratio_sice = wtrac_calc_ratio_fn_jules(i_wt, sice_wtrac(i,n,i_wt), &
>                                                    sice(i,n))
>             dsice_wtrac(i_wt)    = MIN(dsice * ratio_sice, sice_wtrac(i,n,i_wt))
>             sice_wtrac(i,n,i_wt) = sice_wtrac(i,n,i_wt) - dsice_wtrac(i_wt)
>             sliq_wtrac(i,n,i_wt) = sliq_wtrac(i,n,i_wt) + dsice_wtrac(i_wt)
>           END DO
>         END IF  ! l_wtrac_jls
> 
550a665
> 
551a667,673
>       IF (l_wtrac_jls) THEN
>         DO i_wt = 1,n_wtrac_jls
>           dsice_wtrac(i_wt) = MAX( ei_surft_wtrac(i,surft_n,i_wt), 0.0 )       &
>                                 * timestep
>         END DO
>       END IF   ! l_wtrac_jls
> 
558a681,687
>             IF (l_wtrac_jls) THEN
>               ! Need to remove all water tracer in layer
>               DO i_wt = 1, n_wtrac_jls
>                 dsice_wtrac(i_wt)    = dsice_wtrac(i_wt) - sice_wtrac(i,n,i_wt)
>                 sice_wtrac(i,n,i_wt) = 0.0
>               END DO
>             END IF
562a692,698
>             IF (l_wtrac_jls) THEN
>               ! Remove all water tracer leftover sublimation here
>               DO i_wt = 1, n_wtrac_jls
>                 sice_wtrac(i,n,i_wt) = sice_wtrac(i,n,i_wt) - dsice_wtrac(i_wt)
>               END DO
>             END IF
> 
564a701
> 
575a713,720
>       IF (l_wtrac_jls) THEN
>         ! Repeat for water tracers
>         DO i_wt = 1,n_wtrac_jls
>           win_wtrac(i_wt) = infiltration_wtrac(i,i_wt) + can_melt_wtrac(i_wt)  &
>                             * timestep
>         END DO
>       END IF   ! l_wtrac_jls
> 
578c723,731
<     END IF
---
>       IF (l_wtrac_jls) THEN
>         ! Repeat for water tracers
>         DO i_wt = 1,n_wtrac_jls
>           win_wtrac(i_wt) = 0.0
>         END DO
>       END IF   ! l_wtrac_jls
> 
>     END IF ! l_snow_infilt
> 
579a733
> 
583a738,745
>       IF (l_wtrac_jls) THEN
>         ! Repeat for water tracers
>         DO i_wt = 1,n_wtrac_jls
>           sliq_wtrac(i,n,i_wt) = sliq_wtrac(i,n,i_wt) + win_wtrac(i_wt)
>           win_wtrac(i_wt) = 0.0
>         END DO
>       END IF   ! l_wtrac_jls
> 
604a767,779
> 
>         ! Update water tracers first so that sliq can be used in ratio
>         ! calculation before it is updated
>         IF (l_wtrac_jls) THEN
>           DO i_wt = 1, n_wtrac_jls
>             ratio_sliq           = wtrac_calc_ratio_fn_jules(i_wt,             &
>                                      sliq_wtrac(i,n,i_wt), sliq(i,n))
> 
>             win_wtrac(i_wt)      = (sliq(i,n)-sliqmax) * ratio_sliq
>             sliq_wtrac(i,n,i_wt) = sliq_wtrac(i,n,i_wt) - win_wtrac(i_wt)
>           END DO
>         END IF
> 
612a788,806
> 
>         ! Update water tracers first so the ratio calculation can use sliq
>         ! before it is updated
>         IF (l_wtrac_jls) THEN
>           DO i_wt = 1,n_wtrac_jls
>             IF (dsice == sliq(i,n)) THEN
>               ! Simply move all water tracer from liquid to ice
>               dsice_wtrac(i_wt) = sliq_wtrac(i,n,i_wt)
>             ELSE
>               ! Partial freezing
>               ratio_sliq = wtrac_calc_ratio_fn_jules(i_wt,                     &
>                                      sliq_wtrac(i,n,i_wt), sliq(i,n))
>               dsice_wtrac(i_wt) = ratio_sliq * dsice
>             END IF
>             sliq_wtrac(i,n,i_wt)  = sliq_wtrac(i,n,i_wt) - dsice_wtrac(i_wt)
>             sice_wtrac(i,n,i_wt)  = sice_wtrac(i,n,i_wt) + dsice_wtrac(i_wt)
>           END DO
>         END IF    ! l_wtrac_jls
> 
630a825,830
>       IF (l_wtrac_jls) THEN
>         ! Repeat for water tracers
>         DO i_wt = 1,n_wtrac_jls
>           melt_surft_wtrac(i,surft_n,i_wt) = ( win_wtrac(i_wt) / timestep )
>         END DO
>       END IF
632a833,839
>       IF (l_wtrac_jls) THEN
>         ! Repeat for water tracers
>         DO i_wt = 1,n_wtrac_jls
>           melt_surft_wtrac(i,surft_n,i_wt) = ( win_wtrac(i_wt) / timestep )    &
>                                              + can_melt_wtrac(i_wt)
>         END DO
>       END IF
647a855,861
>     IF (l_wtrac_jls) THEN
>       DO i_wt = 1,n_wtrac_jls
>         ! Repeat for water tracers
>         sice0_wtrac(i,i_wt) = snowfall_wtrac(i,i_wt)
>       END DO
>     END IF     !l_wtrac_jls
> 
649a864,871
>       IF (l_wtrac_jls) THEN
>         ! Repeat for water tracers
>         DO i_wt = 1,n_wtrac_jls
>           sice0_wtrac(i,i_wt) = snowfall_wtrac(i,i_wt)                         &
>                                - MIN(ei_surft_wtrac(i,surft_n,i_wt), 0.0)      &
>                                  * timestep
>         END DO
>       END IF    !l_wtrac_jls
650a873
> 
662a886,898
> 
>     IF (l_wtrac_jls) THEN
>       ! Repeat for water tracers
>       DO i_wt = 1,n_wtrac_jls
>         snowmass_wtrac(i,i_wt)  = sice0_wtrac(i,i_wt)
>       END DO
>       DO n = 1,nsnow(i)
>         DO i_wt = 1,n_wtrac_jls
>           snowmass_wtrac(i,i_wt) = snowmass_wtrac(i,i_wt)                      &
>                                + sice_wtrac(i,n,i_wt) + sliq_wtrac(i,n,i_wt)
>         END DO
>       END DO
>     END IF  ! l_wtrac_jls
diff -r vn7.0copy1_c4/src/./science/snow/snowtherm_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/snow/snowtherm_mod.F90
131d130
<   print*,'l is ', l
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/snow: wtrac_snow_mod.F90
diff -r vn7.0copy1_c4/src/./science/soil/calc_fsat_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/soil/calc_fsat_mod.F90
75,76c75,76
< REAL(KIND=real_jlslsm), PARAMETER :: ti_sc_const = 2.7
<     ! ti_sc_const Constant required to ensure that there is no underflow
---
> REAL(KIND=real_jlslsm), PARAMETER :: log_ti_sc_const = LOG(2.7)
>     ! log_ti_sc_const Constant required to ensure that there is no underflow
166c166
<         calc      = (alf_ksat-1.0) * (LOG(ti_sc) + LOG(ti_sc_const))           &
---
>         calc      = (alf_ksat-1.0) * (LOG(ti_sc) + log_ti_sc_const)            &
199c199
<             calc = (alf_ksat-1.0) * (LOG(ti_sc) + LOG(ti_sc_const))            &
---
>             calc = (alf_ksat-1.0) * (LOG(ti_sc) + log_ti_sc_const)             &
209c209
<           calc = (alf_ksat-1.0) * (LOG(ti_sc) + LOG(ti_sc_const))              &
---
>           calc = (alf_ksat-1.0) * (LOG(ti_sc) + log_ti_sc_const)               &
233c233
<             calc = (alf_ksat-1.0) * (LOG(ti_sc) + LOG(ti_sc_const))            &
---
>             calc = (alf_ksat-1.0) * (LOG(ti_sc) + log_ti_sc_const)             &
241c241
<               calc = (alf_ksat-1.0) * (LOG(ti_sc) + LOG(ti_sc_const))          &
---
>               calc = (alf_ksat-1.0) * (LOG(ti_sc) + log_ti_sc_const)           &
251c251
<             calc = (alf_ksat-1.0) * (LOG(ti_sc) + LOG(ti_sc_const))            &
---
>             calc = (alf_ksat-1.0) * (LOG(ti_sc) + log_ti_sc_const)             &
diff -r vn7.0copy1_c4/src/./science/soil/calc_zw_inund_jls_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/soil/calc_zw_inund_jls_mod.F90
52c52
<   bexp(npnts),                                                                 &
---
>   bexp(npnts,nshyd),                                                           &
54c54
<   sathh(npnts),                                                                &
---
>   sathh(npnts,nshyd),                                                          &
204c204,205
<     ! Interpolate thetaf to zw and use this in psisat.
---
>     ! Interpolate thetaf to zw and use this in psisat
>     ! and include frozen soil into calc of psisat
207a209,211
>       fac1 = MAX(MIN(1.0 - sthfk, 1.0), 0.0)
>       facb = MAX(fac1**bexp(i,1), EPSILON(1.0))
>       psisat = -sathh(i,1) / facb
208a213
> 
212a218,220
>         fac1 = MAX(MIN(1.0 - sthfk, 1.0), 0.0)
>         facb = MAX(fac1**bexp(i,n), EPSILON(1.0))
>         psisat = -sathh(i,n) / facb
214a223
> 
216a226,228
>       fac1 = MAX(MIN(1.0 - sthfk, 1.0), 0.0)
>       facb = MAX(fac1**bexp(i,nshyd), EPSILON(1.0))
>       psisat = -sathh(i,nshyd) / facb
219,228d230
<     !-------------------------------------------------------------------------
<     ! Now include frozen soil into calc of PSI_sat:
<     !-------------------------------------------------------------------------
<     fac1   = (1.0 - sthfk)
<     fac1   = MIN(fac1,1.0)
<     fac1   = MAX(fac1,0.0)
<     facb   = fac1**bexp(i)
<     facb   = MAX(facb,EPSILON(1.0))
<     psisat = -sathh(i) / facb
< 
231,236c233,235
<       fac2       = sthu(i,n)
<       fac2       = MIN(fac2,1.0)
<       fac2       = MAX(fac2,0.0)
<       facb       = fac2**bexp(i)
<       facb       = MAX(facb,EPSILON(1.0))
<       psi(n)     = -sathh(i) / facb
---
>       fac2 = MAX(MIN(sthu(i,n), 1.0), 0.0)
>       facb = MAX(fac2**bexp(i,n), EPSILON(1.0))
>       psi(n) = -sathh(i,n) / facb
diff -r vn7.0copy1_c4/src/./science/soil/calc_zw_jls_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/soil/calc_zw_jls_mod.F90
24a25
> USE jules_soil_mod,       ONLY: dzsoil
53,55c54,56
<   bexp(npnts),                                                                 &
<     ! Brooks & Corey exponent.
<   sathh(npnts),                                                                &
---
>   bexp(npnts,nshyd),                                                           &
>     ! Clapp-Hornberger exponent.
>   sathh(npnts,nshyd),                                                          &
62c63
<     ! Moisture content in deep layer.
---
>     ! Moisture content in deep layer (kg/m2).
64,66c65,67
<     ! Moisture content in deep layer at saturation.
<   v_sat(npnts)
<     ! Volumetric soil moisture.
---
>     ! Moisture content in deep layer at saturation (kg/m2).
>   v_sat(npnts,nshyd)
>     ! Volumetric soil moisture concentration at saturation (m3 H2O/m3 soil).
85c86
<   i, j, n, it
---
>   i, j, n, it, nn, nzw
98c99,101
<   psisat
---
>   zdepth(0:nshyd+1),                                                           &
>     ! Lower soil layer boundary depth (m).
>   psisat(nshyd)
108a112,117
> zdepth(:) = 0.0
> DO n=1,nshyd
>   zdepth(n) = zdepth(n-1) + dzsoil(n)
> END DO
> zdepth(nshyd+1) = zw_max
> 
113c122
< !$OMP PRIVATE(j,i,zw_old,smd,psisat,zwest,it,fn,dfn)                           &
---
> !$OMP PRIVATE(j,i,zw_old,smd,psisat,zwest,it,fn,dfn,n,nn,nzw)                  &
115c124
< !$OMP        v_sat,nshyd,zw_max)
---
> !$OMP        v_sat,nshyd,zw_max,zdepth)
134c143
<   psisat = -sathh(i)
---
>   psisat(:) = -sathh(i,:)
148a158,167
>     nzw = nshyd+1
>     DO nn = nshyd+1,1,-1
>       IF (zwest <= zdepth(nn) .AND. nn < nzw) THEN
>         nzw = nn
>       END IF
>     END DO
> 
>     ! soil properties have values defined in layers 1-nshyd
>     !    nzw = MAX(1,nzw)
>     nzw = MIN(nshyd,nzw)
150,154c169,174
<     fn = zwest * v_sat(i) - smd                                                &
<          - v_sat(i) * bexp(i) / (bexp(i) - 1.0) * psisat                       &
<          * ( 1.0 - ( 1.0 - zwest / psisat )**                                  &
<            ( 1.0 - 1.0 / bexp(i) ) )       !   f(zw)
<     dfn =  v_sat(i) + v_sat(i) * ( 1.0 - zwest / psisat )** (-1.0 / bexp(i))
---
>     fn = zwest * v_sat(i,nzw) - smd                                            &
>          - v_sat(i,nzw) * bexp(i,nzw) / (bexp(i,nzw) - 1.0) * psisat(nzw)      &
>          * ( 1.0 - ( 1.0 - zwest / psisat(nzw) )**                             &
>            ( 1.0 - 1.0 / bexp(i,nzw) ) )       !   f(zw)
>     dfn =  v_sat(i,nzw) + v_sat(i,nzw) * ( 1.0 - zwest / psisat(nzw) )**       &
>            (-1.0 / bexp(i,nzw))
diff -r vn7.0copy1_c4/src/./science/soil/ch4_microbe_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/soil/ch4_microbe_mod.F90
85c85
<     ! Concentration of dissolved substrate that methaogens consume (mgC/m3)
---
>     ! Concentration of dissolved substrate that methanogens consume (mgC/m3)
diff -r vn7.0copy1_c4/src/./science/soil/ch4_tdep_layers_jls_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/soil/ch4_tdep_layers_jls_mod.F90
110c110
<     ! For RothC (dim_cs1=4), the pools are DPM, RPM, biomass and humus
---
>     ! For 4-pool (dim_cs1=4), the pools are DPM, RPM, biomass and humus
250,253c250,255
<         DO n = 1,dim_cslayer
<           ch4_tmp_lys(n) = MIN( ch4_tmp_lys(n), cs(i,n,k) / ( timestep *       &
<                                                               f_wetl(i) ) )
<         END DO
---
>         IF (f_wetl(i) > EPSILON(1.0)) THEN
>           DO n = 1,dim_cslayer
>             ch4_tmp_lys(n) = MIN( ch4_tmp_lys(n), cs(i,n,k) / ( timestep *     &
>                                                             f_wetl(i) ) )
>           END DO
>         END IF
255,257c257,261
<         IF ( SUM(ch4_tmp_lys) > cs(i,1,k) / (timestep * f_wetl(i)) ) THEN
<           ch4_tmp_lys(:) = ch4_tmp_lys(:) * cs(i,1,k) /                        &
<                            ( timestep * SUM(ch4_tmp_lys) * f_wetl(i) )
---
>         IF (f_wetl(i) > EPSILON(1.0)) THEN
>           IF ( SUM(ch4_tmp_lys) > cs(i,1,k) / (timestep * f_wetl(i)) ) THEN
>             ch4_tmp_lys(:) = ch4_tmp_lys(:) * cs(i,1,k) /                      &
>                              ( timestep * SUM(ch4_tmp_lys) * f_wetl(i) )
>           END IF
diff -r vn7.0copy1_c4/src/./science/soil/ch4_wetl_jls_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/soil/ch4_wetl_jls_mod.F90
27c27
<   kaps_roth, ch4_substrate,                                                    &
---
>   kaps_4pool, ch4_substrate,                                                   &
102c102
<     ! Dissolved substrate that methaogens consume (kg C/m2)
---
>     ! Dissolved substrate that methanogens consume (kg C/m2)
111c111
<     ! For RothC (dim_cs1=4), the pools are DPM, RPM, biomass and humus
---
>     ! For 4-pool C model (dim_cs1=4), the pools are DPM, RPM, biomass and humus
128c128
<     ! Sum of kaps_roth values.
---
>     ! Sum of kaps_4pool values.
197c197
<     sumkaps = sumkaps + kaps_roth(k)
---
>     sumkaps = sumkaps + kaps_4pool(k)
201c201
<     kaps_weight(k) = kaps_roth(k) / sumkaps
---
>     kaps_weight(k) = kaps_4pool(k) / sumkaps
diff -r vn7.0copy1_c4/src/./science/soil/elev_htc_jls_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/soil/elev_htc_jls_mod.F90
24c24
<                       snow_soil_htf, tsurf_elev_surft )
---
>                       snow_soil_htf, tsurf_elev_surft, l_lice_surft )
29,31d28
< USE ancil_info, ONLY:                                                          &
<   l_lice_surft
< 
34a32,33
> USE jules_surface_types_mod, ONLY: ntype
> 
67a67
> LOGICAL, INTENT(IN) :: l_lice_surft(ntype)
diff -r vn7.0copy1_c4/src/./science/soil/frunoff_jls_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/soil/frunoff_jls_mod.F90
21,23c21,25
< SUBROUTINE frunoff ( npnts, surft_pts, curr_surft, timestep, surft_index,      &
<                      area, can_cpy, can_wcnt, infil, r, frac,                  &
<                      surf_roff, surf_roff_surft)
---
> SUBROUTINE frunoff ( npnts, surft_pts, curr_surft, nsurft, n_wtrac_jls,        &
>                      timestep, surft_index,                                    &
>                      area, can_cpy, can_wcnt, infil, r, r_wtrac, frac,         &
>                      surf_roff, surf_roff_surft, surf_roff_wtrac,              &
>                      surf_roff_surft_wtrac)
30a33,34
> USE jules_water_tracers_mod, ONLY: l_wtrac_jls
> 
43c47
<   curr_surft
---
>   curr_surft,                                                                  &
44a49,52
>   nsurft,                                                                      &
>     ! Number of surface tiles (used by water tracers)
>   n_wtrac_jls
>     ! Number of water tracers
67a76,77
>   r_wtrac(npnts,n_wtrac_jls),                                                  &
>     ! Water tracer fall rate for all tiles (kg/m2/s).
76,77c86,87
<     ! Cummulative surface runoff (kg/m2/s).
<   surf_roff_surft(npnts)
---
>     ! Cumulative surface runoff (kg/m2/s).
>   surf_roff_surft(npnts),                                                      &
79c89,94
< 
---
>   surf_roff_wtrac(npnts,n_wtrac_jls),                                          &
>     ! Cummulative water tracer surface runoff (kg/m2/s).
>   surf_roff_surft_wtrac(npnts,nsurft,n_wtrac_jls)
>     ! Water tracer surface runoff contributions for all tiles (kg/m2/s).
>     ! (Note, unlike the water equivalent, this is the full field containing
>     !  all tiles)
84c99
<   i, j
---
>   i, j, i_wt
96c111
<   runoff,                                                                      &
---
>   runoff(npnts),                                                               &
97a113,114
>   runoff_wtrac,                                                                &
>     ! Local water tracer runoff.
113c130
< !$OMP PRIVATE(i, runoff, aexp, aexp1, aexp2, can_ratio, cm)                    &
---
> !$OMP PRIVATE(i, j, aexp, aexp1, aexp2, can_ratio, cm)                         &
116c133
< !$OMP        curr_surft, lake )                                                &
---
> !$OMP        curr_surft, lake, runoff )                                        &
121c138
<   runoff = 0.0
---
>   runoff(i) = 0.0
135c152
<       runoff    = r(i) * ( can_ratio * aexp1 + (1.0 - can_ratio) * aexp2 )
---
>       runoff(i) = r(i) * ( can_ratio * aexp1 + (1.0 - can_ratio) * aexp2 )
147c164
<       runoff = r(i) * aexp                    !     ... P252.14B
---
>       runoff(i) = r(i) * aexp                    !     ... P252.14B
152c169
<   surf_roff_surft(i) = surf_roff_surft(i) + runoff
---
>   surf_roff_surft(i) = surf_roff_surft(i) + runoff(i)
155c172
<     surf_roff(i)       = surf_roff(i)       + frac(i) * runoff
---
>     surf_roff(i)       = surf_roff(i)       + frac(i) * runoff(i)
158a176,206
> 
> ! Water tracers
> IF (l_wtrac_jls) THEN
> !$OMP PARALLEL DEFAULT(NONE)                                                   &
> !$OMP PRIVATE(i, j, i_wt, runoff_wtrac)                                        &
> !$OMP SHARED(surft_pts, surft_index, r, r_wtrac, runoff, surf_roff_wtrac,      &
> !$OMP        surf_roff_surft_wtrac, frac, l_flake_model, n_wtrac_jls,          &
> !$OMP        curr_surft, lake)
>   DO i_wt = 1, n_wtrac_jls
> !$OMP DO SCHEDULE(STATIC)
>     DO j = 1,surft_pts
>       i = surft_index(j)
>       runoff_wtrac = 0.0
>       IF ( r(i) > EPSILON(r(i)) ) THEN
>         runoff_wtrac = (r_wtrac(i,i_wt)/r(i)) * runoff(i)
>       END IF
> 
>       surf_roff_surft_wtrac(i,curr_surft,i_wt) =                               &
>                                surf_roff_surft_wtrac(i,curr_surft,i_wt) +      &
>                                       runoff_wtrac
> 
>       IF ( .NOT. ((l_flake_model) .AND. (curr_surft == lake)) ) THEN
>         surf_roff_wtrac(i,i_wt) = surf_roff_wtrac(i,i_wt) + frac(i) *          &
>                                   runoff_wtrac
>       END IF
>     END DO
> !$OMP END DO
>   END DO
> !$OMP END PARALLEL
> 
> END IF    ! l_wtrac_jls
diff -r vn7.0copy1_c4/src/./science/soil/hydrol_jls_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/soil/hydrol_jls_mod.F90
25c25
<      asteps_since_triffid, timestep,                                           &
---
>      asteps_since_triffid, n_wtrac_jls, timestep, l_lice_surft,                &
34a35
>      con_rain_land_wtrac, ls_rain_land_wtrac,                                  &
36,38c37,40
<      ecan_surft, ext_irr_soilt,  ext_soilt,                                    &
<      snowdepth_surft, melt_surft, snow_melt,                                   &
<      snow_soil_htf,                                                            &
---
>      ecan_surft, ext_irr_soilt,  ext_soilt, ecan_surft_wtrac,                  &
>      ext_soilt_wtrac,                                                          &
>      snowdepth_surft, melt_surft, snow_melt, melt_surft_wtrac,                 &
>      snow_melt_wtrac, snow_soil_htf,                                           &
41,42c43,44
<      npp_soilt, inlandout_atm_gb,                                              &
<      canopy_surft, smcl_soilt, sthf_soilt,                                     &
---
>      npp_soilt, inlandout_atm_gb, inlandout_atm_gb_wtrac,                      &
>      canopy_surft, canopy_surft_wtrac, smcl_soilt, sthf_soilt,                 &
45c47,48
<      fsat_soilt, fwetl_soilt, sthzw_soilt, zw_soilt,                           &
---
>      smcl_soilt_wtrac, sthf_soilt_wtrac, sthu_soilt_wtrac,                     &
>      fsat_soilt, fwetl_soilt, sthzw_soilt, zw_soilt, sthzw_soilt_wtrac,        &
54c57,58
<      w_flux_soilt, qbase_soilt, qbase_l_soilt, qbase_zw_soilt,                 &
---
>      w_flux_soilt, surf_roff_gb_wtrac, sub_surf_roff_gb_wtrac, qbase_soilt,    &
>      qbase_l_soilt, qbase_zw_soilt,                                            &
59a64,65
> USE ancil_info,               ONLY: dim_cslayer, nsoilt
> USE calc_baseflow_jules_mod,  ONLY: calc_baseflow_jules
62,64c68,71
< USE surf_hyd_mod,             ONLY: surf_hyd
< USE soilt_mod,                ONLY: soilt
< USE soilmc_mod,               ONLY: soilmc
---
> USE elev_htc_mod,             ONLY: elev_htc
> USE ereport_mod,              ONLY: ereport
> USE ice_htc_mod,              ONLY: ice_htc
> USE n_leach_mod,              ONLY: n_leach
67a75
> USE soil_hyd_wtrac_mod,       ONLY: soil_hyd_wtrac
69,80c77,82
< USE ice_htc_mod,              ONLY: ice_htc
< USE calc_baseflow_jules_mod,  ONLY: calc_baseflow_jules
< USE n_leach_mod,              ONLY: n_leach
< 
< !Use in relevant variables
< USE ancil_info,               ONLY:                                            &
<   nsoilt
< 
< USE jules_hydrology_mod, ONLY:                                                 &
<   l_wetland_unfrozen, ti_max, zw_max
< 
< USE ancil_info, ONLY: dim_cslayer
---
> USE soil_htc_wtrac_mod,       ONLY: soil_htc_wtrac
> USE soilmc_mod,               ONLY: soilmc
> USE soilt_mod,                ONLY: soilt
> USE surf_hyd_mod,             ONLY: surf_hyd
> USE um_types,                 ONLY: real_jlslsm
> USE water_constants_mod,      ONLY: rho_water  ! Density of pure water (kg/m3).
82c84,88
< USE elev_htc_mod, ONLY: elev_htc
---
> USE jules_hydrology_mod,      ONLY: l_wetland_unfrozen, ti_max, zw_max
> USE jules_vegetation_mod,     ONLY: l_nitrogen
> USE jules_irrig_mod,          ONLY: l_irrig_dmd
> USE jules_surface_mod,        ONLY: l_elev_land_ice
> USE jules_surface_types_mod,  ONLY: ntype
86c92
<   soil_model_ecosse, soil_model_rothc, soil_model_1pool,                       &
---
>   soil_model_ecosse, soil_model_4pool, soil_model_1pool,                       &
95,105c101,103
< USE jules_vegetation_mod, ONLY: l_nitrogen
< 
< USE jules_irrig_mod, ONLY: l_irrig_dmd
< 
< USE jules_surface_mod, ONLY: l_elev_land_ice
< 
< USE ereport_mod, ONLY: ereport
< 
< USE water_constants_mod, ONLY:                                                 &
<   rho_water  ! Density of pure water (kg/m3).
< 
---
> USE jules_water_tracers_mod, ONLY: l_wtrac_jls
> USE wtrac_hyd_mod,           ONLY: wtrac_hy_type, wtrac_alloc_hyd,             &
>                                    wtrac_dealloc_hyd
108d105
< USE model_time_mod, ONLY: timestep_len
114,115d110
< USE um_types, ONLY: real_jlslsm
< 
142c137
<   asteps_since_triffid
---
>   asteps_since_triffid,                                                        &
143a139,140
>   n_wtrac_jls
>     ! Number of water tracers
161c158
< 
---
> LOGICAL, INTENT(IN) :: l_lice_surft(ntype)
220c217
<   surf_ht_flux_ld(land_pts)
---
>   surf_ht_flux_ld(land_pts),                                                   &
221a219,222
>   con_rain_land_wtrac(land_pts,n_wtrac_jls),                                   &
>     ! Water tracer convective rain (kg/m2/s).
>   ls_rain_land_wtrac(land_pts,n_wtrac_jls)
>     ! Water tracer large-scale rain (kg/m2/s).
229c230
<   ext_soilt(land_pts,nsoilt,sm_levels)
---
>   ext_soilt(land_pts,nsoilt,sm_levels),                                        &
230a232,235
>   ecan_surft_wtrac(land_pts,nsurft,n_wtrac_jls),                               &
>     ! Water tracer canopy evaporation from land tiles (kg/m2/s).
>   ext_soilt_wtrac(land_pts,nsoilt,sm_levels,n_wtrac_jls)
>     ! Extraction of water tracer from each soil layer (kg/m2/s).
240c245
<   snow_soil_htf(land_pts,nsurft)
---
>   snow_soil_htf(land_pts,nsurft),                                              &
241a247,250
>   melt_surft_wtrac(land_pts,nsurft,n_wtrac_jls),                               &
>     ! Water tracer snowmelt on tiles (kg/m2/s).
>   snow_melt_wtrac(land_pts,n_wtrac_jls)
>     ! Water tracer snowmelt (kg/m2/s).
265c274
<   inlandout_atm_gb(land_pts)
---
>   inlandout_atm_gb(land_pts),                                                  &
266a276,278
>   inlandout_atm_gb_wtrac(land_pts,n_wtrac_jls)
>     ! IN TRIP inland basin water tracer outflow for land points only
>     ! (kg/m2/s=mm)
274c286
<   canopy_surft(land_pts,nsurft)
---
>   canopy_surft(land_pts,nsurft),                                               &
275a288,289
>   canopy_surft_wtrac(land_pts,nsurft,n_wtrac_jls)
>     ! Canopy water tracer content for land tiles (kg/m2).
299c313
<   tsurf_elev_surft(land_pts,nsurft)
---
>   tsurf_elev_surft(land_pts,nsurft),                                           &
300a315,322
>   smcl_soilt_wtrac(land_pts,nsoilt,sm_levels,n_wtrac_jls),                     &
>     ! Soil moisture content of each layer (kg/m2).
>   sthf_soilt_wtrac(land_pts,nsoilt,sm_levels,n_wtrac_jls),                     &
>     ! Frozen soil moisture content of each layer as a fraction of saturation.
>   sthu_soilt_wtrac(land_pts,nsoilt,sm_levels,n_wtrac_jls)
>     ! Unfrozen soil moisture content of each layer as a fraction of
>     ! saturation.
> 
310c332
<   zw_soilt(land_pts,nsoilt)
---
>   zw_soilt(land_pts,nsoilt),                                                   &
311a334,336
>   sthzw_soilt_wtrac(land_pts,nsoilt,n_wtrac_jls)
>      ! Soil moisture fraction in deep LSH/TOPMODEL layer.
> 
317c342
< !                          !   For RothC (dim_cs1=4), the pools
---
> !                          !   For 4-pool (dim_cs1=4), the pools
329c354
<     ! Dissolved substrate that methaogens consume (kg C/m2)
---
>     ! Dissolved substrate that methanogens consume (kg C/m2)
371c396
<   w_flux_soilt(land_pts,nsoilt,0:sm_levels)
---
>   w_flux_soilt(land_pts,nsoilt,0:sm_levels),                                   &
372a398,401
>   sub_surf_roff_gb_wtrac(land_pts,n_wtrac_jls),                                &
>     ! Sub-surface water tracer runoff (kg/m2/s).
>   surf_roff_gb_wtrac(land_pts,n_wtrac_jls)
>     ! Water tracer surface runoff (kg/m2/s).
411a441,445
>   i_wt,                                                                        &
>     ! Counter for water tracers.
>   m_wt,                                                                        &
>     ! Actual or dummy pointer to array defined only when running with water
>     ! tracers
448,449c482,483
<     smcl_old_soilt(land_pts,nsoilt,sm_levels)
<     ! Retain oriignal soil moisture for leaching code
---
>   smcl_old_soilt(land_pts,nsoilt,sm_levels)
>     ! Retain original soil moisture for leaching code
475a510,521
> ! Water tracer local fields
> TYPE(wtrac_hy_type) :: wtrac_hy
> 
> REAL(KIND=real_jlslsm), ALLOCATABLE ::                                         &
>   sthu_soilt_old(:,:,:),                                                       &
>     ! Initial value of unfrozen soil moisture content of each layer as a
>     ! fraction of saturation.
>   sthf_soilt_old(:,:,:)
>     ! Initial value of frozen soil moisture content of each layer as a
>     ! fraction of saturation.
> 
> 
484a531,542
> ! Set up water tracer working arrays
> CALL wtrac_alloc_hyd(land_pts, nsoilt, sm_levels, n_wtrac_jls, wtrac_hy)
> 
> ! Set up arrays to store some initial fields which are needed by water tracers
> IF (l_wtrac_jls) THEN
>   ALLOCATE(sthu_soilt_old(land_pts,nsoilt,sm_levels))
>   ALLOCATE(sthf_soilt_old(land_pts,nsoilt,sm_levels))
> ELSE
>   ALLOCATE(sthu_soilt_old(1,1,1))
>   ALLOCATE(sthf_soilt_old(1,1,1))
> END IF
> 
488,489c546,550
<   DO m = 1,nsoilt
<     DO j = 1,soil_pts
---
> !$OMP PARALLEL DO SCHEDULE(STATIC) DEFAULT(NONE) PRIVATE(i,j,m,n)              &
> !$OMP SHARED(soil_pts, nsoilt, soil_index, cs_ch4_soilt, dim_cslayer,          &
> !$OMP        cs_pool_soilt)
>   DO m = 1, nsoilt
>     DO j = 1, soil_pts
496a558
> !$OMP END PARALLEL DO
499,500c561,573
< ! smcl_old_soilt calcuated for leaching code
< smcl_old_soilt(:,:,:) = smcl_soilt(:,:,:)
---
> !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i,m,n)                                    &
> !$OMP SHARED(sm_levels, nsoilt, smcl_old_soilt, smcl_soilt, w_flux_soilt,      &
> !$OMP        w_flux_irr_soilt, land_pts)
> ! smcl_old_soilt calculated for leaching code
> DO n = 1, sm_levels
>   DO m = 1, nsoilt
> !$OMP DO SCHEDULE(STATIC)
>     DO i = 1, land_pts
>       smcl_old_soilt(i,m,n) = smcl_soilt(i,m,n)
>     END DO
> !$OMP END DO NOWAIT
>   END DO
> END DO
503,505c576,589
< w_flux_soilt(:,:,:)     = 0.0
< w_flux_irr_soilt(:,:,:) = 0.0 ! to prevent random values reported over areas
<                     ! that are not included as soil points (i.e. ice points)
---
> DO n = 0, sm_levels
>   DO m = 1, nsoilt
> !$OMP DO SCHEDULE(STATIC)
>     DO i = 1, land_pts
>       w_flux_soilt(i,m,n)     = 0.0
>       w_flux_irr_soilt(i,m,n) = 0.0
>       ! to prevent random values reported over areas
>       ! that are not included as soil points (i.e. ice points)
>     END DO
> !$OMP END DO NOWAIT
>   END DO
> END DO
> ! (Note, water tracer initialisations done in wtrac_alloc_hyd)
> !$OMP END PARALLEL
510c594,595
< zdepth(:) = 0.0
---
> ! set level zero depth to 0
> zdepth(0) = 0.0
512c597
< DO n = 1,sm_levels
---
> DO n = 1, sm_levels
516,518d600
< ! Initialise runoff increment.
< surf_roff_inc_soilt(:,:) = 0.0
< 
523c605,606
< CALL surf_hyd (land_pts, nsurft, sm_levels, soil_pts, timestep, l_top, l_pdm,  &
---
> CALL surf_hyd (land_pts, nsurft, sm_levels, soil_pts, n_wtrac_jls, timestep,   &
>                l_top, l_pdm,                                                   &
528,530c611,614
<                fsat_soilt, smvcst_soilt,                                       &
<                sthf_soilt, sthu_soilt,                                         &
<                canopy_surft, canopy_gb, dsmc_dt_soilt,                         &
---
>                fsat_soilt, smvcst_soilt, sthf_soilt, sthu_soilt,               &
>                ecan_surft_wtrac, melt_surft_wtrac,                             &
>                snow_melt_wtrac, con_rain_land_wtrac, ls_rain_land_wtrac,       &
>                canopy_surft, canopy_surft_wtrac, canopy_gb, dsmc_dt_soilt,     &
532c616,618
<                dun_roff_soilt, surf_roff_soilt)
---
>                dun_roff_soilt, surf_roff_soilt, wtrac_hy%canopy_gb,            &
>                wtrac_hy%dsmc_dt_soilt, surf_roff_gb_wtrac,                     &
>                wtrac_hy%surf_roff_soilt)
538,541c624,634
< DO m = 1, nsoilt
<   DO n = 0,sm_levels
<     !CDIR NODEP
<     DO j = 1,soil_pts
---
> !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i, j, m, n)                               &
> !$OMP SHARED(sm_levels, nsoilt, soil_pts, soil_index, ksz_soilt, satcon_soilt, &
> !$OMP        smclsat_soilt, qbase_l_soilt, qbase_l_unfr_soilt, dumsthf_soilt,  &
> !$OMP        dzsoil, smvcst_soilt, land_pts, qbase_soilt,                      &
> !$OMP        qbase_zw_soilt, wutot_soilt, drain_soilt, qbase_unfr_soilt,       &
> !$OMP        zw_inund_soilt, surf_roff_inc_soilt, l_wtrac_jls,                 &
> !$OMP        sthu_soilt, sthu_soilt_old, sthf_soilt, sthf_soilt_old)
> DO n = 0, sm_levels
>   DO m = 1, nsoilt
> !$OMP DO SCHEDULE(STATIC)
>     DO j = 1, soil_pts
544a638
> !$OMP END DO NOWAIT
548,550c642,644
< DO m = 1, nsoilt
<   DO n = 1,sm_levels
<     !CDIR NODEP
---
> DO n = 1, sm_levels
>   DO m = 1, nsoilt
> !$OMP DO SCHEDULE(STATIC)
552,556c646,650
<       smclsat_soilt(soil_index(j),m,n)      = rho_water * dzsoil(n) *          &
<                                               smvcst_soilt(soil_index(j),m,n)
<       qbase_l_soilt(soil_index(j),m,n)      = 0.0
<       qbase_l_unfr_soilt(soil_index(j),m,n) = 0.0
<       dumsthf_soilt(soil_index(j),m,n)      = 0.0
---
>       i = soil_index(j)
>       smclsat_soilt(i,m,n)      = rho_water * dzsoil(n) * smvcst_soilt(i,m,n)
>       qbase_l_soilt(i,m,n)      = 0.0
>       qbase_l_unfr_soilt(i,m,n) = 0.0
>       dumsthf_soilt(i,m,n)      = 0.0
557a652
> !$OMP END DO NOWAIT
561a657
> !$OMP DO SCHEDULE(STATIC)
568a665,666
>     ! Initialise runoff increment.
>     surf_roff_inc_soilt(i,m) = 0.0
569a668
> !$OMP END DO NOWAIT
571a671,689
> ! (Note, water tracers fields have been initialised in wtrac_alloc_hyd)
> 
> IF (l_wtrac_jls) THEN
>   ! Store initial sthu and sthf for water tracer use later on
>   DO n = 1, sm_levels
>     DO m = 1, nsoilt
> !$OMP DO SCHEDULE(STATIC)
>       DO j = 1,soil_pts
>         i = soil_index(j)
>         sthu_soilt_old(i,m,n) = sthu_soilt(i,m,n)
>         sthf_soilt_old(i,m,n) = sthf_soilt(i,m,n)
>       END DO
> !$OMP END DO NOWAIT
>     END DO
>   END DO
> 
> END IF   ! l_wtrac_jls
> !$OMP END PARALLEL
> 
599c717,724
<       top_crit_soilt(:,:) = dumtop_crit_soilt(:,:)
---
>       DO m = 1, nsoilt
> !$OMP PARALLEL DO SCHEDULE(STATIC) DEFAULT(NONE) PRIVATE(i)                    &
> !$OMP SHARED(m, land_pts, top_crit_soilt, dumtop_crit_soilt)
>         DO i = 1,land_pts
>           top_crit_soilt(i,m) = dumtop_crit_soilt(i,m)
>         END DO
> !$OMP END PARALLEL DO
>       END DO
602a728
>   ! (Note, baseflow for water tracers is calculated later on in soil_hyd_wtrac)
613c739,749
< END IF
---
> 
>   ! Repeat for water tracers
>   IF (l_wtrac_jls) THEN
>     DO i_wt = 1, n_wtrac_jls
>       DO i = 1,land_pts
>         wtrac_hy%dsmc_dt_soilt(i,1,i_wt) = wtrac_hy%dsmc_dt_soilt(i,1,i_wt)    &
>                                            + inlandout_atm_gb_wtrac(i,i_wt)
>       END DO
>     END DO
>   END IF  ! l_wtrac_jls
> END IF    ! l_inland
737a874
>     ! Note, water tracers not currently coded for l_irrig_dmd = T
751a889,925
>     ! Water tracers - calculate the gravitational drainage, baseflow and
>     ! update the layer water tracer soil moisture contents
>     ! (Note, sthzw_soilt has not been changed at this point, hence, there
>     ! is no need for an 'old' value.)
>     IF (l_wtrac_jls) THEN
>       DO i_wt = 1, n_wtrac_jls
>         DO m = 1, nsoilt
>           CALL soil_hyd_wtrac(                                                 &
>                 land_pts, sm_levels, soil_pts, i_wt, timestep, l_top,          &
>                 soil_index, sthzw_soilt(:,m), smclsat_soilt(:,m,:),            &
>                 qbase_l_soilt(:,m,:), w_flux_soilt(:,m,:),                     &
>                 sthzw_soilt_wtrac(:,m,i_wt), ext_soilt_wtrac(:,m,:,i_wt),      &
>                 dsmc_dt_soilt(:,m), wtrac_hy%dsmc_dt_soilt(:,m,i_wt),          &
>                 sthu_soilt_old(:,m,:), wtrac_hy%qbase_l_soilt(:,m,:,i_wt),     &
>                 wtrac_hy%qbase_soilt(:,m,i_wt), smcl_soilt_wtrac(:,m,:,i_wt),  &
>                 sthu_soilt_wtrac(:,m,:,i_wt),                                  &
>                 wtrac_hy%w_flux_soilt(:,m,:,i_wt) )
>         END DO
>       END DO
> 
>       ! Store current sthu values for later use in soil_htc_wtrac
> !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i, j, m, n)                               &
> !$OMP SHARED(sm_levels, nsoilt, soil_pts, soil_index, sthu_soilt_old,          &
> !$OMP        sthu_soilt)
>       DO n = 1, sm_levels
>         DO m = 1, nsoilt
> !$OMP DO SCHEDULE(STATIC)
>           DO j = 1,soil_pts
>             i = soil_index(j)
>             sthu_soilt_old(i,m,n) = sthu_soilt(i,m,n)
>           END DO
> !$OMP END DO NOWAIT
>         END DO
>       END DO
> !$OMP END PARALLEL
>     END IF  ! l_wtrac_jls
> 
762,763c936,937
<       land_pts, sm_levels, soil_pts, timestep, stf_sub_surf_roff,              &
<       l_top,  soil_index,                                                      &
---
>       land_pts, sm_levels, soil_pts, m, nsoilt, n_wtrac_jls, timestep,         &
>       stf_sub_surf_roff, l_top,  soil_index,                                   &
766c940,941
<       w_flux_soilt(:,m,:), smcl_soilt(:,m,:),                                  &
---
>       w_flux_soilt(:,m,:),  wtrac_hy%dsmc_dt_soilt(:,m,:),                     &
>       wtrac_hy%w_flux_soilt(:,m,:,:), smcl_soilt(:,m,:),                       &
768a944
>       surf_roff_gb_wtrac, wtrac_hy%qbase_l_soilt(:,m,:,:), sthzw_soilt_wtrac,  &
770c946,948
<       sthzw_soilt(:,m), surf_roff_inc_soilt(:,m) )
---
>       sthzw_soilt(:,m), surf_roff_inc_soilt(:,m),                              &
>       wtrac_hy%sub_surf_roff_soilt(:,m,:), wtrac_hy%qbase_soilt(:,m,:),        &
>       wtrac_hy%surf_roff_inc_soilt(:,m,:) )
775a954,964
> 
>     IF (l_wtrac_jls) THEN
>       ! Repeat for water tracers
>       DO i_wt = 1, n_wtrac_jls
>         sub_surf_roff_gb_wtrac(:,i_wt) = wtrac_hy%sub_surf_roff_soilt(:,m,i_wt)
>         ! Update the tiled surface runoff.
>         wtrac_hy%surf_roff_soilt(:,m,i_wt) =                                   &
>                                     wtrac_hy%surf_roff_soilt(:,m,i_wt)         &
>                                     + wtrac_hy%surf_roff_inc_soilt(:,m,i_wt)
>       END DO
>     END IF ! l_wtrac_jls
779c968,979
<     sub_surf_roff_gb(:) = 0.0
---
>     DO i = 1, land_pts
>       sub_surf_roff_gb(i) = 0.0
>     END DO
> 
>     IF (l_wtrac_jls) THEN
>       DO i_wt = 1, n_wtrac_jls
>         DO i = 1, land_pts
>           sub_surf_roff_gb_wtrac(i,i_wt) = 0.0
>         END DO
>       END DO
>     END IF
> 
780a981,988
> 
>       ! Set soil tile pointer for water tracers
>       IF (l_wtrac_jls) THEN
>         m_wt = m
>       ELSE
>         m_wt = 1  ! Dummy pointer
>       END IF
> 
782,783c990,991
<         land_pts, sm_levels, soil_pts, timestep, stf_sub_surf_roff,            &
<         l_top, soil_index,                                                     &
---
>         land_pts, sm_levels, soil_pts, m, nsoilt, n_wtrac_jls, timestep,       &
>         stf_sub_surf_roff, l_top, soil_index,                                  &
786c994,995
<         w_flux_soilt(:,m,:), smcl_soilt(:,m,:),                                &
---
>         w_flux_soilt(:,m,:),  wtrac_hy%dsmc_dt_soilt(:,m_wt,:),                &
>         wtrac_hy%w_flux_soilt(:,m_wt,:,:), smcl_soilt(:,m,:),                  &
788a998,999
>         wtrac_hy%surf_roff_soilt(:,m_wt,:),                                    &
>         wtrac_hy%qbase_l_soilt(:,m_wt,:,:), sthzw_soilt_wtrac,                 &
790c1001,1004
<         sthzw_soilt(:,m), surf_roff_inc_soilt(:,m) )
---
>         sthzw_soilt(:,m), surf_roff_inc_soilt(:,m),                            &
>         wtrac_hy%sub_surf_roff_soilt(:,m_wt,:),                                &
>         wtrac_hy%qbase_soilt(:,m_wt,:),                                        &
>         wtrac_hy%surf_roff_inc_soilt(:,m_wt,:) )
797a1012,1021
>       IF (l_wtrac_jls) THEN
>         ! Repeat for water tracers
>         DO i_wt = 1, n_wtrac_jls
>           sub_surf_roff_gb_wtrac(:,i_wt) = sub_surf_roff_gb_wtrac(:,i_wt)      &
>                   + ( tile_frac(:,m) * wtrac_hy%sub_surf_roff_soilt(:,m,i_wt))
>           surf_roff_gb_wtrac(:,i_wt) = surf_roff_gb_wtrac(:,i_wt)              &
>                   + ( tile_frac(:,m) * wtrac_hy%surf_roff_inc_soilt(:,m,i_wt))
>         END DO
>       END IF ! l_wtrac_jls
> 
854a1079,1086
>   IF (l_wtrac_jls) THEN
>     DO i_wt = 1, n_wtrac_jls
>       DO i = 1,land_pts
>         sub_surf_roff_gb_wtrac(i,i_wt) = 0.0
>       END DO
>     END DO
>   END IF
> 
912a1145,1158
> 
>   ! Update water tracers for phase change
>   IF (l_wtrac_jls) THEN
>     DO i_wt = 1, n_wtrac_jls
>       DO m = 1, nsoilt
>         CALL soil_htc_wtrac (                                                  &
>                 land_pts, sm_levels, soil_pts, i_wt, soil_index,               &
>                 sthf_soilt(:,m,:), sthf_soilt_old(:,m,:),                      &
>                 sthu_soilt_old(:,m,:),                                         &
>                 sthf_soilt_wtrac(:,m,:,i_wt), sthu_soilt_wtrac(:,m,:,i_wt) )
>       END DO
>     END DO
>   END IF
> 
929c1175
<                    lice_index, snow_soil_htf, tsurf_elev_surft)
---
>                    lice_index, snow_soil_htf, tsurf_elev_surft, l_lice_surft)
954c1200
<     CASE ( soil_model_1pool, soil_model_rothc )
---
>     CASE ( soil_model_1pool, soil_model_4pool )
976c1222
<                 (fch4_wetl_soilt(i,m) * to_kg_conversion * timestep_len)
---
>                 (fch4_wetl_soilt(i,m) * to_kg_conversion * timestep)
984c1230
< IF ( (soil_bgc_model == soil_model_rothc .AND. l_layeredc )                    &
---
> IF ( (soil_bgc_model == soil_model_4pool .AND. l_layeredc )                    &
1003c1249
< IF (soil_bgc_model == soil_model_rothc .AND. l_nitrogen) THEN
---
> IF (soil_bgc_model == soil_model_4pool .AND. l_nitrogen) THEN
1013a1260,1264
> 
> ! Deallocate water tracer working arrays
> CALL wtrac_dealloc_hyd(wtrac_hy)
> DEALLOCATE(sthf_soilt_old)
> DEALLOCATE(sthu_soilt_old)
diff -r vn7.0copy1_c4/src/./science/soil/sieve_jls_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/soil/sieve_jls_mod.F90
24,26c24,27
< SUBROUTINE sieve ( npnts, surft_pts, curr_surft, timestep, surft_index,        &
<                    area, can_cpy, r, frac,                                     &
<                    can_wcnt, tot_tfall, tot_tfall_surft )
---
> SUBROUTINE sieve ( npnts, surft_pts, curr_surft, nsurft, n_wtrac_jls,          &
>                    timestep, surft_index, area, can_cpy, r, r_wtrac, frac,     &
>                    can_wcnt, tot_tfall, tot_tfall_surft,                       &
>                    can_wcnt_wtrac, tot_tfall_wtrac, tot_tfall_surft_wtrac )
33a35,36
> USE jules_water_tracers_mod, ONLY: l_wtrac_jls
> 
46c49
<   curr_surft
---
>   curr_surft,                                                                  &
47a51,54
>   nsurft,                                                                      &
>     ! Number of tiles (only used by water tracers)
>   n_wtrac_jls
>     ! Number of water tracers
66a74,75
>   r_wtrac(npnts,n_wtrac_jls),                                                  &
>     ! Water tracer fall rate (kg/m2/s).
77,78c86,87
<     ! Cummulative canopy throughfall (kg/m2/s).
<   tot_tfall_surft(npnts)
---
>     ! Cumulative canopy throughfall (kg/m2/s).
>   tot_tfall_surft(npnts),                                                      &
79a89,98
>   can_wcnt_wtrac(npnts,nsurft,n_wtrac_jls),                                    &
>     ! Canopy water tracer content (kg/m2) for all tiles.
>     ! (Note, unlike the water equivalent, this is the full field containing
>     !  all tiles)
>   tot_tfall_wtrac(npnts,n_wtrac_jls),                                          &
>     ! Cummulative canopy water tracer throughfall (kg/m2/s).
>   tot_tfall_surft_wtrac(npnts,nsurft,n_wtrac_jls)
>     ! Water tracer throughfall contributions for all tiles (kg/m2/s).
>     ! (Note, unlike the water equivalent, this is the full field containing
>     !  all tiles)
85c104
<   i, j
---
>   i, j, i_wt
88a108
>     ! i_wt for water tracers
106a127,130
> REAL(KIND=real_jlslsm), ALLOCATABLE ::                                         &
>   tfall_wtrac(:,:)
>     ! Local water tracer throughfall (kg/m2/s).
> 
153a178,221
> 
> ! Repeat for water tracers
> IF (l_wtrac_jls) THEN
> 
>   ALLOCATE(tfall_wtrac(npnts,n_wtrac_jls))
> 
> !$OMP PARALLEL DO DEFAULT(NONE) PRIVATE(j, i, i_wt)                            &
> !$OMP SHARED(surft_pts, surft_index, can_cpy, r, r_wtrac, smallp, timestep,    &
> !$OMP        can_wcnt_wtrac, tfall, tfall_wtrac, tot_tfall_wtrac, frac,        &
> !$OMP        tot_tfall_surft_wtrac, l_flake_model, lake, curr_surft,           &
> !$OMP        n_wtrac_jls)                                                      &
> !$OMP SCHEDULE(STATIC)
>   DO j = 1,surft_pts
>     i = surft_index(j)
>     IF ( can_cpy(i)  >  0.0 .AND. r(i) > smallp ) THEN
>       DO i_wt = 1, n_wtrac_jls
>         tfall_wtrac(i,i_wt) = (r_wtrac(i,i_wt)/r(i)) * tfall(i)
>       END DO
>     ELSE
>       DO i_wt = 1, n_wtrac_jls
>         tfall_wtrac(i,i_wt) = r_wtrac(i,i_wt)
>       END DO
>     END IF
> 
>     DO i_wt = 1, n_wtrac_jls
>       can_wcnt_wtrac(i,curr_surft,i_wt)  = can_wcnt_wtrac(i,curr_surft,i_wt)   &
>                                 + (r_wtrac(i,i_wt) - tfall_wtrac(i,i_wt))      &
>                                 * timestep
> 
>       IF ( .NOT. ((l_flake_model) .AND. (curr_surft == lake)) ) THEN
>         tot_tfall_wtrac(i,i_wt) = tot_tfall_wtrac(i,i_wt)                      &
>                                   + frac(i) * tfall_wtrac(i,i_wt)
>       END IF
> 
>       ! Increment the tile throughfall for this precip type
>       tot_tfall_surft_wtrac(i,curr_surft,i_wt) =                               &
>                                      tot_tfall_surft_wtrac(i,curr_surft,i_wt)  &
>                                       + tfall_wtrac(i,i_wt)
>     END DO
>   END DO
> !$OMP END PARALLEL DO
> 
>   DEALLOCATE(tfall_wtrac)
> END IF ! l_wtrac_jls
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/soil: soil_htc_wtrac_mod.F90
diff -r vn7.0copy1_c4/src/./science/soil/soil_hyd_wt_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/soil/soil_hyd_wt_mod.F90
19,20c19,21
< SUBROUTINE soil_hyd_wt (npnts, nshyd, soil_pts, timestep, stf_slow_runoff,     &
<                         l_top, soil_index,                                     &
---
> SUBROUTINE soil_hyd_wt (npnts, nshyd, soil_pts, curr_soilt, nsoilt,            &
>                         n_wtrac_jls, timestep,                                 &
>                         stf_slow_runoff, l_top, soil_index,                    &
22c23,25
<                         smcl, surf_roff, qbase_l, smclzw, zw,                  &
---
>                         fw_wtrac, w_flux_wtrac, smcl, surf_roff, qbase_l,      &
>                         smclzw, zw,                                            &
>                         surf_roff_wtrac, qbase_l_wtrac, sthzw_wtrac,           &
24c27,28
<                         surf_roff_inc)
---
>                         surf_roff_inc, slow_runoff_wtrac, qbase_wtrac,         &
>                         surf_roff_inc_wtrac )
28a33,34
> USE jules_water_tracers_mod, ONLY: l_wtrac_jls
> 
44c50
<   soil_pts
---
>   soil_pts,                                                                    &
45a52,57
>   curr_soilt,                                                                  &
>     ! Current soil tile.
>   nsoilt,                                                                      &
>     ! Number of soil tiles
>   n_wtrac_jls
>     ! Number of water tracers
77c89
<   w_flux(npnts,0:nshyd)
---
>   w_flux(npnts,0:nshyd),                                                       &
78a91,96
>   fw_wtrac(npnts,n_wtrac_jls),                                                 &
>     ! Water tracer throughfall from canopy plus snowmelt minus surface
>     ! runoff (kg/m2/s).
>   w_flux_wtrac(npnts,0:nshyd,n_wtrac_jls)
>     ! The fluxes of water tracer between layers (kg/m2/s).
> 
92c110
<   zw(npnts)
---
>   zw(npnts),                                                                   &
93a112,120
>   surf_roff_wtrac(npnts,n_wtrac_jls),                                          &
>     ! Surface water tracer runoff (kg/m2/s).
>   qbase_l_wtrac(npnts,nshyd+1,n_wtrac_jls),                                    &
>     ! Water tracer base flow from each level (kg/m2/s).
>   sthzw_wtrac(npnts,nsoilt,n_wtrac_jls)
>     ! Soil water tracer fraction in deep layer.
>     ! (Note, unlike the water equivalent, this is the full field for all soil
>     !  tiles)
> 
107c134
<   surf_roff_inc(npnts)
---
>   surf_roff_inc(npnts),                                                        &
108a136,141
>   slow_runoff_wtrac(npnts,n_wtrac_jls),                                        &
>     ! Water tracer drainage from the base of the soil profile (kg/m2/s).
>   qbase_wtrac(npnts,n_wtrac_jls),                                              &
>     ! Water tracer base flow (kg/m2/s).
>   surf_roff_inc_wtrac(npnts,n_wtrac_jls)
>     ! Increment to surface water tracer runoff (kg m-2 s-1).
114c147,151
<   i, j, n                ! WORK Loop counters.
---
>   i, j, n, i_wt              ! WORK Loop counters.
> 
> REAL(KIND=real_jlslsm) ::                                                      &
>   smclzw_wtrac
>     ! Water tracer content in deep layer (kg/m2)
142a180,193
>   IF (l_wtrac_jls) THEN
>     ! Update water tracer deep layer soil moisture fraction
>     DO i_wt = 1, n_wtrac_jls
>       DO j = 1,soil_pts
>         i = soil_index(j)
>         smclzw_wtrac = sthzw_wtrac(i,curr_soilt,i_wt) * smclsatzw(i)
>         smclzw_wtrac = smclzw_wtrac - (qbase_l_wtrac(i,nshyd+1,i_wt)           &
>                                       - w_flux_wtrac(i,nshyd,i_wt)) * timestep
>         ! Update prognostic deep layer water tracer soil moisture fraction
>         sthzw_wtrac(i,curr_soilt,i_wt) = smclzw_wtrac / smclsatzw(i)
>       END DO
>     END DO
>   END IF ! l_wtrac_jls
> 
154a206,220
>   IF (l_wtrac_jls) THEN
>     ! Repeat for water tracers
>     DO i_wt = 1, n_wtrac_jls
>       DO j = 1,soil_pts
>         i = soil_index(j)
>         qbase_wtrac(i,i_wt) = 0.0
>         DO n = 1,nshyd+1
>           qbase_l_wtrac(i,n,i_wt) = MAX(qbase_l_wtrac(i,n,i_wt),0.0)
>           qbase_wtrac(i,i_wt)     = qbase_wtrac(i,i_wt)                        &
>                                     + qbase_l_wtrac(i,n,i_wt)
>         END DO
>       END DO
>     END DO
>   END IF
> 
165c231
<     ! Ensure correct field is output as deep runoff: dependant on L_TOP
---
>     ! Ensure correct field is output as deep runoff: dependent on L_TOP
182a249,280
> 
> !-----------------------------------------------------------------------------
> ! Output water tracer slow runoff and update surface runoff
> !-----------------------------------------------------------------------------
> 
> IF (l_wtrac_jls) THEN
> 
>   ! Initialise water tracer slow_runoff
>   DO i_wt = 1, n_wtrac_jls
>     DO i = 1, npnts
>       slow_runoff_wtrac(i,i_wt) = 0.0
>     END DO
>   END DO
> 
>   DO i_wt = 1, n_wtrac_jls
>     DO j = 1, soil_pts
>       i = soil_index(j)
> 
>       ! Ensure correct field is output as deep runoff: dependant on L_TOP
>       IF (l_top) THEN
>         slow_runoff_wtrac(i,i_wt) = qbase_wtrac(i,i_wt)
>       ELSE
>         slow_runoff_wtrac(i,i_wt) = w_flux_wtrac(i,nshyd,i_wt)
>       END IF
> 
>       surf_roff_wtrac(i,i_wt)     = surf_roff_wtrac(i,i_wt)                    &
>                                   + (fw_wtrac(i,i_wt) - w_flux_wtrac(i,0,i_wt))
>       surf_roff_inc_wtrac(i,i_wt) = fw_wtrac(i,i_wt) - w_flux_wtrac(i,0,i_wt)
> 
>     END DO
>   END DO
> END IF  ! l_wtrac_jls
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/soil: soil_hyd_wtrac_mod.F90
diff -r vn7.0copy1_c4/src/./science/soil/surf_hyd_jls_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/soil/surf_hyd_jls_mod.F90
16c16
< !            LARGE-SCALE RAIN IS CALCUALTED
---
> !            LARGE-SCALE RAIN IS CALCULATED
19c19
< !            CONVECTIVE RAIN IS CALCUALTED
---
> !            CONVECTIVE RAIN IS CALCULATED
34c34,35
<             land_pts, nsurft, sm_levels, soil_pts, timestep, l_top, l_pdm,     &
---
>             land_pts, nsurft, sm_levels, soil_pts, n_wtrac_jls, timestep,      &
>             l_top, l_pdm,                                                      &
39,40c40,42
<             sthf_soilt, sthu_soilt,                                            &
<             canopy_surft, canopy_gb, dsmc_dt_soilt,                            &
---
>             sthf_soilt, sthu_soilt, ecan_surft_wtrac, melt_surft_wtrac,        &
>             snow_melt_wtrac, con_rain_land_wtrac, ls_rain_land_wtrac,          &
>             canopy_surft, canopy_surft_wtrac, canopy_gb, dsmc_dt_soilt,        &
42,43c44,45
<             dun_roff_soilt, surf_roff_soilt)
< 
---
>             dun_roff_soilt, surf_roff_soilt, canopy_gb_wtrac,                  &
>             dsmc_dt_soilt_wtrac, surf_roff_gb_wtrac, surf_roff_soilt_wtrac)
55a58,59
> USE jules_water_tracers_mod, ONLY: l_wtrac_jls
> 
75c79
<   soil_pts
---
>   soil_pts,                                                                    &
76a81
>   n_wtrac_jls
130c135
<   sthu_soilt(land_pts,nsoilt,sm_levels)
---
>   sthu_soilt(land_pts,nsoilt,sm_levels),                                       &
132a138,147
>   ecan_surft_wtrac(land_pts,nsurft,n_wtrac_jls),                               &
>     ! Water tracer canopy evaporation (kg/m2/s).
>   melt_surft_wtrac(land_pts,nsurft,n_wtrac_jls),                               &
>     ! Water tracer snow melt on tiles (kg/m2/s).
>   snow_melt_wtrac(land_pts,n_wtrac_jls),                                       &
>     ! Water tracer GBM snow melt (kg/m2/s).
>   con_rain_land_wtrac(land_pts,n_wtrac_jls),                                   &
>     ! Water tracer convective rain (kg/m2/s).
>   ls_rain_land_wtrac(land_pts,n_wtrac_jls)
>     ! Water tracer large-scale rain (kg/m2/s).
138c153
<   canopy_surft(land_pts,nsurft)
---
>   canopy_surft(land_pts,nsurft),                                               &
139a155,156
>   canopy_surft_wtrac(land_pts,nsurft,n_wtrac_jls)
>     ! Tile canopy water tracer contents (kg/m2).
157c174
<   surf_roff_soilt(land_pts,nsoilt)
---
>   surf_roff_soilt(land_pts,nsoilt),                                            &
158a176,183
>   canopy_gb_wtrac(land_pts,n_wtrac_jls),                                       &
>     ! Gridbox canopy water tracer content (kg/m2).
>   dsmc_dt_soilt_wtrac(land_pts,nsoilt,n_wtrac_jls),                            &
>     ! Rate of change of water tracer soil moisture content (kg/m2/s).
>   surf_roff_gb_wtrac(land_pts,n_wtrac_jls),                                    &
>     ! Cumulative water tracer surface runoff (kg/m2/s).
>   surf_roff_soilt_wtrac(land_pts,nsoilt,n_wtrac_jls)
>     ! Soil-tiled contributions to water tracer surface runoff (kg/m2/s).
164c189
<   i,j,n,m
---
>   i,j,n,m,i_wt
169a195
>     ! i_wt for water tracer
177c203
<   s_roff
---
>   s_roff,                                                                      &
178a205,206
>   p_in_wtrac
>     ! Water tracer flux reaching the soil surface (kg/m2/s).
191a220,241
> ! Allocatable water tracer arrays:
> REAL(KIND=real_jlslsm), ALLOCATABLE ::                                         &
>   surf_roff_surft_wtrac(:,:,:),                                                &
>     ! Surface-tiled contributions to water tracer surface runoff.
>   can_cond_wtrac(:,:),                                                         &
>     ! Water tracer canopy condensation (kg/m2/s).
>   tot_tfall_gb_wtrac(:,:),                                                     &
>     ! Cumulative water tracer canopy throughfall (kg/m2/s).
>     ! (Currently not output from this routine as just diagnostic)
>   tot_tfall_surft_wtrac(:,:,:),                                                &
>     ! Surface-tiled contributions to water tracer throughfall.
>     ! (Currently not output from this routine as just diagnostic)
>   dun_roff_soilt_wtrac(:,:,:),                                                 &
>     ! Cumulative water tracer Dunne sfc runoff (kg/m2/s).
>     ! (Currently not output from this routine as just diagnostic)
>   tot_tfall_soilt_wtrac(:,:,:),                                                &
>   melt_surft_wtrac_tile(:,:),                                                  &
>     ! Temporary copy of the melt_surft_wtrac field for a particular tile.
>   p_in_store(:,:)
>     ! Water flux reaching the soil surface which is stored for water tracer
>     ! calculations if l_pdm=T or l_top=T
> 
201,202c251,266
< ! Assume snowmelt and evaporation cover 100% of the gridbox
< frac_cov(:) = 1.0
---
> ! Allocate water tracer fields
> IF (l_wtrac_jls) THEN
>   ALLOCATE(surf_roff_surft_wtrac(land_pts,nsurft,n_wtrac_jls))
>   ALLOCATE(can_cond_wtrac(land_pts,n_wtrac_jls))
>   ALLOCATE(tot_tfall_gb_wtrac(land_pts,n_wtrac_jls))
>   ALLOCATE(tot_tfall_surft_wtrac(land_pts,nsurft,n_wtrac_jls))
>   ALLOCATE(dun_roff_soilt_wtrac(land_pts,nsoilt,n_wtrac_jls))
>   ALLOCATE(tot_tfall_soilt_wtrac(land_pts,nsoilt,n_wtrac_jls))
> ELSE
>   ALLOCATE(surf_roff_surft_wtrac(1,1,1))
>   ALLOCATE(can_cond_wtrac(1,1))
>   ALLOCATE(tot_tfall_gb_wtrac(1,1))
>   ALLOCATE(tot_tfall_surft_wtrac(1,1,1))
>   ALLOCATE(dun_roff_soilt_wtrac(1,1,1))
>   ALLOCATE(tot_tfall_soilt_wtrac(1,1,1))
> END IF
203a268
> ! Assume snowmelt and evaporation cover 100% of the gridbox
205c270,277
< DO i = 1,land_pts
---
> !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i, j, i_wt)                               &
> !$OMP SHARED(land_pts, nsoilt, nsurft, frac_cov, tot_tfall_gb, surf_roff_gb,   &
> !$OMP dsmc_dt_soilt, dun_roff_soilt, surf_roff_surft, tot_tfall_surft,         &
> !$OMP l_wtrac_jls, surf_roff_gb_wtrac, surf_roff_surft_wtrac, n_wtrac_jls,     &
> !$OMP tot_tfall_surft_wtrac, tot_tfall_gb_wtrac)
> !$OMP DO SCHEDULE(STATIC)
> DO i = 1, land_pts
>   frac_cov(i)         = 1.0
208,209d279
<   dsmc_dt_soilt(i,:)  = 0.0
<   dun_roff_soilt(i,:) = 0.0
211,212c281,320
< surf_roff_surft(:,:) = 0.0
< tot_tfall_surft(:,:) = 0.0
---
> !$OMP END DO
> DO j = 1, nsoilt
> !$OMP DO SCHEDULE(STATIC)
>   DO i = 1, land_pts
>     dsmc_dt_soilt(i,j)  = 0.0
>     dun_roff_soilt(i,j) = 0.0
>   END DO
> !$OMP END DO NOWAIT
> END DO
> DO j = 1, nsurft
> !$OMP DO SCHEDULE(STATIC)
>   DO i = 1, land_pts
>     surf_roff_surft(i,j) = 0.0
>     tot_tfall_surft(i,j) = 0.0
>   END DO
> !$OMP END DO NOWAIT
> END DO
> ! Initialiase water tracer equivalent fields
> IF (l_wtrac_jls) THEN
>   DO i_wt = 1, n_wtrac_jls
> 
> !$OMP DO SCHEDULE(STATIC)
>     DO i = 1, land_pts
>       surf_roff_gb_wtrac(i,i_wt) = 0.0
>       tot_tfall_gb_wtrac(i,i_wt) = 0.0
>     END DO
> !$OMP END DO
> 
>     DO j = 1, nsurft
> !$OMP DO SCHEDULE(STATIC)
>       DO i = 1, land_pts
>         surf_roff_surft_wtrac(i,j,i_wt) = 0.0
>         tot_tfall_surft_wtrac(i,j,i_wt) = 0.0
>       END DO
> !$OMP END DO NOWAIT
>     END DO
> 
>   END DO ! i_wt
> END IF ! l_wtrac_jls
> !$OMP END PARALLEL
224a333,348
> IF (l_wtrac_jls) THEN
>   ! Repeat for water tracers
>   DO i_wt = 1, n_wtrac_jls
>     DO n = 1,nsurft
>       DO j = 1,surft_pts(n)
>         i = surft_index(j,n)
>         IF (ecan_surft_wtrac(i,n,i_wt) > 0.0) THEN
>           canopy_surft_wtrac(i,n,i_wt) = MAX(canopy_surft_wtrac(i,n,i_wt)      &
>                                       - ecan_surft_wtrac(i,n,i_wt) * timestep, &
>                                        0.0 )
>         END IF
>       END DO
>     END DO
>   END DO
> END IF
> 
227c351,352
<   ! Using point precipitation data.
---
>   ! Using point precipitation data. (Note, water tracers not coded for this
>   ! option.)
273a399,400
>   !
>   ! Note, water tracers are only coded for this option.
277a405,421
>     ! Create a temporary array to hold melt_surft_wtrac for the current tile
>     IF (l_wtrac_jls) THEN
>       ALLOCATE(melt_surft_wtrac_tile(land_pts,n_wtrac_jls))
> 
> !$OMP PARALLEL DO SCHEDULE(STATIC) DEFAULT(NONE) PRIVATE(i,i_wt)               &
> !$OMP SHARED(n, land_pts, n_wtrac_jls, melt_surft_wtrac_tile, melt_surft_wtrac)
>       DO i = 1, land_pts
>         DO i_wt = 1, n_wtrac_jls
>           melt_surft_wtrac_tile(i,i_wt) = melt_surft_wtrac(i,n,i_wt)
>         END DO
>       END DO
> !$OMP END PARALLEL DO
> 
>     ELSE
>       ALLOCATE(melt_surft_wtrac_tile(1,1))
>     END IF
> 
279c423,424
<     CALL frunoff (land_pts, surft_pts(n), n, timestep, surft_index(:,n),       &
---
>     CALL frunoff (land_pts, surft_pts(n), n, nsurft, n_wtrac_jls, timestep,    &
>                   surft_index(:,n),                                            &
281,282c426,431
<                   infil_surft(:,n), melt_surft(:,n), tile_frac(:,n),           &
<                   surf_roff_gb, surf_roff_surft(:,n))
---
>                   infil_surft(:,n), melt_surft(:,n),                           &
>                   melt_surft_wtrac_tile, tile_frac(:,n),                       &
>                   surf_roff_gb, surf_roff_surft(:,n),surf_roff_gb_wtrac,       &
>                   surf_roff_surft_wtrac)
> 
>     DEALLOCATE(melt_surft_wtrac_tile)
293a443,457
> 
>     IF (l_wtrac_jls) THEN
>       ! Repeat for water tracers
>       DO i_wt = 1, n_wtrac_jls
>         DO j = 1,surft_pts(n)
>           i = surft_index(j,n)
>           IF ( ecan_surft_wtrac(i,n,i_wt)  <  0.0 ) THEN
>             can_cond_wtrac(i,i_wt) = - ecan_surft_wtrac(i,n,i_wt)
>           ELSE
>             can_cond_wtrac(i,i_wt) = 0.0
>           END IF
>         END DO
>       END DO
>     END IF
> 
296,298c460,465
<     CALL sieve (land_pts, surft_pts(n), n, timestep, surft_index(:,n),         &
<                 frac_cov, catch_surft(:,n), can_cond, tile_frac(:,n),          &
<                 canopy_surft(:,n), tot_tfall_gb, tot_tfall_surft(:,n))
---
>     CALL sieve (land_pts, surft_pts(n), n, nsurft, n_wtrac_jls, timestep,      &
>                 surft_index(:,n), frac_cov, catch_surft(:,n), can_cond,        &
>                 can_cond_wtrac, tile_frac(:,n),                                &
>                 canopy_surft(:,n), tot_tfall_gb, tot_tfall_surft(:,n),         &
>                 canopy_surft_wtrac, tot_tfall_gb_wtrac,                        &
>                 tot_tfall_surft_wtrac)
300c467,468
<     CALL frunoff (land_pts, surft_pts(n), n, timestep, surft_index(:,n),       &
---
>     CALL frunoff (land_pts, surft_pts(n), n, nsurft, n_wtrac_jls, timestep,    &
>                   surft_index(:,n),                                            &
302,303c470,472
<                   infil_surft(:,n), can_cond, tile_frac(:,n),                  &
<                   surf_roff_gb, surf_roff_surft(:,n))
---
>                   infil_surft(:,n), can_cond, can_cond_wtrac, tile_frac(:,n),  &
>                   surf_roff_gb, surf_roff_surft(:,n),surf_roff_gb_wtrac,       &
>                   surf_roff_surft_wtrac)
307,310d475
<     CALL sieve (land_pts, surft_pts(n), n, timestep, surft_index(:,n),         &
<                 ls_rainfrac_land, catch_surft(:,n), ls_rain_land,              &
<                 tile_frac(:,n), canopy_surft(:,n), tot_tfall_gb,               &
<                 tot_tfall_surft(:,n))
312c477,485
<     CALL frunoff (land_pts, surft_pts(n), n, timestep, surft_index(:,n),       &
---
>     CALL sieve (land_pts, surft_pts(n), n, nsurft, n_wtrac_jls, timestep,      &
>                 surft_index(:,n), ls_rainfrac_land, catch_surft(:,n),          &
>                 ls_rain_land, ls_rain_land_wtrac, tile_frac(:,n),              &
>                 canopy_surft(:,n), tot_tfall_gb, tot_tfall_surft(:,n),         &
>                 canopy_surft_wtrac, tot_tfall_gb_wtrac,                        &
>                 tot_tfall_surft_wtrac)
> 
>     CALL frunoff (land_pts, surft_pts(n), n, nsurft, n_wtrac_jls, timestep,    &
>                   surft_index(:,n),                                            &
314,315c487,490
<                   infil_surft(:,n), ls_rain_land, tile_frac(:,n),              &
<                   surf_roff_gb, surf_roff_surft(:,n))
---
>                   infil_surft(:,n), ls_rain_land, ls_rain_land_wtrac,          &
>                   tile_frac(:,n),                                              &
>                   surf_roff_gb, surf_roff_surft(:,n),surf_roff_gb_wtrac,       &
>                   surf_roff_surft_wtrac)
319,322d493
<     CALL sieve (land_pts, surft_pts(n), n, timestep, surft_index(:,n),         &
<                 con_rainfrac_land, catch_surft(:,n), con_rain_land,            &
<                 tile_frac(:,n), canopy_surft(:,n), tot_tfall_gb,               &
<                 tot_tfall_surft(:,n))
324c495,503
<     CALL frunoff (land_pts, surft_pts(n), n, timestep, surft_index(:,n),       &
---
>     CALL sieve (land_pts, surft_pts(n), n, nsurft, n_wtrac_jls, timestep,      &
>                 surft_index(:,n), con_rainfrac_land, catch_surft(:,n),         &
>                 con_rain_land, con_rain_land_wtrac, tile_frac(:,n),            &
>                 canopy_surft(:,n), tot_tfall_gb, tot_tfall_surft(:,n),         &
>                 canopy_surft_wtrac, tot_tfall_gb_wtrac,                        &
>                 tot_tfall_surft_wtrac)
> 
>     CALL frunoff (land_pts, surft_pts(n), n, nsurft, n_wtrac_jls, timestep,    &
>                   surft_index(:,n),                                            &
326,327c505,508
<                   infil_surft(:,n), con_rain_land, tile_frac(:,n),             &
<                   surf_roff_gb, surf_roff_surft(:,n))
---
>                   infil_surft(:,n), con_rain_land,  con_rain_land_wtrac,       &
>                   tile_frac(:,n),                                              &
>                   surf_roff_gb, surf_roff_surft(:,n),surf_roff_gb_wtrac,       &
>                   surf_roff_surft_wtrac)
332a514,515
> !$OMP PARALLEL DO SCHEDULE(STATIC) IF(land_pts>1) DEFAULT(NONE) PRIVATE(i)     &
> !$OMP SHARED(land_pts, non_lake_frac, tot_tfall_gb, surf_roff_gb)
338a522,542
> !$OMP END PARALLEL DO
> 
> 
>   IF (l_wtrac_jls) THEN
>     ! Repeat for water tracers
> !$OMP PARALLEL DO SCHEDULE(STATIC) IF(land_pts>1) DEFAULT(NONE) PRIVATE(i,i_wt)&
> !$OMP SHARED(land_pts, non_lake_frac, tot_tfall_gb_wtrac, surf_roff_gb_wtrac,  &
> !$OMP         n_wtrac_jls)
>     DO i = 1,land_pts
>       IF (non_lake_frac(i) > EPSILON(0.0)) THEN
>         DO i_wt = 1, n_wtrac_jls
>           tot_tfall_gb_wtrac(i,i_wt) = tot_tfall_gb_wtrac(i,i_wt)              &
>                                          / non_lake_frac(i)
>           surf_roff_gb_wtrac(i,i_wt) = surf_roff_gb_wtrac(i,i_wt)              &
>                                          / non_lake_frac(i)
>         END DO
>       END IF
>     END DO
> !$OMP END PARALLEL DO
>   END IF  ! l_wtrac_jls
> 
367a572,579
>   ! Store water flux reaching the soil surface for later use by water tracers
>   IF (l_wtrac_jls .AND. (l_pdm .OR. l_top)) THEN
>     ALLOCATE(p_in_store(land_pts,nsoilt))
>     DO i = 1,land_pts
>       p_in_store(i,m) = tot_tfall_gb(i) + snow_melt(i) - surf_roff_gb(i)
>     END DO
>   END IF
> 
392a605,607
>     ! Copy the final answers across to the _soilt version so they can be used
>     ! elsewhere.
>     surf_roff_soilt(i,m) = surf_roff_gb(i)
395,397c610,644
<   ! Copy the final answers across to the _soilt version so they can be used
<   ! elsewhere.
<   surf_roff_soilt(:,m) = surf_roff_gb(:)
---
>   ! Repeat for water tracers
>   IF (l_wtrac_jls) THEN
>     IF (l_top .OR. l_pdm) THEN
>       DO i_wt = 1, n_wtrac_jls
>         DO i = 1, land_pts
>           p_in_wtrac = tot_tfall_gb_wtrac(i,i_wt)                              &
>                         + snow_melt_wtrac(i,i_wt) - surf_roff_gb_wtrac(i,i_wt)
> 
>           ! Calculate saturation excess runoff for water tracers
>           IF (ABS(p_in_store(i,m)) > TINY(p_in_store)) THEN
>             dun_roff_soilt_wtrac(i,m,i_wt) = p_in_wtrac                        &
>                                      * (dun_roff_soilt(i,m)/p_in_store(i,m))
>           ELSE
>             dun_roff_soilt_wtrac(i,m,i_wt) = 0.0
>           END IF
>         END DO
>       END DO
>       DEALLOCATE(p_in_store)
>     END IF
> 
>     DO i_wt = 1, n_wtrac_jls
>       DO i = 1,land_pts
>         IF (l_top .OR. l_pdm) THEN
>           surf_roff_gb_wtrac(i,i_wt) = surf_roff_gb_wtrac(i,i_wt)              &
>                                       + dun_roff_soilt_wtrac(i,m,i_wt)
>         END IF
>         dsmc_dt_soilt_wtrac(i,m,i_wt) = tot_tfall_gb_wtrac(i,i_wt)             &
>                                        + snow_melt_wtrac(i,i_wt)               &
>                                        - surf_roff_gb_wtrac(i,i_wt)
>         ! Copy the final answers across to the _soilt version so they can be
>         ! used elsewhere.
>         surf_roff_soilt_wtrac(i,m,i_wt) = surf_roff_gb_wtrac(i,i_wt)
>       END DO
>     END DO
>   END IF  ! l_wtrac_jls
401,402c648,687
<   surf_roff_soilt(:,:)   = surf_roff_surft(:,:)
<   tot_tfall_soilt(:,:)   = tot_tfall_surft(:,:)
---
>   DO j = 1,nsurft
> !$OMP PARALLEL DO SCHEDULE(STATIC) DEFAULT(NONE) PRIVATE(i)                    &
> !$OMP SHARED(j, land_pts,surf_roff_soilt,tot_tfall_soilt,surf_roff_surft,      &
> !$OMP        tot_tfall_surft)
>     DO i = 1,land_pts
>       surf_roff_soilt(i,j)   = surf_roff_surft(i,j)
>       tot_tfall_soilt(i,j)   = tot_tfall_surft(i,j)
>     END DO
> !$OMP END PARALLEL DO
>   END DO
> 
>   IF (l_wtrac_jls) THEN
>     ! Repeat for water tracers
> !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i,j,i_wt)                                 &
> !$OMP SHARED(n_wtrac_jls,nsurft,land_pts,surf_roff_soilt_wtrac,                &
> !$OMP        tot_tfall_soilt_wtrac,surf_roff_surft_wtrac,tot_tfall_surft_wtrac)
>     DO i_wt = 1, n_wtrac_jls
>       DO j = 1,nsurft
> !$OMP DO SCHEDULE(STATIC)
>         DO i = 1,land_pts
>           surf_roff_soilt_wtrac(i,j,i_wt) = surf_roff_surft_wtrac(i,j,i_wt)
>           tot_tfall_soilt_wtrac(i,j,i_wt) = tot_tfall_surft_wtrac(i,j,i_wt)
>         END DO
> !$OMP END DO
>       END DO
>     END DO
> !$OMP END PARALLEL
>   END IF ! l_wtrac_jls
> 
>   ! Store water flux reaching the soil surface for later use by water tracers
>   IF (l_wtrac_jls .AND. (l_pdm .OR. l_top)) THEN
>     ALLOCATE(p_in_store(land_pts,nsoilt))
>     DO m = 1, nsoilt
>       n = m
>       DO i = 1,land_pts
>         p_in_store(i,m) = tot_tfall_soilt(i,m) + melt_surft(i,n)               &
>                             - surf_roff_soilt(i,m)
>       END DO
>     END DO
>   END IF
442a728,770
>   ! Repeat for water tracers
>   IF (l_wtrac_jls) THEN
>     IF (l_top .OR. l_pdm) THEN
>       DO i_wt = 1, n_wtrac_jls
>         DO m = 1, nsoilt
>           n = m
>           DO i = 1,land_pts
>             ! Calculate water tracer flux reaching soil surface
>             p_in_wtrac = tot_tfall_soilt_wtrac(i,m,i_wt)                       &
>                           + melt_surft_wtrac(i,n,i_wt)                         &
>                           - surf_roff_soilt_wtrac(i,m,i_wt)
> 
>             ! Calculate saturation excess runoff for water tracers
>             IF (ABS(p_in_store(i,m)) > TINY(p_in_store)) THEN
>               dun_roff_soilt_wtrac(i,m,i_wt) =  p_in_wtrac                     &
>                                     * (dun_roff_soilt(i,m) / p_in_store(i,m))
>             ELSE
>               dun_roff_soilt_wtrac(i,m,i_wt) = 0.0
>             END IF
>           END DO
>         END DO
>       END DO
>       DEALLOCATE(p_in_store)
>     END IF
> 
>     DO i_wt = 1, n_wtrac_jls
>       DO m = 1, nsoilt
>         n = m
>         DO i = 1,land_pts
>           IF (l_top .OR. l_pdm) THEN
>             surf_roff_soilt_wtrac(i,m,i_wt) = surf_roff_soilt_wtrac(i,m,i_wt)  &
>                                             + dun_roff_soilt_wtrac(i,m,i_wt)
>             surf_roff_gb_wtrac(i,i_wt) = surf_roff_gb_wtrac(i,i_wt)            &
>                             + tile_frac(i,n) * dun_roff_soilt_wtrac(i,m,i_wt)
>           END IF
>           dsmc_dt_soilt_wtrac(i,m,i_wt) = tot_tfall_soilt_wtrac(i,m,i_wt)      &
>                                          + melt_surft_wtrac(i,n,i_wt)          &
>                                          - surf_roff_soilt_wtrac(i,m,i_wt)
>         END DO
>       END DO
>     END DO
>   END IF  ! l_wtrac_jls
> 
449,450c777,780
< !Calulcate GBM canopy water content
< canopy_gb(:) = 0.0
---
> !Calculate GBM canopy water content
> DO i = 1, land_pts
>   canopy_gb(i) = 0.0
> END DO
456a787,812
> 
> ! Repeat for water tracers
> IF (l_wtrac_jls) THEN
>   DO i_wt = 1, n_wtrac_jls
>     DO i = 1, land_pts
>       canopy_gb_wtrac(i,i_wt) = 0.0
>     END DO
> 
>     DO n = 1, nsurft
>       DO j = 1,surft_pts(n)
>         i = surft_index(j,n)
>         canopy_gb_wtrac(i,i_wt) = canopy_gb_wtrac(i,i_wt)                      &
>                              + (tile_frac(i,n) * canopy_surft_wtrac(i,n,i_wt))
>       END DO
>     END DO
>   END DO
> 
> END IF  ! l_wtrac_jls
> 
> ! Deallocate water tracer fields
> DEALLOCATE(tot_tfall_soilt_wtrac)
> DEALLOCATE(dun_roff_soilt_wtrac)
> DEALLOCATE(tot_tfall_surft_wtrac)
> DEALLOCATE(tot_tfall_gb_wtrac)
> DEALLOCATE(can_cond_wtrac)
> DEALLOCATE(surf_roff_surft_wtrac)
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/soil: wtrac_hyd_mod.F90
diff -r vn7.0copy1_c4/src/./science/soil_biogeochem/ecosse/ecosse_decomposition_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/soil_biogeochem/ecosse/ecosse_decomposition_mod.F90
58c58
< !   in the RothC-based code with the same name but often differnt units.
---
> !   in the 4-pool soil C code with the same name but often different units.
311c311
< ! The following code is intentionally similar to that used with the RothC
---
> ! The following code is intentionally similar to that used with the 4-pool C
506c506
< ! These are converted into the units used by TRIFFID and RothC.
---
> ! These are converted into the units used by TRIFFID and 4-pool C model.
536c536
<   decomp_wrate_min_rothc
---
>   decomp_wrate_min_smith
540c540
<   temp_mod_q10, temp_mod_rothc, water_mod_jules, water_mod_rothc,              &
---
>   temp_mod_q10, temp_mod_smith, water_mod_clark, water_mod_smith,              &
546,548c546,548
<   rate_modifier_jules_temp, rate_modifier_jules_water,                         &
<   rate_modifier_rothc_ph,   rate_modifier_rothc_temp,                          &
<   rate_modifier_rothc_water
---
>   rate_modifier_q10_temp, rate_modifier_clark_water,                           &
>   rate_modifier_smith_ph,   rate_modifier_smith_temp,                          &
>   rate_modifier_smith_water
638c638
< CASE ( water_mod_rothc )
---
> CASE ( water_mod_smith )
640,642c640,642
<   CALL rate_modifier_rothc_water( land_pts, nlayer, vs_pts,                    &
<                                   decomp_wrate_min_rothc,                      &
<                                   decomp_wrate_min_rothc, vs_index,            &
---
>   CALL rate_modifier_smith_water( land_pts, nlayer, vs_pts,                    &
>                                   decomp_wrate_min_smith,                      &
>                                   decomp_wrate_min_smith, vs_index,            &
646,647c646,647
< CASE ( water_mod_jules )
<   CALL rate_modifier_jules_water( land_pts, nlayer, vs_pts, vs_index,          &
---
> CASE ( water_mod_clark )
>   CALL rate_modifier_clark_water( land_pts, nlayer, vs_pts, vs_index,          &
657,658c657,658
< CASE ( temp_mod_rothc )
<   CALL rate_modifier_rothc_temp( land_pts, nlayer, vs_pts,                     &
---
> CASE ( temp_mod_smith )
>   CALL rate_modifier_smith_temp( land_pts, nlayer, vs_pts,                     &
662c662
<   CALL rate_modifier_jules_temp( land_pts, nlayer, vs_pts,                     &
---
>   CALL rate_modifier_q10_temp( land_pts, nlayer, vs_pts,                       &
670c670
< CALL rate_modifier_rothc_ph( land_pts, nlayer, vs_pts,                         &
---
> CALL rate_modifier_smith_ph( land_pts, nlayer, vs_pts,                         &
diff -r vn7.0copy1_c4/src/./science/soil_biogeochem/ecosse/ecosse_nitrification_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/soil_biogeochem/ecosse/ecosse_nitrification_mod.F90
301c301
<   temp_mod_q10, temp_mod_rothc, water_mod_jules, water_mod_rothc,              &
---
>   temp_mod_q10, temp_mod_smith, water_mod_clark, water_mod_smith,              &
311,312c311,312
<   rate_modifier_jules_temp, rate_modifier_jules_water,                         &
<   rate_modifier_rothc_temp, rate_modifier_rothc_water
---
>   rate_modifier_q10_temp, rate_modifier_clark_water,                           &
>   rate_modifier_smith_temp, rate_modifier_smith_water
393c393
< CASE ( water_mod_rothc )
---
> CASE ( water_mod_smith )
396c396
<   CALL rate_modifier_rothc_water( land_pts, nlayer, vs_pts,                    &
---
>   CALL rate_modifier_smith_water( land_pts, nlayer, vs_pts,                    &
401c401
< CASE ( water_mod_jules )
---
> CASE ( water_mod_clark )
403c403
<   CALL rate_modifier_jules_water( land_pts, nlayer, vs_pts, vs_index,          &
---
>   CALL rate_modifier_clark_water( land_pts, nlayer, vs_pts, vs_index,          &
413c413
< CASE ( temp_mod_rothc )
---
> CASE ( temp_mod_smith )
416c416
<   CALL rate_modifier_rothc_temp( land_pts, nlayer, vs_pts,                     &
---
>   CALL rate_modifier_smith_temp( land_pts, nlayer, vs_pts,                     &
421c421
<   CALL rate_modifier_jules_temp( land_pts, nlayer, vs_pts,                     &
---
>   CALL rate_modifier_q10_temp( land_pts, nlayer, vs_pts,                       &
diff -r vn7.0copy1_c4/src/./science/soil_biogeochem/ecosse/ecosse_rate_modifier_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/soil_biogeochem/ecosse/ecosse_rate_modifier_mod.F90
37,39c37,39
< PUBLIC rate_modifier_jules_temp, rate_modifier_jules_water,                    &
<        rate_modifier_rothc_ph,   rate_modifier_rothc_temp,                     &
<        rate_modifier_rothc_water
---
> PUBLIC rate_modifier_q10_temp, rate_modifier_clark_water,                      &
>        rate_modifier_smith_ph,   rate_modifier_smith_temp,                     &
>        rate_modifier_smith_water
46c46
< SUBROUTINE rate_modifier_rothc_ph( land_pts, nlayer, vs_pts,                   &
---
> SUBROUTINE rate_modifier_smith_ph( land_pts, nlayer, vs_pts,                   &
51c51
< !   RothC formulation: Eqn.3 of Smith et al. (2010).
---
> !   4-pool soil C formulation: Eqn.3 of Smith et al. (2010).
117c117
< END SUBROUTINE rate_modifier_rothc_ph
---
> END SUBROUTINE rate_modifier_smith_ph
121c121
< SUBROUTINE rate_modifier_rothc_temp( land_pts, nlayer, vs_pts,                 &
---
> SUBROUTINE rate_modifier_smith_temp( land_pts, nlayer, vs_pts,                 &
126,127c126,127
< !   Subroutine to calculate the temperature rate modifying factor using the
< !   RothC formulation: Eqn.4 of Smith et al. (2010).
---
> !   Subroutine to calculate the temperature rate modifying factor:
> !   Eqn.4 of Smith et al. (2010).
131c131
<   decomp_temp_coeff_rothc
---
>   decomp_temp_coeff_smith
179,181c179,181
<       temp_rate(i,il) = decomp_temp_coeff_rothc(1) /                           &
<                         ( 1.0 + EXP( decomp_temp_coeff_rothc(2) /              &
<                           ( soilT_degC(i,il) + decomp_temp_coeff_rothc(3) )    &
---
>       temp_rate(i,il) = decomp_temp_coeff_smith(1) /                           &
>                         ( 1.0 + EXP( decomp_temp_coeff_smith(2) /              &
>                           ( soilT_degC(i,il) + decomp_temp_coeff_smith(3) )    &
188c188
< END SUBROUTINE rate_modifier_rothc_temp
---
> END SUBROUTINE rate_modifier_smith_temp
193c193
< SUBROUTINE rate_modifier_rothc_water( land_pts, nlayer, vs_pts,                &
---
> SUBROUTINE rate_modifier_smith_water( land_pts, nlayer, vs_pts,                &
199,200c199,200
< !   Subroutine to calculate the water rate modifying factor using the RothC
< !   formulation: Eqn.1 of Smith et al. (2010).
---
> !   Subroutine to calculate the water rate modifying factor:
> !   Eqn.1 of Smith et al. (2010).
289c289
< END SUBROUTINE rate_modifier_rothc_water
---
> END SUBROUTINE rate_modifier_smith_water
294c294
< SUBROUTINE rate_modifier_jules_temp( land_pts, nlayer, vs_pts, vs_index,       &
---
> SUBROUTINE rate_modifier_q10_temp( land_pts, nlayer, vs_pts, vs_index,         &
347c347
< END SUBROUTINE rate_modifier_jules_temp
---
> END SUBROUTINE rate_modifier_q10_temp
352c352
< SUBROUTINE rate_modifier_jules_water( land_pts,nlayer,vs_pts,vs_index,         &
---
> SUBROUTINE rate_modifier_clark_water( land_pts,nlayer,vs_pts,vs_index,         &
363c363
<   decomp_wrate_min_jules
---
>   decomp_wrate_min_clark
423c423
< one_minus_min = 1.0 - decomp_wrate_min_jules
---
> one_minus_min = 1.0 - decomp_wrate_min_clark
444c444
<       water_rate(i,il) = decomp_wrate_min_jules +  one_minus_min               &
---
>       water_rate(i,il) = decomp_wrate_min_clark +  one_minus_min               &
455c455
<       water_rate(i,il) = decomp_wrate_min_jules
---
>       water_rate(i,il) = decomp_wrate_min_clark
461c461
< END SUBROUTINE rate_modifier_jules_water
---
> END SUBROUTINE rate_modifier_clark_water
diff -r vn7.0copy1_c4/src/./science/soil_biogeochem/soil_biogeochem_utils_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/soil_biogeochem/soil_biogeochem_utils_mod.F90
32c32
< PUBLIC soil_n_precalc
---
> PUBLIC soil_n_precalc, calc_litc_norm
74c74
<   soil_model_rothc, soil_model_ecosse,                                         &
---
>   soil_model_4pool, soil_model_ecosse,                                         &
234c234
< CASE ( soil_model_rothc )
---
> CASE ( soil_model_4pool )
268c268
<   CASE ( soil_model_rothc )
---
>   CASE ( soil_model_4pool )
334a335
> !#############################################################################
336a338,409
> SUBROUTINE calc_litc_norm(litc_norm)
> 
> !-----------------------------------------------------------------------------
> ! Description:
> !   Set the normalisation factor for vertical profile of litter input.
> !-----------------------------------------------------------------------------
> 
> USE ancil_info, ONLY: dim_cslayer
> 
> USE jules_soil_biogeochem_mod, ONLY:                                           &
>   soil_model_4pool, soil_model_ecosse,                                         &
>   soil_bgc_model, tau_lit
> 
> #if !defined(UM_JULES)
> USE jules_soil_ecosse_mod, ONLY: dz_soilc
> #endif
> 
> USE jules_soil_mod, ONLY: dzsoil
> 
> IMPLICIT NONE
> 
> !-----------------------------------------------------------------------------
> ! Array arguments with intent(inout)
> !-----------------------------------------------------------------------------
> REAL(KIND=real_jlslsm), INTENT(IN OUT) ::                                      &
>   litc_norm
>     ! Normalisation factor for vertical profile of litter input
> 
> !-----------------------------------------------------------------------------
> ! Local variables.
> !-----------------------------------------------------------------------------
> REAL(KIND=real_jlslsm) :: dz(dim_cslayer)
>     ! Thicknesses of soil layers (m).
> 
> LOGICAL :: have_layers
>     !  T if we have multiple soil layers, else F.
> 
> INTEGER :: iz
> 
> CHARACTER(LEN=*), PARAMETER :: RoutineName = 'CALC_LITC_NORM'
> 
> !-----------------------------------------------------------------------------
> ! Set flag for multiple layers.
> !-----------------------------------------------------------------------------
> have_layers = dim_cslayer > 1
> 
> !-----------------------------------------------------------------------------
> ! Get soil layer thicknesses.
> !-----------------------------------------------------------------------------
> SELECT CASE ( soil_bgc_model )
> CASE ( soil_model_4pool )
>   dz(1:dim_cslayer) = dzsoil(1:dim_cslayer)
> #if !defined(UM_JULES)
> CASE ( soil_model_ecosse )
>   dz(:) = dz_soilc(:)
> #endif
> END SELECT
> 
> !-----------------------------------------------------------------------------
> ! Calculate dz * exp(-tau*z) for mid-point depth in each layer.
> !-----------------------------------------------------------------------------
> IF ( have_layers ) THEN
>   litc_norm =  dz(1) * EXP( -tau_lit * 0.5 * dz(1) )
>   DO iz = 2,dim_cslayer
>     litc_norm = litc_norm + dz(iz) *                                           &
>                 EXP( -tau_lit * ( SUM(dz(1:iz-1)) + 0.5 * dz(iz) ) )
>   END DO
> END IF
> 
> RETURN
> 
> END SUBROUTINE calc_litc_norm
diff -r vn7.0copy1_c4/src/./science/soil_biogeochem/soil_inorg_n_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/soil_biogeochem/soil_inorg_n_mod.F90
58c58
<   soil_model_rothc,                                                            &
---
>   soil_model_4pool,                                                            &
125c125
< IF ( soil_bgc_model == soil_model_rothc ) THEN
---
> IF ( soil_bgc_model == soil_model_4pool ) THEN
152c152
< END IF  !  soil_bgc_model = RothC
---
> END IF  !  soil_bgc_model = 4-pool soil C
172c172
<   soil_model_ecosse, soil_model_rothc,                                         &
---
>   soil_model_ecosse, soil_model_4pool,                                         &
276c276
< IF ( soil_bgc_model == soil_model_rothc .OR.                                   &
---
> IF ( soil_bgc_model == soil_model_4pool .OR.                                   &
358c358
<   soil_model_ecosse, soil_model_rothc,                                         &
---
>   soil_model_ecosse, soil_model_4pool,                                         &
477c477
< IF ( soil_bgc_model == soil_model_rothc .OR.                                   &
---
> IF ( soil_bgc_model == soil_model_4pool .OR.                                   &
498c498
<     IF ( soil_bgc_model == soil_model_rothc ) THEN
---
>     IF ( soil_bgc_model == soil_model_4pool ) THEN
584c584
<   soil_model_ecosse, soil_model_rothc,                                         &
---
>   soil_model_ecosse, soil_model_4pool,                                         &
731c731
<     IF ( soil_bgc_model == soil_model_rothc .OR.                               &
---
>     IF ( soil_bgc_model == soil_model_4pool .OR.                               &
783c783
<   IF ( soil_bgc_model == soil_model_rothc ) THEN
---
>   IF ( soil_bgc_model == soil_model_4pool ) THEN
diff -r vn7.0copy1_c4/src/./science/surface/elevate.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/surface/elevate.F90
26c26
<  land_pts,nsurft,surft_pts,land_index,surft_index,                             &
---
>  land_pts,nsurft,n_wtrac_jls,surft_pts,land_index,surft_index,                 &
28c28
<  t_elev,q_elev)
---
>  t_elev,q_elev,qw_1_wtrac,q_elev_wtrac)
42a43,44
> USE jules_water_tracers_mod, ONLY: l_wtrac_jls, wtrac_calc_ratio_fn_jules
> 
52a55,56
> ,n_wtrac_jls                                                                   &
>                        ! IN Number of water tracers in JULES
70c74
< ,surf_hgt(land_pts,nsurft)
---
> ,surf_hgt(land_pts,nsurft)                                                     &
72a77,79
> ,qw_1_wtrac(tdims%i_start:tdims%i_end,tdims%j_start:tdims%j_end,n_wtrac_jls)
>                        ! IN Total water tracer content of lowest
> !                            !    atmospheric layer (kg per kg air).
85a93,97
> REAL(KIND=real_jlslsm), INTENT(OUT) ::                                         &
>  q_elev_wtrac(land_pts,nsurft,n_wtrac_jls)
>                           ! OUT Water tracer specific humidity at elevated
>                                 !  height (kg per kg air)
> 
98c110
< ,delevation
---
> ,delevation                                                                    &
100c112,113
< 
---
> ,ratio_wt
>                         ! Water tracer to water ratio at lowest atmos level
109c122,125
< ,n                   ! Tile index loop counter
---
> ,n                                                                             &
>                      ! Tile index loop counter
> ,i_wt
>                      ! Water tracer loop counter
179a196,237
> 
> ! Water tracers - set elevated water tracer specific elevated value
> 
> IF (l_wtrac_jls) THEN
> 
> !$OMP PARALLEL DEFAULT(NONE) PRIVATE(l,i,j,k,i_wt,n,ratio_wt)                  &
> !$OMP SHARED(nsurft, land_pts, q_elev, q_elev_wtrac, surft_pts,                &
> !$OMP        surft_index, land_index, t_i_length, qw_1, qw_1_wtrac,            &
> !$OMP        n_wtrac_jls)
> 
>   ! Initialise output arrays
>   DO i_wt = 1, n_wtrac_jls
>     DO n = 1,nsurft
> !$OMP DO SCHEDULE(STATIC)
>       DO l = 1,land_pts
>         q_elev_wtrac(l,n,i_wt) = 0.0
>       END DO
> !$OMP END DO
>     END DO
>   END DO
> 
>   ! Set elevated water tracer value to have same ratio as lowest atmospheric
>   ! level
>   DO i_wt = 1, n_wtrac_jls
>     DO n = 1,nsurft
> !$OMP DO SCHEDULE(STATIC)
>       DO k = 1,surft_pts(n)
>         l = surft_index(k,n)
>         j=(land_index(l) - 1) / t_i_length + 1
>         i = land_index(l) - (j-1) * t_i_length
> 
>         ratio_wt = wtrac_calc_ratio_fn_jules(i_wt,                             &
>                       qw_1_wtrac(i,j,i_wt), qw_1(i,j))
>         q_elev_wtrac(l,n,i_wt) = ratio_wt * q_elev(l,n)
> 
>       END DO
> !$OMP END DO NOWAIT
>     END DO
>   END DO
> !$OMP END PARALLEL
> END IF
> 
diff -r vn7.0copy1_c4/src/./science/surface/fcdch.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/surface/fcdch.F90
44,45c44,49
< USE atm_fields_bounds_mod, ONLY:tdims
< USE theta_field_sizes, ONLY: t_i_length
---
> USE atm_fields_bounds_mod, ONLY: tdims
> USE planet_constants_mod,  ONLY: g, cp, vkman
> USE sf_flux_mod,           ONLY: sf_flux
> USE sf_resist_mod,         ONLY: sf_resist
> USE theta_field_sizes,     ONLY: t_i_length
> USE water_constants_mod,   ONLY: lc
47,52d50
< USE water_constants_mod, ONLY: lc
< USE sf_resist_mod, ONLY: sf_resist
< USE sf_flux_mod, ONLY: sf_flux
< USE qsat_mod, ONLY: qsat, qsat_mix
< 
< USE planet_constants_mod, ONLY: g, cp, vkman
66a65
> 
291c290,293
< ,fraca(points)                                                                 &
---
> ,fracaero_t(points)                                                            &
>                      ! Total fraction of surface moisture flux with
> !                          !     only aerodynamic resistance
> ,fracaero_s(points)                                                            &
293c295,296
< !                          !     only aerodynamic resistance.
---
> !                          !     only aerodynamic resistance
> !                          !     over the frozen part of the surface
296c299
< !                          !     resistance factor for fraction 1-FRACA.
---
> !                          !     resistance factor for fraction 1-fracaero_t.
299c302
< !                          !     FRACA+(1-FRACA)*RESFS.
---
> !                          !     fracaero_t+(1-fracaero_t)*resfs.
341a345,347
> INTEGER :: indexi(surft_pts), indexj(surft_pts)
>               ! Arrays to store horizontal field indices i and j
> 
389a396,402
> 
> DO k = 1,surft_pts
>   l = surft_index(k)
>   indexj(k) = (pts_index(l) - 1) / t_i_length + 1
>   indexi(k) = pts_index(l) - (indexj(k) - 1) * t_i_length
> END DO
> 
399c412
< !$OMP  beta_cnv_bl,db,vshr,recip_l_mo,zh,srf_ex_cnv_gust,g) IF(surft_pts>1)
---
> !$OMP  beta_cnv_bl,db,vshr,recip_l_mo,zh,srf_ex_cnv_gust,g,indexi,indexj) IF(surft_pts>1)
403d415
<     !CDIR NODEP
406,408c418,419
<       l = surft_index(k)
<       j =(pts_index(l) - 1) / t_i_length + 1
<       i = pts_index(l) - (j-1) * t_i_length
---
>       j = indexj(k)
>       i = indexi(k)
421d431
<   !CDIR NODEP
425,426c435,436
<     j =(pts_index(l) - 1) / t_i_length + 1
<     i = pts_index(l) - (j-1) * t_i_length
---
>     j = indexj(k)
>     i = indexi(k)
471d480
<     !CDIR NODEP
475c484
< !$OMP  cdv,cdv_std,phi_m) IF(surft_pts>1)
---
> !$OMP  cdv,cdv_std,phi_m,indexi,indexj) IF(surft_pts>1)
478,479c487,488
<       j=(pts_index(l) - 1) / t_i_length + 1
<       i = pts_index(l) - (j-1) * t_i_length
---
>       j = indexj(k)
>       i = indexi(k)
505d513
<     !CDIR NODEP
509c517
< !$OMP  cdv,cdv_std,phi_m) IF(surft_pts>1)
---
> !$OMP  cdv,cdv_std,phi_m,indexi,indexj) IF(surft_pts>1)
512,513c520,521
<       j=(pts_index(l) - 1) / t_i_length + 1
<       i = pts_index(l) - (j-1) * t_i_length
---
>       j = indexj(k)
>       i = indexi(k)
546c554
< !$OMP PARALLEL DO IF(surft_pts > 1) DEFAULT(NONE) PRIVATE(i, j, k, l)          &
---
> !$OMP PARALLEL IF(surft_pts > 1) DEFAULT(NONE) PRIVATE(i, j, k, l)             &
548,549c556,558
< !$OMP        db_older, chv_dim, chv, vshr, rhostar, epdt, dq, timestep)        &
< !$OMP SCHEDULE(STATIC)
---
> !$OMP        db_older, chv_dim, chv, vshr, rhostar, epdt, dq, timestep,        &
> !$OMP        rhokh_can, cp, cdv, l_aggregate, can_model,indexi,indexj)
> !$OMP DO SCHEDULE(STATIC)
552,553c561,562
<       j = (pts_index(l) - 1) / t_i_length + 1
<       i = pts_index(l) - (j-1) * t_i_length
---
>       j = indexj(k)
>       i = indexi(k)
555c564
<       ! Save initial values ready for iterations and calcualte the
---
>       ! Save initial values ready for iterations and calculate the
562c571
< !$OMP END PARALLEL DO
---
> !$OMP END DO NOWAIT
565,567c574
< !$OMP PARALLEL DO IF(surft_pts > 1) DEFAULT(NONE) PRIVATE(i, j, k, l)          &
< !$OMP SHARED(surft_pts, surft_index, pts_index, t_i_length,                    &
< !$OMP        rhokh_can, rhostar, cp, cdv) SCHEDULE(STATIC)
---
> !$OMP DO SCHEDULE(STATIC)
570,571c577,578
<         j = (pts_index(l) - 1) / t_i_length + 1
<         i = pts_index(l) - (j-1) * t_i_length
---
>         j = indexj(k)
>         i = indexi(k)
576c583
< !$OMP END PARALLEL DO
---
> !$OMP END DO
577a585
> !$OMP END PARALLEL
583c591
<      snowdep,snow,vshr,fraca,                                                  &
---
>      snowdep,snow,vshr,tstar,fracaero_t,fracaero_s,                            &
598c606
< !$OMP        rhokh, rhostar, chv) SCHEDULE(STATIC)
---
> !$OMP        rhokh, rhostar, chv, indexi, indexj) SCHEDULE(STATIC)
601,602c609,610
<         j = (pts_index(l) - 1) / t_i_length + 1
<         i = pts_index(l) - (j-1) * t_i_length
---
>         j = indexj(k)
>         i = indexi(k)
609c617
<       ! Calcualte new values for the sensible and latent heat fluxes
---
>       ! Calculate new values for the sensible and latent heat fluxes
616c624
<        radnet,resft,rhokh,l_soil_point,                                        &
---
>        radnet,resft,fracaero_s(:),rhokh,l_soil_point,                          &
632c640
< !$OMP        db_diff_old, db_diff, db_old, db_older) SCHEDULE(STATIC)
---
> !$OMP        db_diff_old, db_diff, db_old, db_older, indexi, indexj) SCHEDULE(STATIC)
635,636c643,644
<         j = (pts_index(l) - 1) / t_i_length + 1
<         i = pts_index(l) - (j-1) * t_i_length
---
>         j = indexj(k)
>         i = indexi(k)
670c678
<         ! Store the current values of the  variables in case of non-convergence
---
>         ! Store the current values of the variables in case of non-convergence
708d715
<     !CDIR NODEP
713c720
< !$OMP  beta_cnv_bl,wstrcnvgust) IF(surft_pts>1)
---
> !$OMP  beta_cnv_bl,wstrcnvgust,z1_tq,z1_uv,indexi,indexj) IF(surft_pts>1)
716,717c723,724
<       j=(pts_index(l) - 1) / t_i_length + 1
<       i = pts_index(l) - (j-1) * t_i_length
---
>       j = indexj(k)
>       i = indexi(k)
763,772d769
<     END DO
< !$OMP END PARALLEL DO
< 
< !$OMP PARALLEL DO DEFAULT(NONE) SCHEDULE(STATIC) PRIVATE(k,l,j,i)              &
< !$OMP  SHARED(surft_pts,surft_index,pts_index,t_i_length,db,z1_tq,             &
< !$OMP   z1_uv,recip_l_mo,vshr) IF(surft_pts>1)
<     DO k = 1,surft_pts
<       l = surft_index(k)
<       j=(pts_index(l) - 1) / t_i_length + 1
<       i = pts_index(l) - (j-1) * t_i_length
796d792
<       !CDIR NODEP
821d816
<       !CDIR NODEP
838c833,834
< !$OMP PARALLEL DEFAULT(NONE) PRIVATE(k,l,j,i,wgst_tmp,cnst_cndd_1a,cnst_cndd_2a) &
---
> !$OMP PARALLEL DEFAULT(NONE)                                                   &
> !$OMP  PRIVATE(k,l,j,i,wgst_tmp,cnst_cndd_1a,cnst_cndd_2a)                     &
840c836
< !$OMP  db,vshr,recip_l_mo,zh,srf_ex_cnv_gust,g) IF(surft_pts>1)
---
> !$OMP  db,vshr,recip_l_mo,zh,srf_ex_cnv_gust,g,indexi,indexj) IF(surft_pts>1)
844d839
<     !CDIR NODEP
847,849c842,843
<       l = surft_index(k)
<       j =(pts_index(l) - 1) / t_i_length + 1
<       i = pts_index(l) - (j-1) * t_i_length
---
>       j = indexj(k)
>       i = indexi(k)
862d855
<   !CDIR NODEP
866,867c859,860
<     j=(pts_index(l) - 1) / t_i_length + 1
<     i = pts_index(l) - (j-1) * t_i_length
---
>     j = indexj(k)
>     i = indexi(k)
911d903
<     !CDIR NODEP
915c907
< !$OMP  cdv,cdv_std,phi_m) IF(surft_pts>1)
---
> !$OMP  cdv,cdv_std,phi_m,indexi,indexj) IF(surft_pts>1)
918,919c910,911
<       j=(pts_index(l) - 1) / t_i_length + 1
<       i = pts_index(l) - (j-1) * t_i_length
---
>       j = indexj(k)
>       i = indexi(k)
944d935
<     !CDIR NODEP
948c939
< !$OMP  cdv,cdv_std,phi_m) IF(surft_pts>1)
---
> !$OMP  cdv,cdv_std,phi_m,indexi,indexj) IF(surft_pts>1)
951,952c942,943
<       j=(pts_index(l) - 1) / t_i_length + 1
<       i = pts_index(l) - (j-1) * t_i_length
---
>       j = indexj(k)
>       i = indexi(k)
984c975
< !$OMP PARALLEL DO IF(surft_pts > 1) DEFAULT(NONE) PRIVATE(i, j, k, l)          &
---
> !$OMP PARALLEL IF(surft_pts > 1) DEFAULT(NONE) PRIVATE(i, j, k, l)             &
986,987c977,979
< !$OMP        db_older, chv_dim, chv, vshr, rhostar, epdt, dq, timestep)        &
< !$OMP SCHEDULE(STATIC)
---
> !$OMP        db_older, chv_dim, chv, vshr, rhostar, epdt, dq, timestep,        &
> !$OMP        rhokh_can, cp, cdv, l_aggregate, can_model, indexi, indexj)
> !$OMP DO SCHEDULE(STATIC)
990,991c982,983
<       j = (pts_index(l) - 1) / t_i_length + 1
<       i = pts_index(l) - (j-1) * t_i_length
---
>       j = indexj(k)
>       i = indexi(k)
993c985
<       ! Save initial values ready for iterations and calcualte the
---
>       ! Save initial values ready for iterations and calculate the
1000c992
< !$OMP END PARALLEL DO
---
> !$OMP END DO NOWAIT
1003,1005c995
< !$OMP PARALLEL DO IF(surft_pts > 1) DEFAULT(NONE) PRIVATE(i, j, k, l)          &
< !$OMP SHARED(surft_pts, surft_index, pts_index, t_i_length,                    &
< !$OMP        rhokh_can, rhostar, cp, cdv) SCHEDULE(STATIC)
---
> !$OMP DO SCHEDULE(STATIC)
1008,1009c998,999
<         j = (pts_index(l) - 1) / t_i_length + 1
<         i = pts_index(l) - (j-1) * t_i_length
---
>         j = indexj(k)
>         i = indexi(k)
1014c1004
< !$OMP END PARALLEL DO
---
> !$OMP END DO
1015a1006
> !$OMP END PARALLEL
1021c1012
<      snowdep,snow,vshr,fraca,                                                  &
---
>      snowdep,snow,vshr,tstar,fracaero_t,fracaero_s,                            &
1036c1027
< !$OMP        rhokh, rhostar, chv) SCHEDULE(STATIC)
---
> !$OMP        rhokh, rhostar, chv, indexi, indexj) SCHEDULE(STATIC)
1039,1040c1030,1031
<         j = (pts_index(l) - 1) / t_i_length + 1
<         i = pts_index(l) - (j-1) * t_i_length
---
>         j = indexj(k)
>         i = indexi(k)
1047c1038
<       ! Calcualte new values for the sensible and latent heat fluxes
---
>       ! Calculate new values for the sensible and latent heat fluxes
1054c1045
<        radnet,resft,rhokh,l_soil_point,                                        &
---
>        radnet,resft,fracaero_s(:),rhokh,l_soil_point,                          &
1070c1061
< !$OMP        db_diff_old, db_diff, db_old, db_older) SCHEDULE(STATIC)
---
> !$OMP        db_diff_old, db_diff, db_old, db_older, indexi, indexj) SCHEDULE(STATIC)
1073,1074c1064,1065
<         j = (pts_index(l) - 1) / t_i_length + 1
<         i = pts_index(l) - (j-1) * t_i_length
---
>         j = indexj(k)
>         i = indexi(k)
1108c1099
<         ! Store the current values of the  variables in case of non-convergence
---
>         ! Store the current values of the variables in case of non-convergence
1147d1137
<     !CDIR NODEP
1149,1152c1139,1142
< !$OMP  PRIVATE(k,l,j,i,b_flux,u_s2,w_s,u_s_std2)                               &
< !$OMP  SHARED(surft_pts,surft_index,pts_index,t_i_length,chv,db,cdv,           &
< !$OMP  vshr,cdv_std,u_s_std,zh,v_s,v_s_std,recip_l_mo,srf_ex_cnv_gust,         &
< !$OMP  wstrcnvgust,cor_mo_iter) IF(surft_pts>1)
---
> !$OMP  PRIVATE(k, l, j, i, b_flux, u_s2, w_s, u_s_std2)                        &
> !$OMP  SHARED(surft_pts, surft_index, pts_index, t_i_length, chv, db, cdv,     &
> !$OMP  vshr, cdv_std, u_s_std, zh, v_s, v_s_std, recip_l_mo, srf_ex_cnv_gust,  &
> !$OMP  wstrcnvgust, cor_mo_iter, z1_uv, z1_tq, indexi, indexj) IF(surft_pts>1)
1155,1156c1145,1146
<       j=(pts_index(l) - 1) / t_i_length + 1
<       i = pts_index(l) - (j-1) * t_i_length
---
>       j = indexj(k)
>       i = indexi(k)
1206,1207d1195
<     END DO
< !$OMP END PARALLEL DO
1209,1216d1196
< !$OMP PARALLEL DO DEFAULT(NONE) SCHEDULE(STATIC) PRIVATE(k,l,j,i)              &
< !$OMP  SHARED(surft_pts,surft_index,pts_index,t_i_length,db,z1_tq,             &
< !$OMP   z1_uv,recip_l_mo,cor_mo_iter,vshr) IF(surft_pts>1)
<     DO k = 1,surft_pts
<       l = surft_index(k)
<       j=(pts_index(l) - 1) / t_i_length + 1
<       i = pts_index(l) - (j-1) * t_i_length
<       !
1222a1203
> 
1242d1222
<       !CDIR NODEP
1267d1246
<       !CDIR NODEP
1319d1297
< !CDIR NODEP
1322c1300
< !$OMP  vshr,cdv_std,chv) IF(surft_pts>1)
---
> !$OMP  vshr,cdv_std,chv, indexi, indexj) IF(surft_pts>1)
1325,1326c1303,1304
<   j=(pts_index(l) - 1) / t_i_length + 1
<   i = pts_index(l) - (j-1) * t_i_length
---
>   j = indexj(k)
>   i = indexi(k)
diff -r vn7.0copy1_c4/src/./science/surface/generate_anthrop_heat_jls_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/surface/generate_anthrop_heat_jls_mod.F90
22c22
<               l_anthrop_heat_src,                                              &
---
>               surft_pts, surft_index,                                          &
27,32c27
<               anthrop_heat_surft,                                              &
<               !Ancil_info
<               l_lice_point)
< 
< !Use in module subroutines
< USE tilepts_mod, ONLY: tilepts
---
>               anthrop_heat_surft)
44c39
< USE jules_surface_mod, ONLY: l_aggregate, l_urban2t
---
> USE jules_surface_mod, ONLY: l_urban2t, l_anthrop_heat_use_wrr
49,53d43
< USE jules_print_mgr, ONLY:                                                     &
<     jules_message,                                                             &
<     jules_print,                                                               &
<     PrNorm
< 
69,71d58
< ! IN Switch for  anthropogenic heat source
< LOGICAL, INTENT(IN) :: l_anthrop_heat_src
< 
79c66
< REAL(KIND=real_jlslsm), INTENT(IN OUT)    :: anthrop_heat_surft(land_pts,nsurft)
---
> REAL(KIND=real_jlslsm), INTENT(IN OUT) :: anthrop_heat_surft(land_pts,nsurft)
82,88c69,72
< LOGICAL, INTENT(IN) :: l_lice_point(land_pts)
< 
< ! Local Variables
< INTEGER ::                                                                     &
<    surft_index(land_pts,ntype),   & ! Index of tile points
<    surft_pts(ntype),                 & ! Number of tile points
<    urban_orig                          ! Original value of urban
---
> INTEGER, INTENT(IN) ::                                                         &
>    surft_index(land_pts,ntype),                                                &
>                               ! Index of tile points  : Only used for
>    surft_pts(ntype)           ! Number of tile points : urban_canyon
94,97c78,81
<    anthrop_heat_urban(land_pts),                                               &
<                ! For checking: Copy of anthrop_heat_surft(:,urban)
<    urban_agg,                                                                  &
<                ! For checking: anthrop_heat_surft aggregated for urban tiles
---
>    furb,                                                                       &
>                ! Total urban fraction
>    anthrop_heat_urban,                                                         &
>                ! Anthropogenic heat on the total urbanised surface
129,145c113,114
< ! Initialise arrays
< anthrop_heat_urban(:) = 0.0
< 
< ! surft_pts isn't set until after ni_bl_ctl so need to call it here.
< CALL tilepts( land_pts, frac, surft_pts, surft_index, l_lice_point )
< 
< ! Check whether anthropogenic heat is switched and make sure that
< ! we have an urban tile
< IF ( .NOT. l_aggregate .AND.                                                   &
<    l_anthrop_heat_src .AND. ( urban > 0 .OR. urban_canyon > 0 ) ) THEN
< 
<   ! Check which urban tile is present to make sure that the following is
<   ! excecuted regardless of urban scheme. "urban" will not be present if
<   ! using a two-tile urban scheme i.e. "urban_canyon" will be present instead
<   urban_orig = urban
<   IF ( urban_canyon > 0 .AND. urban < 0 ) urban = urban_canyon
< 
---
> ! Make sure that we either have an urban tile
> IF ( urban > 0 .OR. urban_canyon > 0 ) THEN
167,169c136
<   anthrop_heat_surft(:,urban)= mm * urban_month(im1)                           &
<                       + (1.0 - mm) * urban_month(im)
<   anthrop_heat_urban(:) = anthrop_heat_surft(:,urban)
---
>   anthrop_heat_urban = mm * urban_month(im1) + (1.0 - mm) * urban_month(im)
172c139,140
<   ! the canyon and roof tiles depending on anthrop_heat_scale.
---
>   ! the canyon and roof tiles depending on anthrop_heat_scale otherwise copy it
>   ! to the urban tile.
174,204c142,162
<     n = urban_canyon
<     DO k = 1,surft_pts(n)
<       l = surft_index(k,n)
<       ! Here anthrop_heat_surft(urban_roof) is a fraction (anthrop_heat_scale)
<       ! of anthrop_heat_surft(urban_canyon) where wrr_gb is the canyon
<       ! fraction. The total from the urban tile is conserved.
<       anthrop_heat_surft(l,n) = anthrop_heat_surft(l,urban) /                  &
<          ( anthrop_heat_scale * ( 1.0 - wrr_gb(l) ) + wrr_gb (l) )
<       anthrop_heat_surft(l,urban_roof) =                                       &
<          anthrop_heat_scale * anthrop_heat_surft(l,n)
<     END DO
<   END IF
< 
<   urban = urban_orig   ! Reset urban value to prevent errors
< 
< END IF
< 
< ! Check that anthrop_heat_surft is conserved
< IF ( l_urban2t .AND. .NOT. l_aggregate ) THEN
<   n = urban_canyon
<   DO k = 1, surft_pts(n)
<     l = surft_index(k,n)
<     urban_agg = anthrop_heat_surft(l,urban_roof) * ( 1.0 - wrr_gb(l) ) +       &
<        anthrop_heat_surft(l,urban_canyon) * wrr_gb(l)
<     IF ( ABS( urban_agg - anthrop_heat_urban(l) ) > 1.0e-3 ) THEN
<       WRITE(jules_message,*)                                                   &
<           'WARNING: anthrop_heat not conserved on urban tiles for', k, l
<       CALL jules_print('generate_anthrop_heat_jls',jules_message,level = PrNorm)
<       WRITE(jules_message,*) 'Aggregated', urban_agg,                          &
<           'Urban', anthrop_heat_urban(l)
<       CALL jules_print('generate_anthrop_heat_jls',jules_message,level = PrNorm)
---
>     ! anthrop_heat_surft(urban_roof) is a fraction (anthrop_heat_scale)
>     ! of anthrop_heat_surft(urban_canyon). The total from the urban tile is
>     ! conserved.
>     IF ( l_anthrop_heat_use_wrr ) THEN
>       ! W/R supplied so use it (bit comparability plus less calculations)
>       DO k = 1,surft_pts(urban_canyon)
>         l = surft_index(k,urban_canyon)
>         anthrop_heat_surft(l,urban_canyon) = anthrop_heat_urban /              &
>            ( anthrop_heat_scale * ( 1.0 - wrr_gb(l) ) + wrr_gb (l) )
>         anthrop_heat_surft(l,urban_roof) =                                     &
>            anthrop_heat_scale * anthrop_heat_surft(l,urban_canyon)
>       END DO
>     ELSE
>       DO k = 1,surft_pts(urban_canyon)
>         l = surft_index(k,urban_canyon)
>         furb = frac(l,urban_canyon) + frac(l,urban_roof)
>         anthrop_heat_surft(l,urban_canyon) = anthrop_heat_urban * furb /       &
>            ( frac(l,urban_canyon) + anthrop_heat_scale * frac(l,urban_roof) )
>         anthrop_heat_surft(l,urban_roof) =                                     &
>            anthrop_heat_scale * anthrop_heat_surft(l,urban_canyon)
>       END DO
206c164,166
<   END DO
---
>   ELSE IF ( urban > 0 ) THEN
>     anthrop_heat_surft(:,urban) = anthrop_heat_urban
>   END IF
diff -r vn7.0copy1_c4/src/./science/surface/im_sf_pt2_jls.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/surface/im_sf_pt2_jls.F90
40c40
< USE model_domain_mod, ONLY: model_type, mt_single_column
---
> USE model_domain_mod, ONLY: model_type, mt_single_column, mt_lfric
300c300
< IF (model_type /= mt_single_column) THEN
---
> IF ((model_type /= mt_single_column) .AND. (model_type /= mt_lfric)) THEN
373c373
<   IF (model_type /= mt_single_column) THEN
---
>   IF ((model_type /= mt_single_column) .AND. (model_type /= mt_lfric)) THEN
874c874
<   IF (model_type /= mt_single_column) THEN
---
>   IF ((model_type /= mt_single_column) .AND. (model_type /= mt_lfric)) THEN
Only in vn7.0copy1_c4/src/./science/surface: .ipynb_checkpoints
diff -r vn7.0copy1_c4/src/./science/surface/jules_griddiag_sf_explicit_jls.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/surface/jules_griddiag_sf_explicit_jls.F90
63c63
<  ssi_index, sice_index_ncat, sice_frac_ncat,                                   &
---
>  ssi_index, sice_index_ncat, sice_frac_ncat, sice_pts_ncat,                    &
98d97
< USE ancil_info, ONLY: sice_pts_ncat
354c353,354
<   sice_index_ncat(t_i_length * t_j_length,nice)
---
>   sice_index_ncat(t_i_length * t_j_length,nice),                               &
>   sice_pts_ncat(nice)
485c485
< !$OMP PARALLEL DO SCHEDULE(STATIC) DEFAULT(NONE) PRIVATE(i,j,k,l, tmp1,tmp2)   &
---
> !$OMP PARALLEL DO IF(surft_pts(n) > 1) SCHEDULE(STATIC) DEFAULT(NONE)          &
487c487,488
< !$OMP tile_frac,rib_surft,fz0,z0m_surft,fz0h,z0h_surft)
---
> !$OMP        tile_frac,rib_surft,fz0,z0m_surft,fz0h,z0h_surft)                 &
> !$OMP PRIVATE(i,j,k,l, tmp1,tmp2)
631,632c632,635
< !$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(i,j,k,l) SHARED(n,surft_pts,        &
< !$OMP surft_index,land_index,t_i_length,rhokh,flandg,tile_frac,rhokh_surft)
---
> !$OMP PARALLEL DO IF(surft_pts(n) > 1) SCHEDULE(STATIC)                        &
> !$OMP SHARED(n,surft_pts,surft_index,land_index,t_i_length,rhokh,flandg,       &
> !$OMP        tile_frac,rhokh_surft)                                            &
> !$OMP PRIVATE(i,j,k,l)
712,714c715,718
< !$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(i,j,k,l,ws10) SHARED(n,surft_pts,   &
< !$OMP surft_index,land_index,t_i_length,cdr10m,vshr_land,unload_rate_u,        &
< !$OMP unload_backgrnd_pft)
---
> !$OMP PARALLEL DO IF(surft_pts(n) > 1) SCHEDULE(STATIC)                        &
> !$OMP SHARED(n,surft_pts,surft_index,land_index,t_i_length,cdr10m,vshr_land,   &
> !$OMP        unload_rate_u,unload_backgrnd_pft)                                &
> !$OMP PRIVATE(i,j,k,l,ws10)
diff -r vn7.0copy1_c4/src/./science/surface/jules_griddiag_sf_implicit_jls.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/surface/jules_griddiag_sf_implicit_jls.F90
155c155
<                              !    FRACA+(1-FRACA)*RESFS for
---
>                              !    fracaero+(1-fracaero)*resfs for
diff -r vn7.0copy1_c4/src/./science/surface/jules_grid_update_implicit_jls.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/surface/jules_grid_update_implicit_jls.F90
158c158
<                              !    FRACA+(1-FRACA)*RESFS for
---
>                              !    fracaero+(1-fracaero)*resfs for
diff -r vn7.0copy1_c4/src/./science/surface/jules_land_sf_explicit_jls.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/surface/jules_land_sf_explicit_jls.F90
33a34,35
> ! IN values defining water tracer field dimensions
>  n_wtrac_jls, n_evap_srce,                                                     &
46c48
<  pstar,lw_down,sw_surft,zh,ddmfx,                                              &
---
>  pstar,lw_down,sw_surft,sky,zh,ddmfx,                                          &
52c54
<  clay_soilt,o3,                                                                &
---
>  clay_soilt,o3, l_emis_surft_set,                                              &
56c58
<  gs,g_leaf_acc,npp_pft_acc,resp_w_pft_acc,resp_s_acc_soilt,                    &
---
>  emis_surft,gs,gc_corr,g_leaf_acc,npp_pft_acc,resp_w_pft_acc,resp_s_acc_soilt, &
65c67
<  alpha1,ashtf_prime_surft,fqw_surft,epot_surft,fraca,                          &
---
>  alpha1,ashtf_prime_surft,fqw_surft,epot_surft,fracaero_t,fracaero_s,          &
67,69c69
<  chr1p5m,smc_soilt,hcons_soilt,gpp,npp,resp_p,g_leaf,gpp_pft,gpp_pft_lay,      & 
<  apar_pft_lay, cmpf_pft_lay, vcmax_pft_lay, vcmax25_pft_lay,                   &
<  wlite_pft_lay, wcarb_pft_lay, wmin_pft_lay, ej_pft_lay, npp_pft,              &
---
>  chr1p5m,smc_soilt,hcons_soilt,gpp,npp,resp_p,g_leaf,gpp_pft,npp_pft,          &
72c72,73
<  flake,surft_index,surft_pts,tile_frac,fsmc_pft,emis_surft,emis_soil,          &
---
>  flake,surft_index,surft_pts,tile_frac,fsmc_pft,emis_soil,                     &
>  growth_sug_pft,growth_sug_gb,f_nsc_pft,lwp_c_pft,psi_root_zone_pft,           &
79,81c80
<  t_home_gb,t_growth_gb, l_growth_gb, vpd_growth_gb, co2_growth_gb,             &
<  pstar_growth_gb,xipam_opt,vcmax_opt,jmax_opt,t_sum,l_sum,                     &
<  t_night,nt_sum,vpd_sum,co2_sum, pstar_sum,                                    &
---
>  t_home_gb, t_growth_gb,                                                       &
118c117
<  l_lice_point, l_soil_point,                                                   &
---
>  l_lice_point, l_soil_point, l_lice_surft,                                     &
122c121,125
<  flux_o3_pft, fo3_pft                                                          &
---
>  flux_o3_pft, fo3_pft,                                                         &
>  !Water tracers (IN)
>  snow_surft_wtrac, canopy_wtrac, sthu_soilt_wtrac, qw_1_wtrac,                 &
>  ! Water tracers (OUT)
>  fqw_1_wtrac, fqw_surft_wtrac, fqw_evapsrce_wtrac, smc_soilt_wtrac             &
125,148c128,162
< USE sf_flux_mod, ONLY: sf_flux
< USE sfl_int_mod, ONLY: sfl_int
< USE fcdch_mod, ONLY: fcdch
< USE stdev1_mod, ONLY: stdev1
< USE sf_rib_mod, ONLY: sf_rib
< USE sf_resist_mod, ONLY: sf_resist
< USE snowtherm_mod,         ONLY: snowtherm
< USE gen_anthrop_heat_mod,  ONLY: generate_anthropogenic_heat
< USE tilepts_mod,           ONLY: tilepts
< USE heat_con_mod,          ONLY: heat_con
< USE physiol_mod,           ONLY: physiol
< USE qsat_mod, ONLY: qsat, qsat_mix
< USE elevate_mod, ONLY: elevate
< USE urbanz0_mod, ONLY: urbanz0
< USE sf_orog_mod, ONLY: sf_orog
< USE can_drag_mod, ONLY: can_drag_z0, can_drag_phi_m_h
< USE calc_air_dens_mod, ONLY: calc_air_dens
< 
< !Use in relevant variables
< USE theta_field_sizes, ONLY: t_i_length,t_j_length
< 
< USE dust_param, ONLY: z0_soil
< USE planet_constants_mod, ONLY: cp, vkman, r, c_virtual,epsil=>repsilon
< USE csigma, ONLY: sbcon
---
> USE ancil_info,              ONLY: dim_cslayer, nsoilt, rad_nband
> USE atm_fields_bounds_mod,      ONLY: pdims_s, pdims, tdims
> USE bl_option_mod,              ONLY: l_quick_ap2
> USE c_elevate,                  ONLY: l_elev_absolute_height
> USE c_z0h_z0m,                  ONLY: z0h_z0m, z0h_z0m_classic
> USE calc_air_dens_mod,          ONLY: calc_air_dens
> USE can_drag_mod,               ONLY: can_drag_z0, can_drag_phi_m_h
> USE csigma,                     ONLY: sbcon
> USE dust_param,                 ONLY: z0_soil
> USE elevate_mod,                ONLY: elevate
> USE fcdch_mod,                  ONLY: fcdch
> USE gen_anthrop_heat_mod,       ONLY: generate_anthropogenic_heat
> USE heat_con_mod,               ONLY: heat_con
> USE physiol_mod,                ONLY: physiol
> USE planet_constants_mod,       ONLY: cp, vkman, r, c_virtual,epsil=>repsilon
> USE qsat_mod,                   ONLY: qsat, qsat_mix
> USE sf_diags_mod,               ONLY: strnewsfdiag
> USE sf_flux_mod,                ONLY: sf_flux
> USE sf_orog_mod,                ONLY: sf_orog
> USE sf_resist_mod,              ONLY: sf_resist
> USE sf_rib_mod,                 ONLY: sf_rib
> USE sfl_int_mod,                ONLY: sfl_int
> USE snowtherm_mod,              ONLY: snowtherm
> USE solinc_data,                ONLY: l_skyview
> USE stdev1_mod,                 ONLY: stdev1
> USE stochastic_physics_run_mod, ONLY: l_rp2, i_rp_scheme, i_rp2b, z0hm_pft_rp
> USE theta_field_sizes,          ONLY: t_i_length,t_j_length
> USE tilepts_mod,                ONLY: tilepts
> USE timestep_mod,               ONLY: timestep
> USE urban_param_mod,            ONLY: z0m_mat
> USE urbanz0_mod,                ONLY: urbanz0
> USE veg_param,                  ONLY: secs_per_360days
> USE veg3_field_mod,             ONLY: veg_state_type
> USE water_constants_mod,        ONLY: lc, rho_ice, tm
> 
151c165
<    soil_model_rothc,                                                           &
---
>    soil_model_4pool,                                                           &
160,164d173
< USE veg_param, ONLY: secs_per_360days
< 
< USE sf_diags_mod, ONLY: strnewsfdiag
< USE timestep_mod, ONLY: timestep
< 
166,167c175
< USE atm_step_local, ONLY:  dim_cs1, dim_cs2,                                   &
<      co2_dim_len,co2_dim_row
---
> USE atm_step_local, ONLY:  dim_cs1, co2_dim_len,co2_dim_row
169,170c177
< USE ancil_info, ONLY:  dim_cs1, dim_cs2,                                       &
<      co2_dim_len,co2_dim_row
---
> USE ancil_info, ONLY:  dim_cs1, co2_dim_len, co2_dim_row
173,183d179
< USE ancil_info, ONLY: dim_cslayer, l_lice_surft, nsoilt, rad_nband
< 
< USE bl_option_mod, ONLY: l_quick_ap2
< USE solinc_data, ONLY: sky, l_skyview
< 
< USE atm_fields_bounds_mod, ONLY:                                               &
<    pdims_s, pdims, tdims
< 
< USE c_z0h_z0m, ONLY: z0h_z0m, z0h_z0m_classic
< USE water_constants_mod, ONLY: lc, rho_ice, tm
< 
192d187
< 
208,209d202
< USE c_elevate, ONLY: l_elev_absolute_height
< 
216,218c209,212
< USE stochastic_physics_run_mod, ONLY: l_rp2, i_rp_scheme, i_rp2b, z0hm_pft_rp
< 
< USE urban_param_mod, ONLY: z0m_mat
---
> USE jules_water_tracers_mod, ONLY: l_wtrac_jls
> USE sf_resist_wtrac_mod,     ONLY: sf_resist_wtrac
> USE sf_evap_srce_frac_mod,   ONLY: sf_evap_srce_frac
> USE sf_flux_land_wtrac_mod,  ONLY: sf_flux_land_wtrac, sf_flux_land_check_wtrac
223,225d216
< !Use in TYPE definitions
< USE veg3_field_mod, ONLY: veg_state_type
< 
229d219
< 
240a231,234
>  n_wtrac_jls,                                                                  &
>             ! IN No. of water tracers in JULES
>  n_evap_srce,                                                                  &
>             ! IN No. of evaporative water sources
362a357,358
> ,sky(tdims%i_start:tdims%i_end,tdims%j_start:tdims%j_end)                      &
>                              ! IN Skyview correction for surface LW
414c410
< ,l_mr_physics
---
> ,l_mr_physics                                                                  &
415a412,414
> ,l_emis_surft_set(nsurft)
>                              ! IN Switch for varying grey surface emissivity
> 
423c422,424
<  gs(land_pts)                                                                  &
---
>  emis_surft(land_pts,nsurft)                                                   &
>                               ! INOUT Emissivity for land tiles
> ,gs(land_pts)                                                                  &
425c426
<                                   !        evaporation (m/s).
---
>                               !        evaporation (m/s).
461d461
< 
476c476
< , u_s_std_surft(land_pts,nsurft)                                               &
---
> ,u_s_std_surft(land_pts,nsurft)                                                &
480,482c480
< ,emis_surft(land_pts,nsurft)                                                   &
<                              ! OUT Emissivity for land tiles
< ,emis_soil(land_pts)
---
> ,emis_soil(land_pts)                                                           &
484,486c482
< 
< REAL(KIND=real_jlslsm), INTENT(OUT) ::                                         &
<  rhokm_land(pdims_s%i_start:pdims_s%i_end,                                     &
---
> ,rhokm_land(pdims_s%i_start:pdims_s%i_end,                                     &
510c506,510
< ,fraca(land_pts,nsurft)                                                        &
---
> ,fracaero_t(land_pts,nsurft)                                                   &
>                              ! OUT Total fraction of surface moisture
>                              !     flux with only aerodynamic
>                              !     resistance
> ,fracaero_s(land_pts,nsurft)                                                   &
513,514c513,514
<                              !     resistance for snow-free land
<                              !     tiles.
---
>                              !     resistance over the frozen portion of the
>                              !     surface alone
518c518
<                              !     factor for fraction (1-FRACA)
---
>                              !     factor for fraction (1-fracaero_t)
522c522
<                              !     FRACA+(1-FRACA)*RESFS for
---
>                              !     fracaero_t+(1-fracaero_t)*resfs for
559,594d558
< ,gpp_pft_lay(land_pts,npft,ilayers)                                           &
<                              ! OUT Gross primary productivity per layer
<                              !     (kg C/m2/s)
< 
< ,apar_pft_lay(land_pts,npft,ilayers)                                          &
<                              ! OUT Absorbed PAR per layer
<                              !     (W/m2)
< 
< ,cmpf_pft_lay(land_pts,npft,ilayers)                                          &
<                              ! OUT CO2 compensation factor per layer
<                              !     (unitless)
< 
< ,vcmax_pft_lay(land_pts,npft,ilayers)                                         &
<                              ! OUT Vcmax per layer
<                              !     (mol CO2/m2/s)
< 
< ,vcmax25_pft_lay(land_pts,npft,ilayers)                                       &
<                              ! OUT Vcmax25 per layer
<                              !     (mol CO2/m2/s)
< 
< ,wlite_pft_lay(land_pts,npft,ilayers)                                         &
<                              ! OUT Light-limited photosynthesis per layer
<                              !     (mol CO2/m2/s)
< 
< ,wcarb_pft_lay(land_pts,npft,ilayers)                                         &
<                              ! OUT Carbon-limited photosynthesis per layer
<                              !     (mol CO2/m2/s)
< 
< ,wmin_pft_lay(land_pts,npft,ilayers)                                          &
<                              ! OUT Minimum of wlight and wcarb per layer
<                              !     (mol CO2/m2/s)
< 
< ,ej_pft_lay(land_pts,npft,ilayers)                                            &
<                              ! OUT Electron transport per layer
<                              !     (mol/m2/s)
< 
600a565,573
> ,growth_sug_gb(land_pts)                                                       &
>                              ! OUT Gridbox mean structural C
>                              !     growth rate (SUGAR only) (kg C/m2/s).
> ,growth_sug_pft(land_pts,npft)                                                 &
>                              ! OUT PFT structural C growth rate (SUGAR only)
>                              !     (kg C/m2/s).
> ,f_nsc_pft(land_pts,npft)                                                      &
>                              ! OUT Plant non-structural carbohydrate
>                              !     mass fraction (kgC/kgC)
603c576
< ,resp_s_tot_soilt(dim_cs2,nsoilt)                                              &
---
> ,resp_s_tot_soilt(land_pts,nsoilt)                                             &
642c615,623
< ,fsmc_pft(land_pts,npft)     ! OUT Moisture availability factor.
---
> ,fsmc_pft(land_pts,npft)                                                       &
>                              ! OUT Moisture availability factor.
> ,gc_corr(land_pts,npft)                                                        &
>                              ! OUT "Stomatal" conductance
>                              !     without bare soil evaporation
> ,lwp_c_pft(land_pts,npft)                                                      &
>                              ! OUT Canopy leaf water potential (MPa)
> ,psi_root_zone_pft(land_pts,npft)
>                              ! OUT Water potential in the root zone (Pa)
690,705c671
< REAL(KIND=real_jlslsm), INTENT(IN OUT) :: t_growth_gb(land_pts,npft)
< REAL(KIND=real_jlslsm), INTENT(IN OUT) :: l_growth_gb(land_pts,npft)
< REAL(KIND=real_jlslsm), INTENT(IN OUT) :: vpd_growth_gb(land_pts,npft)
< REAL(KIND=real_jlslsm), INTENT(IN OUT) :: co2_growth_gb(land_pts,npft)
< REAL(KIND=real_jlslsm), INTENT(IN OUT) :: pstar_growth_gb(land_pts,npft)
< REAL(KIND=real_jlslsm), INTENT(IN OUT) :: xipam_opt(land_pts,npft)
< REAL(KIND=real_jlslsm), INTENT(IN OUT) :: vcmax_opt(land_pts,npft)
< REAL(KIND=real_jlslsm), INTENT(IN OUT) :: jmax_opt(land_pts,npft)
< !REAL(KIND=real_jlslsm), INTENT(IN OUT) :: Rd25New(land_pts,npft)
< REAL(KIND=real_jlslsm), INTENT(IN OUT) :: t_sum(land_pts,npft)
< REAL(KIND=real_jlslsm), INTENT(IN OUT) :: l_sum(land_pts,npft)
< REAL(KIND=real_jlslsm), INTENT(IN OUT) :: t_night(land_pts,npft)
< REAL(KIND=real_jlslsm), INTENT(IN OUT) :: nt_sum(land_pts,npft)
< REAL(KIND=real_jlslsm), INTENT(IN OUT) :: vpd_sum(land_pts,npft)
< REAL(KIND=real_jlslsm), INTENT(IN OUT) :: co2_sum(land_pts,npft)
< REAL(KIND=real_jlslsm), INTENT(IN OUT) :: pstar_sum(land_pts,npft)
---
> 
708c674
< 
---
> REAL(KIND=real_jlslsm), INTENT(IN) :: t_growth_gb(land_pts)
769a736
> LOGICAL, INTENT(IN OUT) :: l_lice_surft(ntype)
777a745,781
> ! Water tracers (IN)
> REAL(KIND=real_jlslsm), INTENT(IN) :: snow_surft_wtrac(land_pts,nsurft,        &
>                                                         n_wtrac_jls)
>                              ! IN Water tracer in lying snow on tiles (kg/m2)
> 
> REAL(KIND=real_jlslsm), INTENT(IN) :: canopy_wtrac(land_pts,nsurft,n_wtrac_jls)
>                              ! IN Water tracer in surface/canopy water for
>                              !    snow-free land tiles (kg/m2)
> 
> REAL(KIND=real_jlslsm), INTENT(IN) :: sthu_soilt_wtrac(land_pts,nsoilt,        &
>                                                  sm_levels,n_wtrac_jls)
>                              ! IN Water tracer Unfrozen soil moisture content
>                              !    of each layer as a fraction of saturation.
> 
> REAL(KIND=real_jlslsm), INTENT(IN) :: qw_1_wtrac(tdims%i_start:tdims%i_end,    &
>                                        tdims%j_start:tdims%j_end,n_wtrac_jls)
>                              ! IN Total water tracer content in lowest atmos
>                              !    layer
> 
> ! Water tracers (OUT)
> REAL(KIND=real_jlslsm), INTENT(OUT) :: fqw_1_wtrac(tdims%i_start:tdims%i_end,  &
>                                         tdims%j_start:tdims%j_end,n_wtrac_jls)
>                              ! OUT Water tracer surface moisture flux
>                              !       (kg/m2/s)
> REAL(KIND=real_jlslsm), INTENT(OUT) :: fqw_surft_wtrac(land_pts,nsurft,        &
>                                                         n_wtrac_jls)
>                              ! OUT Water tracer surface FQW for land tiles
> 
> REAL(KIND=real_jlslsm), INTENT(OUT) :: fqw_evapsrce_wtrac(land_pts,            &
>                                               n_evap_srce,nsurft,n_wtrac_jls)
>                              ! OUT Water tracer surface FQW for each
>                              !     evaporative source for land tiles
> 
> REAL(KIND=real_jlslsm), INTENT(OUT) :: smc_soilt_wtrac(land_pts,nsoilt,        &
>                                                          n_wtrac_jls)
>                              ! OUT Water tracer in available moisture in the
>                              !     soil profile (kg/m2).
797c801
< ,resp_frac(dim_cs2,dim_cslayer)                                                &
---
> ,resp_frac(land_pts,dim_cslayer)                                               &
825c829
< ,dq(land_pts)                                                                  &
---
> ,dq(land_pts,nsurft)                                                           &
943a948,961
> ! Water tracer local fields
> REAL(KIND=real_jlslsm), ALLOCATABLE ::                                         &
>  resf_wtrac(:,:,:,:)                                                           &
>                              ! Resistance factor for water tracer surface
>                              ! fluxes for each evaporative source
>                              ! (which includes kinetic fractionation
>                              ! factor for isotopes)
> ,evap_srce_frac(:,:,:)                                                         &
>                              ! Evaporative source fractional contribution
>                              ! to total evaporation from tile
> ,q_elev_wtrac(:,:,:)
>                              ! Water tracer specific humidity at elevated
>                              ! height
> 
973c991
< ,n_veg
---
> ,n_veg                                                                         &
975a994,997
> ,i_wt                                                                          &
>              ! Loop counter (water tracers)
> ,n_evap
>              ! Loop counter (evaporative sources)
1019d1040
< 
1024,1026c1045,1052
< !$OMP PARALLEL DEFAULT(NONE) PRIVATE(I,j)                                      &
< !$OMP SHARED(t_i_length,t_j_length,array_zero,tdims,rhokm_land,cd_land,        &
< !$OMP ch_land,zdt_dummy)
---
> !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i, j, l, n, i_wt, n_evap)                 &
> !$OMP SHARED(t_i_length, t_j_length, array_zero, tdims, rhokm_land, cd_land,   &
> !$OMP ch_land, zdt_dummy, land_pts, lake_ice_mid_temp, l_shallow_lake_depth,   &
> !$OMP zdt_surft, db_surft, rhokh_can, nsurft,ftl_surft,fqw_surft,              &
> !$OMP rib_surft,z0m_surft,u_s_std_surft,chr1p5m,resfs,alpha1,radnet_surft,     &
> !$OMP scaling_urban,snowdep_surft,snowdepth_surft,sf_diag, n_wtrac_jls,        &
> !$OMP n_evap_srce, fqw_1_wtrac, fqw_surft_wtrac, fqw_evapsrce_wtrac,           &
> !$OMP l_wtrac_jls)
1043d1068
< !$OMP END PARALLEL
1045,1046d1069
< !$OMP PARALLEL DEFAULT(NONE) PRIVATE(l)                                        &
< !$OMP SHARED(land_pts,lake_ice_mid_temp,l_shallow_lake_depth)
1053c1076,1091
< !$OMP END PARALLEL
---
> 
> ! Water tracers
> IF (l_wtrac_jls) THEN
>   ! Initialise GBM surface water tracer flux
>   ! (Equivalent water field is initialised in jules_gridinit_sf_explicit)
>   DO i_wt = 1, n_wtrac_jls
> !$OMP DO SCHEDULE(STATIC)
>     DO j = tdims%j_start,tdims%j_end
>       DO i = tdims%i_start,tdims%i_end
>         fqw_1_wtrac(i,j,i_wt) = 0.0
>       END DO
>     END DO
> !$OMP END DO NOWAIT
>   END DO
> END IF
> 
1059,1062d1096
< !$OMP PARALLEL PRIVATE(l,n) DEFAULT(NONE)                                      &
< !$OMP SHARED(land_pts,nsurft,ftl_surft,fqw_surft,                              &
< !$OMP rib_surft,z0m_surft,u_s_std_surft,chr1p5m,resfs,alpha1,radnet_surft,     &
< !$OMP scaling_urban,snowdep_surft,snowdepth_surft,sf_diag)
1076a1111,1113
>     zdt_surft(l,n)     = 0.0
>     db_surft(l,n)      = 0.0
>     rhokh_can(l,n)     = 0.0
1084a1122,1137
> 
> IF (l_wtrac_jls) THEN
>   DO i_wt = 1, n_wtrac_jls
>     DO n = 1, nsurft
> !$OMP DO SCHEDULE(STATIC)
>       DO l = 1,land_pts
>         fqw_surft_wtrac(l,n,i_wt) = 0.0
>         DO n_evap = 1, n_evap_srce
>           fqw_evapsrce_wtrac(l,n_evap,n,i_wt) = 0.0
>         END DO
>       END DO
> !$OMP END DO NOWAIT
>     END DO
>   END DO
> END IF
> 
1096a1150,1156
> ! Allocate arrays if using water tracers
> IF (l_wtrac_jls) THEN
>   ALLOCATE(q_elev_wtrac(land_pts,nsurft,n_wtrac_jls))
> ELSE
>   ALLOCATE(q_elev_wtrac(1,1,1))
> END IF
> 
1100c1160
< CALL tilepts(land_pts,frac,surft_pts,surft_index, l_lice_point)
---
> CALL tilepts(land_pts, frac, surft_pts, surft_index, l_lice_point, l_lice_surft)
1106,1107c1166,1168
< CALL generate_anthropogenic_heat( curr_day_number, land_pts, frac,             &
<                                   l_anthrop_heat_src,                          &
---
> IF ( l_anthrop_heat_src .AND. .NOT. l_aggregate ) THEN
>   CALL generate_anthropogenic_heat( curr_day_number, land_pts, frac,           &
>                                   surft_pts, surft_index,                      &
1112,1114c1173,1174
<                                   anthrop_heat_surft,                          &
<                                   !Ancil_info (IN)
<                                   l_lice_point)
---
>                                   anthrop_heat_surft)
> END IF
1122,1123c1182,1183
<   sm_levels,nsurft,surft_pts,surft_index,                                      &
<   dim_cs1,dim_cs2,                                                             &
---
>   sm_levels,nsurft,n_wtrac_jls,surft_pts,surft_index,                          &
>   dim_cs1,                                                                     &
1126c1186
<   lai_pft,pstar,qw_1,tl_1, sthu_soilt,sthf_soilt,t_soil_soilt,tstar_surft,     &
---
>   lai_pft,pstar,qw_1,sthu_soilt,sthf_soilt,t_soil_soilt,tstar_surft,           &
1128,1131c1188,1189
<   canhc_surft,vfrac_surft,emis_surft,emis_soil,flake,                          &
<   g_leaf,gs,gc_surft,gc_stom_surft,gpp,gpp_pft,gpp_pft_lay, apar_pft_lay,      &
<   cmpf_pft_lay, vcmax_pft_lay, vcmax25_pft_lay, wlite_pft_lay, wcarb_pft_lay,  &
<   wmin_pft_lay, ej_pft_lay, npp,npp_pft,                                       &
---
>   canhc_surft,vfrac_surft,emis_surft,l_emis_surft_set,emis_soil,flake,         &
>   g_leaf,gs,gc_surft,gc_stom_surft,gc_corr,gpp,gpp_pft,npp,npp_pft,            &
1138a1197,1200
>   !SUGAR variables
>   f_nsc_pft, growth_sug_gb, growth_sug_pft,                                    &
>   ! SOX variables
>   psi_root_zone_pft, lwp_c_pft,                                                &
1141,1143c1203
<   t_home_gb,t_growth_gb, l_growth_gb, vpd_growth_gb, co2_growth_gb,            &
<   pstar_growth_gb,xipam_opt,vcmax_opt,jmax_opt,t_sum,l_sum,                    &
<   t_night,nt_sum,vpd_sum,co2_sum, pstar_sum,                                   &
---
>   t_home_gb,t_growth_gb,                                                       &
1162c1222,1227
<   diff_frac)
---
>   diff_frac,                                                                   &
>   !water tracers (IN)
>   sthu_soilt_wtrac,                                                            &
>   !water tracers (OUT)
>   smc_soilt_wtrac)
> 
1202a1268,1269
> !$OMP PARALLEL DO SCHEDULE(STATIC) DEFAULT(NONE) PRIVATE(l)                    &
> !$OMP SHARED(land_pts, npp_pft, npp_pft_acc, timestep, resp_p_pft, n)
1207a1275
> !$OMP END PARALLEL DO
1210c1278
<   ! Here we have assumed that RothC must be used with TRIFFID, and is called
---
>   ! Here we have assumed that 4-pool C model is used with TRIFFID, and called
1212c1280
<   IF ( soil_bgc_model == soil_model_rothc ) THEN
---
>   IF ( soil_bgc_model == soil_model_4pool ) THEN
1214,1215c1282,1285
<       DO l = 1,land_pts
<         DO nn = 1,dim_cslayer
---
>       DO nn = 1,dim_cslayer
> !$OMP PARALLEL DO SCHEDULE(STATIC) DEFAULT(NONE) PRIVATE(l)                    &
> !$OMP SHARED(land_pts, resp_s_soilt, resp_s_acc_soilt, timestep, n, nn)
>         DO l = 1,land_pts
1221a1292
> !$OMP END PARALLEL DO
1235c1306
<   IF (l_phenol .OR. l_triffid) THEN
---
>   IF (l_phenol .AND. .NOT. l_triffid) THEN
1236a1308,1309
> !$OMP PARALLEL DO SCHEDULE(STATIC) DEFAULT(NONE) PRIVATE(l)                    &
> !$OMP SHARED(n, land_pts, g_leaf_acc, g_leaf, timestep)
1240a1314
> !$OMP END PARALLEL DO
1248a1323,1325
> !$OMP PARALLEL DO SCHEDULE(STATIC) DEFAULT(NONE) PRIVATE(l)                    &
> !$OMP SHARED(n, land_pts, g_leaf_acc, g_leaf, timestep,                        &
> !$OMP        npp_pft_acc, npp_pft, resp_w_pft_acc, resp_w_pft)
1249a1327,1328
>         g_leaf_acc(l,n) = g_leaf_acc(l,n) +                                    &
>                           g_leaf(l,n) * ( timestep / secs_per_360days )
1253a1333
> !$OMP END PARALLEL DO
1257c1337
<   IF ( soil_bgc_model == soil_model_rothc ) THEN
---
>   IF ( soil_bgc_model == soil_model_4pool ) THEN
1259,1260c1339,1342
<       DO l = 1,land_pts
<         DO nn = 1,dim_cslayer
---
>       DO nn = 1,dim_cslayer
> !$OMP PARALLEL DO SCHEDULE(STATIC) DEFAULT(NONE) PRIVATE(l)                    &
> !$OMP SHARED(n, nn, land_pts,resp_s_soilt, resp_s_acc_soilt, timestep)
>         DO l = 1,land_pts
1266a1349
> !$OMP END PARALLEL DO
1286,1292c1369,1379
< IF ( soil_bgc_model == soil_model_rothc ) THEN
<   DO i = 1,land_pts
<     !soil tiling is not compatible with triffid. OK to hard-code soil tile
<     !index to 1 here by setting m = 1
<     m = 1
<     resp_s_tot_soilt(i,m) = 0.0
<     DO nn = 1,dim_cslayer
---
> IF ( soil_bgc_model == soil_model_4pool ) THEN
>   DO j = 1, nsoilt
>     DO i = 1, land_pts
>       resp_s_tot_soilt(i,j)=0.0
>     END DO
>   END DO
>   !soil tiling is not compatible with triffid. OK to hard-code soil tile
>   !index to 1 here by setting m = 1
>   m = 1
>   DO nn = 1,dim_cslayer
>     DO i = 1,land_pts
1316a1404,1405
> !$OMP PARALLEL DO SCHEDULE(STATIC) DEFAULT(NONE) PRIVATE(l)                    &
> !$OMP SHARED(land_pts, tile_frac, surft_index)
1320a1410
> !$OMP END PARALLEL DO
1322a1413,1414
> !$OMP PARALLEL DO SCHEDULE(STATIC) DEFAULT(NONE) PRIVATE(l)                    &
> !$OMP SHARED(land_pts, tile_frac, frac, n)
1325a1418
> !$OMP END PARALLEL DO
1356,1360d1448
< !$OMP PARALLEL                                                                 &
< !$OMP DEFAULT(NONE)                                                            &
< !$OMP PRIVATE(l,k,j,i,n)                                                       &
< !$OMP SHARED(surft_pts,surft_index,land_index,pdims,radnet_surft,sw_surft,     &
< !$OMP        emis_surft,sky,lw_down,tstar_surft,nsurft,l_skyview)
1363c1451,1454
< !$OMP DO SCHEDULE(STATIC)
---
> !$OMP PARALLEL DO IF(surft_pts(n) > 1) DEFAULT(NONE) SCHEDULE(STATIC)          &
> !$OMP PRIVATE(i, j, k, l)                                                      &
> !$OMP SHARED(n,surft_pts,surft_index,land_index,pdims,radnet_surft,sw_surft,   &
> !$OMP        emis_surft,sky,lw_down,tstar_surft,l_skyview)
1371c1462
< !$OMP END DO NOWAIT
---
> !$OMP END PARALLEL DO
1375c1466,1469
< !$OMP DO SCHEDULE(STATIC)
---
> !$OMP PARALLEL DO IF(surft_pts(n) > 1) DEFAULT(NONE) SCHEDULE(STATIC)          &
> !$OMP PRIVATE(i, j, k, l)                                                      &
> !$OMP SHARED(n,surft_pts,surft_index,land_index,pdims,radnet_surft,sw_surft,   &
> !$OMP        emis_surft,lw_down,tstar_surft,l_skyview)
1383c1477
< !$OMP END DO NOWAIT
---
> !$OMP END PARALLEL DO
1386d1479
< !$OMP END PARALLEL
1402c1495
< !$OMP PARALLEL PRIVATE(i,j,l,n) DEFAULT(NONE)                                  &
---
> !$OMP PARALLEL PRIVATE(i,j,l,n) DEFAULT(NONE) IF(land_pts>1)                   &
1433c1526,1527
< ! Calculate temeprature and specific humidity for elevation bands
---
> ! Calculate temperature and specific humidity for elevation bands
> 
1435c1529
<  land_pts,nsurft,surft_pts,land_index,surft_index,                             &
---
>  land_pts,nsurft,n_wtrac_jls,surft_pts,land_index,surft_index,                 &
1437c1531
<  t_elev,q_elev)
---
>  t_elev,q_elev,qw_1_wtrac,q_elev_wtrac)
1478,1480d1571
< !$OMP PARALLEL DEFAULT(NONE) PRIVATE(k,l,n,d_t)                                &
< !$OMP SHARED(nsurft,surft_pts,surft_index,tstar_surft,t_elev,alpha1,           &
< !$OMP        qstar_surft,qs1_elev,epsil,c_virtual,r)
1482c1573,1576
< !$OMP DO SCHEDULE(STATIC)
---
> !$OMP PARALLEL DO IF (surft_pts(n) > 1) DEFAULT(NONE) SCHEDULE(STATIC)         &
> !$OMP PRIVATE(k,l,d_t, i, j)                                                   &
> !$OMP SHARED(n,surft_pts,surft_index,tstar_surft,t_elev,alpha1,                &
> !$OMP        qstar_surft,qs1_elev,epsil,c_virtual,r)
1498c1592
< !$OMP END DO NOWAIT
---
> !$OMP END PARALLEL DO
1500,1501d1593
< !$OMP END PARALLEL
< 
1507,1508c1599,1600
< !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i,j) SHARED(tdims,rhostar_mom,rhostar)
< !$OMP DO SCHEDULE(STATIC)
---
> !$OMP PARALLEL DO DEFAULT(NONE) SCHEDULE(STATIC)                               &
> !$OMP PRIVATE( i, j )   SHARED( tdims, rhostar_mom, rhostar )
1515,1516c1607
< !$OMP END DO
< !$OMP END PARALLEL
---
> !$OMP END PARALLEL DO
1713a1805,1806
> !$OMP PARALLEL DO SCHEDULE(STATIC) DEFAULT(NONE) PRIVATE(l)                    &
> !$OMP SHARED(n, land_pts, lw_down_elevcorr_surft)
1716a1810
> !$OMP END PARALLEL DO
1868d1961
<     IF ((nsmax > 0) .AND. (nsnow_surft(l,n) > 0)) THEN
1869a1963
>     IF ( ( nsmax > 0 ) .AND. ( nsnow_surft(l,n) > 0 ) ) THEN
1875,1876c1969,1971
<       IF ( ( .NOT. cansnowtile(n)) .AND. l_snow_nocan_hc .AND.                 &
<            (nsmax > 0) .AND. (nsnow_surft(l,n) > 0) ) canhc_surf(l,n) = 0.0
---
>       IF ( ( .NOT. cansnowtile(n) ) .AND. l_snow_nocan_hc ) THEN
>         canhc_surf(l,n) = 0.0
>       END IF
2028d2122
< zdt_surft(:,:) = 0.0
2049,2050c2143,2150
<   wind_profile_factor(:,:) = 1.0
<   z0m_eff_surft(:,:)       = z0m_surft(:,:)
---
> !$OMP PARALLEL DO IF(nsurft > 1) DEFAULT(NONE) SCHEDULE(STATIC)                &
> !$OMP SHARED( nsurft, wind_profile_factor, z0m_eff_surft, z0m_surft )          &
> !$OMP PRIVATE( n )
>   DO n = 1,nsurft
>     wind_profile_factor(:,n) = 1.0
>     z0m_eff_surft(:,n)       = z0m_surft(:,n)
>   END DO
> !$OMP END PARALLEL DO
2076c2176
<       dq(l) = qw_1(i,j) - qstar_surft(l,n)
---
>       dq(l,n) = qw_1(i,j) - qstar_surft(l,n)
2096c2196
<       dq(l) = qw_1(i,j) - qstar_surft(l,n)
---
>       dq(l,n) = qw_1(i,j) - qstar_surft(l,n)
2112c2212
<    canopy(:,n),catch(:,n),chn(:,n),dq,epdt,flake(:,n),gc_surft(:,n),           &
---
>    canopy(:,n),catch(:,n),chn(:,n),dq(:,n),epdt,flake(:,n),gc_surft(:,n),      &
2114c2214
<    fraca(:,n),resfs(:,n),resft(:,n),                                           &
---
>    tstar_surft(:,n),fracaero_t(:,n),fracaero_s(:,n),resfs(:,n),resft(:,n),     &
2124d2223
< db_surft(:,:) = 0.0
2234a2334,2336
> !$OMP PARALLEL IF(surft_pts(n) > 1) DEFAULT(NONE) PRIVATE(k, l)                &
> !$OMP SHARED(l_vary_z0m_soil, n, soil, surft_pts, surft_index, z0m_soil_in,    &
> !$OMP        z0_soil, z0h_soil,z0h_z0m, z0m_soil, wind_profile_fac_soil)
2236,2239c2338
< !$OMP PARALLEL DO IF(surft_pts(n) > 1) DEFAULT(NONE) PRIVATE(k, l)             &
< !$OMP             SHARED(n, soil, surft_pts, surft_index, z0m_soil_in,         &
< !$OMP                   z0h_soil,z0h_z0m, z0m_soil, wind_profile_fac_soil)     &
< !$OMP             SCHEDULE(STATIC)
---
> !$OMP DO SCHEDULE(STATIC)
2247c2346
< !$OMP END PARALLEL DO
---
> !$OMP END DO
2249,2252c2348
< !$OMP PARALLEL DO IF(surft_pts(n) > 1) DEFAULT(NONE) PRIVATE(k, l)             &
< !$OMP             SHARED(n, soil, surft_pts, surft_index, z0_soil, z0h_soil,   &
< !$OMP                   z0h_z0m, z0m_soil, wind_profile_fac_soil)              &
< !$OMP             SCHEDULE(STATIC)
---
> !$OMP DO SCHEDULE(STATIC)
2260c2356
< !$OMP END PARALLEL DO
---
> !$OMP END DO
2261a2358
> !$OMP END PARALLEL
2365a2463,2467
> !$OMP PARALLEL DO IF(surft_pts(n) > 1) DEFAULT(NONE) SCHEDULE(STATIC)          &
> !$OMP SHARED( n, surft_pts, surft_index, land_index, t_i_length, cd_land,      &
> !$OMP         tile_frac, cd_surft, ch_land, ch_surft, rhokm_1_surft,           &
> !$OMP         rhostar_mom, vshr_land, rhokm_land, rhokh_surft )                &
> !$OMP PRIVATE( i, j, k, l )
2371a2474,2480
> 
>     rhokm_1_surft(l,n) = rhostar_mom(i,j) * cd_surft(l,n) * vshr_land(i,j)
>     !                                                         ! P243.124
>     rhokm_land(i,j) = rhokm_land(i,j) +                                        &
>            tile_frac(l,n) * rhokm_1_surft(l,n)
>     rhokh_surft(l,n) = rhostar_mom(i,j) * ch_surft(l,n) * vshr_land(i,j)
>     !
2372a2482
> !$OMP END PARALLEL DO
2376a2487,2489
> !$OMP PARALLEL DO IF(land_pts > 1) DEFAULT(NONE) SCHEDULE(STATIC)              &
> !$OMP SHARED( land_pts, land_index, t_i_length, sf_diag, ch_land, vshr_land )  &
> !$OMP PRIVATE( i, j, l )
2381a2495
> !$OMP END PARALLEL DO
2392,2406d2505
< ! Land tiles
< DO n = 1,nsurft
<   DO k = 1,surft_pts(n)
<     l = surft_index(k,n)
<     j=(land_index(l) - 1) / t_i_length + 1
<     i = land_index(l) - (j-1) * t_i_length
<     rhokm_1_surft(l,n) = rhostar_mom(i,j) * cd_surft(l,n) * vshr_land(i,j)
<     !                                                         ! P243.124
<     rhokm_land(i,j) = rhokm_land(i,j) +                                        &
<            tile_frac(l,n) * rhokm_1_surft(l,n)
<     rhokh_surft(l,n) = rhostar_mom(i,j) * ch_surft(l,n) * vshr_land(i,j)
<     !                                                         ! P243.125
<   END DO
< END DO
< 
2413d2511
< rhokh_can(:,:) = 0.0
2416,2418d2513
< !$OMP PARALLEL DO DEFAULT(NONE) PRIVATE(n, k, l, j, i) SHARED(cansnowtile,     &
< !$OMP             cd_surft, land_index, npft, rhokh_can, rhostar, surft_pts,   &
< !$OMP             surft_index, t_i_length, vshr_land, cp) SCHEDULE(STATIC)
2420a2516,2518
> !$OMP PARALLEL DO IF(surft_pts(n) > 1) DEFAULT(NONE) PRIVATE( k, l, j, i)      &
> !$OMP SHARED(n, cd_surft, land_index, rhokh_can, rhostar, surft_pts,           &
> !$OMP        surft_index, t_i_length, vshr_land, cp) SCHEDULE(STATIC)
2427a2526
> !$OMP END PARALLEL DO
2430d2528
< !$OMP END PARALLEL DO
2446c2544
<   ! Calcualte humidity gradient and rate of change of potential evaporation
---
>   ! Calculate humidity gradient and rate of change of potential evaporation
2452c2550
<     dq(l)   = qw_1(i,j) - qstar_surft(l,n)
---
>     dq(l,n)   = qw_1(i,j) - qstar_surft(l,n)
2454c2552
<       *dq(l) * timestep
---
>       *dq(l,n) * timestep
2468c2566
<    canopy(:,n),catch(:,n),ch_surft(:,n),dq,epdt,flake(:,n),gc_surft(:,n),      &
---
>    canopy(:,n),catch(:,n),ch_surft(:,n),dq(:,n),epdt,flake(:,n),gc_surft(:,n), &
2470c2568
<    fraca(:,n),resfs(:,n),resft(:,n),                                           &
---
>    tstar_surft(:,n),fracaero_t(:,n),fracaero_s(:,n),resfs(:,n),resft(:,n),     &
2478c2576
<    radnet_surft(:,n),resft(:,n),rhokh_surft(:,n),l_soil_point,                 &
---
>    radnet_surft(:,n),resft(:,n),fracaero_s(:,n),rhokh_surft(:,n),l_soil_point, &
2503c2601
<     ! Calcualte surface resistance term for irrigated surfaces
---
>     ! Calculate surface resistance term for irrigated surfaces
2618a2717,2797
> 
> ! Calculate water tracer surface fluxes
> IF (l_wtrac_jls) THEN
> 
>   ALLOCATE(resf_wtrac(land_pts,n_evap_srce,nsurft,n_wtrac_jls))
>   ALLOCATE(evap_srce_frac(land_pts,n_evap_srce,nsurft))
> 
>   DO n = 1,nsurft
> 
>     ! Calculate the fractional contribution of each evaporative source to the
>     ! total tile flux. Note that this requires only the total fraction of
>     ! the tile subject to potential evaporation. fracaero_s(:,n) is required
>     ! only for energetic purposes.
>     CALL sf_evap_srce_frac(land_pts, surft_pts(n), surft_index(:,n),           &
>                            flake(:,n), fracaero_t(:,n), snowdep_surft(:,n),    &
>                            dq(:,n), catch(:,n), cansnowtile(n),                &
>                            evap_srce_frac(:,:,n))
> 
>     !Set the current soil tile
>     IF (nsoilt == 1) THEN
>       !There is only 1 soil tile
>       m = 1
>     ELSE ! nsoilt == nsurft
>       !Soil tiles map directly on to surface tiles
>       m = n
>     END IF !nsoilt
> 
>     DO i_wt = 1, n_wtrac_jls
> 
>       ! Set up resistance factors which include any kinetic fractionation
>       CALL sf_resist_wtrac(i_wt, n, land_pts, surft_pts(n),                    &
>                            surft_index(:,n), snowdep_surft(:,n),               &
>                            resfs(:,n), dq(:,n), catch(:,n),                    &
>                            evap_srce_frac(:,:,n),                              &
>                            cansnowtile(n), resf_wtrac(:,:,n,i_wt))
> 
>       ! Calculate surface flux
>       CALL sf_flux_land_wtrac(i_wt, land_pts, surft_pts(n),                    &
>                               surft_index(:,n), alpha1(:,n) ,rhokh_surft(:,n), &
>                               qstar_surft(:,n),dtstar_surft(:,n),              &
>                               resf_wtrac(:,:,n,i_wt), evap_srce_frac(:,:,n),   &
>                               q_elev_wtrac(:,n,i_wt),                          &
>                               snow_surft(:,n), snow_surft_wtrac(:,n,i_wt),     &
>                               smc_soilt(:,m), smc_soilt_wtrac(:,m,i_wt),       &
>                               canopy(:,n), canopy_wtrac(:,n,i_wt),             &
>                               fqw_evapsrce_wtrac(:,:,n,i_wt),                  &
>                               fqw_surft_wtrac(:,n,i_wt))
> 
> 
> !$OMP PARALLEL DO IF(surft_pts(n) > 1) SCHEDULE(STATIC)                        &
> !$OMP DEFAULT(NONE) PRIVATE(i, j, k, l) SHARED(surft_pts, surft_index,         &
> !$OMP    land_index, t_i_length, n, i_wt, fqw_1_wtrac, flandg, tile_frac,      &
> !$OMP    fqw_surft_wtrac)
>       DO k = 1,surft_pts(n)
>         l = surft_index(k,n)
>         j = (land_index(l) - 1) / t_i_length + 1
>         i = land_index(l) - (j-1) * t_i_length
> 
>         ! Calculate gridbox mean water tracer surface flux
>         fqw_1_wtrac(i,j,i_wt) = fqw_1_wtrac(i,j,i_wt)                          &
>            + flandg(i,j) * tile_frac(l,n) * fqw_surft_wtrac(l,n,i_wt)
>       END DO
> !$OMP END PARALLEL DO
> 
>     END DO    ! water tracers
> 
>   END DO  ! surface tiles
> 
>   ! Carry out check on total flux for 'normal' water tracer
>   CALL sf_flux_land_check_wtrac(land_pts, nsurft, land_index, tile_frac,       &
>                flandg, snowdep_surft, canopy, flake, dq, fracaero_t(:,:),      &
>                resfs, resft, resf_wtrac(:,:,:,1), evap_srce_frac,              &
>                fqw_surft, fqw_1, fqw_surft_wtrac(:,:,1), fqw_1_wtrac,          &
>                fqw_evapsrce_wtrac(:,:,:,1))
> 
>   DEALLOCATE(evap_srce_frac)
>   DEALLOCATE(resf_wtrac)
> 
> END IF      ! IF l_wtrac_jls
> 
> DEALLOCATE(q_elev_wtrac)
diff -r vn7.0copy1_c4/src/./science/surface/jules_land_sf_implicit.jls.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/surface/jules_land_sf_implicit.jls.F90
7a8
> USE ereport_mod, ONLY: ereport
34a36,37
> ! IN values defining water tracer field dimensions
>  n_wtrac_jls, n_evap_srce,                                                     &
36,37c39,40
<  lw_down,sw_surft,t_soil_soilt,r_gamma,alpha1,ashtf_prime_surft,               &
<  dtrdz_charney_grid_1,fraca,resfs,resft,rhokh_surft,                           &
---
>  lw_down,sw_surft,sky,t_soil_soilt,r_gamma,alpha1,ashtf_prime_surft,           &
>  dtrdz_charney_grid_1,fracaero_t,fracaero_s,resfs,resft,rhokh_surft,           &
45c48
<  ext_soilt,melt_surft,tstar_surft_old,ERROR,                                   &
---
>  ext_soilt,melt_surft,snowinc_surft,tstar_surft_old,ERROR,                     &
54a58
>  lake_evap,                                                                    &
62c66,74
<  crop_vars                                                                     &
---
>  crop_vars,                                                                    &
>  ! Water tracers (IN)
>  snow_surft_wtrac, smc_soilt_wtrac, canopy_wtrac, fqw_evapsrce_wtrac,          &
>  ! Water tracers (INOUT)
>  fqw_surft_wtrac,                                                              &
>  ! Water tracers (OUT)
>  ei_surft_wtrac, ei_wtrac, esoil_surft_wtrac, esoil_soilt_wtrac,               &
>  ext_soilt_wtrac, ecan_surft_wtrac, ecan_wtrac, lake_evap_wtrac,               &
>  fqw_1_wtrac, dfqw_wtrac                                                       &
89a102,104
> USE jules_rivers_mod,         ONLY: l_rivers, lake_water_conserve_method,      &
>                                     use_fqw_surft, use_elake_surft,            &
>                                     i_river_vn, rivers_um_trip
93c108,111
< USE solinc_data,              ONLY: sky, l_skyview
---
> USE solinc_data,              ONLY: l_skyview
> 
> USE jules_water_tracers_mod,  ONLY: l_wtrac_imp_jls, standard_ratio_wtrac
> USE sf_land_imp_wtrac_mod,    ONLY: sf_land_imp_wtrac
125a144,149
> INTEGER, INTENT(IN) ::                                                         &
>  n_wtrac_jls,                                                                  &
>                              ! IN No. of water tracers in JULES
>  n_evap_srce
>                              ! IN No. of evaporative water sources
> 
161a186,187
> ,sky(tdims%i_start:tdims%i_end,tdims%j_start:tdims%j_end)                      &
>                              ! IN skyview correction for surface LW
184c210,214
< ,fraca(land_pts,nsurft)                                                        &
---
> ,fracaero_t(land_pts,nsurft)                                                   &
>                              ! IN Total fraction of surface moisture
>                              !    flux with only aerodynamic
>                              !    resistance
> ,fracaero_s(land_pts,nsurft)                                                   &
187,188c217,218
<                              !    resistance for snow-free land
<                              !    tiles.
---
>                              !    resistance over the frozen part of the
>                              !    surface
192c222
<                              !    factor for fraction (1-FRACA) of
---
>                              !    factor for fraction (1-fracaero_t) of
196c226
<                              !    FRACA+(1-FRACA)*RESFS for
---
>                              !    fracaero+(1-fracaero)*resfs for
201a232,247
> ! Water tracers (IN)
> REAL(KIND=real_jlslsm), INTENT(IN) :: snow_surft_wtrac(land_pts,nsurft,        &
>                                                        n_wtrac_jls)
>                              ! Water tracer lying snow on tiles (kg/m2)
> REAL(KIND=real_jlslsm), INTENT(IN) :: smc_soilt_wtrac(land_pts,nsoilt,         &
>                                                        n_wtrac_jls)
>                              ! Water tracer in available soil moisture
>                              !    (kg/m2).
> REAL(KIND=real_jlslsm), INTENT(IN) :: canopy_wtrac(land_pts,nsurft,n_wtrac_jls)
>                              ! Water tracer surface/canopy water for
>                              !    snow-free land tiles (kg/m2)
> REAL(KIND=real_jlslsm), INTENT(IN) :: fqw_evapsrce_wtrac(land_pts,             &
>                                                n_evap_srce,nsurft,n_wtrac_jls)
>                              ! Water tracer surface FQW for each
>                              !     evap source for land tiles (kg/m2/s)
> 
225a272,278
> 
> ! Water tracers (INOUT)
> REAL(KIND=real_jlslsm), INTENT(IN OUT) :: fqw_surft_wtrac(land_pts,nsurft,     &
>                                                          n_wtrac_jls)
>                              ! Water tracer surface FQW for land tiles
>                              !    (kg/m2/s)
> 
274a328,333
> ,snowinc_surft(land_pts,nsurft)                                                &
>                              ! OUT Total increment to snow on land tiles
>                              !     (kg m-2 TS-1). This is used in preference
>                              !     to the rate to ensure the precise removal
>                              !     of snow, rather than allowing rounding
>                              !     errors to generate very small amounts.
285a345,388
> 
> ! Water tracers (OUT)
> REAL(KIND=real_jlslsm), INTENT(OUT) :: ei_surft_wtrac(land_pts,nsurft,         &
>                                                         n_wtrac_jls)
>                              ! Water tracer sublimation for land tiles
>                              !     (kg/m2/s)
> REAL(KIND=real_jlslsm), INTENT(OUT) :: ei_wtrac(tdims%i_start:tdims%i_end,     &
>                                         tdims%j_start:tdims%j_end,n_wtrac_jls)
>                              ! Water tracer sublimation from lying snow
>                              !     (kg/m2/s).
> REAL(KIND=real_jlslsm), INTENT(OUT) :: esoil_surft_wtrac(land_pts,nsurft,      &
>                                                          n_wtrac_jls)
>                              ! Water tracer sfc evapotranspiration for
>                              !                 snow-free land tiles (kg/m2/s)
> REAL(KIND=real_jlslsm), INTENT(OUT) :: esoil_soilt_wtrac(                      &
>                                             tdims%i_start:tdims%i_end,         &
>                                             tdims%j_start:tdims%j_end,nsoilt,  &
>                                             n_wtrac_jls)
>                              ! Water tracer surface evapotranspiration
>                              !     from soil moisture store per soil tile
>                              !     (kg/m2/s)
> REAL(KIND=real_jlslsm), INTENT(OUT) :: ext_soilt_wtrac(land_pts,nsoilt,        &
>                                                        sm_levels,n_wtrac_jls)
>                              ! Water tracer extraction of water from each
>                              !     soil layer (kg/m2/s)
> REAL(KIND=real_jlslsm), INTENT(OUT) :: ecan_surft_wtrac(land_pts,nsurft,       &
>                                                         n_wtrac_jls)
>                              ! Water tracer canopy evaporation for snow-free
>                              !     land tiles (kg/m2/s)
> REAL(KIND=real_jlslsm), INTENT(OUT) :: ecan_wtrac(tdims%i_start:tdims%i_end,   &
>                                          tdims%j_start:tdims%j_end,n_wtrac_jls)
>                              ! Water tracer GBM evaporation from
>                              !     canopy/surface store (kg/m2/s)
> REAL(KIND=real_jlslsm), INTENT(OUT) :: lake_evap_wtrac(land_pts,n_wtrac_jls)
>                              ! Water tracer lake evaporation
> REAL(KIND=real_jlslsm), INTENT(OUT) :: fqw_1_wtrac(                            &
>                                           tdims%i_start:tdims%i_end,           &
>                                           tdims%j_start:tdims%j_end,n_wtrac_jls)
>                              ! Water tracer surface flux (kg/m2/s)
> REAL(KIND=real_jlslsm), INTENT(OUT) :: dfqw_wtrac(tdims%i_start:tdims%i_end,   &
>                                         tdims%j_start:tdims%j_end,n_wtrac_jls)
>                              ! Increment in water tracer GBM moisture flux
>                              !      (kg/m2/s)
> 
294a398
> REAL(KIND=real_jlslsm), INTENT(OUT) :: lake_evap(land_pts)
316c420
< ,snowmelt(tdims%i_start:tdims%i_end,tdims%j_start:tdims%j_end)
---
> ,snowmelt(tdims%i_start:tdims%i_end,tdims%j_start:tdims%j_end)                 &
317a422,429
> ,snowinc_flake(land_pts,nsurft)
>                              ! Increment to ice for FLake
> 
> REAL(KIND=real_jlslsm) ::                                                      &
>  elake_surft_wtrac(land_pts,nsurft,n_wtrac_jls)
>                              ! Lake evaporation on land tiles
>                              ! (When using tiles, this will only be non-zero
>                              !  on the 'lake' tile.)
335c447
< ,m
---
> ,m                                                                             &
336a449,452
> ,i_wt
>             ! Loop counter for water tracers
> 
> INTEGER :: errorstatus
346d461
< 
448c563
<   ashtf_prime_surft,canopy,dtrdz_charney_grid_1,flake,fraca,                   &
---
>   ashtf_prime_surft,canopy,dtrdz_charney_grid_1,flake,fracaero_t,fracaero_s,   &
468c583,584
< !$OMP SHARED(tdims,ei_land,snowmelt,nsurft,land_pts,melt_ice_surft)
---
> !$OMP SHARED(tdims,ei_land,snowmelt,nsurft,land_pts,melt_ice_surft,            &
> !$OMP snowinc_flake)
483a600
>     snowinc_flake(l,n) = 0.0
495,496c612,613
<     resft(:,n),rhokh_surft(:,n),tile_frac(:,n),timestep,r_gamma,               &
<     ei_surft(:,n),fqw_1,ftl_1,fqw_surft(:,n),ftl_surft(:,n),                   &
---
>     fracaero_s(:,n),resft(:,n),rhokh_surft(:,n),tile_frac(:,n),                &
>     timestep,r_gamma, ei_surft(:,n),fqw_1,ftl_1,fqw_surft(:,n),ftl_surft(:,n), &
498c615
<     melt_surft(:,n)                                                            &
---
>     melt_surft(:,n),snowinc_surft(:,n)                                         &
524c641,642
<       resft(:,n),rhokh_surft(:,n),tile_frac(:,n),timestep,r_gamma,             &
---
>       fracaero_s(:,n),resft(:,n),rhokh_surft(:,n),tile_frac(:,n),              &
>       timestep,r_gamma,                                                        &
527c645
<       melt_ice_surft(:,n)                                                      &
---
>       melt_ice_surft(:,n),snowinc_flake(:,n)                                   &
680a799,830
> ! Get lake evaporation based on method of conserving water in lakes
> IF ( l_rivers .AND. i_river_vn == rivers_um_trip ) THEN
>   SELECT CASE (lake_water_conserve_method)
>     !
>   CASE ( use_fqw_surft )
>     ! This method gets lake evaporation from fqw_surft which already has
>     ! sublimation removed from it in sf_evap. This needs to be done
>     ! before fqw_surft gets reset from its component parts in the next section
>     ! of code.
> 
> !$OMP DO SCHEDULE(STATIC)
>     DO l = 1, land_pts
>       lake_evap(l) = fqw_surft(l,lake)
>     END DO
> !$OMP END DO
> 
>   CASE ( use_elake_surft )
>     ! This method gets lake evaporation from elake_surft. This is more
>     ! representative of evaporation from the lakes that the atmosphere sees.
> 
> !$OMP DO SCHEDULE(STATIC)
>     DO l = 1, land_pts
>       lake_evap(l) = elake_surft(l,lake)
>     END DO
> !$OMP END DO
> 
>   CASE DEFAULT
>     errorstatus = 101
>     CALL ereport(RoutineName, errorstatus, 'Invalid value for lake_water_conserve_method')
>   END SELECT
> END IF
> 
689a840,841
>     fqw_surft(l,n) = ecan_surft(l,n) + esoil_surft(l,n) +                      &
>                      elake_surft(l,n) + ei_surft(l,n)
723,725c875
< IF (     (l_flake_model   )                                                    &
<     .AND. ( .NOT. l_aggregate) ) THEN
<   DO n = 1,nsurft
---
> IF ( l_flake_model .AND. ( .NOT. l_aggregate) ) THEN
727,737c877,883
<     DO k = 1,surft_pts(n)
<       l = surft_index(k,n)
<       j=(land_index(l) - 1) / t_i_length + 1
<       i = land_index(l) - (j-1) * t_i_length
<       ! be careful about gridboxes that are all lake
<       IF (non_lake_frac(l) > EPSILON(0.0)) THEN
<         surf_ht_flux_land(i,j) =   surf_ht_flux_land(i,j)                      &
<                                  / non_lake_frac(l)
<       END IF
<     END DO
< !$OMP END DO
---
>   DO l = 1,land_pts
>     j=(land_index(l) - 1) / t_i_length + 1
>     i = land_index(l) - (j-1) * t_i_length
>     ! be careful about gridboxes that are all lake
>     IF (non_lake_frac(l) > EPSILON(0.0)) THEN
>       surf_ht_flux_land(i,j) = surf_ht_flux_land(i,j) / non_lake_frac(l)
>     END IF
738a885
> !$OMP END DO
741a889
> !$OMP DO SCHEDULE(STATIC)
744a893
> !$OMP END DO
768a918,951
> !--------------------------------------------------------------------------
> ! Update water tracers for implicit calculation
> !--------------------------------------------------------------------------
> 
> IF (l_wtrac_imp_jls) THEN
>   DO i_wt = 1, n_wtrac_jls
>     CALL sf_land_imp_wtrac(                                                    &
>       land_pts, nsurft, sm_levels, n_evap_srce,                                &
>       surft_pts, land_index, surft_index, timestep,                            &
>       standard_ratio_wtrac(i_wt), flandg, tile_frac, non_lake_frac,            &
>       snow_surft_wtrac(:,:,i_wt), smc_soilt_wtrac(:,:,i_wt),                   &
>       canopy_wtrac(:,:,i_wt), wt_ext_surft,                                    &
>       ei_surft, esoil_surft, ecan_surft, elake_surft,                          &
>       fqw_evapsrce_wtrac(:,:,:,i_wt), fqw_evapsrce_wtrac(:,:,:,1),             &
>       fqw_surft_wtrac(:,:,i_wt), ei_wtrac(:,:,i_wt),                           &
>       ei_surft_wtrac(:,:,i_wt), esoil_soilt_wtrac(:,:,:,i_wt),                 &
>       esoil_surft_wtrac(:,:,i_wt), ext_soilt_wtrac(:,:,:,i_wt),                &
>       ecan_wtrac(:,:,i_wt), ecan_surft_wtrac(:,:,i_wt),                        &
>       elake_surft_wtrac(:,:,i_wt), fqw_1_wtrac(:,:,i_wt),                      &
>       dfqw_wtrac(:,:,i_wt))
> 
>     ! Set lake evaporation which is used in river_routing for conservation
>     ! purposes.
>     ! Water tracers always used lake_water_conserve_method=use_elake_surft
> 
> !$OMP PARALLEL DO SCHEDULE(STATIC) DEFAULT(NONE)                               &
> !$OMP PRIVATE(l) SHARED(i_wt,land_pts,lake_evap_wtrac,lake,elake_surft_wtrac)
>     DO l = 1, land_pts
>       lake_evap_wtrac(l,i_wt) = elake_surft_wtrac(l,lake,i_wt)
>     END DO
> !$OMP END PARALLEL DO
> 
>   END DO
> END IF
770a954
> 
diff -r vn7.0copy1_c4/src/./science/surface/jules_ssi_sf_explicit_jls.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/surface/jules_ssi_sf_explicit_jls.F90
31c31
<  nice, nice_use,                                                               &
---
>  nice, nice_use, n_wtrac_jls,                                                  &
46c46
< ! IN calcualted in land code
---
> ! IN calculated in land code
65a66
>  sice_pts_ncat, ssi_pts, sea_pts,                                              &
67,88c68,80
<  sw_sicat, sw_sea)
< 
< USE sf_flux_mod, ONLY: sf_flux
< USE sfl_int_mod, ONLY: sfl_int
< USE fcdch_mod, ONLY: fcdch
< USE stdev1_mod, ONLY: stdev1
< USE sf_rib_mod, ONLY: sf_rib
< USE qsat_mod, ONLY: qsat, qsat_mix
< USE calc_air_dens_mod, ONLY: calc_air_dens
< 
< !Use in relevant variables
< USE theta_field_sizes, ONLY: t_i_length,t_j_length
< 
< USE planet_constants_mod, ONLY: g, vkman, r, c_virtual,epsil=>repsilon
< USE csigma, ONLY: sbcon
< 
< USE sf_diags_mod, ONLY: strnewsfdiag
< USE timestep_mod, ONLY: timestep
< 
< USE atm_fields_bounds_mod, ONLY:                                               &
<    pdims_s, pdims, tdims
< 
---
>  sw_sicat, sw_sea,                                                             &
>  !Water tracers (IN)
>  qw_1_wtrac, r_sea_wtrac, r_sice_wtrac,                                        &
>  !Water tracers (INOUT)
>  fqw_1_wtrac,                                                                  &
>  !Water tracers (OUT)
>  fqw_sea_wtrac, fqw_sicat_wtrac)
> 
> USE atm_fields_bounds_mod,   ONLY: pdims_s, pdims, tdims
> USE c_kappai,                ONLY: kappa_seasurf,dzsea
> USE calc_air_dens_mod,       ONLY: calc_air_dens
> USE csigma,                  ONLY: sbcon
> USE fcdch_mod,               ONLY: fcdch
90,91c82,91
< USE water_constants_mod, ONLY: lc, rhosea, tm
< USE c_kappai, ONLY: kappa_seasurf,dzsea
---
> USE planet_constants_mod,    ONLY: g, vkman, r, c_virtual,epsil=>repsilon
> USE qsat_mod,                ONLY: qsat, qsat_mix
> USE sf_diags_mod,            ONLY: strnewsfdiag
> USE sf_flux_mod,             ONLY: sf_flux
> USE sf_rib_mod,              ONLY: sf_rib
> USE sfl_int_mod,             ONLY: sfl_int
> USE stdev1_mod,              ONLY: stdev1
> USE theta_field_sizes,       ONLY: t_i_length,t_j_length
> USE timestep_mod,            ONLY: timestep
> USE water_constants_mod,     ONLY: lc, rhosea, tm
112c112,113
< USE ancil_info, ONLY: ssi_pts, sea_pts, sice_pts_ncat
---
> USE jules_water_tracers_mod, ONLY: l_wtrac_jls
> USE sf_flux_ssi_wtrac_mod,   ONLY: sf_flux_ssi_wtrac
117d117
< 
124a125
>  ssi_pts, sea_pts,                                                             &
127,128c128,131
< ,nice_use   ! No. of sea ice categories used fully in surface calculations
< 
---
> ,nice_use                                                                      &
>             ! No. of sea ice categories used fully in surface calculations
> ,n_wtrac_jls
>             ! No. of water tracers used in JULES
358c361,362
<  sice_index_ncat(t_i_length * t_j_length,nice)
---
>  sice_index_ncat(t_i_length * t_j_length,nice),                                &
>  sice_pts_ncat(nice)
370a375,408
> ! Water tracers (IN)
> REAL(KIND=real_jlslsm), INTENT(IN) :: qw_1_wtrac(tdims%i_start:tdims%i_end,    &
>                                          tdims%j_start:tdims%j_end,n_wtrac_jls)
>                          ! IN Total water tracer content in lowest atmos level
> REAL(KIND=real_jlslsm), INTENT(IN) :: r_sea_wtrac(tdims%i_start:tdims%i_end,   &
>                                          tdims%j_start:tdims%j_end,n_wtrac_jls)
>                          ! IN Open ocean surface water tracer ratio
> REAL(KIND=real_jlslsm), INTENT(IN) :: r_sice_wtrac(tdims%i_start:tdims%i_end,  &
>                                                    tdims%j_start:tdims%j_end,  &
>                                                    nice_use,n_wtrac_jls)
>                          ! IN Sea ice surface water tracer ratio per ice cat
> 
> ! Water tracers (INOUT)
> REAL(KIND=real_jlslsm), INTENT(IN OUT) :: fqw_1_wtrac(                         &
>                                             tdims%i_start:tdims%i_end,         &
>                                             tdims%j_start:tdims%j_end,         &
>                                             n_wtrac_jls)
>                          ! INOUT Surface water tracer moisture flux (kg/m2/s)
> 
> ! Water tracers (OUT)
> REAL(KIND=real_jlslsm), INTENT(OUT) :: fqw_sea_wtrac(                          &
>                                             tdims%i_start:tdims%i_end,         &
>                                             tdims%j_start:tdims%j_end,         &
>                                             n_wtrac_jls)
>                          ! OUT Surface water tracer evaporation from sea
>                          !     (kg/m2/s)
> 
> REAL(KIND=real_jlslsm), INTENT(OUT) :: fqw_sicat_wtrac(                        &
>                                             tdims%i_start:tdims%i_end,         &
>                                             tdims%j_start:tdims%j_end,         &
>                                             nice_use,n_wtrac_jls)
>                          ! OUT Surface water tracer sublimation from sea ice
>                          !     categories (kg/m2/s)
> 
620c658
< ,first_counter
---
> ,first_counter                                                                 &
621a660,661
> ,i_wt
>              ! Loop counter (water tracers)
666c706,724
< !$OMP PARALLEL DEFAULT(NONE) PRIVATE(I)                                        &
---
> IF (sf_diag%l_tau_surft .OR. sf_diag%l_tau_1) THEN
>   ALLOCATE(rhokm_1_sice(tdims%i_start:tdims%i_end,tdims%j_start:tdims%j_end))
>   ALLOCATE(rhokm_1_sice_ncats(tdims%i_start:tdims%i_end,tdims%j_start:tdims%j_end,nice_use))
>   ALLOCATE(rhokm_1_sea(tdims%i_start:tdims%i_end,tdims%j_start:tdims%j_end))
> ELSE
>   ALLOCATE(rhokm_1_sice(1,1))
>   ALLOCATE(rhokm_1_sice_ncats(1,1,nice_use))
>   ALLOCATE(rhokm_1_sea(1,1))
> END IF
> 
> IF (i_modiscopt == on) THEN
>   ALLOCATE(z1_tq_top_sea(t_i_length,t_j_length))
>   ALLOCATE(z1_tq_top_ctile(t_i_length,t_j_length))
> ELSE
>   ALLOCATE(z1_tq_top_sea(1,1))
>   ALLOCATE(z1_tq_top_ctile(1,1))
> END IF
> 
> !$OMP PARALLEL DEFAULT(NONE) PRIVATE(I, j, k, l, n, i_wt)                      &
668c726,737
< !$OMP array_zero_int,zdt_dummy,cd_std_ice,v_s_std_ice,u_s_std_ice)
---
> !$OMP array_zero_int,zdt_dummy,cd_std_ice,v_s_std_ice,u_s_std_ice,             &
> !$OMP        tdims,radnet_sea,radnet_sice,z0h_sea,z0hsea,z0m_miz,z0miz,        &
> !$OMP        z0h_miz,z0h_z0m_miz,rib_sea,rib_ice,db_sea,db_ice,rhokm_ssi,      &
> !$OMP        rhokm_ssi_nohalo,cd_ssi,ch_ssi,ftl_ice,fqw_ice,h_sea,e_sea,       &
> !$OMP        cd_ice,ch_ice,v_s_ice,recip_l_mo_ice,l_icerough_prognostic,       &
> !$OMP        z0m_ice,z0m_sice_fmd,z0h_ice,z0h_z0m_sice,z0m_sice_skin,z0sice,   &
> !$OMP        lw_down,sice_pts_ncat,sice_index_ncat,ssi_index,                  &
> !$OMP        sw_sicat,emis_sice,tstar_sice_cat,nice_use, sf_diag,              &
> !$OMP        sea_pts, sea_index, sw_sea, emis_sea, tstar_sea,                  &
> !$OMP        z1_tq_sea,z1_tq,z1_tq_ctile,flandg,z_land,l_ctile,                &
> !$OMP        ctile_orog_fix,z1_tq_top_sea,z1_tq_top,z1_tq_top_ctile,           &
> !$OMP        i_modiscopt,n_wtrac_jls,fqw_sea_wtrac,fqw_sicat_wtrac,l_wtrac_jls)
676,678d744
<   cd_std_ice(i,:)   = 0.0
<   v_s_std_ice(i,:)  = 0.0
<   u_s_std_ice(i,:)  = 0.0
681c747,755
< !$OMP END PARALLEL
---
> DO j = 1, nice_use
> !$OMP DO SCHEDULE(STATIC)
>   DO i = 1,t_i_length * t_j_length
>     cd_std_ice(i,j)   = 0.0
>     v_s_std_ice(i,j)  = 0.0
>     u_s_std_ice(i,j)  = 0.0
>   END DO
> !$OMP END DO NOWAIT
> END DO
683,691c757
< !$OMP PARALLEL DO                                                              &
< !$OMP SCHEDULE(STATIC)                                                         &
< !$OMP DEFAULT(NONE)                                                            &
< !$OMP PRIVATE(j,i)                                                             &
< !$OMP SHARED(tdims,radnet_sea,radnet_sice,z0h_sea,z0hsea,z0m_miz,z0miz,        &
< !$OMP        z0h_miz,z0h_z0m_miz,rib_sea,rib_ice,db_sea,db_ice,rhokm_ssi,      &
< !$OMP        rhokm_ssi_nohalo,cd_ssi,ch_ssi,ftl_ice,fqw_ice,h_sea,e_sea,       &
< !$OMP        cd_ice,ch_ice,v_s_ice,recip_l_mo_ice,l_icerough_prognostic,       &
< !$OMP        z0m_ice,z0m_sice_fmd,z0h_ice,z0h_z0m_sice,z0m_sice_skin,z0sice)
---
> !$OMP DO SCHEDULE(STATIC)
695d760
<     radnet_sice(i,j,:)    = 0.0
700d764
<     rib_ice(i,j,:)        = 0.0
702d765
<     db_ice(i,j,:)         = 0.0
707,708d769
<     ftl_ice(i,j,:)        = 0.0
<     fqw_ice(i,j,:)        = 0.0
711,724d771
<     cd_ice(i,j,:)         = 0.0
<     ch_ice(i,j,:)         = 0.0
<     v_s_ice(i,j,:)        = 0.0
<     recip_l_mo_ice(i,j,:) = 0.0
<     IF (l_icerough_prognostic) THEN
<       ! prognostic z0sice for coupled model
<       ! (makes no discrimination between miz and ice pack)
<       z0m_ice(i,j,:)      = z0m_sice_fmd(i,j)
<       z0h_ice(i,j,:)      = z0h_z0m_sice * z0m_sice_skin(i,j)
<     ELSE
<       ! non prognostic z0sice
<       z0m_ice(i,j,:)      = z0sice
<       z0h_ice(i,j,:)      = z0h_z0m_sice * z0m_ice(i,j,:)
<     END IF
727c774
< !$OMP END PARALLEL DO
---
> !$OMP END DO
728a776,784
> IF (l_wtrac_jls) THEN
>   DO i_wt = 1, n_wtrac_jls
> !$OMP DO SCHEDULE(STATIC)
>     DO j = tdims%j_start,tdims%j_end
>       DO i = tdims%i_start,tdims%i_end
>         fqw_sea_wtrac(i,j,i_wt) = 0.0
>       END DO
>     END DO
> !$OMP END DO
730,737c786,795
< IF (sf_diag%l_tau_surft .OR. sf_diag%l_tau_1) THEN
<   ALLOCATE(rhokm_1_sice(tdims%i_start:tdims%i_end,tdims%j_start:tdims%j_end))
<   ALLOCATE(rhokm_1_sice_ncats(tdims%i_start:tdims%i_end,tdims%j_start:tdims%j_end,nice_use))
<   ALLOCATE(rhokm_1_sea(tdims%i_start:tdims%i_end,tdims%j_start:tdims%j_end))
< ELSE
<   ALLOCATE(rhokm_1_sice(1,1))
<   ALLOCATE(rhokm_1_sice_ncats(1,1,nice_use))
<   ALLOCATE(rhokm_1_sea(1,1))
---
>     DO k=1,nice_use
> !$OMP DO SCHEDULE(STATIC)
>       DO j = tdims%j_start,tdims%j_end
>         DO i = tdims%i_start,tdims%i_end
>           fqw_sicat_wtrac(i,j,k,i_wt) = 0.0
>         END DO
>       END DO
> !$OMP END DO
>     END DO
>   END DO
740c798,824
< 
---
> DO k=1,nice_use
> !$OMP DO SCHEDULE(STATIC)
>   DO j = tdims%j_start,tdims%j_end
>     DO i = tdims%i_start,tdims%i_end
>       radnet_sice(i,j,k)    = 0.0
>       rib_ice(i,j,k)        = 0.0
>       db_ice(i,j,k)         = 0.0
>       ftl_ice(i,j,k)        = 0.0
>       fqw_ice(i,j,k)        = 0.0
>       cd_ice(i,j,k)         = 0.0
>       ch_ice(i,j,k)         = 0.0
>       v_s_ice(i,j,k)        = 0.0
>       recip_l_mo_ice(i,j,k) = 0.0
>       IF (l_icerough_prognostic) THEN
>         ! prognostic z0sice for coupled model
>         ! (makes no discrimination between miz and ice pack)
>         z0m_ice(i,j,k)      = z0m_sice_fmd(i,j)
>         z0h_ice(i,j,k)      = z0h_z0m_sice * z0m_sice_skin(i,j)
>       ELSE
>         ! non prognostic z0sice
>         z0m_ice(i,j,k)      = z0sice
>         z0h_ice(i,j,k)      = z0h_z0m_sice * z0m_ice(i,j,k)
>       END IF
>     END DO
>   END DO
> !$OMP END DO
> END DO
746,752d829
< !$OMP PARALLEL                                                                 &
< !$OMP DEFAULT(NONE)                                                            &
< !$OMP PRIVATE(l,k,j,i,n)                                                       &
< !$OMP SHARED(lw_down,sice_pts_ncat,sice_index_ncat,ssi_index,t_i_length,       &
< !$OMP        radnet_sice,sw_sicat,emis_sice,tstar_sice_cat,nice_use,           &
< !$OMP        sea_pts, sea_index, radnet_sea, sw_sea, emis_sea, tstar_sea)
< 
774d850
< !$OMP END PARALLEL
777c853,859
<   sf_diag%radnet_sea(:,:) = radnet_sea(:,:)
---
> !$OMP DO SCHEDULE(STATIC)
>   DO j = tdims%j_start,tdims%j_end
>     DO i = tdims%i_start,tdims%i_end
>       sf_diag%radnet_sea(i,j) = radnet_sea(i,j)
>     END DO
>   END DO
> !$OMP END DO
780d861
< 
785,799d865
< IF (i_modiscopt == on) THEN
<   ALLOCATE(z1_tq_top_sea(t_i_length,t_j_length))
<   ALLOCATE(z1_tq_top_ctile(t_i_length,t_j_length))
< ELSE
<   ALLOCATE(z1_tq_top_sea(1,1))
<   ALLOCATE(z1_tq_top_ctile(1,1))
< END IF
< 
< !$OMP PARALLEL                                                                 &
< !$OMP DEFAULT(NONE)                                                            &
< !$OMP PRIVATE(j,i)                                                             &
< !$OMP SHARED(tdims,z1_tq_sea,z1_tq,z1_tq_ctile,flandg,z_land,l_ctile,          &
< !$OMP        ctile_orog_fix,z1_tq_top_sea,z1_tq_top,z1_tq_top_ctile,           &
< !$OMP        i_modiscopt)
< 
833d898
< 
892,893c957,960
<   sice_index_use(:) = 0
<   sice_frac_use(:) = 0.0
---
>   DO i = 1, ssi_pts
>     sice_index_use(i) = 0
>     sice_frac_use(i) = 0.0
>   END DO
908,909d974
<   ice_fract(:,:) = ice_fract_cat(:,:,1)
<   tstar_sice(:,:) = tstar_sice_cat(:,:,1)
911,912c976,988
<   sice_index_use(:) = sice_index_ncat(:,1)
<   sice_frac_use(:) = sice_frac_ncat(:,1)
---
> !$OMP PARALLEL DO SCHEDULE(STATIC) DEFAULT(NONE) PRIVATE(i, j)                 &
> !$OMP SHARED(tdims, ice_fract, ice_fract_cat, tstar_sice, tstar_sice_cat)
>   DO j = tdims%j_start,tdims%j_end
>     DO i = tdims%i_start,tdims%i_end
>       ice_fract(i,j) = ice_fract_cat(i,j,1)
>       tstar_sice(i,j) = tstar_sice_cat(i,j,1)
>     END DO
>   END DO
> !$OMP END PARALLEL DO
>   DO i = 1, ssi_pts
>     sice_index_use(i) = sice_index_ncat(i,1)
>     sice_frac_use(i) = sice_frac_ncat(i,1)
>   END DO
915d990
< 
936a1012,1014
> !$OMP PARALLEL DO IF(nice_use>1) SCHEDULE(STATIC) DEFAULT(NONE) PRIVATE(n)     &
> !$OMP SHARED(nice_use, qstar_ice_cat, tstar_sice_cat, pstar, t_i_length,       &
> !$OMP        t_j_length)
940a1019
> !$OMP END PARALLEL DO
941a1021,1023
> !$OMP PARALLEL DO IF(nice_use>1) SCHEDULE(STATIC) DEFAULT(NONE) PRIVATE(n)     &
> !$OMP SHARED(nice_use, qstar_ice_cat, tstar_sice_cat, pstar, t_i_length,       &
> !$OMP        t_j_length)
945a1028
> !$OMP END PARALLEL DO
1002,1005c1085,1090
< !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i,j,n)                                    &
< !$OMP SHARED(t_i_length,t_j_length,tdims,nice_use,                             &
< !$OMP        dzssi,hcons_sea,kappa_seasurf,canhc_sea,hcap_sea,ashtf_sea,       &
< !$OMP        ashtf,k_sice,dzdummy,alpha1_sea,alpha1_sice)
---
> !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i,j,n, d_t)                               &
> !$OMP SHARED(t_i_length, t_j_length, tdims, nice_use,                          &
> !$OMP        dzssi, hcons_sea, kappa_seasurf, canhc_sea, hcap_sea, ashtf_sea,  &
> !$OMP        ashtf, k_sice, dzdummy, alpha1_sea, alpha1_sice,                  &
> !$OMP        tstar_sea, tl_1, qstar_sea, qs1, epsil,                           &
> !$OMP        c_virtual, r, tstar_sice_cat, qstar_ice_cat, qstar_ice)
1036,1041d1120
< !$OMP END PARALLEL
< 
< !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i, j, n, d_t)                             &
< !$OMP SHARED(tdims,tstar_sea,tl_1,alpha1_sea,qstar_sea,qs1,epsil,              &
< !$OMP        c_virtual,r,nice_use,tstar_sice_cat,alpha1_sice,                  &
< !$OMP        qstar_ice_cat,qstar_ice)
1308d1386
< db_ice_mean(:,:) = 0.0
1309a1388,1397
> !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i, j, k ,l, n)                            &
> !$OMP SHARED(sice_pts_ncat, sice_index_ncat, ssi_index, t_i_length, nice_use,  &
> !$OMP        ice_fract, db_ice_mean, sice_frac_ncat, db_ice, tdims)
> !$OMP DO SCHEDULE(STATIC)
>   DO j = tdims%j_start,tdims%j_end
>     DO i = tdims%i_start,tdims%i_end
>       db_ice_mean(i,j) = 0.0
>     END DO
>   END DO
> !$OMP END DO
1310a1399
> !$OMP DO SCHEDULE(STATIC)
1320a1410
> !$OMP END DO
1321a1412
> !$OMP END PARALLEL
1323c1414,1421
<   db_ice_mean(:,:) = db_ice(:,:,1)
---
> !$OMP PARALLEL DO SCHEDULE(STATIC) DEFAULT(NONE) PRIVATE(i, j)                 &
> !$OMP SHARED(tdims, db_ice_mean, db_ice)
>   DO j = tdims%j_start,tdims%j_end
>     DO i = tdims%i_start,tdims%i_end
>       db_ice_mean(i,j) = db_ice(i,j,1)
>     END DO
>   END DO
> !$OMP END PARALLEL DO
1450,1451d1547
< cd_ice_mean(:,:) = 0.0
< ch_ice_mean(:,:) = 0.0
1452a1549,1560
> !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i, j, k, l, n)                            &
> !$OMP SHARED(sice_pts_ncat, sice_index_ncat, ssi_index, t_i_length,            &
> !$OMP        ice_fract, cd_ice_mean, sice_frac_ncat, cd_ice, ch_ice_mean,      &
> !$OMP        ch_ice, tdims, nice_use)
> !$OMP DO SCHEDULE(STATIC)
>   DO j = tdims%j_start,tdims%j_end
>     DO i = tdims%i_start,tdims%i_end
>       cd_ice_mean(i,j) = 0.0
>       ch_ice_mean(i,j) = 0.0
>     END DO
>   END DO
> !$OMP END DO
1453a1562
> !$OMP DO SCHEDULE(STATIC)
1464a1574
> !$OMP END DO
1465a1576
> !$OMP END PARALLEL
1467,1468c1578,1586
<   cd_ice_mean(:,:) = cd_ice(:,:,1)
<   ch_ice_mean(:,:) = ch_ice(:,:,1)
---
> !$OMP PARALLEL DO SCHEDULE(STATIC) DEFAULT(NONE) PRIVATE(i, j)                 &
> !$OMP SHARED(tdims, cd_ice_mean, ch_ice_mean, cd_ice, ch_ice)
>   DO j = tdims%j_start,tdims%j_end
>     DO i = tdims%i_start,tdims%i_end
>       cd_ice_mean(i,j) = cd_ice(i,j,1)
>       ch_ice_mean(i,j) = ch_ice(i,j,1)
>     END DO
>   END DO
> !$OMP END PARALLEL DO
1472,1474c1590
< rhokh_1_sice(:,:) = 0.0
< rhokh_1_sice_ncats(:,:,:) = 0.0
< !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i, j)                                     &
---
> !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i, j, n)                                  &
1476c1592
< !$OMP        ch_sea, cd_ice_mean, ch_ice_mean, nice_use, rhokm_ssi,            &
---
> !$OMP        ch_sea, cd_ice_mean, ch_ice_mean, nice_use, rhokm_ssi, emis_sea,  &
1479c1595
< !$OMP        l_icerough_prognostic,                                            &
---
> !$OMP        l_icerough_prognostic, t_i_length, t_j_length, array_emis,        &
1482a1599,1615
> !$OMP DO SCHEDULE(STATIC)
> DO j = tdims%j_start,tdims%j_end
>   DO i = tdims%i_start,tdims%i_end
>     rhokh_1_sice(i,j) = 0.0
>   END DO
> END DO
> !$OMP END DO
> DO n = 1, nice_use
> !$OMP DO SCHEDULE(STATIC)
>   DO j = tdims%j_start,tdims%j_end
>     DO i = tdims%i_start,tdims%i_end
>       rhokh_1_sice_ncats(i,j,n) = 0.0
>     END DO
>   END DO
> !$OMP END DO
> END DO
> 
1624d1756
< !$OMP END PARALLEL
1626a1759,1764
> !$OMP DO SCHEDULE(STATIC)
> DO i = 1, t_i_length * t_j_length
>   array_emis(i) = emis_sea
> END DO
> !$OMP END DO
> !$OMP END PARALLEL
1628d1765
< array_emis(:) = emis_sea
1643c1780
<      array_one * beta_evap,rhokh_sea,array_false,array_zero,                   &
---
>      array_one * beta_evap,array_zero,rhokh_sea,array_false,array_zero,        &
1667a1805,1816
>   ! Calculate water tracers open sea surface flux
>   IF (l_wtrac_jls) THEN
>     DO i_wt = 1, n_wtrac_jls
>       CALL sf_flux_ssi_wtrac (i_wt, ssi_pts, sea_pts, sea_index,               &
>                               sea_point,  seasalinityfactor,                   &
>                               alpha1_sea, rhokh_sea, qstar_sea,                &
>                               dtstar_sea, array_one * beta_evap,               &
>                               r_sea_wtrac(:,:,i_wt), 'sea',                    &
>                               qw_1_wtrac(:,:,i_wt), fqw_sea_wtrac(:,:,i_wt))
>     END DO
>   END IF
> 
1668a1818
> 
1675c1825
<        array_one * beta_evap,rhokh_1_sice,array_false,array_zero,              &
---
>        array_one * beta_evap,array_zero,rhokh_1_sice,array_false,array_zero,   &
1698a1849,1863
> 
>   ! Calculate water tracers open sea surface flux
>   ! (Note, the only difference in this call to the one for nice_use > 1 is
>   !  the use of rhokh_1_sice instead of rhokh_sea.)
>   IF (l_wtrac_jls) THEN
>     DO i_wt = 1, n_wtrac_jls
>       CALL sf_flux_ssi_wtrac (i_wt, ssi_pts, sea_pts, sea_index,               &
>                               sea_point,  seasalinityfactor,                   &
>                               alpha1_sea, rhokh_1_sice, qstar_sea,             &
>                               dtstar_sea, array_one * beta_evap,               &
>                               r_sea_wtrac(:,:,i_wt), 'sea',                    &
>                               qw_1_wtrac(:,:,i_wt), fqw_sea_wtrac(:,:,i_wt))
>     END DO
>   END IF
> 
1713a1879,1897
> ! Water tracers - add sea contribution to gridbox mean surface flux
> IF (l_wtrac_jls) THEN
>   DO i_wt = 1, n_wtrac_jls
> !$OMP PARALLEL DO IF(sea_pts > 1) SCHEDULE(STATIC) DEFAULT(NONE)               &
> !$OMP PRIVATE(i, j, k, l)                                                      &
> !$OMP SHARED(sea_pts, sea_index, ssi_index, t_i_length, fssi_ij,               &
> !$OMP        sea_frac, fqw_1_wtrac, fqw_sea_wtrac, i_wt)
>     DO k = 1, sea_pts
>       l = sea_index(k)
>       j = (ssi_index(l) - 1) / t_i_length + 1
>       i = ssi_index(l) - (j-1) * t_i_length
>       fqw_1_wtrac(i,j,i_wt) = fqw_1_wtrac(i,j,i_wt)                            &
>                                        + fssi_ij(i,j) * sea_frac(l)            &
>                                          * fqw_sea_wtrac(i,j,i_wt)
>     END DO
> !$OMP END PARALLEL DO
>   END DO
> 
> END IF
1719d1902
< 
1722c1905,1910
< array_emis(:) = emis_sice
---
> !$OMP PARALLEL DO SCHEDULE(STATIC) DEFAULT(NONE) PRIVATE(i)                    &
> !$OMP SHARED(t_i_length, t_j_length, array_emis, emis_sice)
> DO i = 1, t_i_length * t_j_length
>   array_emis(i) = emis_sice
> END DO
> !$OMP END PARALLEL DO
1731c1919
<      qstar_ice_cat(:,:,n),qw_1,radnet_sice(:,:,n),array_one,                   &
---
>      qstar_ice_cat(:,:,n),qw_1,radnet_sice(:,:,n),array_one,array_one,         &
1742a1931,1948
> 
>   ! Water tracers sea ice surface flux
>   IF (l_wtrac_jls) THEN
>     DO i_wt = 1, n_wtrac_jls
>       DO n = 1, nice_use
>         ! (Note, the '1.0' in the call is the seasalinityfactor argument)
>         CALL sf_flux_ssi_wtrac (i_wt, ssi_pts, sice_pts_ncat(n),               &
>                               sice_index_ncat(:,n), sea_point,  1.0,           &
>                               alpha1_sice(:,:,n), rhokh_1_sice_ncats(:,:,n),   &
>                               qstar_ice_cat(:,:,n),                            &
>                               dtstar_sice(:,:,n), array_one,                   &
>                               r_sice_wtrac(:,:,n,i_wt), 'ice',                 &
>                               qw_1_wtrac(:,:,i_wt),                            &
>                               fqw_sicat_wtrac(:,:,n,i_wt))
>       END DO
>     END DO
>   END IF
> 
1748c1954
<    qstar_ice,qw_1,radnet_sice(:,:,1),array_one,                                &
---
>    qstar_ice,qw_1,radnet_sice(:,:,1),array_one,array_one,                      &
1757a1964,1979
> 
>   ! Water tracers sea ice surface flux
>   IF (l_wtrac_jls) THEN
>     DO i_wt = 1, n_wtrac_jls
>       ! (Note, the '1.0' in the call is the seasalinityfactor argument)
>       CALL sf_flux_ssi_wtrac (i_wt, ssi_pts, sice_pts_ncat(1),                 &
>                               sice_index_ncat(:,1), sea_point,  1.0,           &
>                               alpha1_sice(:,:,1), rhokh_1_sice_ncats(:,:,1),   &
>                               qstar_ice,                                       &
>                               dtstar_sice(:,:,1), array_one,                   &
>                               r_sice_wtrac(:,:,1,i_wt), 'ice',                 &
>                               qw_1_wtrac(:,:,i_wt),                            &
>                               fqw_sicat_wtrac(:,:,1,i_wt))
>     END DO
>   END IF
> 
1777a2000,2021
> ! Water tracers - Add sea-ice contribution to gridbox mean surface flux
> IF (l_wtrac_jls) THEN
>   DO i_wt = 1, n_wtrac_jls
>     DO n = 1, nice_use
> !$OMP PARALLEL DO IF(sice_pts_ncat(n) > 1) SCHEDULE(STATIC) DEFAULT(NONE)      &
> !$OMP PRIVATE(i, j, k, l)                                                      &
> !$OMP SHARED(sice_pts_ncat, sice_index_ncat, ssi_index, t_i_length,            &
> !$OMP        fssi_ij, sice_frac_ncat, fqw_1_wtrac, fqw_sicat_wtrac,            &
> !$OMP        i_wt, n)
>       DO k = 1, sice_pts_ncat(n)
>         l = sice_index_ncat(k,n)
>         j = (ssi_index(l) - 1) / t_i_length + 1
>         i = ssi_index(l) - (j-1) * t_i_length
>         fqw_1_wtrac(i,j,i_wt) = fqw_1_wtrac(i,j,i_wt)                          &
>                                         + fssi_ij(i,j) * sice_frac_ncat(l,n)   &
>                                          * fqw_sicat_wtrac(i,j,n,i_wt)
>       END DO
> !$OMP END PARALLEL DO
>     END DO  ! n
>   END DO    ! i_wt
> END IF      ! l_wtrac_jls
> 
1801d2044
< 
1986c2229
<   ALLOCATE(chr10m_sice(1,1,1))
---
>   ALLOCATE(chr10m_sice(1,1,nice_use))
2000c2243,2250
<   chr1p5m_sea(:,:) = 0.0
---
> !$OMP PARALLEL DO SCHEDULE(STATIC) DEFAULT(NONE) PRIVATE(i, j)                 &
> !$OMP SHARED(tdims, chr1p5m_sea)
>   DO j = tdims%j_start,tdims%j_end
>     DO i = tdims%i_start,tdims%i_end
>       chr1p5m_sea(i,j) = 0.0
>     END DO
>   END DO
> !$OMP END PARALLEL DO
2013c2263,2273
<   chr1p5m_sice(:,:,:) = 0.0        ! Initialise
---
>   DO n = 1,nice_use
> !$OMP PARALLEL DO SCHEDULE(STATIC) DEFAULT(NONE) PRIVATE(i, j)                 &
> !$OMP SHARED(tdims, chr1p5m_sice, n)
>     DO j = tdims%j_start,tdims%j_end
>       DO i = tdims%i_start,tdims%i_end
>         chr1p5m_sice(i,j,n) = 0.0        ! Initialise
>       END DO
>     END DO
> !$OMP END PARALLEL DO
>   END DO
> 
2033c2293,2303
<       sf_diag%chr10m(:,:) = ((1.0 - ice_fract(:,:)) * chr10m_sea(:,:))
---
> !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i, j, k ,l, n)                            &
> !$OMP SHARED(sice_pts_ncat, sice_index_ncat, ssi_index, t_i_length, nice_use,  &
> !$OMP        sf_diag, sice_frac_ncat, chr10m_sice, tdims,ice_fract, chr10m_sea)
> !$OMP DO SCHEDULE(STATIC)
>       DO j = tdims%j_start,tdims%j_end
>         DO i = tdims%i_start,tdims%i_end
>           sf_diag%chr10m(i,j) = ((1.0 - ice_fract(i,j)) * chr10m_sea(i,j))
>         END DO
>       END DO
> !$OMP END DO
> 
2034a2305
> !$OMP DO SCHEDULE(STATIC)
2041a2313
> !$OMP END DO
2042a2315
> !$OMP END PARALLEL
2069c2342,2352
<     chr1p5m_ssi_mean(:,:) = ((1.0 - ice_fract(:,:)) * chr1p5m_sea(:,:))
---
> !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i, j, k, l, n)                            &
> !$OMP SHARED(sice_pts_ncat, sice_index_ncat, ssi_index, t_i_length,            &
> !$OMP        chr1p5m_ssi_mean, sice_frac_ncat, chr1p5m_sice,                   &
> !$OMP        tdims, ice_fract, chr1p5m_sea, nice_use)
> !$OMP DO SCHEDULE(STATIC)
>     DO j = tdims%j_start,tdims%j_end
>       DO i = tdims%i_start,tdims%i_end
>         chr1p5m_ssi_mean(i,j) = ((1.0 - ice_fract(i,j)) * chr1p5m_sea(i,j))
>       END DO
>     END DO
> !$OMP END DO
2070a2354
> !$OMP DO SCHEDULE(STATIC)
2077a2362
> !$OMP END DO
2078a2364
> !$OMP END PARALLEL
2098d2383
< 
2100,2101d2384
< 
< 
diff -r vn7.0copy1_c4/src/./science/surface/jules_ssi_sf_implicit.jls.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/surface/jules_ssi_sf_implicit.jls.F90
32a33,34
> ! IN values defining water tracer field dimensions :
>  n_wtrac_jls,                                                                  &
52c54
<  ocn_cpl_point,                                                                &
---
>  ocn_cpl_point, sice_pts_ncat, sea_index, ssi_pts, sice_pts, sea_pts,          &
54c56,62
<  sw_sicat)
---
>  sw_sicat,                                                                     &
>  ! water tracers (IN)
>  fqw_sea_wtrac, fqw_sicat_wtrac,                                               &
>  ! water tracers (IN OUT)
>  fqw_1_wtrac, dfqw_wtrac,                                                      &
>  ! water tracers (OUT)
>  e_sea_wtrac, ei_sice_wtrac)
84a93,95
> USE jules_water_tracers_mod,  ONLY: l_wtrac_imp_jls, standard_ratio_wtrac
> USE sf_ssi_imp_wtrac_mod,     ONLY: sf_ssi_imp_wtrac
> 
91,93d101
< USE ancil_info,               ONLY:                                            &
<   ssi_pts,sice_pts, sice_pts_ncat
< 
102a111
>  ssi_pts, sice_pts, sea_pts,                                                   &
107a117,120
> INTEGER, INTENT(IN) ::                                                         &
>  n_wtrac_jls
>                              ! IN No. of water tracers in JULES
> 
267c280,282
<   sice_index_ncat(t_i_length * t_j_length, nice)
---
>   sice_index_ncat(t_i_length * t_j_length, nice),                              &
>   sice_pts_ncat(nice),                                                         &
>   sea_index(t_i_length * t_j_length)
282a298,333
> ! Water tracers (IN)
> REAL(KIND=real_jlslsm), INTENT(IN) :: fqw_sea_wtrac(                           &
>                                                tdims%i_start:tdims%i_end,      &
>                                                tdims%j_start:tdims%j_end,      &
>                                                n_wtrac_jls)
>                             ! Water tracer surface flux over open ocean
>                             !  from explicit scheme (kg/m2/s)
> REAL(KIND=real_jlslsm), INTENT(IN) :: fqw_sicat_wtrac(                         &
>                                                tdims%i_start:tdims%i_end,      &
>                                                tdims%j_start:tdims%j_end,      &
>                                                nice_use, n_wtrac_jls)
>                             ! Water tracer surface flux over sea ice
>                             !  from explicit scheme per ice cat (kg/m2/s)
> ! Water tracers (INOUT)
> REAL(KIND=real_jlslsm), INTENT(IN OUT) :: fqw_1_wtrac(                         &
>                                          tdims%i_start:tdims%i_end,            &
>                                          tdims%j_start:tdims%j_end,n_wtrac_jls)
>                             ! Water tracer surface moisture flux  (kg/m2/s)
> REAL(KIND=real_jlslsm), INTENT(IN OUT) :: dfqw_wtrac(                          &
>                                                    tdims%i_start:tdims%i_end,  &
>                                                    tdims%j_start:tdims%j_end,  &
>                                                    n_wtrac_jls)
>                             ! Increment to water tracer surface moisture flux
>                             !   (kg/m2/s)
> 
> ! Water tracers (OUT)
> REAL(KIND=real_jlslsm), INTENT(OUT) :: e_sea_wtrac(tdims%i_start:tdims%i_end,  &
>                                          tdims%j_start:tdims%j_end,n_wtrac_jls)
>                             ! Water tracer evaporation from sea times leads
>                             !   fraction (kg/m2/s)
> REAL(KIND=real_jlslsm), INTENT(OUT) :: ei_sice_wtrac(                          &
>                                             tdims%i_start:tdims%i_end,         &
>                                             tdims%j_start:tdims%j_end,         &
>                                             nice_use,n_wtrac_jls)
>                             ! Water tracer sublimation from sea ice per
>                             !   ice category (kg/m2/s)
305c356
<                tdims%j_start:tdims%j_end)
---
>                tdims%j_start:tdims%j_end)                                      &
308a360,365
> ,snowinc_sice(tdims%i_start:tdims%i_end,                                       &
>            tdims%j_start:tdims%j_end,1)
>                              ! Snow increment on sea ice category.
>                              ! Needed for consistency with the land surface
>                              ! but not used directly, so only allocated
>                              ! with a size of 1 in the third dimension
314c371,374
< ! dummy arrays required for sea and se-ice to create universal
---
> REAL(KIND=real_jlslsm), ALLOCATABLE :: sea_frac(:)
>                              ! Leads fraction (used for water tracers)
> 
> ! dummy arrays required for sea and sea-ice to create universal
331c391
< ,n
---
> ,n                                                                             &
333c393,394
< 
---
> ,i_wt
>             ! LOCAL Loop counter (water tracers)
366d426
< 
481a542
> !$OMP        snowinc_sice,                                                     &
502a564,571
> !$OMP DO SCHEDULE(STATIC)
>   DO j = tdims%j_start,tdims%j_end
>     DO i= tdims%i_start,tdims%i_end
>       snowinc_sice(i,j,1)       = 0.0
>     END DO
>   END DO
> !$OMP END DO NOWAIT
> 
591c660
<         array_one,rhokh_sice(:,:,n),sice_frac_ncat(:,n),timestep,              &
---
>         array_one,array_one,rhokh_sice(:,:,n),sice_frac_ncat(:,n),timestep,    &
596c665
<         sice_melt(:,:,n)                                                       &
---
>         sice_melt(:,:,n),snowinc_sice(:,:,1)                                   &
645c714
<         array_one,rhokh_sice(:,:,1),sice_frac_ncat(:,n),timestep,              &
---
>         array_one,array_one,rhokh_sice(:,:,1),sice_frac_ncat(:,n),timestep,    &
650c719
<         sice_melt(:,:,n)                                                       &
---
>         sice_melt(:,:,n),snowinc_sice(:,:,1)                                   &
677a747,787
>   !--------------------------------------------------------------------------
>   ! Update water tracers for implicit calculation
>   !--------------------------------------------------------------------------
> 
>   IF (l_wtrac_imp_jls) THEN
> 
>     ALLOCATE(sea_frac(t_i_length * t_j_length))        ! Leads fraction
> 
>     DO i_wt = 1, n_wtrac_jls
> 
>       ! Set up leads fraction
> !$OMP PARALLEL DO SCHEDULE(STATIC) DEFAULT(NONE) PRIVATE(l)                    &
> !$OMP SHARED(sice_frac,sea_frac,t_i_length,t_j_length)
>       DO l = 1, t_i_length * t_j_length
>         sea_frac(l) = 1.0 - sice_frac(l)
>       END DO
> !$OMP END PARALLEL DO
> 
>       ! Ocean
>       CALL sf_ssi_imp_wtrac(                                                   &
>         ssi_pts, sea_pts, ssi_index, sea_index,                                &
>         standard_ratio_wtrac(i_wt), sea_frac, fssi_ij,  e_sea,                 &
>         fqw_sea_wtrac(:,:,i_wt), fqw_sea_wtrac(:,:,1),                         &
>         fqw_1_wtrac(:,:,i_wt), dfqw_wtrac(:,:,i_wt),                           &
>         e_sea_wtrac(:,:,i_wt))
> 
>       ! Sea ice
>       DO n = 1, nice
>         CALL sf_ssi_imp_wtrac(                                                 &
>           ssi_pts, sice_pts_ncat(n), ssi_index, sice_index_ncat(:,n),          &
>           standard_ratio_wtrac(i_wt), sice_frac_ncat(:,n), fssi_ij,            &
>           fqw_ice(:,:,n),                                                      &
>           fqw_sicat_wtrac(:,:,n,i_wt), fqw_sicat_wtrac(:,:,n,1),               &
>           fqw_1_wtrac(:,:,i_wt), dfqw_wtrac(:,:,i_wt),                         &
>           ei_sice_wtrac(:,:,n,i_wt))
>       END DO
> 
>     END DO   ! i_wt
>     DEALLOCATE(sea_frac)
>   END IF  ! l_wtrac_imp_jls
> 
968a1079,1095
>   IF (l_wtrac_imp_jls) THEN
>     ! Convert water tracer ocean evaporation into sea mean (to keep it
>     ! consistent with e_sea above)
> !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i,j,i_wt)                                 &
> !$OMP SHARED(n_wtrac_jls,tdims,e_sea_wtrac,ice_fract)
>     DO i_wt = 1, n_wtrac_jls
> !$OMP DO SCHEDULE(STATIC)
>       DO j = tdims%j_start,tdims%j_end
>         DO i = tdims%i_start,tdims%i_end
>           e_sea_wtrac(i,j,i_wt) = (1.0 - ice_fract(i,j))                       &
>                                            * e_sea_wtrac(i,j,i_wt)
>         END DO
>       END DO
> !$OMP END DO NOWAIT
>     END DO
> !$OMP END PARALLEL
>   END IF
diff -r vn7.0copy1_c4/src/./science/surface/leaf_jls_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/surface/leaf_jls_mod.F90
15,18c15,16
< ,                clos_index ,open_index, veg_index, icr, fpar, pstar           &
< ,                t1,t_growth_gb,vpd,vpd_growth_gb,l_growth_gb, co2_growth_gb   &
< ,                pstar_growth_gb,xipam_opt,vcmax_opt,jmax_opt                  &
< ,                ca,cim,ci, fsmc, o3mol, ra, tl, wcarb, wexpt, wlite, rd          &
---
> ,                clos_index ,open_index, veg_index                             &
> ,                ca, ci, fsmc, o3mol, ra, tl, wcarb, wexpt, wlite, rd          &
21,22c19
< USE pftparm, ONLY: beta_c3c4, dfp_dcuo, eagamma, eakc, eako, fd, fl_o3_ct      &
< ,                 gamma25, glmin, kc25, ko25,c3
---
> USE pftparm, ONLY: dfp_dcuo, fl_o3_ct, glmin
25c22
< USE conversions_mod, ONLY:zerodegc
---
> 
28,29c25
<     photo_collatz, photo_farquhar, photo_pmodel,photo_acclim_model,            &
<     photo_adapt, photo_acclim, photo_adapt_acclim, photo_pmodel_acclim,        &
---
>     photo_collatz, photo_farquhar,                                             &
32c28
< USE model_time_mod, ONLY: timestep_len, current_time
---
> 
72,73c68,69
<  ,ci(land_field)                                                               &
<                             ! Leaf-internal CO2 partial pressure (Pa).
---
> ,ci(land_field)                                                                &
>                             ! Internal CO2 pressure (Pa).
83a80,82
> ,wcarb(land_field)                                                             &
>                             ! Carboxylation-limited gross photosynthetic
>                             ! rate (mol CO2/m2/s).
87,96c86,88
< ,icr(land_field)                                                               &
<                             ! Incident PAR (mol photons m-2 s-1).
< ,fpar(land_field)                                                              &
< 			    ! PAR absorption factor.
< ,pstar(land_field)                                                             &
<                             ! Surface pressure (Pa).
< ,t1(land_field) 
<                             ! Atmospheric temperature (K)
< 
<                                                                  
---
> ,wlite(land_field)
>                             ! Light-limited gross photosynthetic rate
>                             ! (mol CO2/m2/s).
102,140c94,95
<  rd(land_field)                                                                &
<                              ! Dark respiration (mol CO2/m2/s).
< ,wcarb(land_field)                                                             &
<                             ! Carboxylation-limited gross photosynthetic
<                             ! rate (mol CO2/m2/s).    
< ,wlite(land_field)                                                             &
<                             ! Light-limited gross photosynthetic rate
<                             ! (mol CO2/m2/s).                               
< ,co2_growth_gb(land_field)                                                     &
<                             ! Running mean (growth) CO2 for
<                             ! acclimation of photosynthesis  
< ,l_growth_gb(land_field)                                                       &
<                             ! exponantial mean (growth) light for
<                             ! acclimation of photosynthesis                                                      
< ,pstar_growth_gb(land_field)                                                  &
<                             ! Running mean (growth) surface pressure for
<                             ! acclimation of photosynthesis
< ,t_growth_gb(land_field)                                                       &
<                             ! Running mean (growth) temperature for
<                             ! acclimation of photosynthesis (K).
<                             ! Atmospheric temperature (K).
< ,jmax_opt(land_field)                                                          &
< 			    ! Maximum rate of electron transport at optimal
<                             ! condition (mol m-2 s-1)
< ,vpd_growth_gb(land_field)                                                     &
<                             ! optimal vapour pressure          
<                             ! deficit for acclimation of photosynthesis
< ,vcmax_opt(land_field)                                                         &
< 			    ! Maximum rate of carboxylation at optimal
<                             ! condition(mol CO2/m2s)  
< ,xipam_opt(land_field)                                                         &
<                             ! Sensitivity of ci/ca ratio to VPD at 
<                             ! optimal condition (Pa^1/2)
< ,cim(land_field)                                                               &
< ! Leaf-internal CO2 partial pressure (Pa). pmodel
< ,vpd(land_field)
<                             ! optimal vapour pressure          
<                             ! deficit for acclimation of photosynthesis                            
< 
---
>  rd(land_field)              ! Dark respiration (mol CO2/m2/s).
>                              ! This is modified only if l_o3_damage=.TRUE..
161,174c116
< ,j,m,l                                                                          &                       
<                               ! Loop counters.
< ,current_time_pmodel        ! save currentime for comparison                              
< 
< !-----------------------------------------------------------------------------
< ! Local parameters.
< !-----------------------------------------------------------------------------
< REAL(KIND=real_jlslsm), PARAMETER ::                                           &
<   ha = 65330.0,                                                                &
<     ! Activation energy
<   rgas = 8.314,                                                                &
<     ! Universal gas constant 
<   haj = 43900.0
<     ! Deactivation energy
---
> ,j,l                        ! Loop counters.
179c121
<   beta1p2m4, beta2p2m4
---
>   beta1p2m4, beta2p2m4,                                                        &
180a123,124
>   glmin_ft
>                             ! glmin(ft)
191c135,137
< ,wp(land_field)                                                                &
---
> ,wl(land_field)                                                                &
>                             ! Gross leaf phtosynthesis (mol CO2/m2/s).
> ,wp(land_field)
194,237d139
< ,gammastar25(land_field)                                                  &
< 			    ! CO2 compensation point at 25 degree C (Pa)
< ,gammastarm(land_field)                                                   &
< 			    ! Pressure-dependent photorespiratory          
< 		            ! compensation point  (Pa)  
< ,iabs_light(land_field)                                                         &
< 		            ! Amount of absorbed light (Photon mol m-2 s-1).              
< ,gammastarm_opt(land_field)                                               &
<           ! Pressure-dependent photorespiratory at optimal
< ,jmax25_opt(land_field)                                                   &
< 			    ! Maximum rate of electron transport at optimal
<                             ! condition normalirsed at 25 degree (mol m-2 s-1) 
< ,jmax_pmodel(land_field)                                                  &
< 			    ! Maximum rate of electron transport (mol m-2 s-1)
< ,jmax_adjusted(land_field)                                                &
< 			    ! Adjusted maximum rate of electron transport 
<                             ! (mol m-2 s-1)
< ,jp1(land_field)                                                           &
< 			  ! The electron transport rate mol electrons (m-2 s-1)                           
< ,kcpa(land_field)                                                         &
<                           ! Michaelis-Menten constant for CO2 (Pa) for a point. 
< ,kopa(land_field)                                                         &
<                           ! Michaelis-Menten constant for O2 (Pa) for a point.
< ,kmpa(land_field)                                                          &
< 	   	    	  ! A combination of Michaelis-Menten and other terms.
< ,ta(land_field)                                                            &
< 		            ! Atmospheric temperature (degree C). 
< ,O2_partial_pres(land_field)                                               &
<                             ! Atmospheric O2 partial pressure (K). 
< ,phi0(land_field)                                                          &
< 			    ! Intrinsic quantum yield parameter. 
< ,pratio(land_field)                                                        &
<                             ! Atmospheric pressure/atmospheric pressure at 0m
< ,tgdegc(land_field)                                                        &
<                             ! Temperatures t_growth_gb in degrees Celsius.                            
< ,vcmax25_opt(land_field)                                                   &
< 			    ! Maximum rate of carboxylation (mol CO2/m2s) 
<                             ! normalise at 25 degrees
< ,vcmax_pmodel(land_field)                                                  &
< 			    ! Maximum rate of carboxylation (mol CO2/m2s)
< ,vcmax_adjusted(land_field)                                                &
< 			    ! Adjusted maximum rate of carboxylation 
<                             ! (mol CO2/m2s)                 
< ,viscosityh2ostar(land_field)                                              &
239,243c141,143
< 		            ! viscosity of water unit less
< ,wl(land_field)                                                                &
<                             ! Gross leaf phtosynthesis (mol CO2/m2/s).
< ,xipam(land_field)
< 		            ! Sensitivity of ci/ca ratio to VPD (Pa^1/2)                               
---
> INTEGER ::                                                                     &
>  land_grid_index(open_pts)
>                             ! Land grid index
252a153,157
> DO j = 1,open_pts
>   land_grid_index(j) = veg_index(open_index(j))
> END DO
> glmin_ft = glmin(ft)
> 
255c160
< !$OMP SHARED(open_pts, pft_photo_model, veg_index, open_index, beta1,          &
---
> !$OMP SHARED(open_pts, pft_photo_model, land_grid_index, beta1,                &
258c163
< !$OMP        conv, tl, glco2, ca, ci, gl, glmin, l_o3_damage, ft,              &
---
> !$OMP        conv, tl, glco2, ca, ci, gl, glmin_ft, ft, l_o3_damage,           &
274c179
<     l = veg_index(open_index(j))
---
>     l = land_grid_index(j)
289c194
<     !print*,'wl',wl
---
> 
293a199
> 
300c206
<     l = veg_index(open_index(j))
---
>     l = land_grid_index(j)
303d208
< 
305,494d209
< CASE ( photo_pmodel )
<  SELECT CASE ( photo_acclim_model )
<  CASE ( 0 )
< !$OMP END PARALLEL DO
<   CASE ( photo_adapt, photo_acclim, photo_adapt_acclim )
<       ! DO nothing
< CASE( photo_pmodel_acclim )
<   DO m = 1,veg_pts
<     l = veg_index(m)
<     ta(l) = tl(l) - zerodegc
<    ! print*,'t',tl(l)
<    ! print*,'ta',ta(l)
<     !--------------------------------------------------------------------------
<     !Calculate adjusted Vcmax, Jmax and xim at current time step
<     !Calculate acclimated GPP
<     !(Mengoli et al., 2022)
<     !--------------------------------------------------------------------------
<     !--------------------------------------------------------------------------
<     ! Compute K at give condition(effective Michaelis-Menten coefficient) current
<     !--------------------------------------------------------------------------
<     O2_partial_pres(l) = 2.09476E5 * 1.0E-6 * pstar(l)
<   !print*,'pstar',pstar(l)
<     !--------------------------------------------------------------------------
<     ! Effective Michaelis-Menten coefficient Kc and ko in pascal
<     !--------------------------------------------------------------------------
<     kcpa(l) = kc25(ft) * exp(eakc(ft)*(ta(l) - 25.0)                           &
<                                             /(298.15*8.3145* tl(l)))
<     kopa(l) = ko25(ft) * exp(eako(ft)*(ta(l) - 25.0)                           &
<                                             /(298.15*8.3145* tl(l))) 
<     ! Compute Kmpa in Pascal 
<     kmpa(l) = kcpa(l) * (1.0 + O2_partial_pres(l)/kopa(l))
<    !print*, 'cpa',kmpa(l)
<    !---------------------------------------------------------------------------
<    !calculate the dark respiration mol co2 m-2 s-1 (Wang et al., 2020)
<    !---------------------------------------------------------------------------
<    ! rd(l) = 0.03 * vcmax_opt(l) / EXP((ha/rgas) *                                &
<     !((t_growth_gb(l) -273.15 - 25) / (298.15 * t_growth_gb(l))))*           &
<    ! EXP(0.1012*(t_growth_gb(l) - 273.15-25) - 0.0005*(t_growth_gb(l)**2-25**2))*1E-6
<   !print*,'rd',rd(l)
<     !--------------------------------------------------------------------------
<     ! Adjust gammaStar25 for the pressure at current surface pressure
<     !--------------------------------------------------------------------------
<     pratio(l) = pstar(l)/  101325.0
<     !--------------------------------------------------------------------------
<     ! Compute CO2 compensation point at current surface pressure
<     !--------------------------------------------------------------------------
<     ! Adjust gammaStar25 for the pressure at given surface pressure
<     gammastar25(l) = gamma25(ft) * pratio(l)
<     !--------------------------------------------------------------------------
<     ! Pressure-dependent photorespiratory compensation point
<     !--------------------------------------------------------------------------
<     gammastarm(l) = gammastar25(l) *                                           &
<                    EXP(eagamma(ft) *(ta(l) - 25.0)                             &
<                                      /(8.3145 * 298.15 * tl(l)))
<   !print*, 'cgamma',gammastarm(l)
<   !--------------------------------------------------------------------------
<   ! Compute water viscosity optimal
<   !--------------------------------------------------------------------------
<   viscosityh2ostar(l) = (exp(-3.719 + 580 /((ta(l) + 273) - 138.0)))/    &
<                                0.9102827622
<   !print *, '3', viscosityh2ostar(l)
<   cim(l) = (xipam_opt(l)*ca(l) + gammastarm(l)                          &
<        *sqrt(vpd(l))) /(xipam_opt(l) + sqrt(vpd(l)))
<  ! print*,'ci',cim(l)
<   !--------------------------------------------------------------------------
<   ! Compute sensitivity of ci/ca ratio to VPD (xi)
<   !--------------------------------------------------------------------------
<    xipam(l) = sqrt((beta_c3c4(ft) * (kmpa(l)+gammastarm(l)))               &
<                     / (1.6*viscosityh2ostar(l)))
<    !align with 
<    !print*,'vl',vpd(l)
<    !--------------------------------------------------------------------------
<    ! Calculate absorbed light
<    !--------------------------------------------------------------------------   
<     iabs_light(l) = icr(l)*fpar(l)
<     !print *, 'iabs_light',iabs_light(l)
<     !--------------------------------------------------------------------------
<     ! calculate vcmax at optimal condition
<     ! [molco2 m-2 s-1] optimal kmpa,gammastarm
<     !--------------------------------------------------------------------------
<    ! IF ((1-(0.41*(cim(l)+2*gammastarm(l))/                           &
<    !                 (cim(l)-gammastarm(l)))**(2.0/3))<0) THEN
<    !   vcmax_pmodel(l) = phi0(l) * iabs_light(l) * sqrt(1 - 0.41**(2.0/3))
<    !  ELSE
<    !  vcmax_pmodel(l) = phi0(l) * iabs_light(l) * (cim(l) + kmpa(l))/     &
<    !                             (cim(l) + 2.0 * gammastarm(l)) *      &
<    !           sqrt(1.0 - (0.41 * (cim(l)+ 2.0 * gammastarm(l))        & 
<    !                         / (cim(l) - gammastarm(l))) ** (2.0/3.0))
<    ! END IF 
<     !vcmax_pmodel(l) = max(0.0,vcmax_pmodel(l))
<    !---------------------------------------------------------------------------
<    !calculate adjusted vcmax (mol CO2 m2-1 s-1) 
<    !(Mengoli et al., 2022)
<    !---------------------------------------------------------------------------
<    vcmax_adjusted(l) = vcmax_opt(l)*exp((ha/rgas)*(1/298.15-1/tl(l)))
<    !vcmax_adjusted(l) = vcmax_pmodel(l) 
< !   print *, 'b',vcmax_adjusted(l)
<    rd(l) = 0.015 * vcmax_adjusted(l)*1e-6
<    END DO
<    DO j = 1,open_pts
<     l = veg_index(open_index(j))
<    !---------------------------------------------------------------------------
<    !calculate gross primary productivity umol CO2 m-2 s-1 light
<    !---------------------------------------------------------------------------   
<     !--------------------------------------------------------------------------
<     ! compute maximum rate of electron transport (ref: Wang et al., 2017)
<     ! [mol electrons m2-1 s-1]
<     !--------------------------------------------------------------------------
<     !IF ((1-(0.41*(cim(l)+2*gammastarm(l))/                           &
<     !               (cim(l)-gammastarm(l)))**(2.0/3))<0)THEN
<     !jmax_pmodel(l)=(4.0*phi0(l)*iabs_light(l))/SQRT(1/(1-0.41**(2.0/3.0))-1.0)
<     !print*,'JR'
<     !ELSE
<     !jmax_pmodel(l) =( 4 * phi0(l) * iabs_light(l) ) / sqrt (              &
<     !1/(1-(0.41 * ( cim(l) + 2*gammastarm(l) ) /                      &
<     !                ( cim(l) - gammastarm(l) ) ) ** (2.0/3.0) ) - 1 )
<     !print*,'jn'
<     ! END IF  
<     !jmax_pmodel(l)=MAX(0.0, jmax_pmodel(l))
<    !---------------------------------------------------------------------------
<    !calculate adjusted jmax (umol CO2/m2s)
<    !---------------------------------------------------------------------------
<    jmax_adjusted(l) = jmax_opt(l) * EXP((haj/rgas)* (1/298.15 - 1/tl(l)))
<    !jmax_adjusted(l) = jmax_pmodel(l)
<    !PRINT *, 'c', jmax_adjusted(l)
< 
<    IF (c3(ft) ==1 ) THEN
<    !---------------------------------------------------------------------------
<    ! calcaulate intrinsic quantum efficiency of photosynthesis 
<    ! phi0 is temperature dependent (phi0, mol Co2/mol photons)
<    ! (ref: Bernacchi et al., 2003)
<    !---------------------------------------------------------------------------
<     phi0(l) = (1.0/8.0) * (0.352 + 0.022 * ta(l) - 0.00034 * ta(l) ** 2)
<     !print*,'phi',phi0(l)
<    !---------------------------------------------------------------------------
<    ! Compute the electron transport rate (Smith et al, 1937)
<    ! [mol CO2 m2-1 s-1]
<    !---------------------------------------------------------------------------
<    jp1(l) = (4.0* phi0(l) * iabs_light(l))/                                     &
<                 sqrt(1+((4*phi0(l)*iabs_light(l)/jmax_adjusted(l)) ** 2))
<     !print*,'jp1',jp1(l)
<    !---------------------------------------------------------------------------
<    !aj with the acclimated cim and current gammastarm
<    !umol to mol
<    !calculate acclimated Rubisco-limited assimilation rate (ac1)
<    !this gammastarm and kmpa are current 
<    !---------------------------------------------------------------------------
<     wlite(l) = ((jp1(l)/4.0) * (cim(l) - gammastarm(l)) /                       &
<                                  (cim(l) + 2.0 * gammastarm(l)))*1E-6
<     wcarb(l) =(vcmax_adjusted(l) *(cim(l) - gammastarm(l))                      &
<                                  /(cim(l)+kmpa(l)) )*1E-6
<     !print*,'c3'
<     wl(l) = MIN(wcarb(l), wlite(l))
<     !print*,'d', wlite(l)
<     !print*,'e',wcarb(l)
<     !print*,'gpp_leaf',wl(l)
<     ELSE !c4 phi0
<     !---------------------------------------------------------------------------
<     ! calcaulate intrinsic quantum efficiency of photosynthesis 
<     ! phi0 is temperature dependent (phi0, mol Co2/mol photons)
<     ! (ref: Bernacchi et al., 2003)
<     !---------------------------------------------------------------------------
<     phi0(l) = (-0.008 + 0.00375 * ta(l) - 0.58 * 1e-4 * ta(l) ** 2)
<    !---------------------------------------------------------------------------
<    ! Compute the electron transport rate (Smith et al, 1937)
<    ! [mol CO2 m2-1 s-1]
<    !---------------------------------------------------------------------------
<     jp1(l) = (4.0* phi0(l) * iabs_light(l))/                                     &
<     sqrt(1+((4*phi0(l)*iabs_light(l)/jmax_adjusted(l)) ** 2))
<    !---------------------------------------------------------------------------
<    !aj with the acclimated cim and current gammastarm
<    !umol to mol
<    !calculate acclimated Rubisco-limited assimilation rate (ac1)
<    !this gammastarm and kmpa are current 
<    !---------------------------------------------------------------------------
<     wlite(l) = (jp1(l)/4.0) *1E-6
<     wcarb(l) = vcmax_adjusted(l)*1E-6 !c4 carbon limited assmilation rate
<    !print*,'c4'
<     wl(l) = MIN(wcarb(l), wlite(l))
<    !print*,'d', wlite(l)
<    !print*,'e',wcarb(l)
<    !print*,'gpp_leaf',wl(l)
<    !compute gpp
<    END IF
< 
< 
< 
< 
<   END DO
<   END SELECT !  photo_acclim_model 
496a212
> !$OMP MASTER
499c215,216
<                'pft_photo_model should be photo_collatz or photo_farquhar or P')
---
>                'pft_photo_model should be photo_collatz or photo_farquhar')
> !$OMP END MASTER
503d219
< 
510c226,227
<   l = veg_index(open_index(j))
---
>   l = land_grid_index(j)
> 
515c232
<   !print*,'npp_l',al(l)
---
> 
519a237,243
> 
>   !---------------------------------------------------------------------------
>   ! Diagnose the leaf conductance
>   !---------------------------------------------------------------------------
>   glco2(l) = (al(l) * conv(l)) / (ca(l) - ci(l))
>   gl(l)    = ratio * glco2(l)
> 
530c254
<   l = veg_index(open_index(j))
---
>   l = land_grid_index(j)
532,533c256,257
<   IF (gl(l) <= glmin(ft) .OR. al(l) <= 0.0) THEN
<     gl(l) = glmin(ft)
---
>   IF (gl(l) <= glmin_ft .OR. al(l) <= 0.0) THEN
>     gl(l)    = glmin_ft
547c271
<     l = veg_index(open_index(j))
---
>     l = land_grid_index(j)
587c311
<     l = veg_index(open_index(j))
---
>     l = land_grid_index(j)
589,590c313,314
<     IF (gl(l) <= glmin(ft) .OR. al(l) <= 0.0) THEN
<       gl(l) = glmin(ft)
---
>     IF (gl(l) <= glmin_ft .OR. al(l) <= 0.0) THEN
>       gl(l) = glmin_ft
604c328
< !$OMP  SHARED(clos_pts,veg_index,clos_index,gl,glmin,ft,al,rd,fsmc,l_o3_damage,fo3)
---
> !$OMP  SHARED(clos_pts,veg_index,clos_index,gl,glmin_ft,al,rd,fsmc,l_o3_damage,fo3)
608c332,333
<   gl(l)    = glmin(ft)
---
> 
>   gl(l)    = glmin_ft
609a335
> 
diff -r vn7.0copy1_c4/src/./science/surface/leaf_limits_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/surface/leaf_limits_mod.F90
44c44
<     photo_collatz, photo_farquhar,photo_pmodel, stomata_jacobs,                &
---
>     photo_collatz, photo_farquhar, stomata_jacobs,                             &
161c161
< !$OMP PARALLEL DO                                                              &
---
> !$OMP PARALLEL DO IF(veg_pts > 1)                                              &
176a177
> 
195a197
> 
277a280,284
> !$OMP PARALLEL DO IF(open_pts > 1)                                             &
> !$OMP SCHEDULE(STATIC)                                                         &
> !$OMP DEFAULT(NONE)                                                            &
> !$OMP PRIVATE(l,j)                                                             &
> !$OMP SHARED(open_pts,veg_index,open_index,wcarb,vcmax,wlite,ci,ccp,km,je)
283a291
> !$OMP END PARALLEL DO
285,286d292
< CASE ( photo_pmodel )
< ! Do nothing at this stage for the p-model
290c296
<       'pft_photo_model should be photo_collatz, photo_farquhar or photo_pmodel')
---
>                'pft_photo_model should be photo_collatz or photo_farquhar')
293d298
< 
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/surface: leaf_processes_sox_mod.F90
diff -r vn7.0copy1_c4/src/./science/surface/microbe_jls.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/surface/microbe_jls.F90
21c21
< SUBROUTINE microbe (land_pts,dim_cs1,dim_cs2,l_q10,cs,                         &
---
> SUBROUTINE microbe (land_pts,dim_cs1,l_q10,cs,                                 &
27c27
<    soil_model_1pool, soil_model_rothc,                                         &
---
>    soil_model_1pool, soil_model_4pool,                                         &
32c32
<    kaps_roth
---
>    kaps_4pool
51c51
< ,dim_cs1, dim_cs2           ! IN soil carbon dimensions
---
> ,dim_cs1                    ! IN soil carbon dimensions
59c59
< !                                 !    For RothC (dim_cs1=4), the pools
---
> !                                 !    For 4-pool soil C (dim_cs1=4), the pools
61c61
< ,veg_frac(dim_cs2)                                                             &
---
> ,veg_frac(land_pts)                                                            &
197c197
<   ! use RothC temperature formula (using TSOIL for now...)
---
>   ! use 4-pool temperature formula (using TSOIL for now...)
212c212
< !        only set for RothC runs.
---
> !        only set for 4-pool soil C runs.
214c214
< IF ( soil_bgc_model == soil_model_rothc ) THEN
---
> IF ( soil_bgc_model == soil_model_4pool ) THEN
222c222
< ! set 1-D or 4-D soil resp depending on whether using RothC or not
---
> ! set 1-D or 4-D soil resp depending on whether using 4-pools or not
224c224
<   IF ( soil_bgc_model == soil_model_rothc ) THEN
---
>   IF ( soil_bgc_model == soil_model_4pool ) THEN
228c228
<         resp_s(l,1,n) = kaps_roth(n) * cs(l,1,n) * fsth(l,1) * ftemp(l,1) *    &
---
>         resp_s(l,1,n) = kaps_4pool(n) * cs(l,1,n) * fsth(l,1) * ftemp(l,1) *   &
231c231
<           resp_s(l,j,n) = kaps_roth(n) * cs(l,j,n) * fsth(l,j) * ftemp(l,j) *  &
---
>           resp_s(l,j,n) = kaps_4pool(n) * cs(l,j,n) * fsth(l,j) * ftemp(l,j) * &
257c257
<   IF ( soil_bgc_model == soil_model_rothc ) THEN
---
>   IF ( soil_bgc_model == soil_model_4pool ) THEN
262c262
<           resp_s(l,1,n) = kaps_roth(n) * cs(l,1,n) * fsth(l,2) *               &
---
>           resp_s(l,1,n) = kaps_4pool(n) * cs(l,1,n) * fsth(l,2) *              &
265c265
<           resp_s(l,1,n) = kaps_roth(n) * cs(l,1,n) * fsth(l,1) *               &
---
>           resp_s(l,1,n) = kaps_4pool(n) * cs(l,1,n) * fsth(l,1) *              &
diff -r vn7.0copy1_c4/src/./science/surface/physiol_jls_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/surface/physiol_jls_mod.F90
21,22c21,22
<   sm_levels,nsurft,surft_pts,surft_index,                                      &
<   dim_cs1,dim_cs2,                                                             &
---
>   sm_levels,nsurft,n_wtrac_jls,surft_pts,surft_index,                          &
>   dim_cs1,                                                                     &
25c25
<   lai_pft,pstar,qw_1,tl_1, sthu_soilt,sthf_soilt,t_soil_soilt,tstar_surft,     &
---
>   lai_pft,pstar,qw_1,sthu_soilt,sthf_soilt,t_soil_soilt,tstar_surft,           &
27,30c27,28
<   canhc_surft,vfrac_surft,emis_surft,emis_soil,flake,                          &
<   g_leaf,gs,gc_surft,gc_stom_surft,gpp,gpp_pft,gpp_pft_lay, apar_pft_lay,      &
<   cmpf_pft_lay, vcmax_pft_lay, vcmax25_pft_lay, wlite_pft_lay, wcarb_pft_lay,  &
<   wmin_pft_lay, ej_pft_lay, npp,npp_pft,                                       &
---
>   canhc_surft,vfrac_surft,emis_surft,l_emis_surft_set,emis_soil,flake,         &
>   g_leaf,gs,gc_surft,gc_stom_surft,gc_corr,gpp,gpp_pft,npp,npp_pft,            &
37a36,39
>   !SUGAR variables
>   f_nsc_pft, growth_sug_gb, growth_sug_pft,                                    &
>   ! SOX variables
>   psi_root_zone_pft, lwp_c_pft,                                                &
40,42c42
<   t_home_gb,t_growth_gb,l_growth_gb,vpd_growth_gb,co2_growth_gb,               &
<   pstar_growth_gb, xipam_opt,vcmax_opt,jmax_opt,t_sum,l_sum,                   &
<   t_night,nt_sum,vpd_sum,co2_sum,pstar_sum,                                    &
---
>   t_home_gb,t_growth_gb,                                                       &
61c61,65
<   diff_frac)
---
>   diff_frac,                                                                   &
>   ! water tracers (IN)
>   sthu_soilt_wtrac,                                                            &
>   ! water tracers (OUT)
>   smc_soilt_wtrac)
75c79
< USE conversions_mod, ONLY: zerodegc
---
> 
86c90
<   soil_model_1pool, soil_model_rothc,                                          &
---
>   soil_model_1pool, soil_model_4pool,                                          &
100c104
<   l_crop, l_use_pft_psi, l_triffid, n_day_photo_acclim
---
>   l_crop, l_use_pft_psi, l_triffid
106,107c110
< USE pftparm, ONLY: emis_pft, fsmc_p0, rootd_ft, gsoil_f,beta_c3c4,eagamma,     & 
<               eakc, eako, gamma25, kc25, ko25
---
> USE pftparm, ONLY: emis_pft, fsmc_p0, rootd_ft, gsoil_f
121,122d123
< USE model_time_mod, ONLY: timestep_len, current_time
< 
138a140,141
> USE jules_water_tracers_mod, ONLY: l_wtrac_jls, wtrac_calc_ratio_fn_jules
> 
158a162,163
>   n_wtrac_jls,                                                                 &
>     !Number of water tracers in JULES
165c170
<   dim_cs1, dim_cs2
---
>   dim_cs1
169c174
<   l_co2_interactive
---
>   l_co2_interactive,                                                           &
170a176,177
>   l_emis_surft_set(nsurft)
>     !switch for varying surface emissivity of surface tiles
193,194d199
<   tl_1(tdims%i_start:tdims%i_end,tdims%j_start:tdims%j_end),                   &
<     ! Ice/liquid water temperature
227a233,234
>   emis_surft(land_pts,nsurft),                                                 &
>     !Emissivity for land tiles
240c247
<   gpp(land_pts)                                                                &
---
>   gpp(land_pts),                                                               &
242,261c249,250
< ,gpp_pft(land_pts, npft)                                                       &
<   ! Gross primary productivity on PFTs (kg C/m2/s)
< ,gpp_pft_lay(land_pts, npft, ilayers)                                          &
<   ! Gross primary productivity per layer (kg C/m2/s)
< ,apar_pft_lay(land_pts, npft, ilayers)                                         &
<   ! Absorbed PAR per layer (W/m2)
< ,cmpf_pft_lay(land_pts, npft, ilayers)                                         &
<   ! CO2 compensation factor per layer (unitless)
< ,vcmax_pft_lay(land_pts, npft, ilayers)                                        &
<   ! Vcmax per layer (mol CO2/m2/s)
< ,vcmax25_pft_lay(land_pts, npft, ilayers)                                      &
<   ! Vcmax25 per layer (mol CO2/m2/s)
< ,wlite_pft_lay(land_pts, npft, ilayers)                                        &
<   ! Light-limited photosynthesis per layer (mol CO2/m2/s)
< ,wcarb_pft_lay(land_pts, npft, ilayers)                                        &
<   ! Carbon-limited photosynthesis per layer (mol CO2/m2/s)
< ,wmin_pft_lay(land_pts, npft, ilayers)                                         &
<   ! Minimum of light- and carbon-limited photosynthesis per layer (mol CO2/m2/s)
< ,ej_pft_lay(land_pts, npft, ilayers),                                          &
<   ! Electron transport per layer (mol/m2/s)
---
>   gpp_pft(land_pts,npft),                                                      &
>     !Gross primary productivity (kg C/m2/s).
287c276
<     !Available moisture in the  soil profile (mm).
---
>     !Available moisture in the soil profile (mm).
290,291d278
<   emis_surft(land_pts,nsurft),                                                 &
<     !Emissivity for land tiles
303c290
<   gc_stom_surft(land_pts,nsurft)
---
>   gc_stom_surft(land_pts,nsurft),                                              &
304a292,304
>   gc_corr(land_pts,npft),                                                      &
>     !Stomatal conductance without bare soil evaporation
>   f_nsc_pft(land_pts,npft),                                                    &
>     !Plant non-structural carbohdrate mass fraction (kgC/kgC)
>   growth_sug_gb(land_pts),                                                     &
>     !Gridbox mean structural C growth rate (kg C/m2/s)
>   growth_sug_pft(land_pts,npft),                                               &
>     !Plant structural C growth rate (kg C/m2/s)
>   psi_root_zone_pft(land_pts,npft),                                            &
>     !Water potential in the root zone (Pa)
>   lwp_c_pft(land_pts,npft)
>     !Canopy leaf water potential (MPa)
> 
315,329d314
< REAL(KIND=real_jlslsm), INTENT(IN OUT) :: t_growth_gb(land_pts,npft)
< REAL(KIND=real_jlslsm), INTENT(IN OUT) :: l_growth_gb(land_pts,npft)
< REAL(KIND=real_jlslsm), INTENT(IN OUT) :: vpd_growth_gb(land_pts,npft)
< REAL(KIND=real_jlslsm), INTENT(IN OUT) :: co2_growth_gb(land_pts,npft)
< REAL(KIND=real_jlslsm), INTENT(IN OUT) :: pstar_growth_gb(land_pts,npft)
< REAL(KIND=real_jlslsm), INTENT(IN OUT) :: xipam_opt(land_pts,npft)
< REAL(KIND=real_jlslsm), INTENT(IN OUT) :: vcmax_opt(land_pts,npft)
< REAL(KIND=real_jlslsm), INTENT(IN OUT) :: jmax_opt(land_pts,npft)
< REAL(KIND=real_jlslsm), INTENT(IN OUT) :: t_sum(land_pts,npft)
< REAL(KIND=real_jlslsm), INTENT(IN OUT) :: l_sum(land_pts,npft)
< REAL(KIND=real_jlslsm), INTENT(IN OUT) :: t_night(land_pts,npft)
< REAL(KIND=real_jlslsm), INTENT(IN OUT) :: nt_sum(land_pts,npft)
< REAL(KIND=real_jlslsm), INTENT(IN OUT) :: vpd_sum(land_pts,npft)
< REAL(KIND=real_jlslsm), INTENT(IN OUT) :: co2_sum(land_pts,npft)
< REAL(KIND=real_jlslsm), INTENT(IN OUT) :: pstar_sum(land_pts,npft)
345a331
> REAL(KIND=real_jlslsm), INTENT(IN) :: t_growth_gb(land_pts)
364d349
< 
377a363,374
> ! Water tracers (IN)
> REAL(KIND=real_jlslsm), INTENT(IN) :: sthu_soilt_wtrac(land_pts,nsoilt,        &
>                                                        sm_levels,n_wtrac_jls)
>                                      ! Water tracer soil moisture content in
>                                      ! each lyr as a fraction of saturation
> 
> ! Water tracers (OUT)
> REAL(KIND=real_jlslsm), INTENT(OUT) :: smc_soilt_wtrac(land_pts,nsoilt,        &
>                                                        n_wtrac_jls)
>                                      ! Water tracer in available moisture in
>                                      ! the soil profile (kg/m2).
> 
387,389c384
< ,albpft_call = imdi                                                            &  
<   ! Flag for albpft, scaling to obs
< ,current_time_pmodel        ! save currentime for comparison
---
> ,albpft_call = imdi              ! Flag for albpft, scaling to obs
391d385
< REAL(KIND=real_jlslsm) :: alpha_acclim
422c416
< ,veg_frac(dim_cs2)                                                             &
---
> ,veg_frac(land_pts)                                                            &
471a466,469
> REAL(KIND=real_jlslsm), ALLOCATABLE ::                                         &
>  ratio_wt(:,:,:,:)
>                              ! WORK Water tracer to water ratio
> 
502,509d499
< ,t1_land(land_pts)                                                             &
<                             ! WORK Temperature at level 1
< ,co2_growth(land_pts)                                                          &
<                             ! WORK growth co2 at one PFT
< ,pstar_growth(land_pts)                                                        &
<                             ! WORK growth surface pressure
< ,vpd_growth(land_pts)                                                          &
<                             ! WORK growth vapour pressure deficit
531c521
< !                                 !    + fraction of ground below canopy)
---
> !                                 !    + fraction of ground below canopy
536,537d525
< ,timestep_real                                                                 &
<                                   ! Model timestep (s) in REAL 
546,595d533
< REAL(KIND=real_jlslsm) ::                                                    &
< cim_opt(land_pts,npft)                                                       &
<                             ! Leaf-internal CO2 partial pressure at
<                             ! optimal condition (Pa).
< ,gammastar25(land_pts,npft)                                                  &
< 			    ! CO2 compensation point at 25 degree C (Pa)
< ,gammastarm(land_pts,npft)                                                   &
< 			    ! Pressure-dependent photorespiratory          
< 		            ! compensation point  (Pa)  
< ,gammastarm_opt(land_pts,npft)                                               &
<           ! Pressure-dependent photorespiratory at optimal
< ,jmax25_opt(land_pts,npft)                                                   &
< 			    ! Maximum rate of electron transport at optimal
<                             ! condition normalirsed at 25 degree (mol m-2 s-1) 
< ,jmax_pmodel(land_pts,npft)                                                  &
< 			    ! Maximum rate of electron transport (mol m-2 s-1)
< ,jmax_adjusted(land_pts,npft)                                                &
< 			    ! Adjusted maximum rate of electron transport 
<                             ! (mol m-2 s-1)
< ,kcpa(land_pts,npft)                                                         &
<                           ! Michaelis-Menten constant for CO2 (Pa) for a point. 
< ,kopa(land_pts,npft)                                                         &
<                           ! Michaelis-Menten constant for O2 (Pa) for a point.
< ,kmpa(land_pts,npft)                                                          &
< 	   	    	  ! A combination of Michaelis-Menten and other terms.
< ,ta(land_pts)                                                            &
< 		            ! Atmospheric temperature (degree C). 
< ,O2_partial_pres(land_pts,npft)                                               &
<                             ! Atmospheric O2 partial pressure (K). 
< ,phi0(land_pts,npft)                                                          &
< 			    ! Intrinsic quantum yield parameter. 
< ,pratio(land_pts,npft)                                                        &
<                             ! Atmospheric pressure/atmospheric pressure at 0m
< ,tgdegc(land_pts,npft)                                                        &
<                             ! Temperatures t_growth_gb in degrees Celsius.                            
< ,vcmax25_opt(land_pts,npft)                                                   &
< 			    ! Maximum rate of carboxylation (mol CO2/m2s) 
<                             ! normalise at 25 degrees
< ,vcmax_pmodel(land_pts,npft)                                                  &
< 			    ! Maximum rate of carboxylation (mol CO2/m2s)
< ,vcmax_adjusted(land_pts,npft)                                                &
< 			    ! Adjusted maximum rate of carboxylation 
<                             ! (mol CO2/m2s)
< ,vpd(land_pts)                                                                &
<    ! vapour deficit pressure (Pa)                          
< ,viscosityh2ostar(land_pts,npft)                                              &
< 		            ! viscosity of water unit less
< ,xipam(land_pts,npft)
< 		            ! Sensitivity of ci/ca ratio to VPD (Pa^1/2)        
< 
616,625d553
< !-----------------------------------------------------------------------------
< ! Local parameters.
< !-----------------------------------------------------------------------------
< REAL(KIND=real_jlslsm), PARAMETER ::                                           &
<   ha = 65330.0,                                                                &
<     ! Activation energy
<   rgas = 8.314,                                                                &
<     ! Universal gas constant 
<   haj = 43900.0
<     ! Deactivation energy
628,634c556,563
<   i,  & !for ij (gridded variables)
<   j,  & !for ij (gridded variables); also l=surft_index(j,n)
<   k,  & !index for sm_levels
<   l,  & !index for gridbox in gb or tiled variables
<   m,  & !index for soil tile
<   n,  & !index for surface tile
<   il, & !index for canopy layers
---
>   i,    & !for ij (gridded variables)
>   j,    & !for ij (gridded variables); also l=surft_index(j,n)
>   k,    & !index for sm_levels
>   l,    & !index for gridbox in gb or tiled variables
>   m,    & !index for soil tile
>   n,    & !index for surface tile
>   il,   & !index for canopy layers
>   i_wt, & !index for water tracers
640a570,580
> INTEGER, PARAMETER :: omp_cutoff=50   ! Cut off for loop multithreading
>                                       ! This variable was introduced to do
>                                       ! multithreasding of single level short
>                                       ! loops with not much work involved to
>                                       ! reduce degradation in their performance
>                                       ! with multithreading
>                                       ! 50 is a randomly picked up number,
>                                       ! omp_cutoff should be O(100) based on
>                                       ! using simple test cases
> LOGICAL :: l_do_omp                   ! Do OpenMP
> 
650,656d589
< !Care needed as the timestep is used in arithmetic to control the
< !timing of when various science schemes are called.
< #if defined(UM_JULES)
< timestep_real =  timestep
< #else
< timestep_real = REAL(timestep_len)
< #endif
661c594,595
< veg_frac(:)           = 0.0
---
> veg_frac(:) = 0.0
> l_do_omp    = land_pts>omp_cutoff
663,664c597,599
< !$OMP PARALLEL IF(land_pts > 1) DEFAULT(NONE) PRIVATE(i, j, k, l, n, m, il)    &
< !$OMP SHARED(dim_cslayer)                                                      &
---
> !$OMP PARALLEL IF(l_do_omp) DEFAULT(NONE)                                      &
> !$OMP PRIVATE(i, j, k, l, n, m, il, i_wt)                                      &
> !$OMP SHARED(dim_cslayer, l_do_omp)                                            &
677c612,614
< !$OMP sthu_irr_soilt, smvcst_soilt, gsoil_soilt, sthu_soilt, emis_surft)
---
> !$OMP sthu_irr_soilt, smvcst_soilt, gsoil_soilt, sthu_soilt,                   &
> !$OMP gc_corr, n_wtrac_jls, smc_soilt_wtrac, growth_sug_pft, growth_sug_gb,    &
> !$OMP lwp_c_pft,l_wtrac_jls)
687a625
>     growth_sug_pft(l,n) = 0.0
696a635,636
>     gc_corr(l,n)      = 0.0
>     lwp_c_pft(l,n)    = 0.0
705a646
>   growth_sug_gb(l)      = 0.0
725a667,678
> IF (l_wtrac_jls) THEN
>   DO i_wt = 1, n_wtrac_jls
>     DO m = 1,nsoilt
> !$OMP DO SCHEDULE(STATIC)
>       DO l = 1,land_pts
>         smc_soilt_wtrac(l,m,i_wt) = 0.0
>       END DO
> !$OMP END DO NOWAIT
>     END DO
>   END DO
> END IF
> 
754d706
<     emis_surft(l,n)        = 0.0
775,783d726
<       gpp_pft_lay(l,n,il)    = 0.0
<       apar_pft_lay(l,n,il)   = 0.0
<       cmpf_pft_lay(l,n,il)   = 0.0
<       vcmax_pft_lay(l,n,il)   = 0.0
<       vcmax25_pft_lay(l,n,il) = 0.0
<       wlite_pft_lay(l,n,il)   = 0.0
<       wcarb_pft_lay(l,n,il)   = 0.0
<       wmin_pft_lay(l,n,il)    = 0.0
<       ej_pft_lay(l,n,il)     = 0.0
838d780
<     gsoil_soilt(l,m) = 0.0
845c787,788
<       ! ELSE Do nothing
---
>     ELSE
>       gsoil_soilt(l,m) = 0.0
880d822
<   tstar(l)      = tstar_surft(i,j)
883d824
<   t1_land(l)    = tl_1(i,j)
995,1050d935
< current_time_pmodel = current_time%time
< !print*,current_time_pmodel
< !calculate optimal condition for a certain PFT
< DO n = 1,npft
<   DO l = 1,land_pts
<        !print*,'ct',current_time_pmodel
<        vpd(l) = 610.8 * EXP(17.27 * (t1_land(l)-273.15) /                      &
<                            ((t1_land(l)-273.15) + 237.3))                      &
<                 -(q1_land(l)* pstar_land(l))/(0.622 + q1_land(l)*0.378) 
<        IF (vpd(l)<0) THEN
<            vpd(l) = 0
<        END IF 
<    IF (current_time_pmodel == 41400 .or. current_time_pmodel == 43200          &
<        .or. current_time_pmodel == 45000) THEN
<     IF(current_time_pmodel==41400) THEN 
<       t_sum(l,n) = 0
<       l_sum(l,n) = 0
<       pstar_sum(l,n)= 0
<       vpd_sum(l,n) = 0
<       co2_sum(l,n) = 0
<       !print*,'t0',t_sum(l,n) !if it is rest
<       !print*,'ls',l_sum(l,n) !if it is rest
<     END IF
< 
<      t_sum(l,n) =  tstar(l) + t_sum(l,n)
<      l_sum(l,n) = (1.0 - EXP(-0.5 * lai_pft(l,n)))*2.04 * ipar_land(l)*2 +     &
<                      l_sum(l,n)
<     !print*,'lp',lai_pft(l,n)
<      pstar_sum(l,n) = pstar_land(l) + pstar_sum(l,n)
<      vpd_sum(l,n) =vpd(l) +vpd_sum(l,n)
<      co2_sum(l,n) = co2_mmr / 1.5194 * pstar_land(l) + co2_sum(l,n)
<     IF (current_time_pmodel == 45000) THEN
<       t_growth_gb(l,n)= t_sum(l,n) / 3.0
<       l_growth_gb(l,n) = l_sum(l,n) / 3.0
<       pstar_growth_gb(l,n) = pstar_sum(l,n) / 3.0
<       co2_growth_gb(l,n)  = co2_sum(l,n)/ 3.0
<       vpd_growth_gb(l,n)  = vpd_sum(l,n) / 3.0
<     END IF
<   END IF 
<     !print*,'nts',nt_sum
<     ! print *,'tem',tstar(l)
<    ! print*,'nt',t_night(l,n)
<     !print *,'7', t_growth_gb(l,n)
<     !print *,'8', l_growth_gb(l,n)
<     !print *,'9', vpd_growth_gb(l,n)
<     !print *,'10', co2_growth_gb(l,n)
<    ! print*,'12',t_sum(l,n)
<     !print*, '13',pstar_growth_gb(l,n)
<     !print*,'vps',vpd_sum(l,n)
<     !print*,'ps',pstar_sum(l,n)
<     !print*,'cos',co2_sum(l,n)
<     !print*,'ls',l_sum(l,n)
<     !print*, 'jmax_opt',jmax_opt(l,n)
<   END DO
< END DO
< 
1064,1065c949,950
< !$OMP PARALLEL DO IF(land_pts > 1) DEFAULT(NONE) PRIVATE(l) SHARED(land_pts,   &
< !$OMP              tstar, tstar_surft, z0, z0_surft) SCHEDULE(STATIC)
---
> !$OMP PARALLEL DO IF(l_do_omp) DEFAULT(NONE) PRIVATE(l) SHARED(land_pts,       &
> !$OMP   l_do_omp,  tstar, tstar_surft, z0, z0_surft) SCHEDULE(STATIC)
1072,1073c957,958
< !$OMP PARALLEL DO IF(land_pts > 1) DEFAULT(NONE) PRIVATE(l) SHARED(land_pts,   &
< !$OMP             n, tstar, tstar_surft, z0, z0_surft) SCHEDULE(STATIC)
---
> !$OMP PARALLEL DO IF(l_do_omp) DEFAULT(NONE) PRIVATE(l) SHARED(land_pts,       &
> !$OMP   l_do_omp,  n, tstar, tstar_surft, z0, z0_surft) SCHEDULE(STATIC)
1110,1112c995,997
< !$OMP PARALLEL DO IF(land_pts > 1) DEFAULT(NONE) PRIVATE(l, k)                 &
< !$OMP             SHARED(frac_irr_soilt, frac_irr_surft, land_pts,             &
< !$OMP             l_irrig_dmd, n, m,                                           &
---
> !$OMP PARALLEL IF(l_do_omp) DEFAULT(NONE) PRIVATE(l, k)                        &
> !$OMP             SHARED(frac_irr_soilt, frac_irr_surft, land_pts, v_open,     &
> !$OMP             l_irrig_dmd, n, m,l_use_pft_psi, v_close, v_close_pft,       &
1114,1117c999,1002
< !$OMP             sthu_surft)                                                  &
< !$OMP             SCHEDULE(STATIC)
<   DO l = 1,land_pts
<     DO k = 1,sm_levels
---
> !$OMP l_do_omp,    sthu_surft, v_open_pft, smvcwt_soilt, smvccl_soilt, fsmc_p0)
>   DO k = 1,sm_levels
> !$OMP DO SCHEDULE(STATIC)
>     DO l = 1,land_pts
1118a1004,1005
>     END DO
> !$OMP END DO
1120c1007,1009
<       IF ( l_irrig_dmd ) THEN
---
>     IF ( l_irrig_dmd ) THEN
> !$OMP DO SCHEDULE(STATIC)
>       DO l = 1,land_pts
1131,1132c1020,1022
<       END IF
<     END DO
---
>       END DO
> !$OMP END DO
>     END IF
1134d1023
< !$OMP END PARALLEL DO
1137,1138c1026,1033
<     v_close(:,:) = v_close_pft(:,:,n)
<     v_open(:,:)  = v_open_pft(:,:,n)
---
>     DO k = 1,sm_levels
> !$OMP DO SCHEDULE(STATIC)
>       DO l = 1,land_pts
>         v_close(l,k) = v_close_pft(l,k,n)
>         v_open(l,k)  = v_open_pft(l,k,n)
>       END DO
> !$OMP END DO
>     END DO
1140,1142c1035,1043
<     v_close(:,:) = smvcwt_soilt(:,m,:)
<     v_open(:,:)  = smvccl_soilt(:,m,:) -                                       &
<                    fsmc_p0(n) * (smvccl_soilt(:,m,:) - smvcwt_soilt(:,m,:))
---
>     DO k = 1,sm_levels
> !$OMP DO SCHEDULE(STATIC)
>       DO l = 1,land_pts
>         v_close(l,k) = smvcwt_soilt(l,m,k)
>         v_open(l,k)  = smvccl_soilt(l,m,k) -                                   &
>                      fsmc_p0(n) * (smvccl_soilt(l,m,k) - smvcwt_soilt(l,m,k))
>       END DO
> !$OMP END DO
>     END DO
1143a1045
> !$OMP END PARALLEL
1150c1052
<                 wt_ext_type(:,:,n),fsmc_pft(:,n))
---
>                 wt_ext_type(:,:,n),fsmc_pft(:,n),psi_root_zone_pft(:,n))
1158c1060,1061
<                   wt_ext_irr_type(:,:,n),fsmc_irr(:,n))
---
>                   wt_ext_irr_type(:,:,n),fsmc_irr(:,n),                        &
>                   psi_root_zone_pft(:,n))
1220,1224c1123
< ,               q1_land,t1_land, ra,tstar,o3,t_home_gb,t_growth_gb(:,n)        &
< ,               l_growth_gb(:,n),vpd_growth_gb(:,n),co2_growth_gb(:,n)         &
< ,               pstar_growth_gb(:,n),xipam_opt(:,n),vcmax_opt(:,n)             &
< ,               jmax_opt(:,n),t_sum(:,n),l_sum(:,n),t_night(:,n)               &
< ,               nt_sum(:,n),vpd_sum(:,n),co2_sum(:,n),pstar_sum(:,n)           &
---
> ,               q1_land,ra,tstar,o3,t_home_gb,t_growth_gb                      &
1226,1231c1125,1126
< ,               gpp_pft(:,n), gpp_pft_lay(:,n,:),apar_pft_lay(:,n,:)           &
< ,                cmpf_pft_lay(:,n,:)                                           &
< ,               vcmax_pft_lay(:,n,:), vcmax25_pft_lay(:,n,:)                   &
< ,               wlite_pft_lay(:,n,:), wcarb_pft_lay(:,n,:)                     &
< ,               wmin_pft_lay(:,n,:), ej_pft_lay(:,n,:)                         &
< ,               npp_pft(:,n),resp_p_pft(:,n)                                   &
---
> ,               psi_root_zone_pft(:,n),lwp_c_pft(:,n)                          &
> ,               gpp_pft(:,n),npp_pft(:,n),resp_p_pft(:,n)                      &
1232a1128
> ,               growth_sug_pft(:,n),f_nsc_pft(:,n)                             &
1245a1142,1144
>   ! Store conductance before adjustment for soil evaporation
>   gc_corr(:,n) = gs_type(:,n)
> 
1325,1326c1224,1225
< !$OMP PARALLEL DO IF(land_pts > 1) DEFAULT(NONE) PRIVATE(l) SHARED(frac,       &
< !$OMP             fsoil, fsoil_tot, land_pts, n) SCHEDULE(STATIC)
---
> !$OMP PARALLEL DO IF(l_do_omp) DEFAULT(NONE) PRIVATE(l) SHARED(frac,           &
> !$OMP   l_do_omp, fsoil, fsoil_tot, land_pts, n) SCHEDULE(STATIC)
1488a1388,1397
>   DO n = 1,nsurft
> !$OMP PARALLEL DO IF(l_do_omp) DEFAULT(NONE) PRIVATE(l)                        &
> !$OMP              SHARED(land_pts, n, emis_surft, l_do_omp)                   &
> !$OMP              SCHEDULE(STATIC)
>     DO l = 1,land_pts
>       emis_surft(l,n) = 0.0
>     END DO
> !$OMP END PARALLEL DO
>   END DO
> 
1557c1466,1467
< 
---
>     IF (surft_pts(n) > 0) THEN
>       IF (.NOT. l_emis_surft_set(n)) THEN
1561,1564c1471,1474
<     DO j = 1,surft_pts(n)
<       l = surft_index(j,n)
<       emis_surft(l,n) = emis_pft(n)
<     END DO
---
>         DO j = 1,surft_pts(n)
>           l = surft_index(j,n)
>           emis_surft(l,n) = emis_pft(n)
>         END DO
1565a1476,1477
>       END IF
>     END IF
1569,1572c1481,1492
<     DO j = 1,surft_pts(n)
<       l = surft_index(j,n)
<       emis_surft(l,n) = emis_nvg(n - npft)
<     END DO
---
>     IF (surft_pts(n) > 0) THEN
>       IF (.NOT. l_emis_surft_set(n)) THEN
> !$OMP PARALLEL DO IF(surft_pts(n) > 1) DEFAULT(NONE) PRIVATE(l, j)             &
> !$OMP              SHARED(emis_nvg, emis_surft, n, npft, surft_index,          &
> !$OMP                     surft_pts) SCHEDULE(STATIC)
>         DO j = 1,surft_pts(n)
>           l = surft_index(j,n)
>           emis_surft(l,n) = emis_nvg(n - npft)
>         END DO
> !$OMP END PARALLEL DO
>       END IF
>     END IF
1599c1519
< CASE ( soil_model_1pool, soil_model_rothc )
---
> CASE ( soil_model_1pool, soil_model_4pool )
1602,1604c1522,1524
<   IF ( soil_bgc_model == soil_model_rothc ) THEN
< !$OMP PARALLEL DO IF(land_pts > 1) DEFAULT(NONE) PRIVATE(l) SHARED(frac,       &
< !$OMP             land_pts, npft, veg_frac) SCHEDULE(STATIC)
---
>   IF ( soil_bgc_model == soil_model_4pool ) THEN
> !$OMP PARALLEL DO IF(l_do_omp) DEFAULT(NONE) PRIVATE(l) SHARED(frac,           &
> !$OMP             land_pts, npft, veg_frac,l_do_omp) SCHEDULE(STATIC)
1609c1529
<   END IF  !  RothC
---
>   END IF  !  4-pool soil C
1612c1532
<     CALL microbe (land_pts,dim_cs1,dim_cs2,l_q10,cs_pool_soilt(:,m,:,:),       &
---
>     CALL microbe (land_pts,dim_cs1,l_q10,cs_pool_soilt(:,m,:,:),               &
1686c1606
< !$OMP PARALLEL DO IF(land_pts > 1) DEFAULT(NONE) PRIVATE(k, l)                 &
---
> !$OMP PARALLEL IF(l_do_omp) DEFAULT(NONE) PRIVATE(k, l)                        &
1688,1689c1608,1610
< !$OMP                    land_pts, sm_levels, vfrac, vfrac_surft,              &
< !$OMP                    wt_ext_soilt, m, wt_ext_surft) SCHEDULE(STATIC)
---
> !$OMP                    land_pts, sm_levels, vfrac, vfrac_surft, l_do_omp,    &
> !$OMP                    wt_ext_soilt, m, wt_ext_surft)
> !$OMP DO SCHEDULE(STATIC)
1701c1622,1626
<     DO k = 1,sm_levels
---
>   END DO
> !$OMP END DO
>   DO k = 1,sm_levels
> !$OMP DO SCHEDULE(STATIC)
>     DO l = 1,land_pts
1703a1629
> !$OMP END DO
1705c1631
< !$OMP END PARALLEL DO
---
> !$OMP END PARALLEL
1707,1709c1633,1644
<   gc_surft(:,:)=0.0
<   canhc_surft(:,:)=0.0
<   vfrac_surft(:,:)=0.0
---
> !$OMP PARALLEL IF(l_do_omp) DEFAULT(NONE) PRIVATE(k, l, n)                     &
> !$OMP             SHARED(nsurft, land_pts, gc_surft, canhc_surft, vfrac_surft, &
> !$OMP                    l_do_omp, l_irrig_dmd, gs_irr_surft)
>   DO n = 1, nsurft
> !$OMP DO SCHEDULE(STATIC)
>     DO i =1, land_pts
>       gc_surft(i,n)=0.0
>       canhc_surft(i,n)=0.0
>       vfrac_surft(i,n)=0.0
>     END DO
> !$OMP END DO NOWAIT
>   END DO
1711c1646,1652
<     gs_irr_surft(:,:)=0.0 ! irrigation
---
>     DO n = 1, nsurft
> !$OMP DO SCHEDULE(STATIC)
>       DO i =1, land_pts
>         gs_irr_surft(i,n)=0.0 ! irrigation
>       END DO
> !$OMP END DO NOWAIT
>     END DO
1712a1654,1655
> !$OMP END PARALLEL
> 
1805a1749
> !$OMP        growth_sug_gb, growth_sug_pft,                                    &
1812,1816c1756,1760
<     gpp(l)      = gpp(l) + frac(l,n) * gpp_pft(l,n)
<     !print*,'gpp_pft',gpp_pft(l,n)
<     !print*,'gpp',gpp(l)
<     npp(l)      = npp(l) + frac(l,n) * npp_pft(l,n)
<     resp_p(l)   = resp_p(l) + frac(l,n) * resp_p_pft(l,n)
---
> 
>     gpp(l)       = gpp(l) + frac(l,n) * gpp_pft(l,n)
>     npp(l)       = npp(l) + frac(l,n) * npp_pft(l,n)
>     resp_p(l)    = resp_p(l) + frac(l,n) * resp_p_pft(l,n)
>     growth_sug_gb(l) = growth_sug_gb(l) + frac(l,n) * growth_sug_pft(l,n)
1854a1799,1823
> ! Water tracers - calculate ratio of water tracer to water in the soil
> ! ahead of diagnosing available water tracer in the soil profile
> IF (l_wtrac_jls) THEN
> 
>   ALLOCATE(ratio_wt(land_pts,nsoilt,sm_levels,n_wtrac_jls))
> 
> !$OMP PARALLEL IF(l_do_omp) DEFAULT(NONE) PRIVATE(l,i_wt,m,k)                  &
> !$OMP SHARED(ratio_wt, land_pts, n_wtrac_jls, nsoilt, sm_levels,               &
> !$OMP        sthu_soilt, sthu_soilt_wtrac, l_do_omp)
>   DO i_wt = 1, n_wtrac_jls
>     DO m = 1, nsoilt
>       DO k = 1,sm_levels
> !$OMP DO SCHEDULE(STATIC)
>         DO l = 1,land_pts
>           ratio_wt(l,m,k,i_wt) = wtrac_calc_ratio_fn_jules(i_wt,               &
>                                       sthu_soilt_wtrac(l,m,k,i_wt),            &
>                                       sthu_soilt(l,m,k))
>         END DO ! l
> !$OMP END DO NOWAIT
>       END DO ! k
>     END DO ! m
>   END DO ! i_wt
> !$OMP END PARALLEL
> END IF ! l_wtrac_jls
> 
1873c1842
< !$OMP PARALLEL DO IF(land_pts > 1) DEFAULT(NONE) PRIVATE(l) SHARED(dzsoil,     &
---
> !$OMP PARALLEL DO IF(l_do_omp) DEFAULT(NONE) PRIVATE(l) SHARED(dzsoil,         &
1875c1844
< !$OMP             v_close_pft, wt_ext_type, frac)                              &
---
> !$OMP             v_close_pft, wt_ext_type, frac, l_do_omp)                    &
1889,1891c1858,1860
<   DO m = 1, nsoilt
<     DO k = 1,sm_levels
< !$OMP PARALLEL DO IF(land_pts > 1) DEFAULT(NONE) PRIVATE(l) SHARED(dzsoil,     &
---
>   DO k = 1,sm_levels
>     DO m = 1, nsoilt
> !$OMP PARALLEL DO IF(l_do_omp) DEFAULT(NONE) PRIVATE(l) SHARED(dzsoil,         &
1893c1862
< !$OMP             smvcwt_soilt, wt_ext_soilt)                                  &
---
> !$OMP             smvcwt_soilt, wt_ext_soilt, l_do_omp)                        &
1905c1874,1902
< END IF
---
> 
>   ! Water tracers - calculate water tracer content of water available for
>   ! plant transpiration
>   IF (l_wtrac_jls) THEN
> !$OMP PARALLEL IF(l_do_omp) DEFAULT(NONE) PRIVATE(l,i_wt,m,k)                  &
> !$OMP SHARED(dzsoil, land_pts, n_wtrac_jls, nsoilt, sm_levels, sthu_soilt,     &
> !$OMP        smvcst_soilt, smvcwt_soilt, wt_ext_soilt, smc_soilt_wtrac,        &
> !$OMP        ratio_wt, l_do_omp)
>     DO i_wt = 1, n_wtrac_jls
>       DO m = 1, nsoilt
>         DO k = 1, sm_levels
> !$OMP DO SCHEDULE(STATIC)
>           DO l = 1,land_pts
>             smc_soilt_wtrac(l,m,i_wt) = smc_soilt_wtrac(l,m,i_wt)              &
>                  + ratio_wt(l,m,k,i_wt) * MAX(0.0,                             &
>                                   wt_ext_soilt(l,m,k) * rho_water * dzsoil(k)  &
>                                   * ( sthu_soilt(l,m,k) * smvcst_soilt(l,m,k)  &
>                                      - smvcwt_soilt(l,m,k) ))
>           END DO  ! l
> !$OMP END DO NOWAIT
>         END DO  ! k
>       END DO ! m
>     END DO ! i_wt
> !$OMP END PARALLEL
> 
>   END IF ! l_wtrac_jls
> 
> END IF ! l_use_pft_psi
> 
1913,1914c1910,1911
< !$OMP PARALLEL DO IF(land_pts > 1) DEFAULT(NONE) PRIVATE(l) SHARED(dzsoil,     &
< !$OMP             fsoil_tot, land_pts, smc_soilt, sthu_soilt, smvcst_soilt, m) &
---
> !$OMP PARALLEL DO IF(l_do_omp) DEFAULT(NONE) PRIVATE(l) SHARED(dzsoil,         &
> !$OMP  l_do_omp,  fsoil_tot, land_pts, smc_soilt, sthu_soilt, smvcst_soilt, m) &
1923a1921,1949
> ! Water tracers - add available water tracer for evaporation from bare soil
> 
> IF (l_wtrac_jls) THEN
> !$OMP PARALLEL IF(l_do_omp) DEFAULT(NONE) PRIVATE(l,i_wt,m)                    &
> !$OMP SHARED(dzsoil, fsoil_tot, land_pts, sthu_soilt, smvcst_soilt, nsoilt,    &
> !$OMP        n_wtrac_jls, smc_soilt_wtrac, ratio_wt, l_do_omp)
> 
>   DO i_wt = 1, n_wtrac_jls
>     DO m = 1, nsoilt
> !$OMP DO SCHEDULE(STATIC)
>       DO l = 1,land_pts
>         smc_soilt_wtrac(l,m,i_wt) =                                            &
>                      ! From plants
>                      (1.0 - fsoil_tot(l)) * smc_soilt_wtrac(l,m,i_wt)          &
>                      ! From bare soil
>                      + ratio_wt(l,m,1,i_wt) *                                  &
>                      fsoil_tot(l) * rho_water * dzsoil(1) *                    &
>                      MAX(0.0,sthu_soilt(l,m,1)) * smvcst_soilt(l,m,1)
>       END DO ! l
> !$OMP END DO NOWAIT
>     END DO ! m
>   END DO ! i_wt
> !$OMP END PARALLEL
> 
>   ! Deallocate water tracer working array
>   DEALLOCATE(ratio_wt)
> 
> END IF ! l_wtrac_jls
> 
1938c1964
< !$OMP PARALLEL DO IF(land_pts > 1) DEFAULT(NONE) PRIVATE(l) SHARED(dzsoil,     &
---
> !$OMP PARALLEL DO IF(l_do_omp) DEFAULT(NONE) PRIVATE(l) SHARED(dzsoil,         &
1940c1966
< !$OMP             frac_irr_surft, frac_irr_soilt,                              &
---
> !$OMP             frac_irr_surft, frac_irr_soilt, l_do_omp,                    &
1960,1962c1986,1988
<     DO m = 1,nsoilt
<       DO k = 1,sm_levels
< !$OMP PARALLEL DO IF(land_pts > 1) DEFAULT(NONE) PRIVATE(l) SHARED(dzsoil,     &
---
>     DO k = 1,sm_levels
>       DO m = 1,nsoilt
> !$OMP PARALLEL DO IF(l_do_omp) DEFAULT(NONE) PRIVATE(l) SHARED(dzsoil,         &
1964c1990
< !$OMP             smvcwt_soilt,wt_ext_irr_soilt,m)                             &
---
> !$OMP             smvcwt_soilt,wt_ext_irr_soilt,m, l_do_omp)                   &
1980a2007,2009
> !$OMP PARALLEL IF(l_do_omp) DEFAULT(NONE) PRIVATE(l,m,n) SHARED(dzsoil,        &
> !$OMP             fsoil_tot, land_pts, smc_irr_soilt, sthu_irr_soilt,nsoilt,   &
> !$OMP             smvcst_soilt, gs_irr_surft,gc_irr_surft, nsurft,l_do_omp)
1982,1985c2011
< !$OMP PARALLEL DO IF(land_pts > 1) DEFAULT(NONE) PRIVATE(l) SHARED(dzsoil,     &
< !$OMP             fsoil_tot, land_pts, smc_irr_soilt, sthu_irr_soilt,          &
< !$OMP             smvcst_soilt,m)                                              &
< !$OMP             SCHEDULE(STATIC)
---
> !$OMP DO SCHEDULE(STATIC)
1991c2017
< !$OMP END PARALLEL DO
---
> !$OMP END DO
1994c2020,2027
<   gc_irr_surft(:,:)=gs_irr_surft(:,:)
---
>   DO n =1, nsurft
> !$OMP DO SCHEDULE(STATIC)
>     DO l = 1,land_pts
>       gc_irr_surft(l,n)=gs_irr_surft(l,n)
>     END DO
> !$OMP END DO NOWAIT
>   END DO
> !$OMP END PARALLEL
diff -r vn7.0copy1_c4/src/./science/surface/qsat_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/surface/qsat_mod.F90
20c20
< ! Group V/vol 4B meteorology. Physical and Chemical properties or air, P35
---
> ! Group V/vol 4B meteorology. Physical and Chemical properties of air, P35
diff -r vn7.0copy1_c4/src/./science/surface/screen_tq_jls.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/surface/screen_tq_jls.F90
707c707
<           !	         Calculate the value for air-sea-decoupled screen height
---
>           !              Calculate the value for air-sea-decoupled screen height
846,847c846,847
<           !	     Calculate the value for air-surface-decoupled screen height
<           !          temperature over land tiles.
---
>           ! Calculate the value for air-surface-decoupled screen height
>           ! temperature over land tiles.
903c903
< !$OMP PARALLEL DO                                                              &
---
> !$OMP PARALLEL                                                                 &
905,908c905,910
< !$OMP SCHEDULE(STATIC)                                                         &
< !$OMP SHARED( tdims, sf_diag, flandg, epsilon_ssi,                             &
< !$OMP         chr1p5m_sice, qw_1, qs)                                          &
< !$OMP PRIVATE( i, j, cer1p5m)
---
> !$OMP SHARED( nsurft, land_pts, sf_diag, tstar_surft, pstar_land, pstar,       &
> !$OMP         l_mr_physics, surft_pts, surft_index, i_ind, j_ind, resft,       &
> !$OMP         chr1p5m, qw_1, flandg, tile_frac, epsilon_surft,                 &
> !$OMP         tdims, epsilon_ssi, chr1p5m_sice, qs)                            &
> !$OMP PRIVATE( i, j, k, l, n, cer1p5m, qs_surft)
> !$OMP DO SCHEDULE(STATIC)
924c926
< !$OMP END PARALLEL DO
---
> !$OMP END DO
926,930c928
< !$OMP PARALLEL DO                                                              &
< !$OMP DEFAULT(NONE)                                                            &
< !$OMP SCHEDULE(STATIC)                                                         &
< !$OMP SHARED(pstar_land, pstar, i_ind, j_ind, land_pts)                        &
< !$OMP PRIVATE(l, i, j)
---
> !$OMP DO SCHEDULE(STATIC)
936c934
< !$OMP END PARALLEL DO
---
> !$OMP END DO
938,944c936
< !$OMP PARALLEL DO                                                              &
< !$OMP DEFAULT(NONE)                                                            &
< !$OMP SCHEDULE(STATIC)                                                         &
< !$OMP SHARED( nsurft, land_pts, sf_diag, tstar_surft, pstar_land,              &
< !$OMP         l_mr_physics, surft_pts, surft_index, i_ind, j_ind, resft,       &
< !$OMP         chr1p5m, qw_1, flandg, tile_frac,epsilon_surft)                  &
< !$OMP PRIVATE( i, j, k, l, n, cer1p5m, qs_surft)
---
> !$OMP DO SCHEDULE(STATIC)
968c960
< !$OMP END PARALLEL DO
---
> !$OMP END DO
970a963
> !$OMP DO SCHEDULE(STATIC)
977a971
> !$OMP END DO
979a974
> !$OMP END PARALLEL
diff -r vn7.0copy1_c4/src/./science/surface/sf_diags_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/surface/sf_diags_mod.F90
191c191
<   !                    resistance factor for fraction 1-FRACA.
---
>   !                    resistance factor for fraction 1-fracaero.
244c244
< SUBROUTINE alloc_sf_expl(sf_diag, l_apply_diag)
---
> SUBROUTINE alloc_sf_expl(sf_diag, l_apply_diag, land_points)
249,250c249,250
< USE model_domain_mod, ONLY: model_type, mt_single_column
< USE nlsizes_namelist_mod, ONLY: land_points => land_field, ntiles
---
> USE model_domain_mod, ONLY: model_type, mt_single_column, mt_lfric
> USE nlsizes_namelist_mod, ONLY: ntiles
258a259
> INTEGER, INTENT(IN) :: land_points
343a345,354
> CASE (mt_lfric)
>   sf_diag%l_z0h_eff_gb = .TRUE.
>   sf_diag%l_z0m_gb  = .TRUE.
>   sf_diag%su10    = .TRUE.
>   sf_diag%sv10    = .TRUE.
>   sf_diag%l_gpp   = .TRUE.
>   sf_diag%st1p5   = .TRUE.
>   sf_diag%sq1p5   = .TRUE.
>   sf_diag%l_resp_p = .TRUE.
> 
603c614
< SUBROUTINE alloc_sf_imp(sf_diag, l_apply_diag)
---
> SUBROUTINE alloc_sf_imp(sf_diag, l_apply_diag, land_points)
608,609c619,620
< USE model_domain_mod, ONLY: model_type, mt_single_column
< USE nlsizes_namelist_mod, ONLY: land_points => land_field, ntiles
---
> USE model_domain_mod, ONLY: model_type, mt_single_column, mt_lfric
> USE nlsizes_namelist_mod, ONLY: ntiles
617a629
> INTEGER, INTENT(IN) :: land_points
672a685,696
> 
>   sf_diag%su10    = .TRUE.        ! Calculate u10m
>   sf_diag%sv10    = .TRUE.        !    "      v10m
>   sf_diag%slh     = .TRUE.        !    "      latent_heat
>   sf_diag%sq1p5   = .TRUE.        !    "      q1p5m
>   sf_diag%st1p5   = .TRUE.        !    "      t1p5m
>   sf_diag%simlt   = .TRUE.        !    "      sice_mlt_htf
>   sf_diag%smlt    = .TRUE.        !    "      snomlt_surf_htf
>   sf_diag%l_lw_surft = .TRUE.     !    "      lw_up_surft & lw_down_surft
>   sf_diag%l_lw_up_sice_weighted_cat = .TRUE.  ! " lw_up_sice_weighted_cat
> 
> CASE (mt_lfric)
diff -r vn7.0copy1_c4/src/./science/surface/sf_evap_jls.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/surface/sf_evap_jls.F90
28c28
<  ashtf_prime_surft,canopy,dtrdz_1,flake,fraca,snow_surft,resfs,                &
---
>  ashtf_prime_surft,canopy,dtrdz_1,flake,fracaero_t,fracaero_s,snow_surft,resfs,&
53a54,55
> USE jules_science_fixes_mod, ONLY: l_fix_neg_snow
> 
86,87c88,93
< ,fraca(land_pts,nsurft)                                                        &
<                        ! IN Fraction of surface moisture flux
---
> ,fracaero_t(land_pts,nsurft)                                                   &
>                        ! IN Total fractions of surface moisture flux
> !                            !    with only aerodynamic resistance
> !                            !    for land tiles
> ,fracaero_s(land_pts,nsurft)                                                   &
>                        ! IN Fractions of surface moisture flux
89c95,96
< !                            !    for land tiles.
---
> !                            !    for land tiles from the frozen part of the
> !                            !    surface alone
94c101
< !                            !    resistance factor for fraction 1-FRACA
---
> !                            !    resistance factor for fraction 1-fracaero_t
98c105
< !                            !    FRACA+(1-FRACA)*RESFS.
---
> !                            !    fracaero_t+(1-fracaero_t)*resfs.
236,249d242
<   DO k = 1,surft_pts(n)
<     l = surft_index(k,n)
<     e_surft_old(l,n) = fqw_surft(l,n)
<     IF (snow_surft(l,n)  >   0.0) THEN
<       le_surft_old(l,n) = (lc + lf) * fqw_surft(l,n)
<     ELSE
<       le_surft_old(l,n) = lc * fqw_surft(l,n)
<     END IF
<   END DO
< !$OMP END DO
< END DO
< 
< DO n = 1,nsurft
< !$OMP DO SCHEDULE(STATIC)
265a259,290
> DO n = 1,nsurft
> !$OMP DO SCHEDULE(STATIC)
>   DO k = 1,surft_pts(n)
>     l = surft_index(k,n)
>     e_surft_old(l,n) = fqw_surft(l,n)
>     IF (l_fix_neg_snow) THEN
>       ! Calculate the sublimation or deposition on the snow fraction
>       ! consistently with the assumed resistance network. The canopy
>       ! evaporation must be set here to allow it to be modified to
>       ! account for exhaustion of the snow store.
>       IF (resft(l,n) > 0.0) ecan_surft(l,n) =                                  &
>                           (1.0 - flake(l,n)) *                                 &
>                           (fracaero_t(l,n) - fracaero_s(l,n)) *                &
>                           fqw_surft(l,n) / resft(l,n)
>       le_surft_old(l,n) = lc * fqw_surft(l,n)
>       IF (snow_surft(l,n)  >   0.0) THEN
>         ei_surft(l,n) = (1.0 - flake(l,n)) * fracaero_s(l,n) *                 &
>                         fqw_surft(l,n) / resft(l,n)
>         le_surft_old(l,n) = le_surft_old(l,n) + lf * ei_surft(l,n)
> 
>       END IF
>     ELSE
>       IF (snow_surft(l,n)  >   0.0) THEN
>         le_surft_old(l,n) = (lc + lf) * fqw_surft(l,n)
>       ELSE
>         le_surft_old(l,n) = lc * fqw_surft(l,n)
>       END IF
>     END IF
>   END DO
> !$OMP END DO
> END DO
> 
274,278c299,328
<       ei_surft(l,n) =  fqw_surft(l,n)
<       edt = ei_surft(l,n) * timestep
<       IF ( edt  >   snow_surft(l,n) )                                          &
<         ei_surft(l,n) = snow_surft(l,n) / timestep
<       fqw_surft(l,n) = fqw_surft(l,n) -  ei_surft(l,n)
---
>       IF (l_fix_neg_snow) THEN
>         IF (fqw_surft(l,n) < 0.0) THEN
>           IF (tstar_surft(l,n) < tm) THEN
>             ! Deposit all moisture on the snow.
>             ei_surft(l,n)   = fqw_surft(l,n)
>             ecan_surft(l,n) = 0.0
>           ELSE
>             ! Partition the downward flux between the lake and canopy
>             ! fractions. Actual fluxes are used directly rather than
>             ! fluxes deduced from the potential evaporation to follow
>             ! previous functionality for this case.
>             ecan_surft(l,n)  = (1.0 - flake(l,n)) * fqw_surft(l,n)
>             elake_surft(l,n) = flake(l,n) * fqw_surft(l,n)
>             ei_surft(l,n)    = 0.0
>           END IF
>         ELSE
>           edt = ei_surft(l,n) * timestep
>           IF ( edt  >   snow_surft(l,n) ) THEN
>             ecan_surft(l,n) = ecan_surft(l,n) + ei_surft(l,n) -                &
>                               snow_surft(l,n) / timestep
>             ei_surft(l,n) = snow_surft(l,n) / timestep
>           END IF
>         END IF
>       ELSE
>         ei_surft(l,n) =  fqw_surft(l,n)
>         edt = ei_surft(l,n) * timestep
>         IF ( edt  >   snow_surft(l,n) )                                        &
>           ei_surft(l,n) = snow_surft(l,n) / timestep
>         fqw_surft(l,n) = fqw_surft(l,n) -  ei_surft(l,n)
>       END IF
346,347d395
<       ecan_surft(l,n) = (1.0 - flake(l,n)) *                                   &
<                        fraca(l,n) * fqw_surft(l,n) / resft(l,n)
349c397
<                          (1.0 - fraca(l,n)) * resfs(l,n) * fqw_surft(l,n)      &
---
>                          (1.0 - fracaero_t(l,n)) * resfs(l,n) * fqw_surft(l,n) &
352c400,401
<         sf_diag%et_stom_surft(l,n) = (1.0 - flake(l,n)) * (1.0 - fraca(l,n))   &
---
>         sf_diag%et_stom_surft(l,n) = (1.0 - flake(l,n)) *                      &
>                                      (1.0 - fracaero_t(l,n))                   &
356a406,410
>       ! With the fix, this has already been calculated and adjusted for
>       ! exhaustion of the snow store.
>       IF ( .NOT. l_fix_neg_snow)                                               &
>         ecan_surft(l,n) = (1.0 - flake(l,n)) *                                 &
>                           fracaero_t(l,n) * fqw_surft(l,n) / resft(l,n)
359,366c413,433
<         esoil_surft(l,n) = (1.0 - flake(l,n)) *                                &
<                            (1.0 - fraca(l,n) * canopy(l,n) / edt) *            &
<                                resfs(l,n) * fqw_surft(l,n) / resft(l,n)
<         IF (sf_diag%l_et_stom .OR. sf_diag%l_et_stom_surft) THEN
<           sf_diag%et_stom_surft(l,n) = (1.0 - flake(l,n)) * (1.0 - fraca(l,n)  &
<                                         *canopy(l,n) / edt) *                  &
<                                         sf_diag%resfs_stom(l,n) *              &
<                                         fqw_surft(l,n) / resft(l,n)
---
>         IF (l_fix_neg_snow) THEN
>           esoil_surft(l,n) = esoil_surft(l,n) + resfs(l,n) *                   &
>                              (ecan_surft(l,n) - canopy(l,n) / timestep)
>           IF (sf_diag%l_et_stom .OR. sf_diag%l_et_stom_surft) THEN
>             !           Check that we can use ecan_surft here.
>             sf_diag%et_stom_surft(l,n) = sf_diag%et_stom_surft(l,n) +          &
>                                          sf_diag%resfs_stom(l,n) *             &
>                                          (ecan_surft(l,n) -                    &
>                                           canopy(l,n) / edt)
>           END IF
>         ELSE
>           esoil_surft(l,n) = (1.0 - flake(l,n)) *                              &
>                              (1.0 - fracaero_t(l,n) * canopy(l,n) / edt) *     &
>                                  resfs(l,n) * fqw_surft(l,n) / resft(l,n)
>           IF (sf_diag%l_et_stom .OR. sf_diag%l_et_stom_surft) THEN
>             sf_diag%et_stom_surft(l,n) = (1.0 - flake(l,n)) *                  &
>                                          (1.0 - fracaero_t(l,n) *              &
>                                           canopy(l,n) / edt) *                 &
>                                           sf_diag%resfs_stom(l,n) *            &
>                                           fqw_surft(l,n) / resft(l,n)
>           END IF
375a443,446
>         ! With the fix, ecan_surft will have been initialized and must be
>         ! zeroed.
>         IF (l_fix_neg_snow)                                                    &
>           ecan_surft(l,n) = 0.0
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/surface: sf_evap_srce_frac_mod.F90
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/surface: sf_flux_land_wtrac_mod.F90
diff -r vn7.0copy1_c4/src/./science/surface/sf_flux_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/surface/sf_flux_mod.F90
17c17
<  nsnow,n,canhc,dzsurf,hcons,ashtf,qstar,q_elev,radnet,resft,                   &
---
>  nsnow,n,canhc,dzsurf,hcons,ashtf,qstar,q_elev,radnet,resft,fracs,             &
31c31
< USE jules_surface_mod, ONLY: ls
---
> USE jules_surface_mod, ONLY: ls, lc, lf
36c36,37
< USE jules_science_fixes_mod, ONLY: l_fix_moruses_roof_rad_coupling
---
> USE jules_science_fixes_mod, ONLY: l_fix_moruses_roof_rad_coupling,            &
>                                    l_fix_neg_snow
79a81,82
> ,fracs(points)                                                                 &
>                            ! IN fractional coverage of snow
220c223,228
<   IF (snowdepth(l) > 0.0) lh = ls
---
>   IF (l_fix_neg_snow) THEN
>     ! Effective latent. resft should not be 0 if there is any snow.
>     IF (resft(l) > 0.0) lh = lc + lf * fracs(l) / resft(l)
>   ELSE
>     IF (snowdepth(l) > 0.0) lh = ls
>   END IF
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/surface: sf_flux_ssi_wtrac_mod.F90
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/surface: sf_land_imp_wtrac_mod.F90
diff -r vn7.0copy1_c4/src/./science/surface/sf_melt_jls.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/surface/sf_melt_jls.F90
25c25
< ,resft,rhokh_1,tile_frac,timestep,r_gamma                                      &
---
> ,fracs,resft,rhokh_1,tile_frac,timestep,r_gamma                                &
28c28
< ,melt_surft                                                                    &
---
> ,melt_surft,snowinc_surft                                                      &
39c39
< USE jules_science_fixes_mod, ONLY: l_fix_snow_frac
---
> USE jules_science_fixes_mod, ONLY: l_fix_snow_frac, l_fix_neg_snow
68a69,70
> ,fracs(points)                                                                 &
>                             ! IN Fraction subject to sublimation or deposition
70c72
<                        !IN Resistance factor.
---
>                             ! IN Resistance factor.
98c100
<  melt_surft(points)
---
>  melt_surft(points)                                                            &
99a102,105
> ,snowinc_surft(points)
> !                           ! OUT Total snow increment on tiles (kg/m2/TS)
> !                           !     used to avoid rounding errors in the
> !                           !     snow mass budget
115c121
< ,snow_max                                                                      &
---
> ,snow_new                                                                      &
144c150
< !$OMP PRIVATE(k,j,i,l,snow_density,snow_max,rhokh1_prime,lcmelt,lsmelt,dtstar, &
---
> !$OMP PRIVATE(k,j,i,l,snow_density,snow_new,rhokh1_prime,lcmelt,lsmelt,dtstar, &
169,170c175,177
<   snow_max = MAX( 0.0, snow_surft(l) - ei_surft(l) * timestep )
<   IF ( snow_max >  0.0 .AND. tstar_surft(l) >  tm ) THEN
---
>   snowinc_surft(l) = - MIN(snow_surft(l), ei_surft(l) * timestep )
>   snow_new = MAX( 0.0, snow_surft(l) + snowinc_surft(l))
>   IF ( snow_new >  0.0 .AND. tstar_surft(l) >  tm ) THEN
173,175c180,195
<     lcmelt = (cp + lc * alpha1(l) * resft(l)) * rhokh1_prime                   &
<              + ashtf_prime(l)
<     lsmelt = lcmelt + lf * alpha1(l) * rhokh1_prime
---
>     IF (l_fix_neg_snow) THEN
>       ! This fix renders lcmelt superfluous, but to avoid more complicated
>       ! logic it is clearest to retain it for now and remove it once the old
>       ! functionality is no longer needed.
>       lsmelt = (cp + (lf * fracs(l) + lc * resft(l)) * alpha1(l)) *            &
>                rhokh1_prime + ashtf_prime(l)
>       lcmelt = lsmelt
>     ELSE
>       lcmelt = (cp + lc * alpha1(l) * resft(l)) * rhokh1_prime                 &
>                + ashtf_prime(l)
>       lsmelt = lcmelt + lf * alpha1(l) * rhokh1_prime
>     END IF
>     !   Note the use of lcmelt in the following IF-block. In line with the
>     !   preceeding comment, this should be lsmelt, but lcmelt is used to
>     !   maintain existing behaviour, aside from the loss of bit-comparison
>     !   by moving to increments.
178c198
<           snow_max / snow_density  <=  SQRT(2.0*EPSILON(snow_max))/maskd) THEN
---
>           snow_new / snow_density  <=  SQRT(2.0*EPSILON(snow_new))/maskd) THEN
181,183c201,204
<         dtstar = - MIN( (tstar_surft(l) - tm) *                                &
<                        maskd * snow_max / snow_density,                        &
<                        lf * snow_max / (lcmelt * timestep) )
---
>         snowinc_surft(l) = - MIN(snow_surft(l),                                &
>           (lcmelt * (tstar_surft(l) - tm) *                                    &
>           maskd * snow_new / snow_density / lf +                               &
>           ei_surft(l)) * timestep)
185,187c206,209
<         dtstar = - MIN( (tstar_surft(l) - tm) *                                &
<                  (1.0 - EXP(-maskd * snow_max / snow_density)),                &
<                  lf * snow_max / (lcmelt * timestep) )
---
>         snowinc_surft(l) = - MIN(snow_surft(l),                                &
>           (lcmelt * (tstar_surft(l) - tm) *                                    &
>           (1.0 - EXP(-maskd * snow_new / snow_density)) / lf +                 &
>           ei_surft(l)) * timestep)
190,191c212,213
<       dtstar = - MIN( tstar_surft(l) - tm ,                                    &
<                       lf * snow_max / (lcmelt * timestep) )
---
>       snowinc_surft(l) = - MIN(snow_surft(l),                                  &
>         (lcmelt * (tstar_surft(l) - tm) / lf + ei_surft(l)) * timestep)
192a215,216
>     melt_surft(l) = - snowinc_surft(l) / timestep - ei_surft(l)
>     dtstar = - lf * melt_surft(l) / lsmelt
194d217
<     melt_surft(l) = - lsmelt * dtstar / lf
diff -r vn7.0copy1_c4/src/./science/surface/sf_resist_jls.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/surface/sf_resist_jls.F90
23c23,24
<  vshr,fraca,resfs,resft,resfs_stom,l_et_stom,l_et_stom_surft)
---
>  vshr,tstar,fracaero_t, fracaero_s,resfs,resft,                                &
>  resfs_stom,l_et_stom,l_et_stom_surft)
29c30,31
< USE jules_science_fixes_mod, ONLY: l_fix_snow_frac
---
> USE jules_science_fixes_mod, ONLY: l_fix_snow_frac, l_fix_neg_snow
> USE water_constants_mod, ONLY: tm, rho_ice
80a83,84
> ,tstar(land_pts)                                                               &
>                      ! IN Surface temperature (K)
86,88c90,101
<  fraca(land_pts)                                                               &
<                      ! OUT Fraction of surface moisture flux with
< !                          !     only aerodynamic resistance.
---
>  fracaero_t(land_pts)                                                          &
>                      ! OUT Total fraction of surface moisture flux with
> !                          !     only aerodynamic resistance
> !                          !     frozen fractions (:,2).
> ,fracaero_s(land_pts)                                                          &
>                      ! OUT Fractions of surface moisture flux with
> !                          !     only aerodynamic resistance over a frozen
> !                          !     surface.
> !                          !     i.e. the fraction of the tile with
> !                          !     sublimation or deposition is fracaero_s
> !                          !     and the fraction with evaporation or
> !                          !     condensation is fracaero_t-fracaero_s
91c104
< !                          !     resistance factor for fraction 1-FRACA.
---
> !                          !     resistance factor for fraction 1-fracaero_t.
94c107
< !                          !     FRACA+(1-FRACA)*RESFS.
---
> !                          !     fracaero_t+(1-fracaero_t)*RESFS.
97c110
< !                          !     resistance factor for fraction 1-FRACA.
---
> !                          !     resistance factor for fraction 1-fracaero_t.
105a119,121
> REAL(KIND=real_jlslsm) ::                                                      &
>  msk_sndpth
>              ! Temporary scalar
118,119d133
< !     Set FRACA (= fA in the documentation) according to P243.68,
< !     and RESFS (= fS) according to P243.75 and P243.61.
122c136
< !$OMP PARALLEL DO                                                              &
---
> !$OMP PARALLEL DO IF(surft_pts > 1)                                            &
125,127c139,141
< !$OMP PRIVATE(l,k,j,i)                                                         &
< !$OMP SHARED(surft_pts,surft_index,land_index,t_i_length,fraca,dq,             &
< !$OMP        snowdep_surft,                                                    &
---
> !$OMP PRIVATE(l,k,j,i,msk_sndpth)                                              &
> !$OMP SHARED(surft_pts,surft_index,land_index,t_i_length,fracaero_t,fracaero_s,&
> !$OMP        dq,snowdep_surft,tstar,snow_surft,                                &
130c144
< !$OMP        canopy,epdt,resft,l_fix_snow_frac)
---
> !$OMP        canopy,epdt,resft,l_fix_snow_frac, l_fix_neg_snow)
140a155,156
>   ! Calculate for a snow-free canopy then adjust for snow. With the fix,
>   ! the potential fraction depends on the canopy water content.
142,152c158,186
<   fraca(l) = 1.0
<   IF (dq(l) <  0.0 .AND. snowdep_surft(l) <= 0.0) fraca(l) = 0.0
<   IF (dq(l) <  0.0 .AND. snowdep_surft(l) <= 0.0 .AND. catch(l) >  0.0)        &
<     fraca(l) = canopy(l) / ( epdt(l) + catch(l) )
<   IF (snowdep_surft(l) > 0.0) THEN
<     IF (frac_snow_subl_melt == 1) THEN
<       IF (l_fix_snow_frac) THEN
<         ! Use linear expansion of exponential if non-linear term
<         ! is of order EPSILON (i.e., x^2.0/2.0 ~ EPSILON)
<         IF (snowdep_surft(l)  >   SQRT(2.0*EPSILON(snowdep_surft))/maskd) THEN
<           fraca(l) = 1.0 - EXP(-maskd * snowdep_surft(l)) * (1.0 - fraca(l))
---
>   IF (l_fix_neg_snow) THEN
>     ! Make the logic more transparent.
>     IF (dq(l) >= 0.0) THEN
>       ! Only aerodynamic resistance for downward fluxes.
>       fracaero_t(l) = 1.0
>       IF (tstar(l) > tm) THEN
>         ! All downward moisture flux is added to canopy water.
>         fracaero_s(l) = 0.0
>       ELSE
>         ! All downward moisture flux is added to snow.
>         fracaero_s(l) = 1.0
>       END IF
>     ELSE
>       ! For upward fluxes, calculate the fraction for canopy water,
>       ! then apply that fraction on the snow-free part of the grid box.
>       IF (catch(l) > 0.0) THEN
>         fracaero_t(l) = canopy(l) / ( epdt(l) + catch(l) )
>       ELSE
>         fracaero_t(l) = 0.0
>       END IF
>       msk_sndpth = MAX(snowdep_surft(l), snow_surft(l) / rho_ice)
>       IF (msk_sndpth > 0.0) THEN
>         IF (frac_snow_subl_melt == 1) THEN
>           msk_sndpth = maskd * msk_sndpth
>           IF (msk_sndpth > SQRT(2.0 * EPSILON(msk_sndpth))) THEN
>             fracaero_s(l) = 1.0 - EXP(-msk_sndpth)
>           ELSE
>             fracaero_s(l) = msk_sndpth
>           END IF
154c188,189
<           fraca(l) = fraca(l) + (1.0 - fraca(l)) * maskd * snowdep_surft(l)
---
>           ! Snow is assumed to cover the entire canopy.
>           fracaero_s(l) = 1.0
155a191
>         fracaero_t(l) = fracaero_s(l) + (1.0 - fracaero_s(l)) * fracaero_t(l)
157c193,217
<         fraca(l) = 1.0 - EXP(-maskd * snowdep_surft(l))
---
>         ! Set the sublimation fraction to 0.
>         fracaero_s(l) = 0.0
>       END IF
>     END IF
>   ELSE
>     !   Original code
>     fracaero_t(l) = 1.0
>     IF (dq(l) <  0.0 .AND. snowdep_surft(l) <= 0.0) fracaero_t(l) = 0.0
>     IF (dq(l) <  0.0 .AND. snowdep_surft(l) <= 0.0 .AND. catch(l) >  0.0)      &
>       fracaero_t(l) = canopy(l) / ( epdt(l) + catch(l) )
>     IF (snowdep_surft(l) > 0.0) THEN
>       IF (frac_snow_subl_melt == 1) THEN
>         IF (l_fix_snow_frac) THEN
>           ! Use linear expansion of exponential if non-linear term
>           ! is of order EPSILON (i.e., x^2.0/2.0 ~ EPSILON)
>           IF (snowdep_surft(l) > SQRT(2.0*EPSILON(snowdep_surft))/maskd) THEN
>             fracaero_t(l) = 1.0 - EXP(-maskd * snowdep_surft(l)) *             &
>                          (1.0 - fracaero_t(l))
>           ELSE
>             fracaero_t(l) = fracaero_t(l) +                                    &
>                          (1.0 - fracaero_t(l)) * maskd * snowdep_surft(l)
>           END IF
>         ELSE
>           fracaero_t(l) = 1.0 - EXP(-maskd * snowdep_surft(l))
>         END IF
159a220
>     fracaero_t(l) = MIN(fracaero_t(l),1.0)
161d221
<   fraca(l) = MIN(fraca(l),1.0)
172c232
<                         ( fraca(l) + (1.0 - fraca(l)) * resfs(l) )
---
>                         ( fracaero_t(l) + (1.0 - fracaero_t(l)) * resfs(l) )
184,185c244,245
< !$OMP                 snow_surft, gc, vshr, fraca,                             &
< !$OMP                 resfs, ch, resft)   SCHEDULE(STATIC)
---
> !$OMP                 snow_surft, gc, vshr, fracaero_t,                        &
> !$OMP                 resfs, ch, resft) SCHEDULE(STATIC)
191c251
<         fraca(l) = 0.0
---
>         fracaero_t(l) = 0.0
200,201d259
< 
< 
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/surface: sf_resist_wtrac_mod.F90
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/surface: sf_ssi_imp_wtrac_mod.F90
diff -r vn7.0copy1_c4/src/./science/surface/sf_stom_jls_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/surface/sf_stom_jls_mod.F90
11,723c11,700
<     USE um_types, ONLY: real_jlslsm
<     
<     IMPLICIT NONE
<     
<     CHARACTER(LEN=*), PARAMETER, PRIVATE :: ModuleName='SF_STOM_MOD'
<     
<     PRIVATE
<     PUBLIC sf_stom
<     
<     CONTAINS
<     
<     ! *********************************************************************
<     ! Routines to calculate the bulk stomatal resistance and the canopy
<     ! CO2 fluxes.
<     !
<     ! References:
<     !   Bernacchi et al., 2001, Plant Cell and Environment, 24, 253--259,
<     !      https://doi.org/10.1111/j.1365-3040.2001.00668.x.
<     !   Medlyn et al., 2002, Plant, Cell and Environment, 25: 1167--1179,
<     !     https://doi.org/10.1046/j.1365-3040.2002.00891.x.
<     !   Mercado et al., 2018, New Phytologist, 218: 1462--1477,
<     !     https://doi.org/10.1111/nph.15100.
<     !
<     ! *********************************************************************
<     
<     SUBROUTINE sf_stom  (land_pts,land_index                                       &
<     ,                    veg_pts,veg_index                                         &
<     ,                    ft,co2,co2_3d,co2_dim_len                                 &
<     ,                    co2_dim_row,l_co2_interactive                             &
<     ,                    fsmc,veg_state,ht,ipar,lai                                &
<     ,                    canht,pstar                                               &
<     ,                    q1,t1, ra,tstar,o3,t_home_gb,t_growth_gb                  &
<     ,                    l_growth_gb, vpd_growth_gb                                &
<     ,                    co2_growth_gb,pstar_growth_gb                             &
<     ,                    xipam_opt,vcmax_opt,jmax_opt,t_sum,l_sum                  &
<     ,                    t_night,nt_sum,vpd_sum,co2_sum,pstar_sum                  &
<     ,                    can_rad_mod,ilayers,faparv                                &
<     ,                    gpp,gpp_lay, apar_lay                                     &
<     ,                    cmpf_lay, vcmax_lay, vcmax25_lay                          &
<     ,                    wlite_lay, wcarb_lay                                      &
<     ,                    wmin_lay, ej_lay,npp,resp_p,resp_l,resp_r,resp_w          &
<     ,                    n_leaf,n_root,n_stem,lai_bal,gc                           &
<     ,                    fapar_sun,fapar_shd,fsun                                  &
<     ,                    flux_o3,fo3,fapar_diag,apar_diag                          &
<     ,                    isoprene,terpene,methanol,acetone                         &
<     ,                    open_index,open_pts,                                      &
<                         !New arguments replacing USE statements
<                         !crop_vars_mod (IN)
<                         dvi_cpft,rootc_cpft)
<     
<     USE leaf_mod, ONLY: leaf
<     USE leaf_limits_mod, ONLY: leaf_limits
<     USE bvoc_emissions_mod, ONLY: bvoc_emissions
<     
<     USE conversions_mod, ONLY: zerodegc
<     USE theta_field_sizes, ONLY: t_i_length
<     
<     USE jules_surface_types_mod, ONLY: nnpft, ncpft
<     
<     USE jules_vegetation_mod, ONLY:                                                &
<     ! imported parameters
<         photo_collatz, photo_farquhar, photo_pmodel, stomata_medlyn,               &
<         photo_adapt, photo_acclim, photo_adapt_acclim, photo_pmodel_acclim,        &
<         photo_act_model, photo_act_pft, photo_act_gb, n_photo_coef,                &
<     ! imported scalars that are not changed
<         dsj_coef, dsv_coef, jv25_coef, act_j_coef, act_v_coef,                     &
<         l_bvoc_emis, l_fapar_diag, l_trait_phys, l_stem_resp_fix, l_o3_damage,     &
<         l_scale_resp_pm, photo_acclim_model, photo_model, stomata_model,           &
<         n_day_photo_acclim
<     
<     USE CN_utils_mod, ONLY:                                                        &
<     ! imported procedures
<         get_can_ave_fac, nleaf_from_lai
<     
<     USE pftparm, ONLY:                                                             &
<     ! imported arrays that are not changed
<         a_wl, a_ws, act_jmax, act_vcmax, alpha_elec, b_wl, c3, deact_jmax,         &
<         deact_vcmax, ds_jmax, ds_vcmax, eta_sl, kpar, nl0, nr_nl, ns_nl, omega,    &
<         r_grow, sigl, lma, nmass, kn, knl, tupp, tlow,  q10_leaf, nsw, nr, hw_sw,  &
<         jv25_ratio,beta_c3c4,eagamma, eakc, eako, gamma25, kc25, ko25
<     
<     USE ccarbon, ONLY:                                                             &
<     ! imported scalar parameters
<        epco2,epo2
<     
<     USE c_rmol, ONLY: rmol
<     
<     USE jules_surface_mod, ONLY:                                                   &
<     ! imported scalar parameters
<        iter,o2,cmass
<     
<     USE timestep_mod, ONLY: timestep
<     
<     USE model_time_mod, ONLY: timestep_len, current_time
<     
<     USE parkind1, ONLY: jprb, jpim
<     USE yomhook, ONLY: lhook, dr_hook
<     
<     USE crop_utils_mod, ONLY:                                                      &
<        stemc_from_prognostics,                                                     &
<        lma_from_prognostics
<     USE cropparm, ONLY: cfrac_l
<     
<     USE qsat_mod, ONLY: qsat
<     
<     USE ereport_mod, ONLY: ereport
<     
<     USE veg3_field_mod, ONLY: veg_state_type
<     
<     USE veg3_parm_mod, ONLY: l_veg3
<     IMPLICIT NONE
<     
<     !-----------------------------------------------------------------------------
<     ! Arguments with INTENT(in).
<     !-----------------------------------------------------------------------------
<     INTEGER, INTENT(IN) ::                                                         &
<      land_pts                                                                      &
<                                 ! IN Number of land points to be
<     !                                 !    processed.
<     ,land_index(land_pts)                                                          &
<                                 ! IN Index of land points on the
<     !                                 !    P-grid.
<     ,veg_pts                                                                       &
<                                 ! IN Number of vegetated points.
<     ,veg_index(land_pts)                                                           &
<                                 ! IN Index of vegetated points
<     !                                 !    on the land grid.
<     ,co2_dim_len                                                                   &
<                                 ! IN Length of a CO2 field row.
<     ,co2_dim_row                ! IN Number of CO2 field rows.
<     
<     INTEGER, INTENT(IN) ::                                                         &
<      ft                         ! IN Plant functional type.
<     
<     LOGICAL, INTENT(IN) :: l_co2_interactive   ! switch for 3D CO2 field
<     
<     INTEGER, INTENT(IN) ::                                                         &
<       can_rad_mod                                                                  &
<     !                           !Switch for canopy radiation model
<      ,ilayers
<     !                           !No of layers in canopy radiation model
<     
<     REAL(KIND=real_jlslsm), INTENT(IN) ::                                          &
<      co2                                                                           &
<                                 ! IN Atmospheric CO2 concentration
<     ,co2_3d(co2_dim_len,co2_dim_row)                                               &
<     !                                 ! IN 3D atmos CO2 concentration
<     !                                 !    (kg CO2/kg air).
<     ,fsmc(land_pts)                                                                &
<                                 ! IN Soil water factor.
<     ,ht(land_pts)                                                                  &
<                                 ! IN Canopy height (m).
<     ,ipar(land_pts)                                                                &
<                                 ! IN Incident PAR (W/m2).
<     ,lai(land_pts)                                                                 &
<                                 ! IN Leaf area index.
<     ,canht(land_pts)                                                               &
<                                 ! IN Canopy Height
<     ,pstar(land_pts)                                                               &
<                                 ! IN Surface pressure (Pa).
<     ,faparv(land_pts,ilayers)                                                      &
<                                 ! IN Profile of absorbed PAR.
<     ,fapar_shd(land_pts,ilayers)                                                   &
<                                 ! IN Profile of absorbed DIFF_PAR.
<     ,fapar_sun(land_pts,ilayers)                                                   &
<                                 ! IN Profile of absorbed DIR_PAR.
<     ,fsun(land_pts,ilayers)                                                        &
<                                 ! IN fraction of sunlit leaves
<     ,q1(land_pts)                                                                  &
<                                 ! IN Specific humidity at level 1
<     ,t1(land_pts)                                                                  &
<                                 ! IN Temperature at level 1
<     ,ra(land_pts)                                                                  &
<                                 ! IN Aerodynamic resistance (s/m).
<     ,tstar(land_pts)                                                               &
<                                 ! IN Surface temperature (K).
<     ,o3(land_pts)                                                                  &
<                                 ! IN Surface ozone concentration (ppb).
<     ,t_home_gb(land_pts)
<                                 ! IN Static (home) temperature for adaptation of
<                                 ! photosynthesis (K).
<     
<     
<     TYPE(veg_state_type), INTENT(IN OUT) :: veg_state
<     
<     !-----------------------------------------------------------------------------
<     ! Arguments with INTENT(out).
<     !-----------------------------------------------------------------------------
<     REAL(KIND=real_jlslsm), INTENT(OUT) ::                                         &
<      gpp(land_pts)                                                                 &
<                                 ! OUT Gross Primary Productivity
<     !                                 !     (kg C/m2/s).
<     , gpp_lay(land_pts, ilayers)                                              &
<                                 ! OUT Gross primary productivity per layer
<                                 !     (kg C/m2/s)
< 
<     , apar_lay(land_pts, ilayers)                                             &
<                                 ! OUT Absorbed PAR per layer
<                                 !     (W/m2)
< 
<     , cmpf_lay(land_pts, ilayers)                                             &
<                                 ! OUT CO2 compensation point factor per layer
<                                 !     (unitless)
< 
<     , vcmax_lay(land_pts, ilayers)                                            &
<                                 ! OUT Vcmax per layer
<                                 !     (mol CO2/m2/s)
< 
<     , vcmax25_lay(land_pts, ilayers)                                          &
<                                 ! OUT Vcmax25 per layer
<                                 !     (mol CO2/m2/s)
< 
<     , wlite_lay(land_pts, ilayers)                                            &
<                                 ! OUT Light-limited photosynthesis per layer
<                                 !     (mol CO2/m2/s)
< 
<     , wcarb_lay(land_pts, ilayers)                                            &
<                                 ! OUT Carbon-limited photosynthesis per layer
<                                 !     (mol CO2/m2/s)
< 
<     , wmin_lay(land_pts, ilayers)                                             &
<                                 ! OUT Minimum of light- and carbon-limited rates
<                                 !     (mol CO2/m2/s)
< 
<     , ej_lay(land_pts, ilayers)                                               &
<                                 ! OUT Electron transport rate per layer
<                                 !     (mol/m2/s)
<     ,npp(land_pts)                                                                 &
<                                 ! OUT Net Primary Productivity
<     !                                 !     (kg C/m2/s).
<     ,resp_p(land_pts)                                                              &
<                                 ! OUT Plant respiration rate
<     !                                 !     (kg C/m2/sec).
<     ,resp_r(land_pts)                                                              &
<                                 ! OUT Root respiration rate
<     !                                 !     (kg C/m2/sec).
<     ,resp_l(land_pts)                                                              &
<                                 ! OUT Leaf maintanence respiration rate
<     !                                 !     (kg C/m2/sec).
<     ,resp_w(land_pts)                                                              &
<                                 ! OUT Wood respiration rate
<     !                                 !     (kg C/m2/sec).
<     ,flux_o3(land_pts)                                                             &
<                                 ! OUT Flux of O3 to stomata (nmol O3/m2/s).
<     ,fo3(land_pts)                                                                 &
<                                 ! OUT Ozone exposure factor.
<     ,fapar_diag(land_pts)                                                          &
<                                 ! OUT FAPAR diagnostic
<     ,apar_diag(land_pts)
<                                 ! OUT APAR diagnostic
<     
<     REAL(KIND=real_jlslsm), INTENT(IN OUT) ::                                      &
<      gc(land_pts)                                                                  &
<                                 ! INOUT Canopy resistance to H2O (m/s).
<                                 ! The input value is only used if can_rad_mod=1.
<     ,t_growth_gb(land_pts)                                                         &
<                                 ! IN OUT Running mean (growth) temperature for
<                                 ! acclimation of photosynthesis (K).
<     ,co2_growth_gb(land_pts)                                                       &
<                                 ! Running mean (growth) co2 for        
<                                 ! acclimation of photosynthesis
<     ,l_growth_gb(land_pts)                                                         &
<                                 ! Running mean (growth) light for
<                                 ! acclimation of photosynthesis
<     ,pstar_growth_gb(land_pts)                                                     &
<                                 ! Running mean (growth) surface pressure for
<                                 ! acclimation of photosynthesis (K).
<     ,vpd_growth_gb(land_pts)                                                       &
<                                 ! Running mean (growth) vapour pressure          
<                                 ! deficit for acclimation of photosynthesis
<     ,l_sum(land_pts)                                                               &
<                                 ! sum light at noon running mean
<     ,t_sum(land_pts)                                                               &
<                                 ! sum temp at noon running sum  
<     ,t_night(land_pts)                                                             &
<                                 ! Running mean temperature for
<                                 ! acclimation of dark respiration (degc).
<     ,nt_sum(land_pts)                                                              &
<                                 ! sum temperature at night running mean   
<     ,vpd_sum(land_pts)                                                             &
<                                 ! sum vpd at night running mean
<     ,co2_sum(land_pts)                                                             &
<                                 ! sum co2 at night running mean
<     ,pstar_sum(land_pts)                                                           &
<                                 ! sum pstar at night running sum 
<     ,jmax_opt(land_pts)                                                            &
<                     ! Maximum rate of electron transport at optimal
<                                 ! condition (mol m-2 s-1)
<     ,vcmax_opt(land_pts)                                                           &
<                     ! Maximum rate of carboxylation at optimal
<                                 ! condition(mol CO2/m2s)                         
<     ,xipam_opt(land_pts)
<                                 ! Sensitivity of cim/ca ratio to VPD at 
<                                 ! optimal condition (Pa^1/2)
<     ! BVOC variables
<     REAL(KIND=real_jlslsm), INTENT(OUT) ::                                         &
<      isoprene(land_pts)                                                            &
<                        ! OUT Isoprene Emission Flux (kgC/m2/s)
<     ,terpene(land_pts)                                                             &
<                        ! OUT (Mono-)Terpene Emission Flux (kgC/m2/s)
<     ,methanol(land_pts)                                                            &
<                        ! OUT Methanol Emission Flux (kgC/m2/s)
<     ,acetone(land_pts)
<                        ! OUT Acetone Emission Flux (kgC/m2/s)
<     
<     INTEGER, INTENT(OUT) ::                                                        &
<     open_index(land_pts)                                                           &
<                                 ! OUT Index of land points
<     !                                 !      with open stomata.
<     ,open_pts                   ! OUT Number of land points
<     !                                 !      with open stomata.
<     
<     !New arguments replacing USE statements
<     !crop_vars_mod (IN)
<     REAL(KIND=real_jlslsm), INTENT(IN) :: dvi_cpft(land_pts,ncpft)
<     REAL(KIND=real_jlslsm), INTENT(IN) :: rootc_cpft(land_pts,ncpft)
<     
<     !-----------------------------------------------------------------------------
<     ! Local parameters.
<     !-----------------------------------------------------------------------------
<     REAL(KIND=real_jlslsm), PARAMETER ::                                           &
<       cconu = 12.0e-3,                                                             &
<         ! kg C in 1 mol CO2.
<       conpar = 2.19e5,                                                             &
<         ! Conversion from mol s-1 to W for PAR (J/mol photons).
<       t_ref = zerodegc + 25.0,                                                     &
<         ! Reference temperature (K).
<       tref_rmol = t_ref * rmol,                                                    &
<         ! The product of t_ref and rmol (J mol-1).
<       ha = 65330.0,                                                                &
<         ! Activation energy
<       rgas = 8.314,                                                                &
<         ! Universal gas constant 
<       haj = 43900.0
<         ! Deactivation energy
<     !-----------------------------------------------------------------------------
<     ! Local scalar variables.
<     !-----------------------------------------------------------------------------
<     INTEGER ::                                                                     &
<      i,j,k,l,m,n                                                                   &
<                                 ! WORK Loop counters.
<     ,clos_pts                                                                      &
<                                 ! WORK Number of land points
<     !                                 !      with closed stomata.
<     ,errcode                                                                       &
<                                 ! Error code to pass to ereport.
<     ,pft_photo_model                                                               &
<                                 ! Indicates which photosynthesis model to use for
<                                 ! the current PFT.
<     ,current_time_pmodel        ! save currentime for comparison
<     
<     REAL(KIND=real_jlslsm) ::                                                      &
<      dq_min                                                                        &
<        ! Minimum-allowed specific humidity deficit (kg H20 vapour/kg air).
<     ,expkn                                                                         &
<        ! Decay term.
<     ,fstem                                                                         &
<        ! Ratio of respiring stem wood to total wood.
<     ,jmax_numerator                                                                &
<        ! Numerator term in calculation of Jmax.
<     ,kc_val                                                                        &
<        ! Michaelis-Menten constant for CO2 (Pa) - for a single point.
<     ,ko_val                                                                        &
<        ! Michaelis-Menten constant for O2 (Pa) - for a single point.
<     ,lma_tmp                                                                       &
<        ! Temporary leaf mass per area for crops (kg leaf per m2 leaf area).
<     ,power                                                                         &
<        ! Exponent used in Q10 term.
<     ,stem_resp_scaling                                                             &
<        ! Scaling factor to reduce stem respiration
<     ,stemc                                                                         &
<        ! Stem carbon (kg m-2).
<     ,sun_term                                                                      &
<        ! Conversion from PAR to electron flux (mol electrons J-1).
<     ,timestep_real                                                                 &
<        ! Model timestep (s) in REAL
<     ,t_minus_ref                                                                   &
<        ! Temperature relative to the reference (K).
<     ,t_term                                                                        &
<        ! A temperature-related term (mol J-1).
<     ,tdegc                                                                         &
<        ! Temperature (deg C).
<     ,th_degc,tg_degc                                                               &
<        ! Temperatures t_home_gb and t_growth_gb in degrees Celsius.
<     ,vcmax_numerator
<        ! Numerator term in calculation of Vcmax.
<     
<     !-----------------------------------------------------------------------------
<     ! Local array variables.
<     !-----------------------------------------------------------------------------
<     INTEGER ::                                                                     &
<      clos_index(land_pts)
<                                 ! WORK Index of land points
<     !                                 !      with closed stomata.
<     
<     REAL(KIND=real_jlslsm) :: alpha_acclim
<     REAL(KIND=real_jlslsm) ::                                                      &
<      anetc(land_pts)                                                               &
<                                 ! WORK Net canopy photosynthesis
<     !                                 !     (mol CO2/m2/s).
<     ,co2c(land_pts)                                                                &
<                                 ! WORK Canopy level CO2 concentration
<     !                                 !      (kg CO2/kg air).
<     ,ci(land_pts)                                                                  &
<                                 ! WORK Internal CO2 pressure (Pa).
<     ,dq(land_pts)                                                                  &
<                                 ! WORK Specific humidity deficit
<     !                                 !      (kg H2O/kg air).
<     ,dqc(land_pts)                                                                 &
<                                 ! WORK Canopy level specific humidity
<     !                                 !      deficit (kg H2O/kg air).
<     ,fpar(land_pts)                                                                &
<                                 ! WORK PAR absorption factor.
<     ,i2_shd (land_pts)                                                             &
<                                 ! Radiation that goes to Photosystem II for
<                                 ! shaded leaves, expressed as an electron flux
<                                 ! (mol electrons m-2 s-1).
<     ,i2_sun(land_pts)                                                              &
<                                 ! Radiation that goes to Photosystem II for
<                                 ! sunlit leaves, expressed as an electron flux
<                                 ! (mol electrons m-2 s-1).
<     ,lai_bal(land_pts)                                                             &
<                                 ! WORK Leaf area index in balanced
<     !                                 !      growth state.
<     ,nleaf_top(land_pts)                                                           &
<                                 ! WORK Nitrogen concentration of top leaf.
<     !                           ! if(l_trait_phys)= g N/m2
<                                 ! else= kg N/kg C
<     ,n_leaf(land_pts)                                                              &
<                                 ! WORK Nitrogen contents of the leaf,
<     ,n_root(land_pts)                                                              &
<                                 !      root,
<     ,n_stem(land_pts)                                                              &
<                                 !      and stem (kg N/m2).
<     ,qs(land_pts)                                                                  &
<                                 ! WORK Saturated specific humidity
<     !                                 !      (kg H2O/kg air).
<     ,ra_rc(land_pts)                                                               &
<                                 ! WORK Ratio of aerodynamic resistance
<     !                                 !      to canopy resistance.
<     ,rdc(land_pts)                                                                 &
<                                 ! WORK Canopy dark respiration,
<     !                                 !      without soil water dependence
<     !                                 !      (mol CO2/m2/s).
<     ,rdmean(land_pts)                                                              &
<                                 ! WORK Mean dark respiration
<     !                                 !      per unit leaf area
<     !                                 !      over canopy
<     !                                 !      without soil water dependence
<     !                                 !   (mol CO2/s per m2 leaf area).
<     ,nlmean(land_pts)                                                              &
<                                 ! WORK Mean nitrogen per unit leaf area
<     !                                 !      over canopy
<     !                                 !      without soil water dependence
<     !                                 !      (kg N per m2 leaf area).
<     !                                 !      Used in place of n_leaf when LAI
<     !                                 !      is very small to avoid blowing up
<     !                                 !      the calculation of respiration.
<     ,resp_p_g(land_pts)                                                            &
<                                 ! WORK Plant growth respiration rate
<     !                                 !      (kg C/m2/sec).
<     ,resp_p_m(land_pts)                                                            &
<                                 ! WORK Plant maintenance respiration
<     !                                 !      rate (kg C/m2/sec).
<     ,root(land_pts)                                                                &
<                                 ! WORK Root carbon (kg C/m2).
<     ,faparv_layer(land_pts,ilayers)                                                &
<                                 ! WORK absorbed par(layers)
<     ,flux_o3_l(land_pts)                                                           &
<                                 ! WORK Flux of O3 to stomata (nmol O3/m2/s).
<     ,flux_o3_l_sun(land_pts)                                                       &
<                                 ! WORK Flux of O3 to stomata
<                                 !      for sunlit leaves
<     !                             !      (for can_rad_mod=5)
<                                 !      (nmol O3/m2/s).
<     ,flux_o3_l_shd(land_pts)                                                       &
<                                 ! WORK Flux of O3 to stomata
<                                 !      for shaded leaves
<                                 !      (for can_rad_mod=5)
<                                 !      (nmol O3/m2/s).
<     ,fo3_l(land_pts)                                                               &
<                                 ! WORK Ozone exposure factor.
<     ,fo3_l_sun(land_pts)                                                           &
<                                 ! WORK Ozone exposure factor
<                                 !      for sunlit leaves
<                                 !      (for can_rad_mod=5)
<     ,fo3_l_shd(land_pts)                                                           &
<                                 ! WORK Ozone exposure factor
<                                 !      for shaded leaves
<                                 !      (for can_rad_mod=5)
<     ,o3mol(land_pts)                                                               &
<                                 ! WORK Surface ozone concentration (moles).
<     ,fsmc_scale(land_pts)                                                          &
<                                 ! WORK Scaling of stem and root plant maintenance
<                                 ! respiration.
<     ,denom(land_pts)                                                               &
<        ! Denominator in temperature-dependency of Vcmax (Collatz model only).
<     ,dsj(land_pts)                                                                 &
<        ! Entropy factor for Jmax, including any acclimation (J mol-1 K-1).
<     ,dsv(land_pts)                                                                 &
<        ! Entropy factor for Vcmax, including any acclimation (J mol-1 K-1).
<     ,actj(land_pts)                                                                &
<        ! Activation energy for Jmax, including any acclimation (J mol-1).
<     ,actv(land_pts)                                                                &
<        ! Activation energy for Vcmax, including any acclimation (J mol-1).
<     ,ccp(land_pts)                                                                 &
<        ! Photorespiratory compensatory point (Pa). This is zero for C4 plants.
<     ,i2(land_pts)                                                                  &
<        ! Radiation that goes to Photosystem II, expressed as an electron flux
<        ! (mol electrons m-2 s-1).
<     ,je(land_pts)                                                                  &
<        ! Electron transport rate (mol m-2 s-1).
<     ,je_shd(land_pts)                                                              &
<        ! Electron transport rate for shaded leaves (mol m-2 s-1).
<     ,je_shd_ratio(land_pts)                                                        &
<        ! Ratio je_shd : je.
<     ,je_sun(land_pts)                                                              &
<        ! Electron transport rate for sunlit leaves (mol m-2 s-1).
<     ,je_sun_ratio(land_pts)                                                        &
<        ! Ratio je_sun : je.
<     ,jmax(land_pts)                                                                &
<        ! Maximum rate of electron transport (mol CO2 m-2 s-1).
<     ,jv25(land_pts)                                                                &
<        ! Ratio of Jmax to Vcmax at 25 degC, including any acclimation.
<     ,kc(land_pts)                                                                  &
<        ! Michaelis-Menten constant for CO2 (Pa).
<     ,km(land_pts)                                                                  &
<        ! A combination of Michaelis-Menten and other terms.
<     ,ko(land_pts)                                                                  &
<        ! Michaelis-Menten constant for O2 (Pa).
<     ,jmax_temp(land_pts)                                                           &
<        ! Factor expressing the effect of temperature on Jmax.
<     ,qtenf_term(land_pts)                                                          &
<        ! Q10 temperature term used for Vcmax.
<     ,vcmax_temp(land_pts)                                                          &
<        ! Factor expressing the effect of temperature on Vcmax.
<     ,vcmax(land_pts)                                                               &
<        ! Maximum rate of carboxylation of Rubisco (mol CO2/m2/s).
<     ,anetl(land_pts)                                                               &
<                                 ! WORK Net leaf photosynthesis
<     !                                 !      (mol CO2/m2/s/LAI).
<     ,anetl_sun(land_pts)                                                           &
<     !                                 ! WORK Net leaf photosynthesis of
<     !                                 !      sunlit leaves
<     !                                 !      (mol CO2/m2/s/LAI)
<     ,anetl_shd(land_pts)                                                           &
<     !                                 ! WORK Net leaf photosynthesis of
<     !                                 !      shaded leaves
<     !                                 !      (mol CO2/m2/s/LAI
<     ,apar(land_pts)                                                                &
<     !                                 ! WORK PAR absorbed by the top leaf
<     !                                 !      (W/m2).
<     ,acr(land_pts)                                                                 &
<                                 ! WORK Absorbed PAR
<     !                                 !      (mol photons/m2/s).
<     ,ca(land_pts)                                                                  &
<                                 ! WORK Canopy level CO2 pressure
<     !                                 !      (Pa).
<     ,gl(land_pts)                                                                  &
<                                 ! WORK Leaf conductance for H2O
<     !                                 !      (m/s).
<     ,gl_sun(land_pts)                                                              &
<                                 ! WORK Leaf conductance for H2O of
<     !                                 !      sunlit leaves (m/s).
<     ,gl_shd(land_pts)                                                              &
<                                 ! WORK Leaf conductance for H2O of
<     !                                 !      shaded leaves (m/s).
<     ,icr(land_pts)                                                                 &
<                                 ! WORK Incident PAR (mol photons/m2/s).
<     ,oa(land_pts)                                                                  &
<                                 ! WORK Atmospheric O2 pressure
<     !                                 !      (Pa).
<     ,rd(land_pts)                                                                  &
<                                 ! WORK Dark respiration, including any effect of
<                                 !      light inhibition (mol CO2/m2/s).
<     ,rd_dark(land_pts)                                                             &
<                                 ! WORK Dark respiration, excluding effect of
<                                 !      light inhibition (mol CO2/m2/s).
<     ,rd_sun(land_pts)                                                              &
<                                 ! WORK Dark respiration of sunlit leaves
<     !                                 !      (mol CO2/m2/s).
<     ,rd_shd(land_pts)                                                              &
<                                 ! WORK Dark respiration of shaded leaves
<     !                                 !      (mol CO2/m2/s).
<     
<     ,wcarb(land_pts)                                                               &
<                                 ! WORK Carboxylation, ...
<     ,wlite(land_pts)                                                               &
<                                 !      ... Light, and ...
<     ,wexpt(land_pts)                                                               &
<                                 !      ... export limited gross ...
<     !                                 !      ... photosynthetic rates ...
<     !                                 !      ... (mol CO2/m2/s).
<     ,wlitev(land_pts)                                                              &
<     !                                 ! WORK Light limited gross
<     !                                 !      photosynthetic rates
<     !                                 !      for each layer
<     !                                 !      (mol CO2/m2/s).
<     ,wlitev_sun(land_pts)                                                          &
<     !                                 ! WORK Light limited gross
<     !                                 !      photosynthetic rates
<     !                                 !      for sunlit leaves
<     !                                 !      (mol CO2/m2/s).
<     ,wlitev_shd(land_pts)                                                          &
<     !                                 ! WORK Light limited gross
<     !                                 !      photosynthetic rates
<     !                                 !      for shaded leaves
<     !                                 !      (mol CO2/m2/s).
<     ,dlai(land_pts)                                                                &
<                                 ! WORK LAI Increment.
<     ,nleaf_layer(land_pts)                                                         &
<                                 ! WORK Leaf nitrogen concentration in a layer.
<                                 ! kgN/kgC if l_trait_phys=F
<                                 ! gN/m2   if l_trait_phys=T.
<     ,can_averaging_fac(land_pts)                                                   &
<                                 ! WORK factor to convert top of canopy
<                                 ! value to canopy average.
<     ,cim_opt(land_pts)                                                           &
<                                 ! Leaf-internal CO2 partial pressure at
<                                 ! optimal condition (Pa).      
<     ,cim(land_pts)                                                           &
<                                ! Leaf-internal CO2 partial pressure at
<                                ! current condition (Pa).                           
<     ,gammastar25(land_pts)                                                       &
<                     ! CO2 compensation point at 25 degree C (Pa)
<     ,gammastarm(land_pts)                                                        &
<                     ! Pressure-dependent photorespiratory          
<                         ! compensation point  (Pa)  
<     ,gammastarm_opt(land_pts)                                                    &
<               ! Pressure-dependent photorespiratory at optimal
<     ,jmax25_opt(land_pts)                                                        &
<                     ! Maximum rate of electron transport at optimal
<                                 ! condition normalirsed at 25 degree (mol m-2 s-1) 
<     ,jmax_pmodel(land_pts)                                                       &
<                     ! Maximum rate of electron transport (mol m-2 s-1)
<     ,jmax_adjusted(land_pts)                                                     &
<                     ! Adjusted maximum rate of electron transport 
<                                 ! (mol m-2 s-1)
<     ,kcpa(land_pts)                                                              &
<                               ! Michaelis-Menten constant for CO2 (Pa) for a point. 
<     ,kopa(land_pts)                                                              &
<                               ! Michaelis-Menten constant for O2 (Pa) for a point.
<     ,kmpa(land_pts)                                                              &
<                          ! A combination of Michaelis-Menten and other terms.
<     ,ta(land_pts)                                                                &
<                         ! Atmospheric temperature (degree C). 
<     ,O2_partial_pres(land_pts)                                                   &
<                                 ! Atmospheric O2 partial pressure (K). 
<     ,phi0(land_pts)                                                              &
<                     ! Intrinsic quantum yield parameter. 
<     ,pratio(land_pts)                                                            &
<                                 ! Atmospheric pressure/atmospheric pressure at 0m
<     ,tgdegc(land_pts)                                                            &
<                                 ! Temperatures t_growth_gb in degrees Celsius.                            
<     ,vcmax25_opt(land_pts)                                                       &
<                     ! Maximum rate of carboxylation (mol CO2/m2s) 
<                                 ! normalise at 25 degrees
<     ,vcmax_pmodel(land_pts)                                                      &
<                     ! Maximum rate of carboxylation (mol CO2/m2s)
<     ,vcmax_adjusted(land_pts)                                                    &
<                     ! Adjusted maximum rate of carboxylation 
<                                 ! (mol CO2/m2s)
<     ,Rdopt(land_pts)                                                             &
<        ! Dark respiration at optimal condition
<     ,Rdnew(land_pts)                                                             &
<        ! Dark respiration at optimal condition normalise at 25 degrees
<     ,vpd(land_pts)                                                               &
<        ! vapour deficit pressure (Pa)                           
<     ,viscosityh2ostar(land_pts)                                                  &
<                         ! viscosity of water unit less
<     ,xipam(land_pts)
<                         ! Sensitivity of cim/ca ratio to VPD (Pa^1/2)                
<     REAL(KIND=real_jlslsm) ::                                                      &
<      act_j_tmp(n_photo_coef)                                                       &
<        ! Coefficients governing the acclimation of activation energy for Jmax.
<     ,act_v_tmp(n_photo_coef)
<        ! Coefficients governing the acclimation of activation energy for Vcmax.
<     INTEGER(KIND=jpim), PARAMETER :: zhook_in  = 0
<     INTEGER(KIND=jpim), PARAMETER :: zhook_out = 1
<     REAL(KIND=jprb)               :: zhook_handle
<     REAL :: tau(land_pts)
<     CHARACTER(LEN=*), PARAMETER :: RoutineName='SF_STOM'
<     
<     IF (lhook) CALL dr_hook(ModuleName//':'//RoutineName,zhook_in,zhook_handle)
<     !Care needed as the timestep is used in arithmetic to control the
<     !timing of when various science schemes are called.
<     #if defined(UM_JULES)
<     timestep_real =  timestep
<     #else
<     timestep_real = REAL(timestep_len)
<     #endif
<     
<     !-----------------------------------------------------------------------------
<     ! Initialisation.
<     !
<     ! Note that the initialisation is appropriate for the existing code! If an
<     ! existing variable is used differently (e.g. it is made available as a
<     ! diagnostic) it might need to be treated differently - e.g. initialised.
<     !
<     ! In general we only initialise output variables (diagnostics and/or those
<     ! required elsewhere - so that these have a defined value at all location)
<     ! and any local variables that need to be initialised (e.g. so as to allow
<     ! accumulation over canopy layers). Many other variables are not initialised
<     ! because they are always calculated at all locations for which a value is
<     ! required (e.g. all vegetated points, or all points with open stomata).
<     !-----------------------------------------------------------------------------
<     
<     !$OMP PARALLEL DO IF(land_pts > 1)                                             &
<     !$OMP DEFAULT(NONE)                                                            &
<     !$OMP SHARED(land_pts,l_o3_damage,fo3,flux_o3,isoprene,                        &
<     !$OMP        terpene,methanol,acetone,fsmc_scale)                              &
<     !$OMP PRIVATE(l)                                                               &
<     !$OMP SCHEDULE(STATIC)
---
> USE um_types, ONLY: real_jlslsm
> 
> IMPLICIT NONE
> 
> CHARACTER(LEN=*), PARAMETER, PRIVATE :: ModuleName='SF_STOM_MOD'
> 
> PRIVATE
> PUBLIC sf_stom
> 
> CONTAINS
> 
> ! *********************************************************************
> ! Routines to calculate the bulk stomatal resistance and the canopy
> ! CO2 fluxes.
> !
> ! References:
> !   Bernacchi et al., 2001, Plant Cell and Environment, 24, 253--259,
> !      https://doi.org/10.1111/j.1365-3040.2001.00668.x.
> !   Medlyn et al., 2002, Plant, Cell and Environment, 25: 1167--1179,
> !     https://doi.org/10.1046/j.1365-3040.2002.00891.x.
> !   Mercado et al., 2018, New Phytologist, 218: 1462--1477,
> !     https://doi.org/10.1111/nph.15100.
> !
> ! *********************************************************************
> 
> SUBROUTINE sf_stom  (land_pts,land_index                                       &
> ,                    veg_pts,veg_index                                         &
> ,                    ft,co2,co2_3d,co2_dim_len                                 &
> ,                    co2_dim_row,l_co2_interactive                             &
> ,                    fsmc,veg_state,ht,ipar,lai                                &
> ,                    canht,pstar                                               &
> ,                    q1,ra,tstar,o3,t_home_gb,t_growth_gb                      &
> ,                    can_rad_mod,ilayers,faparv                                &
> ,                    psi_root_zone,lwp_c                                       &
> ,                    gpp,npp,resp_p,resp_l,resp_r,resp_w                       &
> ,                    growth_sug, f_nsc                                         &
> ,                    n_leaf,n_root,n_stem,lai_bal,gc                           &
> ,                    fapar_sun,fapar_shd,fsun                                  &
> ,                    flux_o3,fo3,fapar_diag,apar_diag                          &
> ,                    isoprene,terpene,methanol,acetone                         &
> ,                    open_index,open_pts,                                      &
>                     !New arguments replacing USE statements
>                     !crop_vars_mod (IN)
>                     dvi_cpft,rootc_cpft)
> 
> USE leaf_mod, ONLY: leaf
> USE leaf_limits_mod, ONLY: leaf_limits
> USE leaf_processes_sox_mod, ONLY: leaf_processes_sox
> USE bvoc_emissions_mod, ONLY: bvoc_emissions
> 
> USE conversions_mod, ONLY: zerodegc
> USE theta_field_sizes, ONLY: t_i_length
> 
> USE jules_surface_types_mod, ONLY: nnpft, ncpft
> 
> USE jules_vegetation_mod, ONLY:                                                &
> ! imported parameters
>     photo_collatz, photo_farquhar, photo_sox_collatz,                          &
>     rd_classic, rd_pftq10, rd_tdq10, stomata_medlyn, stomata_sox,              &
>     photo_adapt, photo_acclim, photo_adapt_acclim,                             &
>     photo_act_model, photo_act_pft, photo_act_gb, n_photo_coef,                &
> ! imported scalars that are not changed
>     dsj_coef, dsv_coef, jv25_coef, act_j_coef, act_v_coef,                     &
>     tdq10_int, tdq10_slope,                                                    &
>     l_bvoc_emis, l_fapar_diag, l_trait_phys, l_stem_resp_fix, l_o3_damage,     &
>     l_scale_resp_pm, photo_acclim_model, photo_model, rd_model, stomata_model, &
>     l_sugar, l_vcmax_jmax_diurnal
> 
> USE CN_utils_mod, ONLY:                                                        &
> ! imported procedures
>     get_can_ave_fac, nleaf_from_lai
> 
> USE pftparm, ONLY:                                                             &
> ! imported arrays that are not changed
>     a_wl, a_ws, act_jmax, act_vcmax, alpha_elec, b_wl, c3, deact_jmax,         &
>     deact_vcmax, ds_jmax, ds_vcmax, eta_sl, kpar, nl0, nr_nl, ns_nl, omega,    &
>     r_grow, sigl, lma, nmass, kn, knl, tupp, tlow,  q10_leaf, nsw, nr, hw_sw,  &
>     jv25_ratio
> 
> USE ccarbon, ONLY:                                                             &
> ! imported scalar parameters
>    epco2,epo2
> 
> USE c_rmol, ONLY: rmol
> 
> USE jules_surface_mod, ONLY:                                                   &
> ! imported scalar parameters
>    iter,o2,cmass
> 
> USE parkind1, ONLY: jprb, jpim
> USE yomhook, ONLY: lhook, dr_hook
> 
> USE crop_utils_mod, ONLY:                                                      &
>    stemc_from_prognostics,                                                     &
>    lma_from_prognostics
> USE cropparm, ONLY: cfrac_l
> 
> USE qsat_mod, ONLY: qsat
> 
> USE ereport_mod, ONLY: ereport
> 
> USE veg3_field_mod, ONLY: veg_state_type
> 
> USE veg3_parm_mod, ONLY: l_veg3
> 
> USE sugar_mod, ONLY: sugar
> 
> !***rfu
> USE model_time_mod, ONLY: current_time  ! The time that the current timestep started
> !***rfu
> USE model_grid_mod, ONLY: longitude, latitude
> !***rfu
> !USE conversions_mod, ONLY: rsec_per_day, isec_per_min, imin_per_hour
> 
> IMPLICIT NONE
> 
> !-----------------------------------------------------------------------------
> ! Arguments with INTENT(in).
> !-----------------------------------------------------------------------------
> INTEGER, INTENT(IN) ::                                                         &
>  land_pts                                                                      &
>                             ! IN Number of land points to be
> !                                 !    processed.
> ,land_index(land_pts)                                                          &
>                             ! IN Index of land points on the
> !                                 !    P-grid.
> ,veg_pts                                                                       &
>                             ! IN Number of vegetated points.
> ,veg_index(land_pts)                                                           &
>                             ! IN Index of vegetated points
> !                                 !    on the land grid.
> ,co2_dim_len                                                                   &
>                             ! IN Length of a CO2 field row.
> ,co2_dim_row                ! IN Number of CO2 field rows.
> 
> INTEGER, INTENT(IN) ::                                                         &
>  ft                         ! IN Plant functional type.
> 
> LOGICAL, INTENT(IN) :: l_co2_interactive   ! switch for 3D CO2 field
> 
> INTEGER, INTENT(IN) ::                                                         &
>   can_rad_mod                                                                  &
> !                           !Switch for canopy radiation model
>  ,ilayers
> !                           !No of layers in canopy radiation model
> 
> REAL(KIND=real_jlslsm), INTENT(IN) ::                                          &
>  co2                                                                           &
>                             ! IN Atmospheric CO2 concentration
> ,co2_3d(co2_dim_len,co2_dim_row)                                               &
> !                                 ! IN 3D atmos CO2 concentration
> !                                 !    (kg CO2/kg air).
> ,fsmc(land_pts)                                                                &
>                             ! IN Soil water factor.
> ,ht(land_pts)                                                                  &
>                             ! IN Canopy height (m).
> ,ipar(land_pts)                                                                &
>                             ! IN Incident PAR (W/m2).
> ,lai(land_pts)                                                                 &
>                             ! IN Leaf area index.
> ,canht(land_pts)                                                               &
>                             ! IN Canopy Height
> ,pstar(land_pts)                                                               &
>                             ! IN Surface pressure (Pa).
> ,faparv(land_pts,ilayers)                                                      &
>                             ! IN Profile of absorbed PAR.
> ,fapar_shd(land_pts,ilayers)                                                   &
>                             ! IN Profile of absorbed DIFF_PAR.
> ,fapar_sun(land_pts,ilayers)                                                   &
>                             ! IN Profile of absorbed DIR_PAR.
> ,fsun(land_pts,ilayers)                                                        &
>                             ! IN fraction of sunlit leaves
> ,q1(land_pts)                                                                  &
>                             ! IN Specific humidity at level 1
> ,ra(land_pts)                                                                  &
>                             ! IN Aerodynamic resistance (s/m).
> ,tstar(land_pts)                                                               &
>                             ! IN Surface temperature (K).
> ,o3(land_pts)                                                                  &
>                             ! IN Surface ozone concentration (ppb).
> ,t_home_gb(land_pts)                                                           &
>                             ! IN Static (home) temperature for adaptation of
>                             ! photosynthesis (K).
> ,t_growth_gb(land_pts)                                                         &
>                             ! IN Running mean (growth) temperature for
>                             ! acclimation of photosynthesis (K).
> ,psi_root_zone(land_pts)
>                             ! IN (negative) soil water potential (in Pa)
>                             ! in root zone. Only required when SOX is used
> 
> TYPE(veg_state_type), INTENT(IN OUT) :: veg_state
> 
> !-----------------------------------------------------------------------------
> ! Arguments with INTENT(out).
> !-----------------------------------------------------------------------------
> REAL(KIND=real_jlslsm), INTENT(OUT) ::                                         &
>  gpp(land_pts)                                                                 &
>                             ! OUT Gross Primary Productivity
> !                                 !     (kg C/m2/s).
> ,npp(land_pts)                                                                 &
>                             ! OUT Net Primary Productivity
> !                                 !     (kg C/m2/s).
> ,resp_p(land_pts)                                                              &
>                             ! OUT Plant respiration rate
> !                                 !     (kg C/m2/sec).
> ,resp_r(land_pts)                                                              &
>                             ! OUT Root respiration rate
> !                                 !     (kg C/m2/sec).
> ,resp_l(land_pts)                                                              &
>                             ! OUT Leaf maintanence respiration rate
> !                                 !     (kg C/m2/sec).
> ,resp_w(land_pts)                                                              &
>                             ! OUT Wood respiration rate
> !                                 !     (kg C/m2/sec).
> ,growth_sug(land_pts)                                                          &
>                             ! OUT Net structural C growth rate (SUGAR only)
>                                   !     (kg C/m2/sec).
> ,flux_o3(land_pts)                                                             &
>                             ! OUT Flux of O3 to stomata (nmol O3/m2/s).
> ,fo3(land_pts)                                                                 &
>                             ! OUT Ozone exposure factor.
> ,fapar_diag(land_pts)                                                          &
>                             ! OUT FAPAR diagnostic
> ,apar_diag(land_pts)                                                           &
>                             ! OUT APAR diagnostic
> ,lwp_c(land_pts)
>                             ! OUT Canopy leaf water potential (MPa)
> 
> 
> REAL(KIND=real_jlslsm), INTENT(IN OUT) ::                                      &
>  gc(land_pts)                                                                  &
>                             ! INOUT Canopy resistance to H2O (m/s).
>                             ! The input value is only used if can_rad_mod=1.
> ,f_nsc(land_pts)
>                             ! INOUT Non-structural carbohydrate mass fraction
>                             !      (kgC/kgC)
> 
> ! BVOC variables
> REAL(KIND=real_jlslsm), INTENT(OUT) ::                                         &
>  isoprene(land_pts)                                                            &
>                    ! OUT Isoprene Emission Flux (kgC/m2/s)
> ,terpene(land_pts)                                                             &
>                    ! OUT (Mono-)Terpene Emission Flux (kgC/m2/s)
> ,methanol(land_pts)                                                            &
>                    ! OUT Methanol Emission Flux (kgC/m2/s)
> ,acetone(land_pts)
>                    ! OUT Acetone Emission Flux (kgC/m2/s)
> 
> INTEGER, INTENT(OUT) ::                                                        &
> open_index(land_pts)                                                           &
>                             ! OUT Index of land points
> !                                 !      with open stomata.
> ,open_pts                   ! OUT Number of land points
> !                                 !      with open stomata.
> 
> !New arguments replacing USE statements
> !crop_vars_mod (IN)
> REAL(KIND=real_jlslsm), INTENT(IN) :: dvi_cpft(land_pts,ncpft)
> REAL(KIND=real_jlslsm), INTENT(IN) :: rootc_cpft(land_pts,ncpft)
> 
> !-----------------------------------------------------------------------------
> ! Local parameters.
> !-----------------------------------------------------------------------------
> REAL(KIND=real_jlslsm), PARAMETER ::                                           &
>   cconu = 12.0e-3,                                                             &
>     ! kg C in 1 mol CO2.
>   conpar = 2.19e5,                                                             &
>     ! Conversion from mol s-1 to W for PAR (J/mol photons).
>   t_ref = zerodegc + 25.0,                                                     &
>     ! Reference temperature (K).
>   tref_rmol = t_ref * rmol
>     ! The product of t_ref and rmol (J mol-1).
> 
> !-----------------------------------------------------------------------------
> ! Local scalar variables.
> !-----------------------------------------------------------------------------
> INTEGER ::                                                                     &
>  i,j,k,l,m,n                                                                   &
>                             ! WORK Loop counters.
> ,clos_pts                                                                      &
>                             ! WORK Number of land points
> !                                 !      with closed stomata.
> ,errcode                                                                       &
>                             ! Error code to pass to ereport.
> ,pft_photo_model
>                             ! Indicates which photosynthesis model to use for
>                             ! the current PFT.
> 
> REAL(KIND=real_jlslsm) ::                                                      &
>  dq_min                                                                        &
>    ! Minimum-allowed specific humidity deficit (kg H20 vapour/kg air).
> ,expkn                                                                         &
>    ! Decay term.
> ,fstem                                                                         &
>    ! Ratio of respiring stem wood to total wood.
> ,jmax_numerator                                                                &
>    ! Numerator term in calculation of Jmax.
> ,kc_val                                                                        &
>    ! Michaelis-Menten constant for CO2 (Pa) - for a single point.
> ,ko_val                                                                        &
>    ! Michaelis-Menten constant for O2 (Pa) - for a single point.
> ,lma_tmp                                                                       &
>    ! Temporary leaf mass per area for crops (kg leaf per m2 leaf area).
> ,power                                                                         &
>    ! Exponent used in Q10 term.
> ,stem_resp_scaling                                                             &
>    ! Scaling factor to reduce stem respiration
> ,stemc                                                                         &
>    ! Stem carbon (kg m-2)
> ,sun_term                                                                      &
>    ! Conversion from PAR to electron flux (mol electrons J-1).
> ,t_mid                                                                         &
>    ! Mid-point between tstar and t_ref (deg C).
> ,tdq10                                                                         &
>    ! Temperature dependent Q10 (unitless).
> ,t_minus_ref                                                                   &
>    ! Temperature relative to the reference (K).
> ,t_term                                                                        &
>    ! A temperature-related term (mol J-1).
> ,tau                                                                           &
>    ! Rubisco specificty for CO2 relative to O2.
> ,tdegc                                                                         &
>    ! Temperature (deg C).
> ,th_degc, tg_degc                                                              &
>    ! Temperatures t_home_gb and t_growth_gb in degrees Celsius.
> ,vcmax_numerator
>    ! Numerator term in calculation of Vcmax.
> 
> !-----------------------------------------------------------------------------
> ! Local array variables.
> !-----------------------------------------------------------------------------
> INTEGER ::                                                                     &
>  clos_index(land_pts)
>                             ! WORK Index of land points
> !                                 !      with closed stomata.
> 
> REAL(KIND=real_jlslsm) ::                                                      &
>  anetc(land_pts)                                                               &
>                             ! WORK Net canopy photosynthesis
> !                                 !     (mol CO2/m2/s).
> ,co2c(land_pts)                                                                &
>                             ! WORK Canopy level CO2 concentration
> !                                 !      (kg CO2/kg air).
> ,ci(land_pts)                                                                  &
>                             ! WORK Internal CO2 pressure (Pa).
> ,dq(land_pts)                                                                  &
>                             ! WORK Specific humidity deficit
> !                                 !      (kg H2O/kg air).
> ,dqc(land_pts)                                                                 &
>                             ! WORK Canopy level specific humidity
> !                                 !      deficit (kg H2O/kg air).
> ,fpar(land_pts)                                                                &
>                             ! WORK PAR absorption factor.
> ,i2_shd (land_pts)                                                             &
>                             ! Radiation that goes to Photosystem II for
>                             ! shaded leaves, expressed as an electron flux
>                             ! (mol electrons m-2 s-1).
> ,i2_sun(land_pts)                                                              &
>                             ! Radiation that goes to Photosystem II for
>                             ! sunlit leaves, expressed as an electron flux
>                             ! (mol electrons m-2 s-1).
> ,lai_bal(land_pts)                                                             &
>                             ! WORK Leaf area index in balanced
> !                                 !      growth state.
> ,nleaf_top(land_pts)                                                           &
>                             ! WORK Nitrogen concentration of top leaf.
> !                           ! if(l_trait_phys)= g N/m2
>                             ! else= kg N/kg C
> ,n_leaf(land_pts)                                                              &
>                             ! WORK Nitrogen contents of the leaf,
> ,n_root(land_pts)                                                              &
>                             !      root,
> ,n_stem(land_pts)                                                              &
>                             !      and stem (kg N/m2).
> ,leafc(land_pts)                                                               &
>                             ! WORK Leaf Carbon (kg C/m2)
> ,leafc_bal(land_pts)                                                           &
>                             ! WORK Carbon of balanced LAI (kg C/m2)
> ,woodc(land_pts)                                                               &
>                             ! WORK Wood Carbon (kg C/m2)
> ,rootc(land_pts)                                                               &
>                             ! WORK Root Carbon (kg C/m2).
> ,qs(land_pts)                                                                  &
>                             ! WORK Saturated specific humidity
> !                                 !      (kg H2O/kg air).
> ,ra_rc(land_pts)                                                               &
>                             ! WORK Ratio of aerodynamic resistance
> !                                 !      to canopy resistance.
> ,rdc(land_pts)                                                                 &
>                             ! WORK Canopy dark respiration,
> !                                 !      without soil water dependence
> !                                 !      (mol CO2/m2/s).
> ,rdmean(land_pts)                                                              &
>                             ! WORK Mean dark respiration
> !                                 !      per unit leaf area
> !                                 !      over canopy
> !                                 !      without soil water dependence
> !                                 !   (mol CO2/s per m2 leaf area).
> ,nlmean(land_pts)                                                              &
>                             ! WORK Mean nitrogen per unit leaf area
> !                                 !      over canopy
> !                                 !      without soil water dependence
> !                                 !      (kg N per m2 leaf area).
> !                                 !      Used in place of n_leaf when LAI
> !                                 !      is very small to avoid blowing up
> !                                 !      the calculation of respiration.
> ,resp_p_g(land_pts)                                                            &
>                             ! WORK Plant growth respiration rate
> !                                 !      (kg C/m2/sec).
> ,resp_p_m(land_pts)                                                            &
>                             ! WORK Plant maintenance respiration
> !                                 !      rate (kg C/m2/sec).
> ,root(land_pts)                                                                &
>                             ! WORK Root carbon (kg C/m2).
> ,faparv_layer(land_pts,ilayers)                                                &
>                             ! WORK absorbed par(layers)
> ,flux_o3_l(land_pts)                                                           &
>                             ! WORK Flux of O3 to stomata (nmol O3/m2/s).
> ,flux_o3_l_sun(land_pts)                                                       &
>                             ! WORK Flux of O3 to stomata
>                             !      for sunlit leaves
> !                             !      (for can_rad_mod=5)
>                             !      (nmol O3/m2/s).
> ,flux_o3_l_shd(land_pts)                                                       &
>                             ! WORK Flux of O3 to stomata
>                             !      for shaded leaves
>                             !      (for can_rad_mod=5)
>                             !      (nmol O3/m2/s).
> ,fo3_l(land_pts)                                                               &
>                             ! WORK Ozone exposure factor.
> ,fo3_l_sun(land_pts)                                                           &
>                             ! WORK Ozone exposure factor
>                             !      for sunlit leaves
>                             !      (for can_rad_mod=5)
> ,fo3_l_shd(land_pts)                                                           &
>                             ! WORK Ozone exposure factor
>                             !      for shaded leaves
>                             !      (for can_rad_mod=5)
> ,o3mol(land_pts)                                                               &
>                             ! WORK Surface ozone concentration (moles).
> ,fsmc_scale(land_pts)                                                          &
>                             ! WORK Scaling of stem and root plant maintenance
>                             ! respiration.
> ,denom(land_pts)                                                               &
>    ! Denominator in temperature-dependency of Vcmax (Collatz model only).
> ,dsj(land_pts)                                                                 &
>    ! Entropy factor for Jmax, including any acclimation (J mol-1 K-1).
> ,dsv(land_pts)                                                                 &
>    ! Entropy factor for Vcmax, including any acclimation (J mol-1 K-1).
> ,actj(land_pts)                                                                &
>    ! Activation energy for Jmax, including any acclimation (J mol-1).
> ,actv(land_pts)                                                                &
>    ! Activation energy for Vcmax, including any acclimation (J mol-1).
> ,ccp(land_pts)                                                                 &
>    ! Photorespiratory compensatory point (Pa). This is zero for C4 plants.
> ,i2(land_pts)                                                                  &
>    ! Radiation that goes to Photosystem II, expressed as an electron flux
>    ! (mol electrons m-2 s-1).
> ,je(land_pts)                                                                  &
>    ! Electron transport rate (mol m-2 s-1).
> ,je_shd(land_pts)                                                              &
>    ! Electron transport rate for shaded leaves (mol m-2 s-1).
> ,je_shd_ratio(land_pts)                                                        &
>    ! Ratio je_shd : je.
> ,je_sun(land_pts)                                                              &
>    ! Electron transport rate for sunlit leaves (mol m-2 s-1).
> ,je_sun_ratio(land_pts)                                                        &
>    ! Ratio je_sun : je.
> ,jmax(land_pts)                                                                &
>    ! Maximum rate of electron transport (mol CO2 m-2 s-1).
> ,jv25(land_pts)                                                                &
>    ! Ratio of Jmax to Vcmax at 25 degC, including any acclimation.
> ,kc(land_pts)                                                                  &
>    ! Michaelis-Menten constant for CO2 (Pa).
> ,km(land_pts)                                                                  &
>    ! A combination of Michaelis-Menten and other terms.
> ,ko(land_pts)                                                                  &
>    ! Michaelis-Menten constant for O2 (Pa).
> ,jmax_temp(land_pts)                                                           &
>    ! Factor expressing the effect of temperature on Jmax.
> ,qtenf_term(land_pts)                                                          &
>    ! Q10 temperature term used for Vcmax.
> ,qtenf_resp(land_pts)                                                          &
>    ! Temperature=dependent Q10 temperature term used for dark respiration.
> ,vcmax_temp(land_pts)                                                          &
>    ! Factor expressing the effect of temperature on Vcmax.
> ,vcmax(land_pts)                                                               &
>    ! Maximum rate of carboxylation of Rubisco (mol CO2/m2/s).
> ,anetl(land_pts)                                                               &
>                             ! WORK Net leaf photosynthesis
> !                                 !      (mol CO2/m2/s/LAI).
> ,anetl_sun(land_pts)                                                           &
> !                                 ! WORK Net leaf photosynthesis of
> !                                 !      sunlit leaves
> !                                 !      (mol CO2/m2/s/LAI)
> ,anetl_shd(land_pts)                                                           &
> !                                 ! WORK Net leaf photosynthesis of
> !                                 !      shaded leaves
> !                                 !      (mol CO2/m2/s/LAI
> ,apar(land_pts)                                                                &
> !                                 ! WORK PAR absorbed by the top leaf
> !                                 !      (W/m2).
> ,acr(land_pts)                                                                 &
>                             ! WORK Absorbed PAR
> !                                 !      (mol photons/m2/s).
> ,ca(land_pts)                                                                  &
>                             ! WORK Canopy level CO2 pressure
> !                                 !      (Pa).
> ,gl(land_pts)                                                                  &
>                             ! WORK Leaf conductance for H2O
> !                                 !      (m/s).
> ,gl_sun(land_pts)                                                              &
>                             ! WORK Leaf conductance for H2O of
> !                                 !      sunlit leaves (m/s).
> ,gl_shd(land_pts)                                                              &
>                             ! WORK Leaf conductance for H2O of
> !                                 !      shaded leaves (m/s).
> ,icr(land_pts)                                                                 &
>                             ! WORK Incident PAR (mol photons/m2/s).
> ,oa(land_pts)                                                                  &
>                             ! WORK Atmospheric O2 pressure
> !                                 !      (Pa).
> ,rd(land_pts)                                                                  &
>                             ! WORK Dark respiration, including any effect of
>                             !      light inhibition (mol CO2/m2/s).
> ,rd_dark(land_pts)                                                             &
>                             ! WORK Dark respiration, excluding effect of
>                             !      light inhibition (mol CO2/m2/s).
> ,rd_sun(land_pts)                                                              &
>                             ! WORK Dark respiration of sunlit leaves
> !                                 !      (mol CO2/m2/s).
> ,rd_shd(land_pts)                                                              &
>                             ! WORK Dark respiration of shaded leaves
> !                                 !      (mol CO2/m2/s).
> 
> ,wcarb(land_pts)                                                               &
>                             ! WORK Carboxylation, ...
> ,wlite(land_pts)                                                               &
>                             !      ... Light, and ...
> ,wexpt(land_pts)                                                               &
>                             !      ... export limited gross ...
> !                                 !      ... photosynthetic rates ...
> !                                 !      ... (mol CO2/m2/s).
> ,wlitev(land_pts)                                                              &
> !                                 ! WORK Light limited gross
> !                                 !      photosynthetic rates
> !                                 !      for each layer
> !                                 !      (mol CO2/m2/s).
> ,wlitev_sun(land_pts)                                                          &
> !                                 ! WORK Light limited gross
> !                                 !      photosynthetic rates
> !                                 !      for sunlit leaves
> !                                 !      (mol CO2/m2/s).
> ,wlitev_shd(land_pts)                                                          &
> !                                 ! WORK Light limited gross
> !                                 !      photosynthetic rates
> !                                 !      for shaded leaves
> !                                 !      (mol CO2/m2/s).
> ,dlai(land_pts)                                                                &
>                             ! WORK LAI Increment.
> ,nleaf_layer(land_pts)                                                         &
>                             ! WORK Leaf nitrogen concentration in a layer.
>                             ! kgN/kgC if l_trait_phys=F
>                             ! gN/m2   if l_trait_phys=T.
> ,can_averaging_fac(land_pts)
>                             ! WORK factor to convert top of canopy
>                             ! value to canopy average.
> 
> REAL(KIND=real_jlslsm) ::                                                      &
>  act_j_tmp(n_photo_coef)                                                       &
>    ! Coefficients governing the acclimation of activation energy for Jmax.
> ,act_v_tmp(n_photo_coef)
> ! Coefficients governing the acclimation of activation energy for Vcmax.
> 
> 
> !***rfu
> REAL(KIND=real_jlslsm)     :: local_time_rfu(land_pts)
> REAL(KIND=real_jlslsm)     :: time_offset(land_pts)
> REAL(KIND=real_jlslsm)     :: gmt_hours(land_pts)
> REAL(KIND=real_jlslsm)     :: lat_rfu(land_pts)
> 
> INTEGER(KIND=jpim), PARAMETER :: zhook_in  = 0
> INTEGER(KIND=jpim), PARAMETER :: zhook_out = 1
> REAL(KIND=jprb)               :: zhook_handle
> 
> CHARACTER(LEN=*), PARAMETER :: RoutineName='SF_STOM'
> 
> IF (lhook) CALL dr_hook(ModuleName//':'//RoutineName,zhook_in,zhook_handle)
> 
> !-----------------------------------------------------------------------------
> ! Initialisation.
> !
> ! Note that the initialisation is appropriate for the existing code! If an
> ! existing variable is used differently (e.g. it is made available as a
> ! diagnostic) it might need to be treated differently - e.g. initialised.
> !
> ! In general we only initialise output variables (diagnostics and/or those
> ! required elsewhere - so that these have a defined value at all location)
> ! and any local variables that need to be initialised (e.g. so as to allow
> ! accumulation over canopy layers). Many other variables are not initialised
> ! because they are always calculated at all locations for which a value is
> ! required (e.g. all vegetated points, or all points with open stomata).
> !-----------------------------------------------------------------------------
> 
> !$OMP PARALLEL DO IF(land_pts > 1)                                             &
> !$OMP DEFAULT(NONE)                                                            &
> !$OMP SHARED(land_pts,l_o3_damage,fo3,flux_o3,isoprene,                        &
> !$OMP        terpene,methanol,acetone,fsmc_scale,                              &
> !$OMP        stomata_model,lwp_c)                                              &
> !$OMP PRIVATE(l)                                                               &
> !$OMP SCHEDULE(STATIC)
> DO l = 1, land_pts
> 
>   ! Ozone variables that are output.
>   flux_o3(l)    = 0.0
>   IF ( l_o3_damage ) THEN
>     ! Initialise to zero to allow accumulation.
>     fo3(l)      = 0.0
>   ELSE
>     ! Initialise to 1 to indicate no effect.
>     fo3(l)      = 1.0
>   END IF
> 
>   ! BVOC fluxes: values used at non-vegetated points or if fluxes are not
>   ! calculated (l_bvoc_emis=F).
>   isoprene(l)   = 0.0
>   terpene(l)    = 0.0
>   methanol(l)   = 0.0
>   acetone(l)    = 0.0
> 
>   fsmc_scale(l) = 1.0  !  Value used if l_scale_resp_pm =.FALSE..
>   ! leaf water potential variables for lwp_c diagnostic if SOX is used
>   IF ( stomata_model == stomata_sox ) THEN
>     ! initialise to zero to allow accumulation
>     lwp_c(l) = 0.0
>   END IF
> END DO
> !$OMP END PARALLEL DO
> 
> !-----------------------------------------------------------------------------
> ! Initialise variables that are accumulated over layers.
> ! Note that some or all of these variables are also used by the big-leaf
> ! model (can_rad_mod=1) but do not need to be initialised in that case.
> !-----------------------------------------------------------------------------
> SELECT CASE ( can_rad_mod )
> CASE ( 4,5,6 )
> !$OMP PARALLEL DO IF(land_pts > 1)                                             &
> !$OMP DEFAULT(NONE)                                                            &
> !$OMP SHARED(land_pts,anetc,gc,rdc,rdmean)                                     &
> !$OMP PRIVATE(l)                                                               &
> !$OMP SCHEDULE(STATIC)
>   DO l = 1, land_pts
>     anetc(l)  = 0.0
>     gc(l)     = 0.0
>     rdc(l)    = 0.0
>     rdmean(l) = 0.0
>   END DO
> !$OMP END PARALLEL DO
> END SELECT
> 
> !-----------------------------------------------------------------------------
> ! Decide which photosynthesis model will be used for this PFT.
> !-----------------------------------------------------------------------------
> SELECT CASE ( photo_model )
> CASE ( photo_collatz )
>   ! C3 and C4 both use a Collatz model.
>   pft_photo_model = photo_collatz
> CASE ( photo_farquhar )
>   ! C3 uses Farquhar, C4 uses Collatz.
>   IF ( c3(ft) == 1 ) THEN
>     pft_photo_model = photo_farquhar
>   ELSE
>     pft_photo_model = photo_collatz
>   END IF
> CASE ( photo_sox_collatz )
>   pft_photo_model = photo_collatz
>   ! For the purposes of initialisation these are both photo_collatz
> END SELECT
> 
> !-----------------------------------------------------------------------------
> ! Initialise ratios of electron fluxes.
> !-----------------------------------------------------------------------------
> IF ( pft_photo_model == photo_farquhar ) THEN
>   SELECT CASE ( can_rad_mod )
>   CASE ( 5, 6 )
> !$OMP PARALLEL DO IF(land_pts > 1)                                             &
> !$OMP DEFAULT(NONE)                                                            &
> !$OMP SHARED(land_pts, je_shd_ratio, je_sun_ratio)                             &
> !$OMP PRIVATE(l)                                                               &
> !$OMP SCHEDULE(STATIC)
725,743c702,703
<     
<       ! Ozone variables that are output.
<       flux_o3(l)    = 0.0
<       IF ( l_o3_damage ) THEN
<         ! Initialise to zero to allow accumulation.
<         fo3(l)      = 0.0
<       ELSE
<         ! Initialise to 1 to indicate no effect.
<         fo3(l)      = 1.0
<       END IF
<     
<       ! BVOC fluxes: values used at non-vegetated points or if fluxes are not
<       ! calculated (l_bvoc_emis=F).
<       isoprene(l)   = 0.0
<       terpene(l)    = 0.0
<       methanol(l)   = 0.0
<       acetone(l)    = 0.0
<     
<       fsmc_scale(l) = 1.0  !  Value used if l_scale_resp_pm =.FALSE..
---
>       je_shd_ratio(l)  = 0.0
>       je_sun_ratio(l)  = 0.0
745,821c705,813
<     !$OMP END PARALLEL DO
<     
<     !-----------------------------------------------------------------------------
<     ! Initialise variables that are accumulated over layers.
<     ! Note that some or all of these variables are also used by the big-leaf
<     ! model (can_rad_mod=1) but do not need to be initialised in that case.
<     !-----------------------------------------------------------------------------
<     SELECT CASE ( can_rad_mod )
<     CASE ( 4,5,6 )
<     !$OMP PARALLEL DO IF(land_pts > 1)                                             &
<     !$OMP DEFAULT(NONE)                                                            &
<     !$OMP SHARED(land_pts,anetc,gc,rdc,rdmean)                                     &
<     !$OMP PRIVATE(l)                                                               &
<     !$OMP SCHEDULE(STATIC)
<       DO l = 1, land_pts
<         anetc(l)  = 0.0
<         gc(l)     = 0.0
<         rdc(l)    = 0.0
<         rdmean(l) = 0.0
<       END DO
<     !$OMP END PARALLEL DO
<     END SELECT
<     
<     !-----------------------------------------------------------------------------
<     ! Decide which photosynthesis model will be used for this PFT.
<     !-----------------------------------------------------------------------------
<     SELECT CASE ( photo_model )
<     CASE ( photo_collatz )
<       ! C3 and C4 both use a Collatz model.
<       pft_photo_model = photo_collatz
<     CASE ( photo_farquhar )
<       ! C3 uses Farquhar, C4 uses Collatz.
<       IF ( c3(ft) == 1 ) THEN
<         pft_photo_model = photo_farquhar
<       ELSE
<         pft_photo_model = photo_collatz
<       END IF
<     CASE ( photo_pmodel )
<       ! C3 and C4 both use P-model.
<       pft_photo_model = photo_pmodel
<     END SELECT
<     
<     !-----------------------------------------------------------------------------
<     ! Initialise ratios of electron fluxes.
<     !-----------------------------------------------------------------------------
<     IF ( pft_photo_model == photo_farquhar ) THEN
<       SELECT CASE ( can_rad_mod )
<       CASE ( 5, 6 )
<     !$OMP PARALLEL DO IF(land_pts > 1)                                             &
<     !$OMP DEFAULT(NONE)                                                            &
<     !$OMP SHARED(land_pts, je_shd_ratio, je_sun_ratio)                             &
<     !$OMP PRIVATE(l)                                                               &
<     !$OMP SCHEDULE(STATIC)
<         DO l = 1, land_pts
<           je_shd_ratio(l)  = 0.0
<           je_sun_ratio(l)  = 0.0
<         END DO
<     !$OMP END PARALLEL DO
<       END SELECT
<     END IF
<     
<     !-----------------------------------------------------------------------------
<     ! Set the CO2 compensation point to zero for C4 plants.
<     !-----------------------------------------------------------------------------
<     IF ( c3(ft) == 0 ) THEN
<       ccp(:) = 0.0
<     END IF
<     
<     !-----------------------------------------------------------------------------
<     ! Calculate humidity at saturation.
<     !-----------------------------------------------------------------------------
<     CALL qsat(qs,tstar,pstar,land_pts)
<     
<     ! Set the minimum-allowed humidity deficit.
<     IF ( stomata_model == stomata_medlyn ) THEN
<       ! Avoid dq=0 as this would cause the model to blow up.
<       dq_min = 0.0001
---
> !$OMP END PARALLEL DO
>   END SELECT
> END IF
> 
> !-----------------------------------------------------------------------------
> ! Set the CO2 compensation point to zero for C4 plants.
> !-----------------------------------------------------------------------------
> IF ( c3(ft) == 0 ) THEN
>   ccp(:) = 0.0
> END IF
> 
> !-----------------------------------------------------------------------------
> ! Calculate humidity at saturation.
> !-----------------------------------------------------------------------------
> CALL qsat(qs,tstar,pstar,land_pts)
> 
> ! Set the minimum-allowed humidity deficit.
> IF ( ( stomata_model == stomata_medlyn ) .OR. ( stomata_model == stomata_sox ) ) THEN
>   ! Avoid dq=0 as this would cause the model to blow up.
>   dq_min = 0.0001
> ELSE
>   dq_min = 0.0
> END IF
> 
> !-----------------------------------------------------------------------------
> ! Set the canopy CO2 concentration.
> !-----------------------------------------------------------------------------
> !$OMP PARALLEL IF(veg_pts > 1) DEFAULT(NONE) PRIVATE(i, j, l, m, lma_tmp)      &
> !$OMP SHARED(l_co2_interactive, l_o3_damage, acr, veg_pts, veg_index,          &
> !$OMP        land_index, t_i_length, co2c, co2_3d, co2, dq, qs, q1,            &
> !$OMP        can_rad_mod, fpar, icr, kpar, lai, ft, apar, omega, ipar,         &
> !$OMP        l_trait_phys, nnpft, dvi_cpft, nleaf_top, nmass, nl0,             &
> !$OMP        dlai, ilayers, o3mol, o3, pstar, tstar, lma, ca, stomata_model,   &
> !$OMP        dq_min, c3, oa)
> IF ( l_co2_interactive ) THEN
>   !       Use full 3D CO2 field.
> !$OMP  DO SCHEDULE(STATIC)
>   DO m = 1,veg_pts
>     l = veg_index(m)
>     j = (land_index(l) - 1) / t_i_length + 1
>     i = land_index(l) - (j-1) * t_i_length
>     co2c(l) = co2_3d(i,j)
>   END DO
> !$OMP END DO NOWAIT
> ELSE
>   !       Use single CO2_MMR value.
> !$OMP DO SCHEDULE(STATIC)
>   DO m = 1,veg_pts
>     l = veg_index(m)
>     co2c(l) = co2
>   END DO
> !$OMP END DO NOWAIT
> END IF
> 
> !---------------------------------------------------------------------------
> !***rfu---- calculate the local time here as only needs to be done once ----
> !---------------------------------------------------------------------------
>   DO m = 1,veg_pts
>     l = veg_index(m)
>     j = (land_index(l) - 1) / t_i_length + 1
>     i = land_index(l) - (j-1) * t_i_length
>     gmt_hours(l) = current_time%TIME / 3600.0 ! comvert GMT seconds to hours
>     time_offset(l) = longitude(i,j) / 15.0 !convert longitude to time offset in hours (15 degrees = 1 hr)
>     local_time_rfu(l) = mod(gmt_hours(l) + time_offset(l), 24.0) !compute local time in hours
>     IF (local_time_rfu(l) < 0.0) THEN !ensure local time is positive
>        local_time_rfu(l) = local_time_rfu(l) + 24.0
>     END IF   
>     lat_rfu(l) = latitude(i,j)
>     !IF (current_time%TIME == 00000) THEN
>     !   print*,l,j,longitude(i,j),latitude(i,j),lat_rfu(l),current_time%TIME,gmt_hours(l), time_offset(l), local_time_rfu(l)
>     !   END IF
>   END DO
> 
> 
> !-----------------------------------------------------------------------------
> ! Calculate the surface to level 1 humidity deficit.
> !-----------------------------------------------------------------------------
> !$OMP DO SCHEDULE(STATIC)
> DO m = 1,veg_pts
>   l = veg_index(m)
>   dq(l) = MAX(dq_min,(qs(l) - q1(l)))
> END DO
> !$OMP END DO NOWAIT
> 
> !-----------------------------------------------------------------------------
> ! Calculate the PAR absorption factor
> !-----------------------------------------------------------------------------
> IF ( can_rad_mod == 1 ) THEN
> !$OMP DO SCHEDULE(STATIC)
>   DO m = 1,veg_pts
>     l = veg_index(m)
>     fpar(l) = (1.0 - EXP(-kpar(ft) * lai(l))) / kpar(ft)
>   END DO
> !$OMP END DO NOWAIT
> END IF
> 
> !-----------------------------------------------------------------------------
> ! Calculate the PAR absorbed by the top leaf and set top leaf N value.
> !-----------------------------------------------------------------------------
> !$OMP DO SCHEDULE(STATIC)
> DO m  = 1,veg_pts
>   l = veg_index(m)
>   apar(l) = (1.0 - omega(ft)) * ipar(l)
>   acr(l)  = apar(l) / conpar
>   IF ( l_trait_phys ) THEN
>     IF ( ft > nnpft ) THEN
>       lma_tmp = lma_from_prognostics(ft - nnpft, dvi_cpft(l,ft - nnpft))
>       nleaf_top(l) = nmass(ft) * lma_tmp * 1000.0
>         ! gN/gleaf * gleaf/m2 = gN/m2
823c815,816
<       dq_min = 0.0
---
>       nleaf_top(l) = nmass(ft) * lma(ft) * 1000.0
>         ! gN/gleaf * gleaf/m2 = gN/m2
825,853c818,914
<     
<     !-----------------------------------------------------------------------------
<     ! Set the canopy CO2 concentration.
<     !-----------------------------------------------------------------------------
<     !$OMP PARALLEL IF(veg_pts > 1) DEFAULT(NONE) PRIVATE(i, j, l, m, lma_tmp)      &
<     !$OMP SHARED(l_co2_interactive, l_o3_damage, acr, veg_pts, veg_index,          &
<     !$OMP        land_index, t_i_length, co2c, co2_3d, co2, dq, qs, q1,            &
<     !$OMP        can_rad_mod, fpar, icr, kpar, lai, ft, apar, omega, ipar,         &
<     !$OMP        l_trait_phys, nnpft, dvi_cpft, nleaf_top, nmass, nl0,             &
<     !$OMP        dlai, ilayers, o3mol, o3, pstar, tstar, lma, ca, stomata_model,   &
<     !$OMP        dq_min, c3, oa)
<     IF ( l_co2_interactive ) THEN
<       !       Use full 3D CO2 field.
<     !$OMP  DO SCHEDULE(STATIC)
<       DO m = 1,veg_pts
<         l = veg_index(m)
<         j = (land_index(l) - 1) / t_i_length + 1
<         i = land_index(l) - (j-1) * t_i_length
<         co2c(l) = co2_3d(i,j)
<       END DO
<     !$OMP END DO NOWAIT
<     ELSE
<       !       Use single CO2_MMR value.
<     !$OMP DO SCHEDULE(STATIC)
<       DO m = 1,veg_pts
<         l = veg_index(m)
<         co2c(l) = co2
<       END DO
<     !$OMP END DO NOWAIT
---
>   ELSE
>     nleaf_top(l) = nl0(ft)
>   END IF
> END DO
> !$OMP END DO NOWAIT
> 
> !-----------------------------------------------------------------------------
> ! Calculate incoming PAR (mol photons m-2 s-1).
> !-----------------------------------------------------------------------------
> SELECT CASE ( can_rad_mod )
> CASE ( 5:6 )
> !$OMP DO SCHEDULE(STATIC)
>   DO m  = 1,veg_pts
>     l = veg_index(m)
>     icr(l) = ipar(l) / conpar
>   END DO
> !$OMP END DO NOWAIT
> END SELECT
> 
> !-----------------------------------------------------------------------------
> ! Calculate the LAI in each canopy layer.
> !-----------------------------------------------------------------------------
> SELECT CASE ( can_rad_mod )
> CASE ( 4:6 )
> !$OMP DO SCHEDULE(STATIC)
>   DO m  = 1,veg_pts
>     l = veg_index(m)
>     dlai(l) = lai(l) / REAL(ilayers)
>   END DO
> !$OMP END DO NOWAIT
> END SELECT
> 
> !-----------------------------------------------------------------------------
> ! Convert O3 concentration from ppb to moles.
> !-----------------------------------------------------------------------------
> IF ( l_o3_damage ) THEN
> !$OMP DO SCHEDULE(STATIC)
>   DO m  = 1,veg_pts
>     l = veg_index(m)
>     o3mol(l) = o3(l) * pstar(l) / (rmol * tstar(l))
>   END DO
> !$OMP END DO NOWAIT
> END IF
> 
> !-----------------------------------------------------------------------------
> ! Calculate partial pressure of oxygen.
> !-----------------------------------------------------------------------------
> IF ( c3(ft) == 1 ) THEN
>   ! Calculate partial pressure of oxygen.
> !$OMP DO SCHEDULE(STATIC)
>   DO m  = 1,veg_pts
>     l = veg_index(m)
>     ! Convert O2 from mass fraction to partial pressure.
>     oa(l)  = o2 / epo2 * pstar(l)
>   END DO
> !$OMP END DO
> END IF  !  C3
> 
> !-----------------------------------------------------------------------------
> ! Convert CO2 from mass fraction to partial pressure.
> ! We ignore the (small) difference between the canopy- and
> ! reference-level CO2 concentrations.
> !-----------------------------------------------------------------------------
> !$OMP DO SCHEDULE(STATIC)
> DO m  = 1,veg_pts
>   l = veg_index(m)
>   ca(l) = co2c(l) / epco2 * pstar(l)
> END DO
> !$OMP END DO
> !$OMP END PARALLEL
> 
> !-----------------------------------------------------------------------------
> ! Pre-calculate some expensive terms that do not change between iterations
> ! and layers.
> ! tstar is for the current pft, so can't be moved up another level.
> !-----------------------------------------------------------------------------
> IF ( (pft_photo_model == photo_collatz) .OR. (rd_model == rd_pftq10) ) THEN
>   ! Use the Collatz model (for C3 or C4 plants).
> !$OMP PARALLEL DO IF(veg_pts > 1) DEFAULT(NONE) PRIVATE(l,m,power,tau,tdegc)   &
> !$OMP SHARED(c3, veg_pts, veg_index, ccp, denom, ft, kc, ko, oa, tlow,         &
> !$OMP        q10_leaf,  qtenf_term, tstar, tupp) SCHEDULE(STATIC)
>   DO m  = 1,veg_pts
>     l = veg_index(m)
>     tdegc         = tstar(l) - zerodegc
>     power         = 0.1 * (tdegc- 25.0)
>     denom(l)      = (1.0 + EXP (0.3 * (tdegc - tupp(ft)))) *                   &
>                     (1.0 + EXP (0.3 * (tlow(ft) - tdegc)))
>     qtenf_term(l) = q10_leaf(ft)** power
> 
>     IF ( c3(ft) == 1 ) THEN
>       ! Calculate terms that are only needed for C3 plants.
>       ! Although oa, kc and ko are always used together we keep them separate
>       ! to maintain bit comparability.
>       tau    = 2600.0  * (0.57 ** power)
>       ccp(l) = 0.5 * oa(l) / tau
>       kc(l)  = 30.0    * (2.1 ** power)
>       ko(l)  = 30000.0 * (1.2 ** power)
855,859c916,933
<     
<     !-----------------------------------------------------------------------------
<     ! Calculate the surface to level 1 humidity deficit.
<     !-----------------------------------------------------------------------------
<     !$OMP DO SCHEDULE(STATIC)
---
> 
>   END DO
> !$OMP END PARALLEL DO
> 
> ELSE IF ( pft_photo_model == photo_farquhar ) THEN
>   ! Use the Farquhar model (for C3 plants).
>   ! Calculate a constant.
>   sun_term = alpha_elec(ft) / conpar
> 
>   ! Load parameter values, depending on options.
>   SELECT CASE ( photo_acclim_model )
>   CASE ( 0 )
>     ! No acclimation.
>     ! Copy the PFT parameters, including fixed J:V.
> !$OMP PARALLEL DO IF(veg_pts > 1) DEFAULT(NONE) PRIVATE(l,m)                   &
> !$OMP SHARED(ds_jmax, ds_vcmax, dsj, dsv, ft, jv25, jv25_ratio,                &
> !$OMP        actj, act_jmax, actv, act_vcmax, veg_index, veg_pts)              &
> !$OMP SCHEDULE(STATIC)
862c936,940
<       dq(l) = MAX(dq_min,(qs(l) - q1(l)))
---
>       dsj(l)  = ds_jmax(ft)
>       dsv(l)  = ds_vcmax(ft)
>       jv25(l) = jv25_ratio(ft)
>       actj(l) = act_jmax(ft)
>       actv(l) = act_vcmax(ft)
864,870c942,1116
<     !$OMP END DO NOWAIT
<     
<     !-----------------------------------------------------------------------------
<     ! Calculate the PAR absorption factor
<     !-----------------------------------------------------------------------------
<     IF ( can_rad_mod == 1 ) THEN
<     !$OMP DO SCHEDULE(STATIC)
---
> !$OMP END PARALLEL DO
> 
>   CASE ( photo_adapt, photo_acclim, photo_adapt_acclim )
>     ! These use the same forms but t_growth_gb will generally be
>     ! different. Although there is no dependency on PFT here (meaning
>     ! this could be moved up and out of a PFT loop), we leave it here
>     ! so that these parameters are calculated here regardless of the
>     ! acclimation model selected.
> 
>     ! Decide whether the activation energies are subject to acclimation.  If
>     ! they are, then the energies vary by gridbox but not by PFT, otherwise
>     ! the energies vary by PFT but not by gridbox.
>     SELECT CASE ( photo_act_model )
>     CASE ( photo_act_pft )
>       act_j_tmp(:) = [act_jmax(ft), 0.0, 0.0]
>       act_v_tmp(:) = [act_vcmax(ft), 0.0, 0.0]
>     CASE ( photo_act_gb )
>       act_j_tmp(:) = act_j_coef(:)
>       act_v_tmp(:) = act_v_coef(:)
>     CASE DEFAULT
>       errcode = 101  !  a hard error
>       CALL ereport(RoutineName, errcode,                                       &
>                    'photo_act_model should be photo_act_pft or photo_act_gb')
>     END SELECT
> 
> !$OMP PARALLEL DO IF(veg_pts > 1) DEFAULT(NONE) PRIVATE(l,m,th_degc,tg_degc)   &
> !$OMP SHARED(dsj, dsj_coef, dsv, dsv_coef, jv25, jv25_coef,                    &
> !$OMP        actj, act_j_tmp, actv, act_v_tmp,                                 &
> !$OMP        t_home_gb, t_growth_gb, veg_index, veg_pts)                       &
> !$OMP SCHEDULE(STATIC)
>     DO m = 1,veg_pts
>       l = veg_index(m)
>       th_degc = t_home_gb(l) - zerodegc
>       tg_degc = t_growth_gb(l) - zerodegc
>       dsj(l)  = dsj_coef(1) + dsj_coef(2) * th_degc + dsj_coef(3) * tg_degc
>       dsv(l)  = dsv_coef(1) + dsv_coef(2) * th_degc + dsv_coef(3) * tg_degc
>       jv25(l) = jv25_coef(1) + jv25_coef(2) * th_degc + jv25_coef(3) * tg_degc
>       actj(l) = act_j_tmp(1) + act_j_tmp(2) * th_degc + act_j_tmp(3) * tg_degc
>       actv(l) = act_v_tmp(1) + act_v_tmp(2) * th_degc + act_v_tmp(3) * tg_degc
>     END DO
> !$OMP END PARALLEL DO
> 
>   END SELECT  !  photo_acclim_model
> 
> !$OMP PARALLEL DO IF(veg_pts > 1) DEFAULT(NONE)                                &
> !$OMP PRIVATE(l, m, jmax_numerator, kc_val, ko_val, t_minus_ref, t_term,       &
> !$OMP         vcmax_numerator)                                                 &
> !$OMP SHARED(c3, veg_pts, veg_index, acr, actj, actv, alpha_elec,              &
> !$OMP        ccp, deact_jmax, deact_vcmax, dsj, dsv, ft, i2, jmax_temp, km,    &
> !$OMP        oa, q10_leaf, qtenf_term, tstar, vcmax_temp) SCHEDULE(STATIC)
>   DO m = 1,veg_pts
> 
>     l = veg_index(m)
>     ! Temperature responses of carboxylation, oxygenation,and CO2 compensation
>     ! point, from Bernacchi et al. (2001).
>     t_minus_ref = tstar(l) - t_ref
>     t_term      = t_minus_ref / ( tref_rmol * tstar(l) )
>     ccp(l)      = 4.73078 * EXP( 37830.0 * t_term )
>     ! For the Farquhar model we combine oa, kc and ko into km.
>     kc_val      = 44.8    * EXP( 79430.0 * t_term )
>     ko_val      = 30808.2 * EXP( 36380.0 * t_term )
>     km(l)       = kc_val * ( 1.0 + oa(l) / ko_val )
>     ! Radiation that goes to Photosystem II.
>     i2(l)       = alpha_elec(ft) * acr(l)
> 
>     ! Calculate the temperature response of Vcmax and Jmax, Eq.17 of
>     ! Medlyn et al. (2002).
>     vcmax_numerator = EXP( actv(l) * t_minus_ref                               &
>                            / ( tref_rmol * tstar(l) ) )                        &
>                       * ( 1.0 + EXP( ( t_ref * dsv(l) - deact_vcmax(ft) )      &
>                                      / tref_rmol ) )
>     vcmax_temp(l)   = vcmax_numerator                                          &
>                       / ( 1.0 + EXP( ( tstar(l) * dsv(l) - deact_vcmax(ft) )   &
>                                      / ( tstar(l) * rmol ) ) )
> 
>     jmax_numerator = EXP( actj(l) * t_minus_ref                                &
>                            / ( tref_rmol * tstar(l) ) )                        &
>                       * ( 1.0 + EXP( ( t_ref * dsj(l) - deact_jmax(ft) )       &
>                                      / tref_rmol ) )
>     jmax_temp(l)   = jmax_numerator                                            &
>                      / ( 1.0 + EXP( ( tstar(l) * dsj(l) - deact_jmax(ft) )     &
>                                     / ( tstar(l) * rmol ) ) )
> 
>   END DO
> !$OMP END PARALLEL DO
> END IF  ! pft_photo_model
> 
> SELECT CASE ( pft_photo_model )
> CASE (photo_collatz, photo_farquhar)
>   ! These are valid, so nothing to do.
> CASE DEFAULT
>   errcode = 101  !  a hard error
>   CALL ereport(RoutineName, errcode,                                           &
>                'pft_photo_model should be photo_collatz or photo_farquhar')
> 
> END SELECT  !  pft_photo_model
> 
> !-----------------------------------------------------------------------------
> ! Calculate the temperature-dependent Q10 factor used to calculate dark
> ! respiration.  The Q10 factor is calculated from the mid-point temperature
> ! following Eq 7 of Atkin et al (2005), Response of Plant Respiration to
> ! Changes in Temperature: Mechanisms and Consequences of Variations in Q10
> ! Values and Acclimation, doi:10.1007/1-4020-3589-6_7.  This parameterisation
> ! can be used to simulate a fixed Q10 by setting tdq10_slope=0.0 and
> ! tdq10_int=Q10.
> !-----------------------------------------------------------------------------
> SELECT CASE ( rd_model )
> CASE ( rd_tdq10 )
> !$OMP PARALLEL DO IF(veg_pts > 1) DEFAULT(NONE) PRIVATE(l,m,power,tdq10,t_mid) &
> !$OMP SHARED(qtenf_resp, tdq10_int, tdq10_slope, tstar, veg_index, veg_pts)  &
> !$OMP SCHEDULE(STATIC)
>   DO m  = 1,veg_pts
>     l = veg_index(m)
> 
>     t_mid = 0.5 * (tstar(l) + t_ref) - zerodegc
>     tdq10 = tdq10_slope * t_mid + tdq10_int
>     power = 0.1 * (tstar(l) - t_ref)
>     qtenf_resp(l) = tdq10 ** power
>   END DO
> !$OMP END PARALLEL DO
> END SELECT
> 
> !-----------------------------------------------------------------------------
> ! Calculate fluxes.
> !-----------------------------------------------------------------------------
> 
> SELECT CASE ( can_rad_mod )
> 
> CASE ( 4 )
> 
>   !---------------------------------------------------------------------------
>   ! Varying N model+altered leaf respiration
>   ! Multiple canopy layers
>   ! N varies through canopy as exponential function of layers.
>   !---------------------------------------------------------------------------
> 
>   DO n = 1,ilayers
>     !-------------------------------------------------------------------------
>     ! Initialise GL and calculate the PAR absorbed in this layer.
>     !-------------------------------------------------------------------------
>     expkn = EXP( REAL(n-1) / REAL(ilayers) * (-kn(ft)) )
> !$OMP PARALLEL DO IF(veg_pts > 1) DEFAULT(NONE) PRIVATE(l, m)                  &
> !$OMP             SHARED(dlai, expkn, faparv, faparv_layer, gl, nleaf_layer, n,&
> !$OMP                    nleaf_top, veg_index, veg_pts)                        &
> !$OMP             SCHEDULE(STATIC)
>     DO m = 1,veg_pts
>       l = veg_index(m)
>       gl(l)             = 0.0
>       nleaf_layer(l)    = nleaf_top(l) * expkn
>       faparv_layer(l,n) = faparv(l,n) * dlai(l)
>     END DO
> !$OMP END PARALLEL DO
> 
>     !-------------------------------------------------------------------------
>     ! Calculate photosynthetic parameters.
>     !-------------------------------------------------------------------------
>     CALL calc_photo_parameters( ft, land_pts, pft_photo_model, veg_pts,        &
>                                 veg_index, denom, jmax_temp, jv25,             &
>                                 nleaf_layer, qtenf_term, qtenf_resp,           &
>                                 vcmax_temp, jmax, rd_dark, vcmax,              &
>                                 local_time_rfu, lat_rfu )
> 
>     !-------------------------------------------------------------------------
>     ! Iterate to ensure that the canopy humidity deficit is consistent with
>     ! the H2O flux.
>     !-------------------------------------------------------------------------
> 
>     DO k = 1,iter
>       !-----------------------------------------------------------------------
>       ! Diagnose the canopy-level humidity deficit.
>       ! Initialise dark respiration with the uninhibited rate.
>       !-----------------------------------------------------------------------
> !$OMP PARALLEL IF(veg_pts > 1) DEFAULT(NONE) PRIVATE(l, m)                     &
> !$OMP          SHARED(dq, dqc, gl, ra, ra_rc, rd, rd_dark, veg_index, veg_pts)
> !$OMP DO SCHEDULE(STATIC)
873c1119,1121
<         fpar(l) = (1.0 - EXP(-kpar(ft) * lai(l))) / kpar(ft)
---
>         ra_rc(l) = ra(l) * gl(l)
>         dqc(l)   = dq(l) / (1.0 + ra_rc(l))
>         rd(l)    = rd_dark(l)
875,893c1123,1146
<     !$OMP END DO NOWAIT
<     END IF
<     
<     !-----------------------------------------------------------------------------
<     ! Calculate the PAR absorbed by the top leaf and set top leaf N value.
<     !-----------------------------------------------------------------------------
<     !$OMP DO SCHEDULE(STATIC)
<     DO m  = 1,veg_pts
<       l = veg_index(m)
<       apar(l) = (1.0 - omega(ft)) * ipar(l)
<       acr(l)  = apar(l) / conpar
<       IF ( l_trait_phys ) THEN
<         IF ( ft > nnpft ) THEN
<           lma_tmp = lma_from_prognostics(ft - nnpft, dvi_cpft(l,ft - nnpft))
<           nleaf_top(l) = nmass(ft) * lma_tmp * 1000.0
<             ! gN/gleaf * gleaf/m2 = gN/m2
<         ELSE
<           nleaf_top(l) = nmass(ft) * lma(ft) * 1000.0
<             ! gN/gleaf * gleaf/m2 = gN/m2
---
> !$OMP END DO
> !$OMP END PARALLEL
> 
>       !-----------------------------------------------------------------------
>       ! Calculate the limiting factors for leaf photosynthesis
>       !-----------------------------------------------------------------------
>       CALL leaf_limits (ft, land_pts, pft_photo_model ,veg_pts, veg_index      &
> ,                       acr, apar, ca, ccp, dqc, fsmc, je, kc, km, ko, oa      &
> ,                       pstar, vcmax                                           &
> ,                       clos_pts, open_pts, clos_index, open_index             &
> ,                       ci, wcarb, wexpt, wlite )
> 
> !$OMP PARALLEL DO IF(open_pts > 1) DEFAULT(NONE) PRIVATE(l, m)                 &
> !$OMP             SHARED(acr, apar, faparv, faparv_layer, ipar, land_index,    &
> !$OMP                    n, open_index, open_pts, rd, t_i_length,              &
> !$OMP                    wlite, wlitev, veg_index) SCHEDULE(STATIC)
>       DO m = 1,open_pts
>         l = veg_index(open_index(m))
>         wlitev(l) = wlite(l) / apar(l) * faparv(l,n) * ipar(l)
>         ! Calculate light inhibition of dark respiration.
>         ! This does not change between iterations (though open_index might).
>         IF (acr(l) * 1.0e6 * faparv_layer(l,n) >  10.0) THEN
>           rd(l) = ( 0.5 - 0.05 * LOG(acr(l) * faparv_layer(l,n) * 1.0e6) )     &
>                   * rd(l)
894a1148,1209
>       END DO
> !$OMP END PARALLEL DO
> 
>       !-----------------------------------------------------------------------
>       ! Calculate leaf-level fluxes.
>       !-----------------------------------------------------------------------
>       CALL leaf (clos_pts, ft, land_pts, open_pts, pft_photo_model, veg_pts    &
> ,                clos_index, open_index, veg_index                             &
> ,                ca, ci, fsmc, o3mol, ra, tstar, wcarb, wexpt, wlitev, rd      &
> ,                anetl, flux_o3_l, fo3_l, gl)
> 
>     END DO                 ! K-ITER
> 
>     !-------------------------------------------------------------------------
>     ! Add to canopy-level values.
>     !-------------------------------------------------------------------------
> !$OMP PARALLEL DO IF(veg_pts > 1) DEFAULT(NONE) PRIVATE(l, m)                  &
> !$OMP             SHARED(anetc, anetl, dlai, flux_o3, flux_o3_l, fo3, fo3_l,   &
> !$OMP                    rdmean,ilayers,gc, gl, rd, rdc, veg_index, veg_pts,   &
> !$OMP                    LAI,l_o3_damage                                     ) &
> !$OMP             SCHEDULE(STATIC)
>     DO m = 1,veg_pts
>       l = veg_index(m)
>       anetc(l) = anetc(l) + anetl(l) * dlai(l)
>       gc(l)    = gc(l)    + gl(l) * dlai(l)
>       rdc(l)   = rdc(l)   + rd(l) * dlai(l)
> 
>       rdmean(l) = rdmean(l) + rd(l) / REAL(ilayers)
> 
>       IF (l_o3_damage) THEN
>         flux_o3(l) = flux_o3(l) + flux_o3_l(l) * dlai(l)
>         fo3(l)     = fo3(l) + fo3_l(l) * dlai(l) / lai(l)
>       END IF
>     END DO
> !$OMP END PARALLEL DO
> 
>   END DO                   ! N LAYERS
> 
> 
> CASE ( 5, 6 )
> 
>   !---------------------------------------------------------------------------
>   ! Sunlit and shaded leaves treated separately
>   ! Multiple canopy layers
>   ! N varies through canopy as exponential
>   !---------------------------------------------------------------------------
> 
>   DO n = 1,ilayers
> 
>     !-------------------------------------------------------------------------
>     ! Initialise GL for this layer.
>     ! We could initialise to gl(n-1) here, but simpler to use zero
>     ! and seems to converge pretty quickly anyway.
>     !-------------------------------------------------------------------------
> !$OMP PARALLEL DO IF(veg_pts > 1) DEFAULT(NONE) PRIVATE(l, m)                  &
> !$OMP             SHARED(ft, gl, ilayers, kn, knl, n, nleaf_top, nleaf_layer,  &
> !$OMP   veg_index,dlai,can_rad_mod, veg_pts) SCHEDULE(STATIC)
>     DO m = 1,veg_pts
>       l = veg_index(m)
>       gl(l) = 0.0
>       IF ( can_rad_mod == 6 ) THEN
>         nleaf_layer(l) = nleaf_top(l) * EXP((n-1) * dlai(l) * (-knl(ft)))
896c1211
<         nleaf_top(l) = nl0(ft)
---
>         nleaf_layer(l) = nleaf_top(l) * EXP((n-1) / REAL(ilayers) * (-kn(ft)))
899,945c1214,1235
<     !$OMP END DO NOWAIT
<     
<     !-----------------------------------------------------------------------------
<     ! Calculate incoming PAR (mol photons m-2 s-1).
<     !-----------------------------------------------------------------------------
<     SELECT CASE ( can_rad_mod )
<     CASE ( 5:6 )
<     !$OMP DO SCHEDULE(STATIC)
<       DO m  = 1,veg_pts
<         l = veg_index(m)
<         icr(l) = ipar(l) / conpar
<       END DO
<     !$OMP END DO NOWAIT
<     END SELECT
<     
<     !-----------------------------------------------------------------------------
<     ! Calculate the LAI in each canopy layer.
<     !-----------------------------------------------------------------------------
<     SELECT CASE ( can_rad_mod )
<     CASE ( 4:6 )
<     !$OMP DO SCHEDULE(STATIC)
<       DO m  = 1,veg_pts
<         l = veg_index(m)
<         dlai(l) = lai(l) / REAL(ilayers)
<       END DO
<     !$OMP END DO NOWAIT
<     END SELECT
<     
<     !-----------------------------------------------------------------------------
<     ! Convert O3 concentration from ppb to moles.
<     !-----------------------------------------------------------------------------
<     IF ( l_o3_damage ) THEN
<     !$OMP DO SCHEDULE(STATIC)
<       DO m  = 1,veg_pts
<         l = veg_index(m)
<         o3mol(l) = o3(l) * pstar(l) / (rmol * tstar(l))
<       END DO
<     !$OMP END DO NOWAIT
<     END IF
<     
<     !-----------------------------------------------------------------------------
<     ! Calculate partial pressure of oxygen.
<     !-----------------------------------------------------------------------------
<     IF ( c3(ft) == 1 ) THEN
<       ! Calculate partial pressure of oxygen.
<     !$OMP DO SCHEDULE(STATIC)
<       DO m  = 1,veg_pts
---
> !$OMP END PARALLEL DO
> 
>     !-------------------------------------------------------------------------
>     ! Calculate photosynthetic parameters.
>     !-------------------------------------------------------------------------
>     CALL calc_photo_parameters( ft, land_pts, pft_photo_model, veg_pts,        &
>                                 veg_index, denom, jmax_temp, jv25,             &
>                                 nleaf_layer, qtenf_term, qtenf_resp,           &
>                                 vcmax_temp, jmax, rd_dark, vcmax,              &
>                                 local_time_rfu, lat_rfu )
> 
>     IF ( pft_photo_model == photo_farquhar ) THEN
>       !-----------------------------------------------------------------------
>       ! Calculate sunlit and shaded radiation terms.
>       !-----------------------------------------------------------------------
> !$OMP PARALLEL DO IF(veg_pts > 1)                                              &
> !$OMP DEFAULT(NONE)                                                            &
> !$OMP SHARED(n, veg_pts, veg_index, fapar_sun, fapar_shd, i2_shd, i2_sun,      &
> !$OMP        ipar, sun_term)                                                   &
> !$OMP PRIVATE(l,m)                                                             &
> !$OMP SCHEDULE(STATIC)
>       DO m = 1,veg_pts
947,948c1237,1238
<         ! Convert O2 from mass fraction to partial pressure.
<         oa(l)  = o2 / epo2 * pstar(l)
---
>         i2_sun(l) = sun_term * fapar_sun(l,n) * ipar(l)
>         i2_shd(l) = sun_term * fapar_shd(l,n) * ipar(l)
950,978c1240,1263
<     !$OMP END DO
<     END IF  !  C3
<     
<     !-----------------------------------------------------------------------------
<     ! Convert CO2 from mass fraction to partial pressure.
<     ! We ignore the (small) difference between the canopy- and
<     ! reference-level CO2 concentrations.
<     !-----------------------------------------------------------------------------
<     !$OMP DO SCHEDULE(STATIC)
<     DO m  = 1,veg_pts
<       l = veg_index(m)
<       ca(l) = co2c(l) / epco2 * pstar(l)
<     END DO
<     !$OMP END DO
<     !$OMP END PARALLEL
<     
<     !-----------------------------------------------------------------------------
<     ! Pre-calculate some expensive terms that do not change between iterations
<     ! and layers.
<     ! tstar is for the current pft, so can't be moved up another level.
<     !-----------------------------------------------------------------------------
<     
<     SELECT CASE ( pft_photo_model )
<     CASE ( photo_collatz )
<       ! Use the Collatz model (for C3 or C4 plants).
<     !$OMP PARALLEL DO IF(veg_pts > 1) DEFAULT(NONE) PRIVATE(l,m,power,tau,tdegc)   &
<     !$OMP SHARED(c3, veg_pts, veg_index, ccp, denom, ft, kc, ko, oa, tlow,         &
<     !$OMP        q10_leaf,  qtenf_term, tstar, tupp) SCHEDULE(STATIC)
<       DO m  = 1,veg_pts
---
> !$OMP END PARALLEL DO
> 
>       !-----------------------------------------------------------------------
>       ! Calculate the electron fluxes.
>       ! Although we ultimately only need je_sun and je_shd, we also calculate
>       ! je because we use that to calculate a single value of wlite, from which
>       ! sunlit and shaded terms are calculated using je_sun and je_shd.
>       !-----------------------------------------------------------------------
>       CALL calc_electron_flux( land_pts, veg_pts, veg_index, i2, jmax, je)
>       CALL calc_electron_flux( land_pts, veg_pts, veg_index, i2_sun, jmax,     &
>                                je_sun)
>       CALL calc_electron_flux( land_pts, veg_pts, veg_index, i2_shd, jmax,     &
>                                je_shd)
> 
>       ! Calculate ratios of electron flux terms.
>       ! These are used to scale the light-limited photosynthesis, which is
>       ! linearly related to the electron flux.
> !$OMP PARALLEL DO IF(veg_pts > 1)                                              &
> !$OMP DEFAULT(NONE)                                                            &
> !$OMP SHARED(veg_pts, veg_index, je, je_shd, je_shd_ratio, je_sun,             &
> !$OMP        je_sun_ratio)                                                     &
> !$OMP PRIVATE(l,m)                                                             &
> !$OMP SCHEDULE(STATIC)
>       DO m = 1,veg_pts
980,993c1265,1267
<         tdegc         = tstar(l) - zerodegc
<         power         = 0.1 * (tdegc- 25.0)
<         denom(l)      = (1.0 + EXP (0.3 * (tdegc - tupp(ft)))) *                   &
<                         (1.0 + EXP (0.3 * (tlow(ft) - tdegc)))
<         qtenf_term(l) = q10_leaf(ft)** power
<     
<         IF ( c3(ft) == 1 ) THEN
<           ! Calculate terms that are only needed for C3 plants.
<           ! Although oa, kc and ko are always used together we keep them separate
<           ! to maintain bit comparability.
<           tau(l)   = 2600.0 * (0.57 ** (0.1 * (tdegc - 25.0)))
<           ccp(l) = 0.5 * oa(l) / tau(l)
<           kc(l)  = 30.0    * (2.1 ** power)
<           ko(l)  = 30000.0 * (1.2 ** power)
---
>         IF ( je(l) > TINY(je(l)) ) THEN
>           je_sun_ratio(l) = je_sun(l) / je(l)
>           je_shd_ratio(l) = je_shd(l) / je(l)
995d1268
<     
997,1070c1270,1289
<     !$OMP END PARALLEL DO
<     
<     CASE ( photo_farquhar )
<       ! Use the Farquhar model (for C3 plants).
<       ! Calculate a constant.
<       sun_term = alpha_elec(ft) / conpar
<     
<       ! Load parameter values, depending on options.
<       SELECT CASE ( photo_acclim_model )
<       CASE ( 0 )
<         ! No acclimation.
<         ! Copy the PFT parameters, including fixed J:V.
<     !$OMP PARALLEL DO IF(veg_pts > 1) DEFAULT(NONE) PRIVATE(l,m)                   &
<     !$OMP SHARED(ds_jmax, ds_vcmax, dsj, dsv, ft, jv25, jv25_ratio,                &
<     !$OMP        actj, act_jmax, actv, act_vcmax, veg_index, veg_pts)              &
<     !$OMP SCHEDULE(STATIC)
<         DO m = 1,veg_pts
<           l = veg_index(m)
<           dsj(l)  = ds_jmax(ft)
<           dsv(l)  = ds_vcmax(ft)
<           jv25(l) = jv25_ratio(ft)
<           actj(l) = act_jmax(ft)
<           actv(l) = act_vcmax(ft)
<         END DO
<     !$OMP END PARALLEL DO
<     
<       CASE ( photo_adapt, photo_acclim, photo_adapt_acclim )
<         ! These use the same forms but t_growth_gb will generally be
<         ! different. Although there is no dependency on PFT here (meaning
<         ! this could be moved up and out of a PFT loop), we leave it here
<         ! so that these parameters are calculated here regardless of the
<         ! acclimation model selected.
<     
<         ! Decide whether the activation energies are subject to acclimation.  If
<         ! they are, then the energies vary by gridbox but not by PFT, otherwise
<         ! the energies vary by PFT but not by gridbox.
<         SELECT CASE ( photo_act_model )
<         CASE ( photo_act_pft )
<           act_j_tmp(:) = [act_jmax(ft), 0.0, 0.0]
<           act_v_tmp(:) = [act_vcmax(ft), 0.0, 0.0]
<         CASE ( photo_act_gb )
<           act_j_tmp(:) = act_j_coef(:)
<           act_v_tmp(:) = act_v_coef(:)
<         CASE DEFAULT
<           errcode = 101  !  a hard error
<           CALL ereport(RoutineName, errcode,                                       &
<                        'photo_act_model should be photo_act_pft or photo_act_gb')
<         END SELECT
<     
<     !$OMP PARALLEL DO IF(veg_pts > 1) DEFAULT(NONE) PRIVATE(l,m,th_degc,tg_degc)   &
<     !$OMP SHARED(dsj, dsj_coef, dsv, dsv_coef, jv25, jv25_coef,                    &
<     !$OMP        actj, act_j_tmp, actv, act_v_tmp,                                 &
<     !$OMP        t_home_gb, t_growth_gb, veg_index, veg_pts)                       &
<     !$OMP SCHEDULE(STATIC)
<         DO m = 1,veg_pts
<           l = veg_index(m)
<           th_degc = t_home_gb(l) - zerodegc
<           tg_degc = t_growth_gb(l) - zerodegc
<           dsj(l)  = dsj_coef(1) + dsj_coef(2) * th_degc + dsj_coef(3) * tg_degc
<           dsv(l)  = dsv_coef(1) + dsv_coef(2) * th_degc + dsv_coef(3) * tg_degc
<           jv25(l) = jv25_coef(1) + jv25_coef(2) * th_degc + jv25_coef(3) * tg_degc
<           actj(l) = act_j_tmp(1) + act_j_tmp(2) * th_degc + act_j_tmp(3) * tg_degc
<           actv(l) = act_v_tmp(1) + act_v_tmp(2) * th_degc + act_v_tmp(3) * tg_degc
<         END DO
<     !$OMP END PARALLEL DO
<     
<       END SELECT  !  photo_acclim_model
<     
<     !$OMP PARALLEL DO IF(veg_pts > 1) DEFAULT(NONE)                                &
<     !$OMP PRIVATE(l, m, jmax_numerator, kc_val, ko_val, t_minus_ref, t_term,       &
<     !$OMP         vcmax_numerator)                                                 &
<     !$OMP SHARED(c3, veg_pts, veg_index, acr, actj, actv, alpha_elec,              &
<     !$OMP        ccp, deact_jmax, deact_vcmax, dsj, dsv, ft, i2, jmax_temp, km,    &
<     !$OMP        oa, q10_leaf, qtenf_term, tstar, vcmax_temp) SCHEDULE(STATIC)
---
> !$OMP END PARALLEL DO
> 
>     END IF  !  pft_photo_model
> 
>     !-------------------------------------------------------------------------
>     ! Iterate to ensure that the canopy humidity deficit is consistent with
>     ! the H2O flux.
>     !-------------------------------------------------------------------------
> 
>     DO k = 1,iter
> 
>       !-----------------------------------------------------------------------
>       ! Diagnose the canopy-level humidity deficit.
>       ! Initialise the sunlit and shaded respiration rates with the
>       ! uninhibited, sunlit respiration rate.
>       !-----------------------------------------------------------------------
> !$OMP PARALLEL IF(veg_pts > 1) DEFAULT(NONE) PRIVATE(l, m)                     &
> !$OMP          SHARED(dq, dqc, gl, ra, ra_rc, rd_dark, rd_shd, rd_sun,         &
> !$OMP                 veg_index, veg_pts)
> !$OMP DO SCHEDULE(STATIC)
1072d1290
<     
1074,1103c1292,1295
<         ! Temperature responses of carboxylation, oxygenation,and CO2 compensation
<         ! point, from Bernacchi et al. (2001).
<         t_minus_ref = tstar(l) - t_ref
<         t_term      = t_minus_ref / ( tref_rmol * tstar(l) )
<         ccp(l)      = 4.73078 * EXP( 37830.0 * t_term )
<         ! For the Farquhar model we combine oa, kc and ko into km.
<         kc_val      = 44.8    * EXP( 79430.0 * t_term )
<         ko_val      = 30808.2 * EXP( 36380.0 * t_term )
<         km(l)       = kc_val * ( 1.0 + oa(l) / ko_val )
<         ! Radiation that goes to Photosystem II.
<         i2(l)       = alpha_elec(ft) * acr(l)
<     
<         ! Calculate the temperature response of Vcmax and Jmax, Eq.17 of
<         ! Medlyn et al. (2002).
<         vcmax_numerator = EXP( actv(l) * t_minus_ref                               &
<                                / ( tref_rmol * tstar(l) ) )                        &
<                           * ( 1.0 + EXP( ( t_ref * dsv(l) - deact_vcmax(ft) )      &
<                                          / tref_rmol ) )
<         vcmax_temp(l)   = vcmax_numerator                                          &
<                           / ( 1.0 + EXP( ( tstar(l) * dsv(l) - deact_vcmax(ft) )   &
<                                          / ( tstar(l) * rmol ) ) )
<     
<         jmax_numerator = EXP( actj(l) * t_minus_ref                                &
<                                / ( tref_rmol * tstar(l) ) )                        &
<                           * ( 1.0 + EXP( ( t_ref * dsj(l) - deact_jmax(ft) )       &
<                                          / tref_rmol ) )
<         jmax_temp(l)   = jmax_numerator                                            &
<                          / ( 1.0 + EXP( ( tstar(l) * dsj(l) - deact_jmax(ft) )     &
<                                         / ( tstar(l) * rmol ) ) )
<     
---
>         ra_rc(l)  = ra(l) * gl(l)
>         dqc(l)    = dq(l) / (1.0 + ra_rc(l))
>         rd_sun(l) = rd_dark(l)
>         rd_shd(l) = rd_dark(l)
1105,1231c1297,1321
<     !$OMP END PARALLEL DO
<     CASE (photo_pmodel)
<     CASE DEFAULT
<       errcode = 101  !  a hard error
<       CALL ereport(RoutineName, errcode,                                           &
<              'pft_photo_model should be photo_collatz or photo_farquhar or pmodel')
<     
<     END SELECT  !  pft_photo_model
<     
<     !-----------------------------------------------------------------------------
<     ! Calculate fluxes.
<     !-----------------------------------------------------------------------------
<     
<     SELECT CASE ( can_rad_mod )
<     
<     CASE ( 4 )
<     
<       !---------------------------------------------------------------------------
<       ! Varying N model+altered leaf respiration
<       ! Multiple canopy layers
<       ! N varies through canopy as exponential function of layers.
<       !---------------------------------------------------------------------------
<     
<       DO n = 1,ilayers
<         !-------------------------------------------------------------------------
<         ! Initialise GL and calculate the PAR absorbed in this layer.
<         !-------------------------------------------------------------------------
<         expkn = EXP( REAL(n-1) / REAL(ilayers) * (-kn(ft)) )
<     !$OMP PARALLEL DO IF(veg_pts > 1) DEFAULT(NONE) PRIVATE(l, m)                  &
<     !$OMP             SHARED(dlai, expkn, faparv, faparv_layer, gl, nleaf_layer, n,&
<     !$OMP                    nleaf_top, veg_index, veg_pts)                        &
<     !$OMP             SCHEDULE(STATIC)
<         DO m = 1,veg_pts
<           l = veg_index(m)
<           gl(l)             = 0.0
<           nleaf_layer(l)    = nleaf_top(l) * expkn
<           faparv_layer(l,n) = faparv(l,n) * dlai(l)
<         END DO
<     !$OMP END PARALLEL DO
<     
<         !-------------------------------------------------------------------------
<         ! Calculate photosynthetic parameters.
<         !-------------------------------------------------------------------------
<         CALL calc_photo_parameters( ft, land_pts, pft_photo_model, veg_pts,        &
<                                     veg_index, denom, jmax_temp, jv25,             &
<                                     nleaf_layer, qtenf_term, vcmax_temp,           &
<                                     jmax, rd_dark, vcmax )
<     
<         !-------------------------------------------------------------------------
<         ! Iterate to ensure that the canopy humidity deficit is consistent with
<         ! the H2O flux.
<         !-------------------------------------------------------------------------
<     
<         DO k = 1,iter
<           !-----------------------------------------------------------------------
<           ! Diagnose the canopy-level humidity deficit.
<           ! Initialise dark respiration with the uninhibited rate.
<           !-----------------------------------------------------------------------
<     !$OMP PARALLEL IF(veg_pts > 1) DEFAULT(NONE) PRIVATE(l, m)                     &
<     !$OMP          SHARED(dq, dqc, gl, ra, ra_rc, rd, rd_dark, veg_index, veg_pts)
<     !$OMP DO SCHEDULE(STATIC)
<           DO m = 1,veg_pts
<             l = veg_index(m)
<             ra_rc(l) = ra(l) * gl(l)
<             dqc(l)   = dq(l) / (1.0 + ra_rc(l))
<             rd(l)    = rd_dark(l)
<           END DO
<     !$OMP END DO
<     !$OMP END PARALLEL
<     
<           !-----------------------------------------------------------------------
<           ! Calculate the limiting factors for leaf photosynthesis
<           !-----------------------------------------------------------------------
<           CALL leaf_limits (ft, land_pts, pft_photo_model ,veg_pts, veg_index      &
<     ,                       acr, apar, ca, ccp, dqc, fsmc, je, kc, km, ko, oa      &
<     ,                       pstar, vcmax                                           &
<     ,                       clos_pts, open_pts, clos_index, open_index             &
<     ,                       ci,wcarb, wexpt, wlite )
<     
<     !$OMP PARALLEL DO IF(open_pts > 1) DEFAULT(NONE) PRIVATE(l, m)                 &
<     !$OMP             SHARED(acr, apar, faparv, faparv_layer, ipar, land_index,    &
<     !$OMP                    n, open_index, open_pts, rd, t_i_length,              &
<     !$OMP                    wlite, wlitev, veg_index) SCHEDULE(STATIC)
<           DO m = 1,open_pts
<             l = veg_index(open_index(m))
<             wlitev(l) = wlite(l) / apar(l) * faparv(l,n) * ipar(l)
<             ! Calculate light inhibition of dark respiration.
<             ! This does not change between iterations (though open_index might).
<             IF (acr(l) * 1.0e6 * faparv_layer(l,n) >  10.0) THEN
<               rd(l) = ( 0.5 - 0.05 * LOG(acr(l) * faparv_layer(l,n) * 1.0e6) )     &
<                       * rd(l)
<             END IF
<           END DO
<     !$OMP END PARALLEL DO
<     
<           !-----------------------------------------------------------------------
<           ! Calculate leaf-level fluxes.
<           !-----------------------------------------------------------------------
<           CALL leaf (clos_pts, ft, land_pts, open_pts, pft_photo_model, veg_pts    &
<     ,                clos_index, open_index, veg_index, icr, fpar, pstar           &
<     ,                t1,t_growth_gb,vpd,vpd_growth_gb,l_growth_gb, co2_growth_gb   &
<     ,                pstar_growth_gb,xipam_opt,vcmax_opt,jmax_opt                  &
<     ,                ca, cim,ci,fsmc, o3mol, ra, tstar, wcarb, wexpt, wlitev, rd      &
<     ,                anetl, flux_o3_l, fo3_l, gl)
<     
<         END DO                 ! K-ITER
<     
<         !-------------------------------------------------------------------------
<         ! Add to canopy-level values.
<         !-------------------------------------------------------------------------
<     !$OMP PARALLEL DO IF(veg_pts > 1) DEFAULT(NONE) PRIVATE(l, m)                  &
<     !$OMP             SHARED(anetc, anetl, dlai, flux_o3, flux_o3_l, fo3, fo3_l,   &
<     !$OMP                    rdmean,ilayers,gc, gl, rd, rdc, veg_index, veg_pts,   &
<     !$OMP                    LAI,l_o3_damage                                     ) &
<     !$OMP             SCHEDULE(STATIC)
<         DO m = 1,veg_pts
<           l = veg_index(m)
<           anetc(l) = anetc(l) + anetl(l) * dlai(l)
<           gc(l)    = gc(l)    + gl(l) * dlai(l)
<           rdc(l)   = rdc(l)   + rd(l) * dlai(l)
<     
<           rdmean(l) = rdmean(l) + rd(l) / REAL(ilayers)
<     
<           IF (l_o3_damage) THEN
<             flux_o3(l) = flux_o3(l) + flux_o3_l(l) * dlai(l)
<             fo3(l)     = fo3(l) + fo3_l(l) * dlai(l) / lai(l)
<           END IF
---
> !$OMP END DO
> !$OMP END PARALLEL
> 
>       !-----------------------------------------------------------------------
>       ! Calculate the limiting factors for leaf photosynthesis
>       !-----------------------------------------------------------------------
>       CALL leaf_limits (ft, land_pts, pft_photo_model, veg_pts, veg_index      &
> ,                       acr, apar, ca, ccp, dqc, fsmc, je, kc, km, ko, oa      &
> ,                       pstar, vcmax                                           &
> ,                       clos_pts, open_pts, clos_index, open_index             &
> ,                       ci, wcarb, wexpt, wlite)
> 
> !$OMP PARALLEL IF(veg_pts > 1)                                                 &
> !$OMP DEFAULT(NONE)                                                            &
> !$OMP PRIVATE(m,l)                                                             &
> !$OMP SHARED(veg_pts,veg_index,rd_sun,rd_shd,rd,open_pts,pft_photo_model,      &
> !$OMP        open_index,wlitev_sun,wlite,apar,fapar_sun,ipar,je_shd_ratio,     &
> !$OMP        je_sun_ratio,wlitev_shd,fapar_shd,icr,n,fsun,dlai)
> 
>       IF ( pft_photo_model == photo_collatz ) THEN
> !$OMP DO SCHEDULE(STATIC)
>         DO m = 1,open_pts
>           l = veg_index(open_index(m))
>           wlitev_sun(l) = wlite(l) / apar(l) * fapar_sun(l,n) * ipar(l)
>           wlitev_shd(l) = wlite(l) / apar(l) * fapar_shd(l,n) * ipar(l)
1233,1263c1323,1329
<     !$OMP END PARALLEL DO
<     
<       END DO                   ! N LAYERS
<     
<     
<     CASE ( 5, 6 )
<     
<       !---------------------------------------------------------------------------
<       ! Sunlit and shaded leaves treated separately
<       ! Multiple canopy layers
<       ! N varies through canopy as exponential
<       !---------------------------------------------------------------------------
<     
<       DO n = 1,ilayers
<     
<         !-------------------------------------------------------------------------
<         ! Initialise GL for this layer.
<         ! We could initialise to gl(n-1) here, but simpler to use zero
<         ! and seems to converge pretty quickly anyway.
<         !-------------------------------------------------------------------------
<     !$OMP PARALLEL DO IF(veg_pts > 1) DEFAULT(NONE) PRIVATE(l, m)                  &
<     !$OMP             SHARED(ft, gl, ilayers, kn, knl, n, nleaf_top, nleaf_layer,  &
<     !$OMP   veg_index,dlai,can_rad_mod, veg_pts) SCHEDULE(STATIC)
<         DO m = 1,veg_pts
<           l = veg_index(m)
<           gl(l) = 0.0
<           IF ( can_rad_mod == 6 ) THEN
<             nleaf_layer(l) = nleaf_top(l) * EXP((n-1) * dlai(l) * (-knl(ft)))
<           ELSE
<             nleaf_layer(l) = nleaf_top(l) * EXP((n-1) / REAL(ilayers) * (-kn(ft)))
<           END IF
---
> !$OMP END DO NOWAIT
>       ELSE
> !$OMP DO SCHEDULE(STATIC)
>         DO m = 1,open_pts
>           l = veg_index(open_index(m))
>           wlitev_sun(l) = wlite(l) * je_sun_ratio(l)
>           wlitev_shd(l) = wlite(l) * je_shd_ratio(l)
1265,1430c1331,1332
<     !$OMP END PARALLEL DO
<     
<         !-------------------------------------------------------------------------
<         ! Calculate photosynthetic parameters.
<         !-------------------------------------------------------------------------
<         CALL calc_photo_parameters( ft, land_pts, pft_photo_model, veg_pts,        &
<                                     veg_index, denom, jmax_temp, jv25,             &
<                                     nleaf_layer, qtenf_term, vcmax_temp,           &
<                                     jmax, rd_dark, vcmax )
<     
<         IF ( pft_photo_model == photo_farquhar ) THEN
<           !-----------------------------------------------------------------------
<           ! Calculate sunlit and shaded radiation terms.
<           !-----------------------------------------------------------------------
<     !$OMP PARALLEL DO IF(veg_pts > 1)                                              &
<     !$OMP DEFAULT(NONE)                                                            &
<     !$OMP SHARED(n, veg_pts, veg_index, fapar_sun, fapar_shd, i2_shd, i2_sun,      &
<     !$OMP        ipar, sun_term)                                                   &
<     !$OMP PRIVATE(l,m)                                                             &
<     !$OMP SCHEDULE(STATIC)
<           DO m = 1,veg_pts
<             l = veg_index(m)
<             i2_sun(l) = sun_term * fapar_sun(l,n) * ipar(l)
<             i2_shd(l) = sun_term * fapar_shd(l,n) * ipar(l)
<           END DO
<     !$OMP END PARALLEL DO
<     
<           !-----------------------------------------------------------------------
<           ! Calculate the electron fluxes.
<           ! Although we ultimately only need je_sun and je_shd, we also calculate
<           ! je because we use that to calculate a single value of wlite, from which
<           ! sunlit and shaded terms are calculated using je_sun and je_shd.
<           !-----------------------------------------------------------------------
<           CALL calc_electron_flux( land_pts, veg_pts, veg_index, i2, jmax, je)
<           CALL calc_electron_flux( land_pts, veg_pts, veg_index, i2_sun, jmax,     &
<                                    je_sun)
<           CALL calc_electron_flux( land_pts, veg_pts, veg_index, i2_shd, jmax,     &
<                                    je_shd)
<     
<           ! Calculate ratios of electron flux terms.
<           ! These are used to scale the light-limited photosynthesis, which is
<           ! linearly related to the electron flux.
<     !$OMP PARALLEL DO IF(veg_pts > 1)                                              &
<     !$OMP DEFAULT(NONE)                                                            &
<     !$OMP SHARED(veg_pts, veg_index, je, je_shd, je_shd_ratio, je_sun,             &
<     !$OMP        je_sun_ratio)                                                     &
<     !$OMP PRIVATE(l,m)                                                             &
<     !$OMP SCHEDULE(STATIC)
<           DO m = 1,veg_pts
<             l = veg_index(m)
<             IF ( je(l) > TINY(je(l)) ) THEN
<               je_sun_ratio(l) = je_sun(l) / je(l)
<               je_shd_ratio(l) = je_shd(l) / je(l)
<             END IF
<           END DO
<     !$OMP END PARALLEL DO
<     
<         END IF  !  pft_photo_model
<     
<         !-------------------------------------------------------------------------
<         ! Iterate to ensure that the canopy humidity deficit is consistent with
<         ! the H2O flux.
<         !-------------------------------------------------------------------------
<     
<         DO k = 1,iter
<     
<           !-----------------------------------------------------------------------
<           ! Diagnose the canopy-level humidity deficit.
<           ! Initialise the sunlit and shaded respiration rates with the
<           ! uninhibited, sunlit respiration rate.
<           !-----------------------------------------------------------------------
<     !$OMP PARALLEL IF(veg_pts > 1) DEFAULT(NONE) PRIVATE(l, m)                     &
<     !$OMP          SHARED(dq, dqc, gl, ra, ra_rc, rd_dark, rd_shd, rd_sun,         &
<     !$OMP                 veg_index, veg_pts)
<     !$OMP DO SCHEDULE(STATIC)
<           DO m = 1,veg_pts
<             l = veg_index(m)
<             ra_rc(l)  = ra(l) * gl(l)
<             dqc(l)    = dq(l) / (1.0 + ra_rc(l))
<             rd_sun(l) = rd_dark(l)
<             rd_shd(l) = rd_dark(l)
<           END DO
<     !$OMP END DO
<     !$OMP END PARALLEL
<     
<           !-----------------------------------------------------------------------
<           ! Calculate the limiting factors for leaf photosynthesis
<           !-----------------------------------------------------------------------
<           CALL leaf_limits (ft, land_pts, pft_photo_model, veg_pts, veg_index      &
<     ,                       acr, apar, ca, ccp, dqc, fsmc, je, kc, km, ko, oa      &
<     ,                       pstar, vcmax                                           &
<     ,                       clos_pts, open_pts, clos_index, open_index             &
<     ,                       ci, wcarb, wexpt, wlite)
<     
<     !$OMP PARALLEL IF(veg_pts > 1)                                                 &
<     !$OMP DEFAULT(NONE)                                                            &
<     !$OMP PRIVATE(m,l)                                                             &
<     !$OMP SHARED(veg_pts,veg_index,rd_sun,rd_shd,rd,open_pts,pft_photo_model,      &
<     !$OMP        open_index,wlitev_sun,wlite,apar,fapar_sun,ipar,je_shd_ratio,     &
<     !$OMP        je_sun_ratio,wlitev_shd,fapar_shd,icr,n,fsun,dlai)
<     
<           IF ( pft_photo_model == photo_collatz ) THEN
<     !$OMP DO SCHEDULE(STATIC)
<             DO m = 1,open_pts
<               l = veg_index(open_index(m))
<               wlitev_sun(l) = wlite(l) / apar(l) * fapar_sun(l,n) * ipar(l)
<               wlitev_shd(l) = wlite(l) / apar(l) * fapar_shd(l,n) * ipar(l)
<               wlite_lay(l,n) =  wlitev_sun(l) * fsun(l,n)                   &
<                                      + wlitev_shd(l) * (1.0 - fsun(l,n))
<              !PCM: Calculate APAR per layer for output:
<               apar_lay(l,n)=(fapar_shd(l,n)+fapar_shd(l,n))*ipar(l)*dlai(l)
<                       !This is taken from leaf_limits:
<               cmpf_lay(l,n)=(ci(l) - ccp(l)) / (ci(l) + 2.0 * ccp(l))
<               !write (*,*) "####", l, n, cmpf_lay(l,n)
<               vcmax_lay(l,n) = vcmax(l)
<               !write (*,*) "####", l, n, vcmax_lay(l,n)     
<               vcmax25_lay(l,n) = 0
<               wcarb_lay(l,n) = 0
<               ej_lay(l,n)=0
<             END DO
<     !$OMP END DO NOWAIT
<           ELSE
<     !$OMP DO SCHEDULE(STATIC)
<             DO m = 1,open_pts
<               l = veg_index(open_index(m))
<               wlitev_sun(l) = wlite(l) * je_sun_ratio(l)
<               wlitev_shd(l) = wlite(l) * je_shd_ratio(l)
<             END DO
<     !$OMP END DO NOWAIT
<           END IF  !  photo_model
<     
<           !-----------------------------------------------------------------------
<           ! Introducing inhibition of leaf respiration in the light for sunlit
<           ! and shaded leaves, from papers by Atkin et al. This is an
<           ! improvement over the description used for can_rad_mod=4.
<           ! This does not change between iterations (though open_index might).
<           !-----------------------------------------------------------------------
<     !$OMP DO SCHEDULE(STATIC)
<           DO m = 1,open_pts
<             l = veg_index(open_index(m))
<             IF ( fapar_sun(l,n) * icr(l) * fsun(l,n) * dlai(l) *                   &
<                  1.0e6 >  10.0 ) rd_sun(l) = 0.7 * rd_sun(l)
<             IF ( fapar_shd(l,n) * icr(l) * (1.0 - fsun(l,n)) * dlai(l) *           &
<                  1.0e6 >  10.0 ) rd_shd(l) = 0.7 * rd_shd(l)
<           END DO
<     !$OMP END DO
<     !$OMP END PARALLEL
<     
<           !-----------------------------------------------------------------------
<           ! Calculate leaf-level fluxes separately for sunlit and shaded leaves.
<           !-----------------------------------------------------------------------
<           CALL leaf (clos_pts, ft, land_pts, open_pts, pft_photo_model, veg_pts    &
<     ,                clos_index, open_index, veg_index, icr, fpar, pstar           &
<     ,                t1,t_growth_gb,vpd,vpd_growth_gb,l_growth_gb, co2_growth_gb   &
<     ,                pstar_growth_gb,xipam_opt,vcmax_opt,jmax_opt                  &
<     ,                ca,cim,ci,fsmc, o3mol, ra, tstar                                &
<     ,                wcarb, wexpt, wlitev_sun, rd_sun                              &
<     ,                anetl_sun, flux_o3_l_sun, fo3_l_sun, gl_sun)
<     
<           CALL leaf (clos_pts, ft, land_pts, open_pts, pft_photo_model, veg_pts    &
<     ,                clos_index, open_index, veg_index, icr, fpar, pstar           &
<     ,                t1,t_growth_gb,vpd,vpd_growth_gb,l_growth_gb, co2_growth_gb   &
<     ,                pstar_growth_gb,xipam_opt,vcmax_opt,jmax_opt                  &
<     ,                ca,cim,ci,fsmc, o3mol, ra, tstar                                &
<     ,                wcarb, wexpt, wlitev_shd, rd_shd                              &
<     ,                anetl_shd, flux_o3_l_shd, fo3_l_shd, gl_shd)
---
> !$OMP END DO NOWAIT
>       END IF  !  photo_model
1432c1334,1341
<      DO m = 1,open_pts
---
>       !-----------------------------------------------------------------------
>       ! Introducing inhibition of leaf respiration in the light for sunlit
>       ! and shaded leaves, from papers by Atkin et al. This is an
>       ! improvement over the description used for can_rad_mod=4.
>       ! This does not change between iterations (though open_index might).
>       !-----------------------------------------------------------------------
> !$OMP DO SCHEDULE(STATIC)
>       DO m = 1,open_pts
1434c1343,1346
<         wmin_lay(l,n) = 0
---
>         IF ( fapar_sun(l,n) * icr(l) * fsun(l,n) * dlai(l) *                   &
>              1.0e6 >  10.0 ) rd_sun(l) = 0.7 * rd_sun(l)
>         IF ( fapar_shd(l,n) * icr(l) * (1.0 - fsun(l,n)) * dlai(l) *           &
>              1.0e6 >  10.0 ) rd_shd(l) = 0.7 * rd_shd(l)
1436,1473c1348,1349
<     
<           !-----------------------------------------------------------------------
<           ! Update layer conductance.
<           !-----------------------------------------------------------------------
<     !$OMP PARALLEL DO                                                              &
<     !$OMP SCHEDULE(STATIC)                                                         &
<     !$OMP DEFAULT(NONE)                                                            &
<     !$OMP PRIVATE(m,l)                                                             &
<     !$OMP SHARED(veg_pts,veg_index,gl,fsun,n,gl_sun,gl_shd,rd,rd_sun,rd_shd)
<           DO m = 1,veg_pts
<             l = veg_index(m)
<             gl(l) = fsun(l,n) * gl_sun(l) + (1.0 - fsun(l,n)) * gl_shd(l)
<             rd(l) = fsun(l,n) * rd_sun(l) + (1.0 - fsun(l,n)) * rd_shd(l)
<           END DO
<     !$OMP END PARALLEL DO
<     
<         END DO                 ! K-ITER
<     
<         !-------------------------------------------------------------------------
<         ! Add to canopy-level values.
<         !-------------------------------------------------------------------------
<     !$OMP PARALLEL DO                                                              &
<     !$OMP SCHEDULE(STATIC)                                                         &
<     !$OMP DEFAULT(NONE)                                                            &
<     !$OMP PRIVATE(m,l)                                                             &
<     !$OMP SHARED(veg_pts,veg_index,anetl,fsun,anetl_sun,anetl_shd,anetc,dlai,gc,   &
<     !$OMP        gl,rdc,rd,rdmean,ilayers,l_o3_damage,flux_o3_l,flux_o3_l_sun,     &
<     !$OMP        flux_o3_l_shd,fo3_l_sun,fo3_l_shd,flux_o3,fo3,lai,n,fo3_l)
<         DO m = 1,veg_pts
<           l = veg_index(m)
<           ! Don't multiply by dlai(l) here, since wlite already has been multiplied by this
<           anetl(l)     = fsun(l,n) * anetl_sun(l) + (1.0 - fsun(l,n)) * anetl_shd(l)
<           gpp_lay(l,n) = anetl(l) + rd(l) * fsmc(l)
<           gpp_lay(l,n) = gpp_lay(l,n) * cconu
<           anetc(l)     = anetc(l) + anetl(l) * dlai(l)
<           !print*,'anetl',anetl
<           !print*,fsun(l,n) * anetl_sun(l) 
<           !print*,(1.0 - fsun(l,n)) * anetl_shd(l)
---
> !$OMP END DO
> !$OMP END PARALLEL
1475,1515c1351,1358
<           gc(l)        = gc(l)  + gl(l) * dlai(l)
<           rdc(l)       = rdc(l) + rd(l) * dlai(l)
<     
<           rdmean(l)    = rdmean(l) + rd(l) / REAL(ilayers)
<     
<           IF (l_o3_damage) THEN
<             flux_o3_l(l) = fsun(l,n) * flux_o3_l_sun(l)                            &
<                            + (1.0 - fsun(l,n)) * flux_o3_l_shd(l)
<             fo3_l(l)     = fsun(l,n) * fo3_l_sun(l)                                &
<                            + (1.0 - fsun(l,n)) * fo3_l_shd(l)
<     
<             flux_o3(l)   = flux_o3(l) + flux_o3_l(l) * dlai(l)
<             fo3(l)       = fo3(l)     + fo3_l(l) * dlai(l) / lai(l)
<           END IF
<         END DO
<     !$OMP END PARALLEL DO
<     
<       END DO                   ! N LAYERS
<     
<     CASE ( 1 )
<     
<       !---------------------------------------------------------------------------
<       ! "Big leaf" model.
<       ! N varies through canopy according to Beers Law
<       !---------------------------------------------------------------------------
<     
<       !---------------------------------------------------------------------------
<       ! Calculate photosynthetic parameters.
<       ! There is no light limitation of dark respiration in this case.
<       !---------------------------------------------------------------------------
<       CALL calc_photo_parameters( ft, land_pts, pft_photo_model, veg_pts,          &
<                                   veg_index, denom, jmax_temp, jv25,               &
<                                   nleaf_top, qtenf_term, vcmax_temp,               &
<                                   jmax, rd, vcmax )
<     
<       IF ( pft_photo_model == photo_farquhar ) THEN
<         ! Calculate the electron flux.
<         CALL calc_electron_flux( land_pts, veg_pts, veg_index, i2, jmax, je)
<       END IF
<     current_time_pmodel = current_time%time
<     PRINT *, 'T =', REAL(current_time_pmodel, kind=8)
---
>       !-----------------------------------------------------------------------
>       ! Calculate leaf-level fluxes separately for sunlit and shaded leaves.
>       !-----------------------------------------------------------------------
>       CALL leaf (clos_pts, ft, land_pts, open_pts, pft_photo_model, veg_pts    &
> ,                clos_index, open_index, veg_index                             &
> ,                ca, ci, fsmc, o3mol, ra, tstar                                &
> ,                wcarb, wexpt, wlitev_sun, rd_sun                              &
> ,                anetl_sun, flux_o3_l_sun, fo3_l_sun, gl_sun)
1517,1723c1360,1373
<     !---------------------------------------------------------------------------------
<     !calculate 15-day acclimated  jmax,vcmax,xipam
<     !---------------------------------------------------------------------------------
<       IF (current_time_pmodel == 45000.0) THEN 
<       !print*,ft
<       DO m = 1,veg_pts    
<             l = veg_index(m)
<               !print*,'tn', t_growth_gb(l)
<        ! print *,'ln', l_growth_gb(l)
<        ! print *,'vn', vpd_growth_gb(l)
<        ! print *,'cn', co2_growth_gb(l)
<         !print*, 'pn',pstar_growth_gb(l)
<         tgdegc(l) = t_growth_gb(l) - zerodegc
<           !print *,'tg',tgdegc(l)
<        ! print*,'rn'
<        !------------------------------------------------------------------------------
<        !Calculate Vcmax, Jmax and xim at optimal condition 
<        !------------------------------------------------------------------------------
<         !--------------------------------------------------------------------------
<         ! Compute K at optimal condition(effective Michaelis-Menten coefficient)
<         !--------------------------------------------------------------------------
<         ! O2 partial pressure [Pa]
<         O2_partial_pres(l) = 2.09476E5 * 1.0E-6 * pstar_growth_gb(l) !optimal condition
<         ! Effective Michaelis-Menten coefficient Kc and ko in pascal
<         kcpa(l) = kc25(ft) * exp(eakc(ft)*(tgdegc(l) - 25.0)                      &
<                                                 /(298.15*8.3145* t_growth_gb(l)))
<         kopa(l) = ko25(ft) * exp(eako(ft)*(tgdegc(l) - 25.0)                      &
<                                                 /(298.15*8.3145* t_growth_gb(l)))
<         ! Compute Kmpa in Pascal 
<         kmpa(l) = kcpa(l) * (1.0 + O2_partial_pres(l)/kopa(l))
<         !print*, '1',kmpa(l)
<         !--------------------------------------------------------------------------
<         ! Adjust gammaStar25 for the pressure at optimal surface pressure optimal
<         !--------------------------------------------------------------------------
<         pratio(l) = pstar_growth_gb(l)/ 101325.0 !optimal condition
<         !--------------------------------------------------------------------------
<         ! Compute CO2 compensation point at optimal surface pressure (optimal)
<         !--------------------------------------------------------------------------
<         ! Adjust gammaStar25 for the pressure at given surface pressure
<         gammastar25(l) = gamma25(ft) * pratio(l)
<     
<         ! Pressure-dependent photorespiratory compensation point
<         gammastarm_opt(l) = gammastar25(l) * exp(eagamma(ft) *(tgdegc(l) - 25.0)   &
<                                          /(8.3145 * 298.15 *  t_growth_gb(l)))
<         !print*, '2',gammastarm_opt(l)
<         !--------------------------------------------------------------------------
<         ! Compute water viscosity optimal
<         !--------------------------------------------------------------------------
<         viscosityh2ostar(l) = (exp(-3.719 + 580 /((tgdegc(l) + 273) - 138.0)))/    &
<                                    0.9102827622
<         !print *, '3', viscosityh2ostar(l)
<         !--------------------------------------------------------------------------
<         ! Compute sensitivity of ci/ca ratio to VPD (xi)
<         !--------------------------------------------------------------------------
<         xipam(l) = sqrt((beta_c3c4(ft) * (kmpa(l)+gammastarm_opt(l)))               &
<                         / (1.6*viscosityh2ostar(l)))
<         !print*,'cx',xipam(l)
<         xipam_opt(l) = 0.067*xipam(l) + 0.933*xipam_opt(l) 
<         !print *, '4', xipam_opt(l)
<         !--------------------------------------------------------------------------
<         ! Compute acclimated Leaf-internal CO2 partial pressure (Pa)
<         ! acclimated cim
<         !--------------------------------------------------------------------------
<         cim_opt(l)=(xipam_opt(l)*co2_growth_gb(l) + gammastarm_opt(l)              &
<                          *sqrt(vpd_growth_gb(l))) /                                &
<                          (xipam_opt(l) + sqrt(vpd_growth_gb(l)))
<         !print*,'ci_on',cim_opt(l)
<         !--------------------------------------------------------------------------
<         ! calculate maximum rate of carboxylation at optimal condition (vcmax)
<         !--------------------------------------------------------------------------
<         IF (c3(ft) ==1 ) THEN
<         !--------------------------------------------------------------------------
<         ! calcaulate intrinsic quantum efficiency of photosynthesis 
<         ! phi0 is temperature dependent (phi0, mol Co2/mol photons)
<         ! (ref: Bernacchi et al., 2003)
<         !--------------------------------------------------------------------------
<         phi0(l) = (1.0/8.0) * (0.352 + 0.022 * tgdegc(l) -                       &
<                0.00034 * tgdegc(l) ** 2)
<         IF ((1-(0.41*(cim_opt(l)+2*gammastarm_opt(l))/                           &
<         (cim_opt(l)-gammastarm_opt(l)))**(2.0/3))<0) THEN
<         vcmax_pmodel(l) = phi0(l) * l_growth_gb(l) * sqrt(1 - 0.41**(2.0/3.0))
<         jmax_pmodel(l)=(4.0*phi0(l)*l_growth_gb(l))/SQRT(1/(1-0.41**(2.0/3.0))-1.0)
<         ELSE
<         !--------------------------------------------------------------------------
<         ! calculate vcmax at optimal condition
<         ! [molco2 m-2 s-1] optimal kmpa,gammastarm
<         ! compute maximum rate of electron transport (ref: Wang et al., 2017)
<         ! [mol electrons m2-1 s-1]
<         !--------------------------------------------------------------------------
<         vcmax_pmodel(l) = phi0(l) * l_growth_gb(l) * (cim_opt(l) + kmpa(l))/     &
<                     (cim_opt(l) + 2.0 * gammastarm_opt(l)) *                     &
<         sqrt(1.0 - (0.41 * (cim_opt(l)+ 2.0 * gammastarm_opt(l))                 & 
<                 / (cim_opt(l) - gammastarm_opt(l))) ** (2.0/3.0))
<         
<         jmax_pmodel(l) =( 4 * phi0(l) * l_growth_gb(l) ) / sqrt (                 &
<                 1/(1-(0.41 * ( cim_opt(l) + 2*gammastarm_opt(l) ) /               &
<                   ( cim_opt(l) - gammastarm_opt(l) ) ) ** (2.0/3.0) ) - 1 )
<         END IF
<         !print*,'c3j',jmax_pmodel
<        ! print*,'c3v',vcmax_pmodel
<         ELSE !for c4 plants
<         !--------------------------------------------------------------------------
<         ! calcaulate intrinsic quantum efficiency of photosynthesis 
<         ! phi0 is temperature dependent (phi0, mol Co2/mol photons)
<         ! (ref: Bernacchi et al., 2003)
<         !--------------------------------------------------------------------------
<         phi0(l) = (-0.008 + 0.00375 * tgdegc(l) - 0.58 * 1e-4 * tgdegc(l) ** 2)
<         !--------------------------------------------------------------------------
<         ! calculate vcmax at optimal condition
<         ! [molco2 m-2 s-1] optimal kmpa,gammastarm
<         ! compute maximum rate of electron transport (ref: Wang et al., 2017)
<         ! [mol electrons m2-1 s-1]
<         !--------------------------------------------------------------------------
<         vcmax_pmodel(l) = phi0(l) * l_growth_gb(l) * sqrt(1 - 0.41**(2.0/3.0))
<         jmax_pmodel(l) =( 4 * phi0(l) * l_growth_gb(l) )/                         &
<                                           SQRT(1/(1-0.41**(2.0/3.0))-1.0)
<        ! print*,'c4'
<         END IF
<         !print *, 'phi0o', phi0(l)
<         vcmax_pmodel(l) = max(0.0,vcmax_pmodel(l))
<         vcmax25_opt(l)=vcmax_pmodel(l)*exp((ha/rgas)*(1/t_growth_gb(l)-1/298.15))
<         !print*,'vob',   vcmax_opt(l)
<         vcmax_opt(l) = 0.067 * vcmax25_opt(l) + 0.933 * vcmax_opt(l)
<         !print*,'vcp',vcmax_pmodel(l)
<         !print *, 'vo25',vcmax25_opt(l)
<         !print*,'jn'
<         jmax_pmodel(l)=MAX(0.0, jmax_pmodel(l))
<         jmax25_opt(l)=jmax_pmodel(l)* EXP((haj/rgas)* (1/t_growth_gb(l)-1/298.15))
<         jmax_opt(l) = 0.067 * jmax25_opt(l) + 0.933 * jmax_opt(l)
<         !print*, 'jcp',jmax_pmodel(l)
<         !print *, 'jo25',jmax25_opt(l)
<     END DO
<     
<     ELSE
<     
<     DO m = 1,veg_pts
<        l = veg_index(m) 
<        tgdegc(l) = t_growth_gb(l) - zerodegc
<        t_growth_gb(l) = t_growth_gb(l)
<        l_growth_gb(l) = l_growth_gb(l)
<        vcmax_opt(l) = vcmax_opt(l)
<        xipam_opt(l) = xipam_opt(l)
<        jmax_opt(l) = jmax_opt(l)
<     END DO
<     END IF
<     
<       !---------------------------------------------------------------------------
<       !calculate vpd,fpar for current timestep (pmodel)
<       !---------------------------------------------------------------------------
<        DO m = 1,veg_pts
<        l = veg_index(m) 
<        !print*, ft
<        vpd(l) = 610.8 * EXP(17.27 * (t1(l)-273.15) / ((t1(l)-273.15) + 237.3)) &
<                     -(q1(l)* pstar(l))/(0.622 + q1(l)*0.378) 
<         IF (vpd(l) <0)THEN
<            vpd(l) = 0.0
<         END IF 
<        icr(l) = ipar(l) *2.0 * 2.04
<        fpar(l) = (1.0 - EXP(-0.5 * lai(l)))
<       END DO
<       !---------------------------------------------------------------------------
<       ! Iterate to ensure that the canopy humidity deficit is consistent with the
<       ! H2O flux. The first estimate of the canopy humidity deficit uses the
<       ! stomatal conductance from the previous timestep.
<       !---------------------------------------------------------------------------
<       DO k = 1,iter
<     
<         !-------------------------------------------------------------------------
<         ! Diagnose the canopy-level humidity deficit.
<         !-------------------------------------------------------------------------
<         DO m = 1,veg_pts
<           l = veg_index(m)
<           ra_rc(l) = ra(l) * gc(l)
<           dqc(l)   = dq(l) / (1.0 + ra_rc(l))
<         END DO
<     
<         !-------------------------------------------------------------------------
<         ! Calculate the limiting factors for leaf photosynthesis.
<         !-------------------------------------------------------------------------
<         CALL leaf_limits (ft, land_pts, pft_photo_model, veg_pts, veg_index        &
<     ,                     acr, apar, ca, ccp, dqc, fsmc, je, kc, km, ko, oa        &
<     ,                     pstar, vcmax                                             &
<     ,                     clos_pts, open_pts, clos_index, open_index               &
<     ,                     ci, wcarb, wexpt, wlite)
<     
<         !-------------------------------------------------------------------------
<         ! Calculate leaf-level fluxes.
<         !-------------------------------------------------------------------------
<         CALL leaf (clos_pts, ft, land_pts, open_pts, pft_photo_model, veg_pts      &
<     ,                clos_index ,open_index, veg_index, icr, fpar, pstar           &
<     ,                t1,t_growth_gb,vpd,vpd_growth_gb,l_growth_gb, co2_growth_gb   &
<     ,                pstar_growth_gb,xipam_opt,vcmax_opt,jmax_opt                  &
<     ,                ca,cim,ci,fsmc, o3mol, ra, tstar, wcarb, wexpt, wlite, rd       &
<     ,                anetl, flux_o3_l, fo3_l, gl)
<     
<     
<         !-------------------------------------------------------------------------
<         ! Scale to canopy level.
<         !-------------------------------------------------------------------------
<         DO m = 1,veg_pts
<           l = veg_index(m)
<           gc(l) = fpar(l) * gl(l)
<         END DO
<       END DO   ! End of iteration loop
<       !---------------------------------------------------------------------------
<       ! Calculate canopy-level fluxes.
<       !---------------------------------------------------------------------------
---
>       CALL leaf (clos_pts, ft, land_pts, open_pts, pft_photo_model, veg_pts    &
> ,                clos_index, open_index, veg_index                             &
> ,                ca, ci, fsmc, o3mol, ra, tstar                                &
> ,                wcarb, wexpt, wlitev_shd, rd_shd                              &
> ,                anetl_shd, flux_o3_l_shd, fo3_l_shd, gl_shd)
> 
>       !-----------------------------------------------------------------------
>       ! Update layer conductance.
>       !-----------------------------------------------------------------------
> !$OMP PARALLEL DO                                                              &
> !$OMP SCHEDULE(STATIC)                                                         &
> !$OMP DEFAULT(NONE)                                                            &
> !$OMP PRIVATE(m,l)                                                             &
> !$OMP SHARED(veg_pts,veg_index,gl,fsun,n,gl_sun,gl_shd,rd,rd_sun,rd_shd)
1726,1739c1376,1377
<         anetc(l) = anetl(l) * fpar(l)
<         rdc(l)   = rd(l) * fpar(l)
<         !print*,'rd_stom',rd(l)
<         IF ( lai(l) > EPSILON(0.0) ) THEN
<           rdmean(l) = rd(l) * fpar(l) / lai(l)
<         ELSE
<           rdmean(l) = rd(l)
<         END IF
<     
<         IF (l_o3_damage) THEN
<           flux_o3(l) = flux_o3_l(l) * fpar(l)
<           fo3(l)     = fo3_l(l)
<         END IF
<     
---
>         gl(l) = fsun(l,n) * gl_sun(l) + (1.0 - fsun(l,n)) * gl_shd(l)
>         rd(l) = fsun(l,n) * rd_sun(l) + (1.0 - fsun(l,n)) * rd_shd(l)
1741,1762c1379,1392
<     
<     CASE DEFAULT
<       errcode = 101  !  a hard error
<       CALL ereport(RoutineName, errcode,                                           &
<                    'can_rad_mod should be 1, 4, 5 or 6')
<     
<     END SELECT  ! can_rad_mod
<     
<     !-----------------------------------------------------------------------------
<     ! Calculate plant-level respiration, NPP and GPP.
<     !-----------------------------------------------------------------------------
<     
<     !-----------------------------------------------------------------------------
<     ! Calculate the conversion from top-leaf to canopy-average nitrogen.
<     !-----------------------------------------------------------------------------
<     can_averaging_fac(:) =                                                         &
<         get_can_ave_fac( ft, land_pts, veg_pts, veg_index, lai )
<     
<     !$OMP PARALLEL DO                                                              &
<     !$OMP SCHEDULE(STATIC)                                                         &
<     !$OMP DEFAULT(SHARED)                                                          &
<     !$OMP PRIVATE(m,l,stemc,lma_tmp,fstem,stem_resp_scaling)
---
> !$OMP END PARALLEL DO
> 
>     END DO                 ! K-ITER
> 
>     !-------------------------------------------------------------------------
>     ! Add to canopy-level values.
>     !-------------------------------------------------------------------------
> !$OMP PARALLEL DO                                                              &
> !$OMP SCHEDULE(STATIC)                                                         &
> !$OMP DEFAULT(NONE)                                                            &
> !$OMP PRIVATE(m,l)                                                             &
> !$OMP SHARED(veg_pts,veg_index,anetl,fsun,anetl_sun,anetl_shd,anetc,dlai,gc,   &
> !$OMP        gl,rdc,rd,rdmean,ilayers,l_o3_damage,flux_o3_l,flux_o3_l_sun,     &
> !$OMP        flux_o3_l_shd,fo3_l_sun,fo3_l_shd,flux_o3,fo3,lai,n,fo3_l)
1765,1870c1395,1412
<     
<       !---------------------------------------------------------------------------
<       ! Calculate the actual and balanced mean leaf nitrogen concentration
<       ! assuming perfect light acclimation, then
<       ! calculate the total nitrogen content of the leaf, root and stem
<       ! Assume that root biomass is equal to balanced growth leaf biomass
<       !---------------------------------------------------------------------------
<       lai_bal(l) = (a_ws(ft) * eta_sl(ft) * ht(l) / a_wl(ft))                      &
<                    **(1.0 / (b_wl(ft) - 1.0))
<     
<       IF (l_veg3) lai_bal(l) = veg_state%lai_bal(l,ft)
<     
<       !---------------------------------------------------------------------------
<       ! Calculate the total nitrogen content of the leaf, root and stem
<       !---------------------------------------------------------------------------
<       IF ( ft > nnpft ) THEN
<         !Crop PFTs
<         stemc   = stemc_from_prognostics(ft - nnpft, canht(l) )
<         root(l) = rootc_cpft(l,ft - nnpft)
<     
<         IF ( l_trait_phys ) THEN
<     
<           n_leaf(l) = nleaf_from_lai( l, ft, lai(l), dvi_cpft, can_averaging_fac(l) )
<           n_root(l) = nr_nl(ft) * nmass(ft) * (1.0 / cfrac_l(ft - nnpft))          &
<                       * root(l)
<           n_stem(l) = ns_nl(ft) * nmass(ft) * (1.0 / cfrac_l(ft - nnpft)) * stemc
<             ! nmass(ft)/cfrac_l(ft-nnpft) is equivalent to nl0(ft)
<     
<           lma_tmp   = lma_from_prognostics(ft - nnpft, dvi_cpft(l,ft - nnpft))
<           nlmean(l) = nmass(ft) * lma_tmp * can_averaging_fac(l)
<         ELSE
<           n_leaf(l) = nleaf_from_lai( l, ft, lai(l), dvi_cpft, can_averaging_fac(l) )
<           n_root(l) = nr_nl(ft) * nl0(ft) * root(l)
<           n_stem(l) = ns_nl(ft) * nl0(ft) * stemc
<     
<           nlmean(l) = nl0(ft) * can_averaging_fac(l) * cfrac_l(ft - nnpft)         &
<                       * lma_from_prognostics(ft - nnpft, dvi_cpft(l,ft - nnpft))
<         END IF
<     
<       ELSE
<     
<         !Non-crop PFTs
<         IF ( l_trait_phys ) THEN
<           root(l) = lma(ft) * lai_bal(l)
<           !Note new units of temporary variable root:
<           !kg root/m2= gleaf/m2 * kg/g
<     
<           n_leaf(l) = nleaf_from_lai( l, ft, lai(l), dvi_cpft, can_averaging_fac(l))
<           nlmean(l) = nmass(ft) * lma(ft) * can_averaging_fac(l)
<     
<           n_root(l) = nr(ft) * root(l) * cmass
<     
<           !Initial calculation of N content in respiring stem wood
<           n_stem(l) = eta_sl(ft) * ht(l) * lai_bal(l) * nsw(ft)
<           !USE veg3 allometry
<           IF (l_veg3) n_stem(l) = veg_state%woodC(l,ft) * nsw(ft)
<     
<           !Reduce n_stem for consistency with non-trait n_stem for now
<           !This must be done to achieve realistic respiration rates.
<           fstem            = 1.0 / a_ws(ft)
<           stem_resp_scaling = fstem + (1.0 - fstem) * hw_sw(ft)
<           n_stem(l)         = n_stem(l) * stem_resp_scaling
<     
<         ELSE
<     
<           n_leaf(l) = nleaf_from_lai( l, ft, lai(l), dvi_cpft, can_averaging_fac(l))
<           root(l)   = sigl(ft) * lai_bal(l)
<           n_root(l) = nr_nl(ft) * nl0(ft) * root(l)
<     
<           IF ( l_stem_resp_fix ) THEN
<             n_stem(l) = ns_nl(ft) * nl0(ft) * eta_sl(ft) * ht(l) * lai_bal(l)
<           ELSE
<             n_stem(l) = ns_nl(ft) * nl0(ft) * eta_sl(ft) * ht(l) * lai(l)
<           END IF
<     
<           nlmean(l) = nl0(ft) * can_averaging_fac(l) * sigl(ft)
<     
<         END IF
<     
<       END IF
<     
<       !---------------------------------------------------------------------------
<       ! Calculate the Gross Primary Productivity, the plant maintenance
<       ! respiration rate, and the wood maintenance respiration rate
<       ! in kg C/m2/sec enable fsmc try leaf level gpp x fsmc x fpar
<       !---------------------------------------------------------------------------
<       gpp(l) = cconu * (anetc(l) + rdc(l) * fsmc(l))
<      !print*, 'npp', anetc(l)
<      !print*,'gpp_stom', gpp(l)
<      !print*,'sf', fsmc(l)
<      !print*, 'rd_stom', rdc(l)
<       IF (l_scale_resp_pm) THEN
<         fsmc_scale(l) = fsmc(l)
<       END IF
<       IF ( lai(l) > EPSILON(0.0) ) THEN
<         resp_p_m(l) = cconu * rdc(l)                                               &
<              * (n_leaf(l) * fsmc(l) + n_stem(l) * fsmc_scale(l) +                  &
<                 n_root(l) * fsmc_scale(l)) / n_leaf(l)
<         resp_w(l) = cconu * rdc(l) * n_stem(l) * fsmc_scale(l) / n_leaf(l)
<         resp_r(l) = cconu * rdc(l) * n_root(l) * fsmc_scale(l) / n_leaf(l)
<         resp_l(l) = cconu * rdc(l) * fsmc(l)
<       ELSE
<         resp_w(l) = cconu * rdmean(l) * n_stem(l) * fsmc_scale(l) / nlmean(l)
<         resp_r(l) = cconu * rdmean(l) * n_root(l) * fsmc_scale(l) / nlmean(l)
<         resp_l(l) = cconu * rdc(l) * fsmc(l)
<         resp_p_m(l) = resp_w(l) + resp_r(l) + resp_l(l)
---
> 
>       anetl(l)     = fsun(l,n) * anetl_sun(l)                                  &
>                      + (1.0 - fsun(l,n)) * anetl_shd(l)
>       anetc(l)     = anetc(l) + anetl(l) * dlai(l)
> 
>       gc(l)        = gc(l)  + gl(l) * dlai(l)
>       rdc(l)       = rdc(l) + rd(l) * dlai(l)
> 
>       rdmean(l)    = rdmean(l) + rd(l) / REAL(ilayers)
> 
>       IF (l_o3_damage) THEN
>         flux_o3_l(l) = fsun(l,n) * flux_o3_l_sun(l)                            &
>                        + (1.0 - fsun(l,n)) * flux_o3_l_shd(l)
>         fo3_l(l)     = fsun(l,n) * fo3_l_sun(l)                                &
>                        + (1.0 - fsun(l,n)) * fo3_l_shd(l)
> 
>         flux_o3(l)   = flux_o3(l) + flux_o3_l(l) * dlai(l)
>         fo3(l)       = fo3(l)     + fo3_l(l) * dlai(l) / lai(l)
1872,1879d1413
<     
<       !---------------------------------------------------------------------------
<       ! Calculate the total plant respiration and the Net Primary Productivity
<       !---------------------------------------------------------------------------
<       resp_p_g(l) = r_grow(ft) * (gpp(l) - resp_p_m(l))
<       resp_p(l)   = resp_p_m(l) + resp_p_g(l)
<       npp(l)      = gpp(l) - resp_p(l)
<     
1881,1893c1415,1508
<     !$OMP END PARALLEL DO
<     
<     !-----------------------------------------------------------------------------
<     ! Calculate BVOC emissions
<     !-----------------------------------------------------------------------------
<     IF ( l_bvoc_emis ) THEN
<       CALL bvoc_emissions(land_pts,ft,veg_index,                                   &
<                           open_pts,open_index,clos_pts,clos_index,                 &
<                           lai,ci,gpp,tstar,                                        &
<                           isoprene,terpene,methanol,acetone,                       &
<                           !New arguments replacing USE statements
<                           !crop_vars_mod (IN)
<                           dvi_cpft)
---
> !$OMP END PARALLEL DO
> 
>   END DO                   ! N LAYERS
> 
> CASE ( 1 )
> 
>   !---------------------------------------------------------------------------
>   ! "Big leaf" model.
>   ! N varies through canopy according to Beers Law
>   !---------------------------------------------------------------------------
> 
>   !---------------------------------------------------------------------------
>   ! Calculate photosynthetic parameters.
>   ! There is no light limitation of dark respiration in this case.
>   !---------------------------------------------------------------------------
>   CALL calc_photo_parameters( ft, land_pts, pft_photo_model, veg_pts,          &
>                               veg_index, denom, jmax_temp, jv25,               &
>                               nleaf_top, qtenf_term, qtenf_resp, vcmax_temp,   &
>                               jmax, rd, vcmax, local_time_rfu, lat_rfu )
> 
>   IF ( pft_photo_model == photo_farquhar ) THEN
>     ! Calculate the electron flux.
>     CALL calc_electron_flux( land_pts, veg_pts, veg_index, i2, jmax, je)
>   END IF
> 
>   !---------------------------------------------------------------------------
>   ! Iterate to ensure that the canopy humidity deficit is consistent with the
>   ! H2O flux. The first estimate of the canopy humidity deficit uses the
>   ! stomatal conductance from the previous timestep.
>   !---------------------------------------------------------------------------
>   DO k = 1,iter
> 
>     !-------------------------------------------------------------------------
>     ! Diagnose the canopy-level humidity deficit.
>     !-------------------------------------------------------------------------
>     DO m = 1,veg_pts
>       l = veg_index(m)
>       ra_rc(l) = ra(l) * gc(l)
>       dqc(l)   = dq(l) / (1.0 + ra_rc(l))
>     END DO
> 
>     !-------------------------------------------------------------------------
>     ! Calculate leaf fluxes.
>     !-------------------------------------------------------------------------
>     IF (stomata_model == stomata_sox) THEN
>       CALL leaf_processes_sox(ft, land_pts, veg_pts, veg_index                 &
> ,                             acr, apar, ca, ccp, dqc, kc, ko, oa              &
> ,                             pstar, vcmax, tstar, ht, psi_root_zone, rd       &
> ,                             clos_pts, open_pts, clos_index, open_index       &
> ,                             ci, o3mol, ra, anetl, flux_o3_l                  &
> ,                             fo3_l, gl, lwp_c, pft_photo_model)
> 
>     ELSE
>       !-----------------------------------------------------------------------
>       ! Calculate the limiting factors for leaf photosynthesis.
>       !-----------------------------------------------------------------------
>       CALL leaf_limits (ft, land_pts, pft_photo_model, veg_pts, veg_index      &
> ,                       acr, apar, ca, ccp, dqc, fsmc, je, kc, km, ko, oa      &
> ,                       pstar, vcmax                                           &
> ,                       clos_pts, open_pts, clos_index, open_index             &
> ,                       ci, wcarb, wexpt, wlite)
> 
>       !-----------------------------------------------------------------------
>       ! Calculate leaf-level fluxes.
>       !-----------------------------------------------------------------------
>       CALL leaf (clos_pts, ft, land_pts, open_pts, pft_photo_model, veg_pts    &
> ,                clos_index, open_index, veg_index                             &
> ,                ca, ci, fsmc, o3mol, ra, tstar, wcarb, wexpt, wlite, rd       &
> ,                anetl, flux_o3_l, fo3_l, gl)
>     END IF ! stomata_model
> 
>     !-------------------------------------------------------------------------
>     ! Scale to canopy level.
>     !-------------------------------------------------------------------------
>     DO m = 1,veg_pts
>       l = veg_index(m)
>       gc(l) = fpar(l) * gl(l)
>     END DO
> 
>   END DO   ! End of iteration loop
> 
>   !---------------------------------------------------------------------------
>   ! Calculate canopy-level fluxes.
>   !---------------------------------------------------------------------------
>   DO m = 1,veg_pts
>     l = veg_index(m)
> 
>     anetc(l) = anetl(l) * fpar(l)
>     rdc(l)   = rd(l) * fpar(l)
> 
>     IF ( lai(l) > EPSILON(0.0) ) THEN
>       rdmean(l) = rd(l) * fpar(l) / lai(l)
>     ELSE
>       rdmean(l) = rd(l)
1895,1925c1510,1513
<     
<     !-----------------------------------------------------------------------------
<     ! If this functional type is a crop that has not emerged in a particular grid
<     ! box, set all the output variables to zero.
<     !-----------------------------------------------------------------------------
<     IF ( ft > nnpft ) THEN
<     
<     !$OMP PARALLEL DO                                                              &
<     !$OMP SCHEDULE(STATIC)                                                         &
<     !$OMP DEFAULT(NONE)                                                            &
<     !$OMP SHARED(veg_pts,veg_index,dvi_cpft,nnpft,gpp,resp_w,resp_p,npp,gc,fo3,    &
<     !$OMP         flux_o3,isoprene,terpene,methanol,acetone,ft)                    &
<     !$OMP PRIVATE(m,l)
<       DO m = 1,veg_pts
<         l = veg_index(m)
<     
<         IF ( dvi_cpft(l,ft - nnpft) < 0.0 ) THEN
<           gpp(l)      = 0.0
<           resp_w(l)   = 0.0
<           resp_p(l)   = 0.0
<           npp(l)      = 0.0
<           gc(l)       = 0.0
<           fo3(l)      = 0.0
<           flux_o3(l)  = 0.0
<           isoprene(l) = 0.0
<           terpene(l)  = 0.0
<           methanol(l) = 0.0
<           acetone(l)  = 0.0
<         END IF
<       END DO
<     !$OMP END PARALLEL DO
---
> 
>     IF (l_o3_damage) THEN
>       flux_o3(l) = flux_o3_l(l) * fpar(l)
>       fo3(l)     = fo3_l(l)
1927,1962c1515,1579
<     
<     !-----------------------------------------------------------------------------
<     ! Calculate FAPAR diagnostic (fraction of absorbed photosynthetically
<     ! active radiation). N.b. this is not per LAI.
<     ! Calculate APAR diagnostic (absorbed photosynthetically
<     ! active radiation).
<     !-----------------------------------------------------------------------------
<     
<     fapar_diag(:) = 0.0
<     apar_diag(:) = 0.0
<     
<     IF ( l_fapar_diag ) THEN
<       SELECT CASE ( can_rad_mod )
<       CASE ( 1 )
<         DO m = 1,veg_pts
<           l = veg_index(m)
<           fapar_diag(l) = (1.0 - omega(ft)) * fpar(l) * kpar(ft)
<         END DO
<       CASE ( 4 )
<         DO m = 1,veg_pts
<           l = veg_index(m)
<           fapar_diag(l) = SUM(faparv(l,:)) * dlai(l)
<         END DO
<       CASE ( 5, 6 )
<         DO m = 1,veg_pts
<           l = veg_index(m)
<           fapar_diag(l) = SUM( fsun(l,:) * fapar_sun(l,:) +                        &
<                                ( 1.0 - fsun(l,:) ) * fapar_shd(l,:)                &
<                              ) * dlai(l)
<         END DO
<       CASE DEFAULT
<         errcode = 101  !  a hard error
<         CALL ereport(RoutineName, errcode,                                         &
<                      'can_rad_mod should be 1, 4, 5 or 6 (l_fapar_diag)')
<       END SELECT
<       apar_diag(:) = fapar_diag(:) * ipar(:)
---
> 
>   END DO
> 
> CASE DEFAULT
>   errcode = 101  !  a hard error
>   CALL ereport(RoutineName, errcode,                                           &
>                'can_rad_mod should be 1, 4, 5 or 6')
> 
> END SELECT  ! can_rad_mod
> 
> !-----------------------------------------------------------------------------
> ! Calculate plant-level respiration, NPP and GPP.
> !-----------------------------------------------------------------------------
> 
> !-----------------------------------------------------------------------------
> ! Calculate the conversion from top-leaf to canopy-average nitrogen.
> !-----------------------------------------------------------------------------
> can_averaging_fac(:) =                                                         &
>     get_can_ave_fac( ft, land_pts, veg_pts, veg_index, lai )
> 
> !$OMP PARALLEL DO                                                              &
> !$OMP SCHEDULE(STATIC)                                                         &
> !$OMP DEFAULT(SHARED)                                                          &
> !$OMP PRIVATE(m,l,stemc,lma_tmp,fstem,stem_resp_scaling)
> DO m = 1,veg_pts
>   l = veg_index(m)
> 
>   !---------------------------------------------------------------------------
>   ! Calculate the actual and balanced mean leaf nitrogen concentration
>   ! assuming perfect light acclimation, then
>   ! calculate the total nitrogen content of the leaf, root and stem
>   ! Assume that root biomass is equal to balanced growth leaf biomass
>   !---------------------------------------------------------------------------
>   lai_bal(l) = (a_ws(ft) * eta_sl(ft) * ht(l) / a_wl(ft))                      &
>                **(1.0 / (b_wl(ft) - 1.0))
> 
>   IF (l_veg3) lai_bal(l) = veg_state%lai_bal(l,ft)
> 
>   !---------------------------------------------------------------------------
>   ! Calculate the total nitrogen content of the leaf, root and stem
>   !---------------------------------------------------------------------------
>   IF ( ft > nnpft ) THEN
>     !Crop PFTs
>     stemc   = stemc_from_prognostics(ft - nnpft, canht(l) )
>     root(l) = rootc_cpft(l,ft - nnpft)
> 
>     IF ( l_trait_phys ) THEN
> 
>       n_leaf(l) = nleaf_from_lai( l, ft, lai(l), dvi_cpft, can_averaging_fac(l) )
>       n_root(l) = nr_nl(ft) * nmass(ft) * (1.0 / cfrac_l(ft - nnpft))          &
>                   * root(l)
>       n_stem(l) = ns_nl(ft) * nmass(ft) * (1.0 / cfrac_l(ft - nnpft)) * stemc
>         ! nmass(ft)/cfrac_l(ft-nnpft) is equivalent to nl0(ft)
> 
>       lma_tmp   = lma_from_prognostics(ft - nnpft, dvi_cpft(l,ft - nnpft))
>       nlmean(l) = nmass(ft) * lma_tmp * can_averaging_fac(l)
> 
>     ELSE
> 
>       n_leaf(l) = nleaf_from_lai( l, ft, lai(l), dvi_cpft, can_averaging_fac(l) )
>       n_root(l) = nr_nl(ft) * nl0(ft) * root(l)
>       n_stem(l) = ns_nl(ft) * nl0(ft) * stemc
> 
>       nlmean(l) = nl0(ft) * can_averaging_fac(l) * cfrac_l(ft - nnpft)         &
>                   * lma_from_prognostics(ft - nnpft, dvi_cpft(l,ft - nnpft))
1964,2077c1581,1619
<     
<     IF (lhook) CALL dr_hook(ModuleName//':'//RoutineName,zhook_out,zhook_handle)
<     RETURN
<     END SUBROUTINE sf_stom
<     
<     !#############################################################################
<     !#############################################################################
<     
<     SUBROUTINE calc_photo_parameters( ft, land_pts, pft_photo_model, veg_pts,      &
<                                       veg_index, denom, jmax_temp, jv25,           &
<                                       nleaf, qtenf_term, vcmax_temp,               &
<                                       jmax, rd_dark, vcmax )
<     
<     ! Calculate the maximum rates of carboxylation of Rubisco and electron
<     ! transport, and dark respiration without light inhibition.
<     
<     USE jules_vegetation_mod, ONLY:                                                &
<     ! imported parameters
<         jv_ntotal, jv_scale, photo_collatz, photo_farquhar,photo_pmodel,           &
<     ! imported scalars that are not changed
<         n_alloc_jmax, n_alloc_vcmax, l_trait_phys, photo_jv_model
<     
<     USE pftparm, ONLY: fd, jv25_ratio, neff, vint, vsl, beta_c3c4,eagamma, eakc,   &
<                        eako,gamma25, kc25, ko25
<     USE parkind1, ONLY: jprb, jpim
<     USE yomhook, ONLY: lhook, dr_hook
<     
<     IMPLICIT NONE
<     
<     !-----------------------------------------------------------------------------
<     ! Arguments with INTENT(IN).
<     !-----------------------------------------------------------------------------
<     INTEGER,INTENT(IN) ::                                                          &
<       ft,                                                                          &
<         ! Index of plant functional type.
<       land_pts,                                                                    &
<         ! Number of land points.
<       pft_photo_model,                                                             &
<         ! Indicates which photosynthesis model to use for the current PFT.
<       veg_pts,                                                                     &
<         ! Number of vegetated points.
<       veg_index(land_pts)
<         ! Index of vegetated points on the land grid.
<     
<     REAL(KIND=real_jlslsm), INTENT(IN) ::                                          &
<       denom(land_pts),                                                             &
<         ! Denominator in equation for Vcmax with the Collatz model.
<       jmax_temp(land_pts),                                                         &
<         ! Factor expressing the effect of temperature on Jmax.
<         ! Only used with the Farquhar model.
<       jv25(land_pts),                                                              &
<         ! Ratio of Jmax to Vcmax at 25 degC, including any acclimation.
<         ! Only used with the Farquhar model.
<       nleaf(land_pts),                                                             &
<         ! Leaf nitrogen concentration.
<         ! If l_trait_phys = (kg N m-2),  else = (kgN [kgC]-1).
<       qtenf_term(land_pts),                                                        &
<        ! Q10 temperature term used for Vcmax with the Collatz model.
<       vcmax_temp(land_pts)
<         ! Factor expressing the effect of temperature on Vcmax.
<         ! Only used with the Farquhar model.
<     
<     !-----------------------------------------------------------------------------
<     ! Arguments with INTENT(OUT).
<     !-----------------------------------------------------------------------------
<     REAL(KIND=real_jlslsm), INTENT(OUT) ::                                         &
<       jmax(land_pts),                                                              &
<         ! Maximum rate of electron transport (mol CO2 m-2 s-1).
<         ! Only calculated with the Farquhar model.
<       rd_dark(land_pts),                                                           &
<         ! Dark respiration before light inhibition (mol CO2/m2/s).
<       vcmax(land_pts)
<         ! Maximum rate of carboxylation of Rubisco (mol CO2/m2/s).
<     
<     !-----------------------------------------------------------------------------
<     ! Local scalar variables.
<     !-----------------------------------------------------------------------------
<     INTEGER ::                                                                     &
<       l, m
<         ! Indices.
<     
<     REAL(KIND=real_jlslsm) ::                                                      &
<       n_total,                                                                     &
<         ! Total N allocated to photosynthetic components (kg m-2).
<       recip_j,                                                                     &
<         ! Reciprocal of n_alloc_jmax (kg m-2 of N [mol CO2 m-2 s-1]).
<       recip_v
<         ! Reciprocal of n_alloc_vcmax (kg m-2 of N [mol CO2 m-2 s-1]).
<     
<     !-----------------------------------------------------------------------------
<     ! Local array variables.
<     !-----------------------------------------------------------------------------
<     REAL ::                                                                        &
<       vcmax_ref(land_pts)
<         ! Maximum rate of carboxylation of Rubisco at the reference temperature,
<         ! ignoring the effects of acclimation and N allocation (mol CO2/m2/s).
<     
<     INTEGER(KIND=jpim), PARAMETER :: zhook_in  = 0
<     INTEGER(KIND=jpim), PARAMETER :: zhook_out = 1
<     REAL(KIND=jprb)               :: zhook_handle
<     
<     CHARACTER(LEN=*), PARAMETER :: RoutineName='CALC_PHOTO_PARAMETERS'
<     
<     !-----------------------------------------------------------------------------
<     !end of header
<     
<     IF (lhook) CALL dr_hook(ModuleName//':'//RoutineName,zhook_in,zhook_handle)
<     
<     !-----------------------------------------------------------------------------
<     ! Calculate some constants.
<     !-----------------------------------------------------------------------------
<     IF ( photo_jv_model == jv_ntotal ) THEN
<       recip_j  = 1.0 / n_alloc_jmax
<       recip_v  = 1.0 / n_alloc_vcmax
---
> 
>   ELSE
> 
>     !Non-crop PFTs
>     IF ( l_trait_phys ) THEN
>       root(l) = lma(ft) * lai_bal(l)
>       !Note new units of temporary variable root:
>       !kg root/m2= gleaf/m2 * kg/g
> 
>       n_leaf(l) = nleaf_from_lai( l, ft, lai(l), dvi_cpft, can_averaging_fac(l))
>       nlmean(l) = nmass(ft) * lma(ft) * can_averaging_fac(l)
> 
>       n_root(l) = nr(ft) * root(l) * cmass
> 
>       !Initial calculation of N content in respiring stem wood
>       n_stem(l) = eta_sl(ft) * ht(l) * lai_bal(l) * nsw(ft)
>       !USE veg3 allometry
>       IF (l_veg3) n_stem(l) = veg_state%woodC(l,ft) / a_ws(ft) * nsw(ft)
> 
>       !Reduce n_stem for consistency with non-trait n_stem for now
>       !This must be done to achieve realistic respiration rates.
>       fstem            = 1.0 / a_ws(ft)
>       stem_resp_scaling = fstem + (1.0 - fstem) * hw_sw(ft)
>       n_stem(l)         = n_stem(l) * stem_resp_scaling
> 
>     ELSE
> 
>       n_leaf(l) = nleaf_from_lai( l, ft, lai(l), dvi_cpft, can_averaging_fac(l))
>       root(l)   = sigl(ft) * lai_bal(l)
>       n_root(l) = nr_nl(ft) * nl0(ft) * root(l)
> 
>       IF ( l_stem_resp_fix ) THEN
>         n_stem(l) = ns_nl(ft) * nl0(ft) * eta_sl(ft) * ht(l) * lai_bal(l)
>       ELSE
>         n_stem(l) = ns_nl(ft) * nl0(ft) * eta_sl(ft) * ht(l) * lai(l)
>       END IF
> 
>       nlmean(l) = nl0(ft) * can_averaging_fac(l) * sigl(ft)
> 
2079,2090c1621,1753
<     
<     !-----------------------------------------------------------------------------
<     ! Calculate Vcmax at the reference temperature, without any acclimation.
<     !-----------------------------------------------------------------------------
<     !$OMP PARALLEL IF(veg_pts > 1)  DEFAULT(NONE)                                  &
<     !$OMP PRIVATE(l, m, n_total)                                                   &
<     !$OMP SHARED(ft, pft_photo_model, photo_jv_model, veg_index, veg_pts,          &
<     !$OMP        denom, fd, jmax, jmax_temp, jv25, jv25_ratio, neff, nleaf,        &
<     !$OMP        qtenf_term, rd_dark, recip_j, recip_v, vcmax, vcmax_ref,          &
<     !$OMP        vcmax_temp, vint, vsl, l_trait_phys )
<     
<     !$OMP DO SCHEDULE(STATIC)
---
> 
>   END IF
> 
>   !---------------------------------------------------------------------------
>   ! Calculate the Gross Primary Productivity, the plant maintenance
>   ! respiration rate, and the wood maintenance respiration rate
>   ! in kg C/m2/sec
>   !---------------------------------------------------------------------------
>   gpp(l) = cconu * (anetc(l) + rdc(l) * fsmc(l))
> 
>   IF (l_scale_resp_pm) THEN
>     fsmc_scale(l) = fsmc(l)
>   END IF
> 
>   IF ( l_sugar ) THEN
>     !-------------------------------------------------------------------------
>     ! Calculate carbon contents of leaf root and wood
>     !-------------------------------------------------------------------------
>     IF ( l_trait_phys ) THEN
> 
>       leafc(l)     = lma(ft) * lai(l) * cmass
>       leafc_bal(l) = lma(ft) * lai_bal(l) * cmass
> 
>       IF ( l_veg3 ) THEN
>         rootc(l) = veg_state%rootC(l,ft)
>         woodc(l) = veg_state%woodC(l,ft)
>       ELSE
>         rootc(l) = lma(ft) * lai_bal(l) * cmass
>         woodc(l) = a_ws(ft) * eta_sl(ft) * ht(l) * lai_bal(l)
>       END IF ! ( l_veg3 )
> 
>     ELSE
> 
>       leafc(l)     = sigl(ft) * lai(l)
>       leafc_bal(l) = sigl(ft) * lai_bal(l)
>       rootc(l) = lma(ft) * lai_bal(l) * cmass
>       woodc(l) = a_ws(ft) * eta_sl(ft) * ht(l) * lai_bal(l)
> 
>     END IF ! ( l_trait_phys )
>     !---------------------------------------------------------------------------
>     ! Calculate respration using SUGAR model
>     !---------------------------------------------------------------------------
>     CALL sugar(ft, leafc(l), leafc_bal(l) , woodc(l), rootc(l), f_nsc(l),      &
>                resp_l(l), resp_w(l), resp_r(l), resp_p_m(l), resp_p_g(l),      &
>                resp_p(l), growth_sug(l), tstar(l), gpp(l))
> 
>   ELSE
>     IF ( lai(l) > EPSILON(0.0) ) THEN
>       resp_p_m(l) = cconu * rdc(l)                                             &
>            * (n_leaf(l) * fsmc(l) + n_stem(l) * fsmc_scale(l) +                &
>               n_root(l) * fsmc_scale(l)) / n_leaf(l)
>       resp_w(l) = cconu * rdc(l) * n_stem(l) * fsmc_scale(l) / n_leaf(l)
>       resp_r(l) = cconu * rdc(l) * n_root(l) * fsmc_scale(l) / n_leaf(l)
>       resp_l(l) = cconu * rdc(l) * fsmc(l)
>     ELSE
>       resp_w(l) = cconu * rdmean(l) * n_stem(l) * fsmc_scale(l) / nlmean(l)
>       resp_r(l) = cconu * rdmean(l) * n_root(l) * fsmc_scale(l) / nlmean(l)
>       resp_l(l) = cconu * rdc(l) * fsmc(l)
>       resp_p_m(l) = resp_w(l) + resp_r(l) + resp_l(l)
>     END IF
>     !-------------------------------------------------------------------------
>     ! Calculate the total plant respiration
>     !-------------------------------------------------------------------------
>     resp_p_g(l) = r_grow(ft) * (gpp(l) - resp_p_m(l))
>     resp_p(l)   = resp_p_m(l) + resp_p_g(l)
>   END IF !l_sugar
> 
>   !---------------------------------------------------------------------------
>   ! Calculate Net Primary Productivity
>   !---------------------------------------------------------------------------
>   npp(l)      = gpp(l) - resp_p(l)
> 
> END DO
> !$OMP END PARALLEL DO
> 
> !-----------------------------------------------------------------------------
> ! Calculate BVOC emissions
> !-----------------------------------------------------------------------------
> IF ( l_bvoc_emis ) THEN
>   CALL bvoc_emissions(land_pts,ft,veg_index,                                   &
>                       open_pts,open_index,clos_pts,clos_index,                 &
>                       lai,ci,gpp,tstar,                                        &
>                       isoprene,terpene,methanol,acetone,                       &
>                       !New arguments replacing USE statements
>                       !crop_vars_mod (IN)
>                       dvi_cpft)
> END IF
> 
> !-----------------------------------------------------------------------------
> ! If this functional type is a crop that has not emerged in a particular grid
> ! box, set all the output variables to zero.
> !-----------------------------------------------------------------------------
> IF ( ft > nnpft ) THEN
> 
> !$OMP PARALLEL DO                                                              &
> !$OMP SCHEDULE(STATIC)                                                         &
> !$OMP DEFAULT(NONE)                                                            &
> !$OMP SHARED(veg_pts,veg_index,dvi_cpft,nnpft,gpp,resp_w,resp_p,npp,gc,fo3,    &
> !$OMP         flux_o3,isoprene,terpene,methanol,acetone,ft)                    &
> !$OMP PRIVATE(m,l)
>   DO m = 1,veg_pts
>     l = veg_index(m)
> 
>     IF ( dvi_cpft(l,ft - nnpft) < 0.0 ) THEN
>       gpp(l)      = 0.0
>       resp_w(l)   = 0.0
>       resp_p(l)   = 0.0
>       npp(l)      = 0.0
>       gc(l)       = 0.0
>       fo3(l)      = 0.0
>       flux_o3(l)  = 0.0
>       isoprene(l) = 0.0
>       terpene(l)  = 0.0
>       methanol(l) = 0.0
>       acetone(l)  = 0.0
>     END IF
>   END DO
> !$OMP END PARALLEL DO
> END IF
> 
> !-----------------------------------------------------------------------------
> ! Calculate FAPAR diagnostic (fraction of absorbed photosynthetically
> ! active radiation). N.b. this is not per LAI.
> ! Calculate APAR diagnostic (absorbed photosynthetically
> ! active radiation).
> !-----------------------------------------------------------------------------
> 
> fapar_diag(:) = 0.0
> apar_diag(:) = 0.0
> 
> IF ( l_fapar_diag ) THEN
>   SELECT CASE ( can_rad_mod )
>   CASE ( 1 )
2092d1754
<     
2094,2100c1756
<     
<       IF (l_trait_phys) THEN
<         vcmax_ref(l) = (vsl(ft) * nleaf(l) + vint(ft)) * 1.0e-6  ! Kattge 2009
<       ELSE
<         vcmax_ref(l) = neff(ft) * nleaf(l)
<       END IF
<     
---
>       fapar_diag(l) = (1.0 - omega(ft)) * fpar(l) * kpar(ft)
2102,2183c1758
<     !$OMP END DO NOWAIT
<     
<     !-----------------------------------------------------------------------------
<     ! Calculate Vcmax and Jmax.
<     !-----------------------------------------------------------------------------
<     SELECT CASE ( pft_photo_model )
<     CASE ( photo_collatz )
<     
<       !---------------------------------------------------------------------------
<       ! Use the Collatz model.
<       !---------------------------------------------------------------------------
<     !$OMP DO SCHEDULE(STATIC)
<       DO m = 1,veg_pts
<         l = veg_index(m)
<         ! Using brackets here to recreate existing results.
<         vcmax(l) = ( vcmax_ref(l) * qtenf_term(l) ) / denom(l)
<       END DO
<     !$OMP END DO NOWAIT
<     
<     CASE ( photo_farquhar )
<     
<       !---------------------------------------------------------------------------
<       ! Use the Farquhar model (for C3 plants).
<       !---------------------------------------------------------------------------
<     
<       !---------------------------------------------------------------------------
<       ! Calculate values at the reference temperature, including any acclimation
<       ! of jv25 (but excluding other acclimation terms).
<       !---------------------------------------------------------------------------
<       SELECT CASE ( photo_jv_model )
<     
<       CASE ( jv_scale )
<         ! Find J25 by scaling V25.
<     !$OMP DO SCHEDULE(STATIC)
<         DO m = 1,veg_pts
<           l = veg_index(m)
<           vcmax(l) = vcmax_ref(l)
<           jmax(l)  = vcmax_ref(l) * jv25(l)
<         END DO
<     !$OMP END DO NOWAIT
<     
<       CASE ( jv_ntotal )
<         ! Assume the total N allocated to photosynthetic capacity is constant.
<     !$OMP DO SCHEDULE(STATIC)
<         DO m = 1,veg_pts
<           l = veg_index(m)
<           ! Calculate total N allocated to photosynthetic capacity, using the
<           ! prescribed parameters at the reference temperature.
<           ! This is Eq.5 of Mercado et al. (2018).
<           n_total = vcmax_ref(l) * recip_v                                         &
<                     + vcmax_ref(l) * jv25_ratio(ft) * recip_j
<           ! Calculate Vcmax and Jmax at 25degC, including temperature acclimation
<           ! of J:V.
<           vcmax(l) = n_total / ( recip_v + jv25(l) * recip_j )
<           jmax(l)  = n_total / ( recip_v / jv25(l) + recip_j )
<         END DO
<     !$OMP END DO NOWAIT
<     
<       END SELECT  !  photo_jv_model
<     
<       !---------------------------------------------------------------------------
<       ! Calculate final values, including temperature effect.
<       !---------------------------------------------------------------------------
<     !$OMP DO SCHEDULE(STATIC)
<       DO m = 1,veg_pts
<         l = veg_index(m)
<     
<         ! Calculate rates according to acclimated ratio and N allocation to
<         ! photosynthesis, and including temperature term.
<         ! At present neither acclimation nor N allocation are represented.
<         vcmax(l) = vcmax(l) * vcmax_temp(l)
<         jmax(l)  = jmax(l)  * jmax_temp(l)
<     
<       END DO
<     !$OMP END DO NOWAIT
<     CASE  (photo_pmodel)
<     !Do nothing as vcmax is needed 
<     END SELECT  !  pft_photo_model
<     !-----------------------------------------------------------------------------
<     ! Calculate dark respiration. Any effect of light inhibition is added later.
<     !-----------------------------------------------------------------------------
<     !$OMP DO SCHEDULE(STATIC)
---
>   CASE ( 4 )
2186c1761
<       rd_dark(l) = fd(ft) * vcmax(l)
---
>       fapar_diag(l) = SUM(faparv(l,:)) * dlai(l)
2188,2272c1763
<     !$OMP END DO NOWAIT
<     !$OMP END PARALLEL
<     
<     IF (lhook) CALL dr_hook(ModuleName//':'//RoutineName,zhook_out,zhook_handle)
<     RETURN
<     
<     END SUBROUTINE calc_photo_parameters
<     
<     !#############################################################################
<     !#############################################################################
<     
<     SUBROUTINE calc_electron_flux( land_pts, veg_pts, veg_index, i2, jmax, je )
<     
<     ! Calculate the electron flux for the Farquhar model.
<     
<     USE parkind1, ONLY: jprb, jpim
<     USE yomhook, ONLY: lhook, dr_hook
<     
<     IMPLICIT NONE
<     
<     !-----------------------------------------------------------------------------
<     ! Arguments with INTENT(IN).
<     !-----------------------------------------------------------------------------
<     INTEGER,INTENT(IN) ::                                                          &
<       land_pts,                                                                    &
<         ! Number of land points.
<       veg_pts,                                                                     &
<         ! Number of vegetated points.
<       veg_index(land_pts)
<         ! Index of vegetated points on the land grid.
<     
<     REAL(KIND=real_jlslsm), INTENT(IN) ::                                          &
<       i2(land_pts),                                                                &
<         ! Radiation that goes to Photosystem II, expressed as an electron flux
<         ! (mol m-2 s-1).
<       jmax(land_pts)
<         ! Maximum rate of electron transport (mol CO2 m-2 s-1).
<     
<     !-----------------------------------------------------------------------------
<     ! Arguments with INTENT(OUT).
<     !-----------------------------------------------------------------------------
<     REAL(KIND=real_jlslsm), INTENT(OUT) ::                                         &
<       je(land_pts)
<         ! Electron transport rate (mol m-2 s-1).
<     
<     !-----------------------------------------------------------------------------
<     ! Local parameters.
<     !-----------------------------------------------------------------------------
<     REAL(KIND=real_jlslsm), PARAMETER ::                                           &
<       light_curvature = 0.90
<         ! Curvature of the light response function. Used with Farquhar model of
<         ! photosynthesis. See Eq.4 of Medlyn et al. (2002).
<     
<     !-----------------------------------------------------------------------------
<     ! Local variables.
<     !-----------------------------------------------------------------------------
<     INTEGER ::                                                                     &
<       l, m
<         ! Indices.
<     
<     REAL(KIND=real_jlslsm) ::                                                      &
<      recip_denom
<        ! The reciprocal of the denominator.
<     
<     
<     INTEGER(KIND=jpim), PARAMETER :: zhook_in  = 0
<     INTEGER(KIND=jpim), PARAMETER :: zhook_out = 1
<     REAL(KIND=jprb)               :: zhook_handle
<     
<     CHARACTER(LEN=*), PARAMETER :: RoutineName='CALC_ELECTRON_FLUX'
<     
<     !-----------------------------------------------------------------------------
<     !end of header
<     
<     IF (lhook) CALL dr_hook(ModuleName//':'//RoutineName,zhook_in,zhook_handle)
<     
<     !-----------------------------------------------------------------------------
<     ! Calculate a constant.
<     !-----------------------------------------------------------------------------
<     recip_denom = 1.0 / ( 2.0 * light_curvature )
<     
<     !-----------------------------------------------------------------------------
<     ! Calculate electron flux by finding a root of a quadratic equation.
<     ! This is the solution of Eq.4 of Medlyn et al. (2002).
<     !-----------------------------------------------------------------------------
---
>   CASE ( 5, 6 )
2275,2278c1766,1768
<       je(l)  = ( i2(l) + jmax(l)                                                   &
<                         - SQRT( ( i2(l) + jmax(l) )**2                             &
<                                 - 4.0 * light_curvature * i2(l) * jmax(l) )        &
<                ) * recip_denom
---
>       fapar_diag(l) = SUM( fsun(l,:) * fapar_sun(l,:) +                        &
>                            ( 1.0 - fsun(l,:) ) * fapar_shd(l,:)                &
>                          ) * dlai(l)
2279a1770,2068
>   CASE DEFAULT
>     errcode = 101  !  a hard error
>     CALL ereport(RoutineName, errcode,                                         &
>                  'can_rad_mod should be 1, 4, 5 or 6 (l_fapar_diag)')
>   END SELECT
>   apar_diag(:) = fapar_diag(:) * ipar(:)
> END IF
> 
> IF (lhook) CALL dr_hook(ModuleName//':'//RoutineName,zhook_out,zhook_handle)
> RETURN
> END SUBROUTINE sf_stom
> 
> !#############################################################################
> !#############################################################################
> 
> SUBROUTINE calc_photo_parameters( ft, land_pts, pft_photo_model, veg_pts,      &
>                                   veg_index, denom, jmax_temp, jv25,           &
>                                   nleaf, qtenf_term, qtenf_resp, vcmax_temp,   &
>                                   jmax, rd_dark, vcmax, local_time_rfu, lat_rfu )
> 
> ! Calculate the maximum rates of carboxylation of Rubisco and electron
> ! transport, and dark respiration without light inhibition.
> 
> USE jules_vegetation_mod, ONLY:                                                &
> ! imported parameters
>     jv_ntotal, jv_scale, photo_collatz, photo_farquhar,                        &
>     rd_classic, rd_pftq10, rd_tdq10,                                           &
> ! imported scalars that are not changed
>     n_alloc_jmax, n_alloc_vcmax, l_trait_phys, photo_jv_model, rd_model,       &
>     l_vcmax_jmax_diurnal
> 
> USE pftparm, ONLY: fd, jv25_ratio, neff, vint, vsl
> 
> USE parkind1, ONLY: jprb, jpim
> USE yomhook, ONLY: lhook, dr_hook
> 
> !***rfu
> USE model_grid_mod, ONLY: longitude, latitude
> !***rfu
> USE model_time_mod, ONLY: current_time  ! The time that the current timestep started
> 
> 
> IMPLICIT NONE
> 
> !-----------------------------------------------------------------------------
> ! Arguments with INTENT(IN).
> !-----------------------------------------------------------------------------
> INTEGER,INTENT(IN) ::                                                          &
>   ft,                                                                          &
>     ! Index of plant functional type.
>   land_pts,                                                                    &
>     ! Number of land points.
>   pft_photo_model,                                                             &
>     ! Indicates which photosynthesis model to use for the current PFT.
>   veg_pts,                                                                     &
>     ! Number of vegetated points.
>   veg_index(land_pts)
>     ! Index of vegetated points on the land grid.
> 
> REAL(KIND=real_jlslsm), INTENT(IN) ::                                          &
>   denom(land_pts),                                                             &
>     ! Denominator in equation for Vcmax with the Collatz model.
>   jmax_temp(land_pts),                                                         &
>     ! Factor expressing the effect of temperature on Jmax.
>     ! Only used with the Farquhar model.
>   jv25(land_pts),                                                              &
>     ! Ratio of Jmax to Vcmax at 25 degC, including any acclimation.
>     ! Only used with the Farquhar model.
>   nleaf(land_pts),                                                             &
>     ! Leaf nitrogen concentration.
>     ! If l_trait_phys = (kg N m-2),  else = (kgN [kgC]-1).
>   qtenf_term(land_pts),                                                        &
>    ! Q10 temperature term used for Vcmax with the Collatz model.
>   qtenf_resp(land_pts),                                                        &
>     ! Temperature=dependent Q10 temperature term used for dark respiration.
>   vcmax_temp(land_pts)
>     ! Factor expressing the effect of temperature on Vcmax.
>     ! Only used with the Farquhar model.
> 
> !-----------------------------------------------------------------------------
> ! Arguments with INTENT(OUT).
> !-----------------------------------------------------------------------------
> REAL(KIND=real_jlslsm), INTENT(OUT) ::                                         &
>   jmax(land_pts),                                                              &
>     ! Maximum rate of electron transport (mol CO2 m-2 s-1).
>     ! Only calculated with the Farquhar model.
>   rd_dark(land_pts),                                                           &
>     ! Dark respiration before light inhibition (mol CO2/m2/s).
>   vcmax(land_pts)
>     ! Maximum rate of carboxylation of Rubisco (mol CO2/m2/s).
> 
> !-----------------------------------------------------------------------------
> ! Local scalar variables.
> !-----------------------------------------------------------------------------
> INTEGER ::                                                                     &
>   l, m
>     ! Indices.
> 
> REAL(KIND=real_jlslsm) ::                                                      &
>   n_total,                                                                     &
>     ! Total N allocated to photosynthetic components (kg m-2).
>   recip_j,                                                                     &
>     ! Reciprocal of n_alloc_jmax (kg m-2 of N [mol CO2 m-2 s-1]).
>   recip_v
>     ! Reciprocal of n_alloc_vcmax (kg m-2 of N [mol CO2 m-2 s-1]).
> 
> !-----------------------------------------------------------------------------
> ! Local array variables.
> !-----------------------------------------------------------------------------
> REAL ::                                                                        &
>   vcmax_ref(land_pts),                                                         &
>     ! Maximum rate of carboxylation of Rubisco at the reference temperature,
>     ! ignoring the effects of acclimation and N allocation (mol CO2/m2/s).
>   vcmax_scale_trop,                                                            &
>     !***rfu - Time of day scale factor for Vcmax in tropical regions
>   jmax_scale_trop,                                                             &
>     !***rfu - Time of day scale factor for Jmax in tropical regions
>   vcmax_scale_temp,                                                            &
>     !***rfu - Time of day scale factor for Vcmax in temperate regions
>   jmax_scale_temp
>     !***rfu - Time of day scale factor for Jmax in temperate regions
> 
> !***rfu
> REAL(KIND=real_jlslsm)     :: local_time_rfu(land_pts)
> REAL(KIND=real_jlslsm)     :: lat_rfu(land_pts)
> 
> 
> INTEGER(KIND=jpim), PARAMETER :: zhook_in  = 0
> INTEGER(KIND=jpim), PARAMETER :: zhook_out = 1
> REAL(KIND=jprb)               :: zhook_handle
> 
> CHARACTER(LEN=*), PARAMETER :: RoutineName='CALC_PHOTO_PARAMETERS'
> 
> !-----------------------------------------------------------------------------
> !end of header
> 
> IF (lhook) CALL dr_hook(ModuleName//':'//RoutineName,zhook_in,zhook_handle)
> 
> !-----------------------------------------------------------------------------
> ! Calculate some constants.
> !-----------------------------------------------------------------------------
> IF ( photo_jv_model == jv_ntotal ) THEN
>   recip_j  = 1.0 / n_alloc_jmax
>   recip_v  = 1.0 / n_alloc_vcmax
> END IF
> 
> !-----------------------------------------------------------------------------
> ! Calculate Vcmax at the reference temperature, without any acclimation.
> !-----------------------------------------------------------------------------
> !$OMP PARALLEL IF(veg_pts > 1)  DEFAULT(NONE)                                  &
> !$OMP PRIVATE(l, m, n_total)                                                   &
> !$OMP SHARED(ft, pft_photo_model, photo_jv_model, veg_index, veg_pts,          &
> !$OMP        denom, fd, jmax, jmax_temp, jv25, jv25_ratio, neff, nleaf,        &
> !$OMP        qtenf_term, qtenf_resp, rd_model, rd_dark, recip_j, recip_v,      &
> !$OMP        vcmax, vcmax_ref, vcmax_temp, vint, vsl, l_trait_phys )
> 
> !$OMP DO SCHEDULE(STATIC)
> DO m = 1,veg_pts
> 
>   l = veg_index(m)
> 
>   IF (l_trait_phys) THEN
>     vcmax_ref(l) = (vsl(ft) * nleaf(l) + vint(ft)) * 1.0e-6  ! Kattge 2009
>   ELSE
>     vcmax_ref(l) = neff(ft) * nleaf(l)
>   END IF
> 
> END DO
> !$OMP END DO NOWAIT
> 
> !-----------------------------------------------------------------------------
> ! Calculate Vcmax and Jmax.
> !-----------------------------------------------------------------------------
> SELECT CASE ( pft_photo_model )
> CASE ( photo_collatz )
> 
>   !---------------------------------------------------------------------------
>   ! Use the Collatz model.
>   !---------------------------------------------------------------------------
> !$OMP DO SCHEDULE(STATIC)
>   DO m = 1,veg_pts
>     l = veg_index(m)
>     ! Using brackets here to recreate existing results.
>     vcmax(l) = ( vcmax_ref(l) * qtenf_term(l) ) / denom(l)
>   END DO
> !$OMP END DO NOWAIT
> 
> CASE ( photo_farquhar )
> 
>   !---------------------------------------------------------------------------
>   ! Use the Farquhar model (for C3 plants).
>   !---------------------------------------------------------------------------
> 
>   !---------------------------------------------------------------------------
>   ! Calculate values at the reference temperature, including any acclimation
>   ! of jv25 (but excluding other acclimation terms).
>   !---------------------------------------------------------------------------
>   SELECT CASE ( photo_jv_model )
> 
>   CASE ( jv_scale )
>     ! Find J25 by scaling V25.
> !$OMP DO SCHEDULE(STATIC)
>     DO m = 1,veg_pts
>       l = veg_index(m)
>       vcmax(l) = vcmax_ref(l)
>       jmax(l)  = vcmax_ref(l) * jv25(l)
>     END DO
> !$OMP END DO NOWAIT
> 
>   CASE ( jv_ntotal )
>     ! Assume the total N allocated to photosynthetic capacity is constant.
> !$OMP DO SCHEDULE(STATIC)
>     DO m = 1,veg_pts
>       l = veg_index(m)
>       ! Calculate total N allocated to photosynthetic capacity, using the
>       ! prescribed parameters at the reference temperature.
>       ! This is Eq.5 of Mercado et al. (2018).
>       n_total = vcmax_ref(l) * recip_v                                         &
>                 + vcmax_ref(l) * jv25_ratio(ft) * recip_j
>       ! Calculate Vcmax and Jmax at 25degC, including temperature acclimation
>       ! of J:V.
>       vcmax(l) = n_total / ( recip_v + jv25(l) * recip_j )
>       jmax(l)  = n_total / ( recip_v / jv25(l) + recip_j )
>     END DO
> !$OMP END DO NOWAIT
> 
>  END SELECT  !  photo_jv_model
> 
>   !---------------------------------------------------------------------------
>   ! Calculate final values, including temperature effect.
>   !---------------------------------------------------------------------------
> !$OMP DO SCHEDULE(STATIC)
>   DO m = 1,veg_pts
>     l = veg_index(m)
> 
>     ! Calculate rates according to acclimated ratio and N allocation to
>     ! photosynthesis, and including temperature term.
>     ! At present neither acclimation nor N allocation are represented.
>     vcmax(l) = vcmax(l) * vcmax_temp(l)
>     jmax(l)  = jmax(l)  * jmax_temp(l)
> 
>   END DO
> !$OMP END DO NOWAIT
> 
> END SELECT  !  pft_photo_model
> 
> !-----------------------------------------------------------------------------
> ! Calculate dark respiration. Any effect of light inhibition is added later.
> !-----------------------------------------------------------------------------
> SELECT CASE ( rd_model )
> CASE ( rd_classic )
>   !---------------------------------------------------------------------------
>   ! Calculate respiration as a fixed fraction of Vcmax, regardless of how
>   ! Vcmax was calculated.
>   !---------------------------------------------------------------------------
> !$OMP DO SCHEDULE(STATIC)
>   DO m = 1,veg_pts
>     l = veg_index(m)
>     rd_dark(l) = fd(ft) * vcmax(l)
>   END DO
> !$OMP END DO NOWAIT
> 
> CASE ( rd_pftq10 )
>   !---------------------------------------------------------------------------
>   ! Calculate respiration using a fixed Q10 with supression at high and low
>   ! temperatures.  This should be equivalent to rd_classic when used with
>   ! Collatz, but it allows the classic temperature adjusted respiration
>   ! function to be used with other models of Vcmax, e.g., Farquhar.
>   !---------------------------------------------------------------------------
> !$OMP DO SCHEDULE(STATIC)
>   DO m=1,veg_pts
>     l = veg_index(m)
>     rd_dark(l) = fd(ft) * ( vcmax_ref(l) * qtenf_term(l) ) / denom(l)
>   END DO
> !$OMP END DO NOWAIT
> 
> CASE ( rd_tdq10 )
>   !---------------------------------------------------------------------------
>   ! Calculate respiration using a temperature-dependent Q10.
>   !---------------------------------------------------------------------------
> !$OMP DO SCHEDULE(STATIC)
>   DO m=1,veg_pts
>     l = veg_index(m)
>     rd_dark(l) = fd(ft) * (vcmax_ref(l) * qtenf_resp(l))
>   END DO
> !$OMP END DO NOWAIT
> 
> END SELECT
> 
>  !---------------------------------------------------------------------------
>  ! !***rfu Add the time of day effect for Vcmax and Jmax - adding here so if use the original calculation for rd_dark (rd_classic)
>  ! then the time of day correction for vcmax and jmax does not affect the calculation of rd_dark.
>  !---------------------------------------------------------------------------
> !$OMP DO SCHEDULE(STATIC)
> DO m = 1,veg_pts
>    l = veg_index(m)
> 
>  IF (l_vcmax_jmax_diurnal) THEN
> 
2281,2286c2070,2200
<     IF (lhook) CALL dr_hook(ModuleName//':'//RoutineName,zhook_out,zhook_handle)
<     RETURN
<     
<     END SUBROUTINE calc_electron_flux
<     
<     END MODULE sf_stom_mod
---
>     !correction for time of day only applies between these hours according to equations
>    IF (local_time_rfu(l) > 5.5 .AND. local_time_rfu(l) < 22.0) THEN
>           !IF (current_time%TIME == 00000) THEN
>              !print*,'And the time on the doors is...', local_time_rfu(l), lat_rfu(l)
>              !END IF
>        IF (lat_rfu(l) < 23.0 .AND. lat_rfu(l) > -23.0) THEN !equations depend on latitude
>           !correction for tropics
>           vcmax_scale_trop = 1.77032 - 0.06064 * local_time_rfu(l)
>           vcmax(l) = vcmax(l) * vcmax_scale_trop
>           jmax_scale_trop = 1.533371 - 0.041987 * local_time_rfu(l)
>           jmax(l) = jmax(l) * jmax_scale_trop
>           !print*,'club tropicana', lat_rfu(l), vcmax_scale_trop, vcmax(l), jmax_scale_trop 
>        ELSE
>           !correction for sub-tropics
>           vcmax_scale_temp = 0.895097 + 0.036081 * local_time_rfu(l) - 0.001968 * local_time_rfu(l)**2
>           vcmax(l) = vcmax(l) * vcmax_scale_temp
>           jmax_scale_temp = 1.149561 - 0.01177 * local_time_rfu(l)
>           jmax(l) = jmax(l) * jmax_scale_temp
>           !print*,'chilly',lat_rfu(l), vcmax_scale_temp, vcmax(l), jmax_scale_temp
>        END IF
>     ELSE
>        !correction for time of day doesn't apply anywhere so vcmax just has temp correction
>            vcmax(l) = vcmax(l)
>            jmax(l)  = jmax(l)
>        !print*,'Go to bed',local_time_rfu(l), vcmax(l)
>     END IF
>   END IF
> 
> END DO
> !$OMP END DO NOWAIT
> 
>   !-----------------------------------------------------------------------------
> 
> !$OMP END PARALLEL
> 
> IF (lhook) CALL dr_hook(ModuleName//':'//RoutineName,zhook_out,zhook_handle)
> RETURN
> 
> END SUBROUTINE calc_photo_parameters
> 
> !#############################################################################
> !#############################################################################
> 
> SUBROUTINE calc_electron_flux( land_pts, veg_pts, veg_index, i2, jmax, je )
> 
> ! Calculate the electron flux for the Farquhar model.
> 
> USE parkind1, ONLY: jprb, jpim
> USE yomhook, ONLY: lhook, dr_hook
> 
> IMPLICIT NONE
> 
> !-----------------------------------------------------------------------------
> ! Arguments with INTENT(IN).
> !-----------------------------------------------------------------------------
> INTEGER,INTENT(IN) ::                                                          &
>   land_pts,                                                                    &
>     ! Number of land points.
>   veg_pts,                                                                     &
>     ! Number of vegetated points.
>   veg_index(land_pts)
>     ! Index of vegetated points on the land grid.
> 
> REAL(KIND=real_jlslsm), INTENT(IN) ::                                          &
>   i2(land_pts),                                                                &
>     ! Radiation that goes to Photosystem II, expressed as an electron flux
>     ! (mol m-2 s-1).
>   jmax(land_pts)
>     ! Maximum rate of electron transport (mol CO2 m-2 s-1).
> 
> !-----------------------------------------------------------------------------
> ! Arguments with INTENT(OUT).
> !-----------------------------------------------------------------------------
> REAL(KIND=real_jlslsm), INTENT(OUT) ::                                         &
>   je(land_pts)
>     ! Electron transport rate (mol m-2 s-1).
> 
> !-----------------------------------------------------------------------------
> ! Local parameters.
> !-----------------------------------------------------------------------------
> REAL(KIND=real_jlslsm), PARAMETER ::                                           &
>   light_curvature = 0.90
>     ! Curvature of the light response function. Used with Farquhar model of
>     ! photosynthesis. See Eq.4 of Medlyn et al. (2002).
> 
> !-----------------------------------------------------------------------------
> ! Local variables.
> !-----------------------------------------------------------------------------
> INTEGER ::                                                                     &
>   l, m
>     ! Indices.
> 
> REAL(KIND=real_jlslsm) ::                                                      &
>  recip_denom
>    ! The reciprocal of the denominator.
> 
> 
> INTEGER(KIND=jpim), PARAMETER :: zhook_in  = 0
> INTEGER(KIND=jpim), PARAMETER :: zhook_out = 1
> REAL(KIND=jprb)               :: zhook_handle
> 
> CHARACTER(LEN=*), PARAMETER :: RoutineName='CALC_ELECTRON_FLUX'
> 
> !-----------------------------------------------------------------------------
> !end of header
> 
> IF (lhook) CALL dr_hook(ModuleName//':'//RoutineName,zhook_in,zhook_handle)
> 
> !-----------------------------------------------------------------------------
> ! Calculate a constant.
> !-----------------------------------------------------------------------------
> recip_denom = 1.0 / ( 2.0 * light_curvature )
> 
> !-----------------------------------------------------------------------------
> ! Calculate electron flux by finding a root of a quadratic equation.
> ! This is the solution of Eq.4 of Medlyn et al. (2002).
> !-----------------------------------------------------------------------------
> DO m = 1,veg_pts
>   l = veg_index(m)
>   je(l)  = ( i2(l) + jmax(l)                                                   &
>                     - SQRT( ( i2(l) + jmax(l) )**2                             &
>                             - 4.0 * light_curvature * i2(l) * jmax(l) )        &
>            ) * recip_denom
> END DO
> 
> IF (lhook) CALL dr_hook(ModuleName//':'//RoutineName,zhook_out,zhook_handle)
> RETURN
> 
> END SUBROUTINE calc_electron_flux
> 
> END MODULE sf_stom_mod
diff -r vn7.0copy1_c4/src/./science/surface/smc_ext_jls_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/surface/smc_ext_jls_mod.F90
22c22
< ,                   wt_ext,fsmc)
---
> ,                   wt_ext,fsmc,psi_root_zone_sox)
34c34
< USE jules_vegetation_mod, ONLY: fsmc_shape
---
> USE jules_vegetation_mod, ONLY: fsmc_shape,stomata_model,stomata_sox
91c91
<  wt_ext(npnts,nshyd)  ! Cummulative fraction of transpiration
---
>  wt_ext(npnts,nshyd)  ! Cumulative fraction of transpiration
96,97c96,101
<  fsmc(npnts)          ! Soil moisture availability
< !                     !    factor.
---
>  fsmc(npnts)                                                                   &
>                       ! Soil moisture availability
> !                     ! factor.
> ,psi_root_zone_sox(npnts)
>                       ! (negative) Soil water potential in root zone (Pa)
>                       ! To be passed up for use by SOX in sf_stom.
149c153,154
< !$OMP SHARED(nshyd,npnts,psi,v_layer,sthu,v_sat,wt_ext,psi_root_zone,fsmc,ones)
---
> !$OMP SHARED(nshyd,npnts,psi,v_layer,sthu,v_sat,wt_ext,psi_root_zone,fsmc,ones,&
> !$OMP        psi_root_zone_sox)
162a168
>   psi_root_zone_sox(i) = 0.0
195,197c201,223
<   fsmc = fsmc_layer(npnts,surft_pts,surft_index,                               &
<                     ft, v_root_zone, v_close_root_zone,                        &
<                     v_open_root_zone, ones, psi_root_zone)
---
>   IF ( stomata_model == stomata_sox ) THEN
> !$OMP PARALLEL DO                                                              &
> !$OMP SCHEDULE(STATIC)                                                         &
> !$OMP DEFAULT(NONE)                                                            &
> !$OMP PRIVATE(j,i)                                                             &
> !$OMP SHARED(surft_pts,surft_index,psi_root_zone_sox,v_root_zone,v_sat,sathh,  &
> !$OMP        bexp)
>     DO j = 1,surft_pts
>       i = surft_index(j)
>       ! If SOX is being used psi_root_zone is needed. fsmc_shape is not
>       ! be used in sox - fsmc will be set to 1.0 always
>       psi_root_zone_sox(i) = psi_from_sthu(v_root_zone(i) / v_sat(i,1),        &
>                                        sathh(i,1), bexp(i,1), sthu_min)
> 
>     END DO
> !$OMP END PARALLEL DO
> 
>     fsmc(:) = 1.0
> 
>   ELSE
>     fsmc = fsmc_layer(npnts, surft_pts, surft_index, ft, v_root_zone,          &
>                       v_close_root_zone, v_open_root_zone, ones, psi_root_zone)
>   END IF !stomata_model
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/surface: sugar_mod.F90
diff -r vn7.0copy1_c4/src/./science/surface/urbanz0.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/surface/urbanz0.F90
26,27d25
< 
< 
31c29
< USE um_types, ONLY: REAL64
---
> USE um_types, ONLY: real_64
85c83
< REAL ( KIND=REAL64 ) ::  & ! Do need the double precision (Aurore Porson)
---
> REAL ( KIND=real_64 ) ::  & ! Do need the double precision (Aurore Porson)
diff -r vn7.0copy1_c4/src/./science/vegetation/crop_date_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/vegetation/crop_date_mod.F90
187a188
> icount(:,:) = 0
diff -r vn7.0copy1_c4/src/./science/vegetation/crop_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/vegetation/crop_mod.F90
33c33
<                 l_lice_point)
---
>                 l_lice_point, l_lice_surft)
150a151
> LOGICAL, INTENT(IN OUT) :: l_lice_surft(ntype)
184c185
< CALL tilepts(land_pts, frac, surft_pts, surft_index, l_lice_point)
---
> CALL tilepts(land_pts, frac, surft_pts, surft_index, l_lice_point, l_lice_surft)
diff -r vn7.0copy1_c4/src/./science/vegetation/dpm_rpm_jls.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/vegetation/dpm_rpm_jls.F90
21c21
< !            in the RothC soil carbon sub-model
---
> !            in the 4-pool soil carbon sub-model
diff -r vn7.0copy1_c4/src/./science/vegetation/irrigation_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/vegetation/irrigation_mod.F90
216c216
< ! irr_crop == 1 is not advisable for UM use. It requires detailed
---
> ! irr_crop == irr_crop_doell is not advisable for UM use. It requires detailed
277c277,278
< USE jules_irrig_mod, ONLY: irr_crop, irr_crop_doell, irr_crop_dvimax
---
> USE jules_irrig_mod, ONLY: irr_crop, irr_crop_all_year, irr_crop_doell,        &
>                            irr_crop_dvimax
390c391,392
<   ! on in the UM. irr_crop=0 is the only available option for UM JULES.
---
>   ! on in the UM. irr_crop=irr_crop_all_year is the only available option for
>   ! UM JULES.
416c418
<       CASE ( 0 )
---
>       CASE ( irr_crop_all_year )
420c422
<       CASE ( 1 )
---
>       CASE ( irr_crop_doell )
424c426
<           l_irrigate_now = .FALSE.
---
>           l_irrigate_now(l,m) = .FALSE.
428c430
<           l_irrigate_now = .TRUE.
---
>           l_irrigate_now(l,m) = .TRUE.
436c438
<           l_irrigate_now = .TRUE.
---
>           l_irrigate_now(l,m) = .TRUE.
440c442
<       CASE ( 2 )
---
>       CASE ( irr_crop_dvimax )
544,545d545
< USE conversions_mod, ONLY: secs_in_day=>isec_per_day
< 
548c548
< USE jules_irrig_mod, ONLY: l_irrig_limit
---
> USE jules_irrig_mod, ONLY: l_irrig_limit, nstep_irrig
551a552,553
> USE timestep_mod, ONLY: timestep
> 
648a651,652
>   timestep_irrig,                                                              &
>     ! Irrigation timestep length (s).
795a800,802
> ! Calculate irrigation timestep length.
> timestep_irrig = timestep * REAL(nstep_irrig)
> 
798c805
<   ! Sum irrigation over soil tiles and irrigated layers.
---
>   ! Sum irrigation over soil tiles and irrigated layers, and convert to rate.
800c807
<                       / REAL(secs_in_day)
---
>                       / timestep_irrig
diff -r vn7.0copy1_c4/src/./science/vegetation/lotka_noeq_jls.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/vegetation/lotka_noeq_jls.F90
365a366,370
>     IF (frac_na(l,n) < frac_min) THEN
>       dfrac_na(l,n) = dfrac_na(l,n) + (frac_min - frac_na(l,n))
>       frac_na(l,n)  = frac_min
>     END IF
> 
diff -r vn7.0copy1_c4/src/./science/vegetation/lotka_noeq_subset_jls.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/vegetation/lotka_noeq_subset_jls.F90
326a327,331
>     IF (frac(l,o) < frac_min) THEN
>       dfrac(l,o) = dfrac(l,o) + (frac_min - frac(l,o))
>       frac(l,o)  = frac_min
>     END IF
> 
diff -r vn7.0copy1_c4/src/./science/vegetation/soilcarb_jls.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/vegetation/soilcarb_jls.F90
352d351
< #if !defined(UM_JULES)
370d368
< #endif
diff -r vn7.0copy1_c4/src/./science/vegetation/soilcarb_layers_jls_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/vegetation/soilcarb_layers_jls_mod.F90
40c40,41
< USE jules_soil_biogeochem_mod, ONLY: bio_hum_cn, tau_lit, l_label_frac_cs
---
> USE jules_soil_biogeochem_mod, ONLY: bio_hum_cn, tau_lit, l_label_frac_cs,     &
>                                      z_burn_max
65c66
< INTEGER, INTENT(IN)::                                                          &
---
> INTEGER, INTENT(IN) ::                                                         &
75c76
< REAL(KIND=real_jlslsm), INTENT(IN)::                                           &
---
> REAL(KIND=real_jlslsm), INTENT(IN) ::                                          &
81c82
< REAL(KIND=real_jlslsm), INTENT(IN)::                                           &
---
> REAL(KIND=real_jlslsm), INTENT(IN) ::                                          &
94c95
< REAL(KIND=real_jlslsm), INTENT(IN OUT)::                                       &
---
> REAL(KIND=real_jlslsm), INTENT(IN OUT) ::                                      &
110c111
< REAL(KIND=real_jlslsm), INTENT(OUT)::                                          &
---
> REAL(KIND=real_jlslsm), INTENT(OUT) ::                                         &
126c127
< REAL(KIND=real_jlslsm), INTENT(IN):: t_soil_soilt_acc(land_pts,nsoilt,sm_levels)
---
> REAL(KIND=real_jlslsm), INTENT(IN) :: t_soil_soilt_acc(land_pts,nsoilt,sm_levels)
154c155
< REAL(KIND=real_jlslsm) , PARAMETER ::                                          &
---
> REAL(KIND=real_jlslsm), PARAMETER ::                                           &
157c158
<     ! Decomposable Plant Material burns between 80 to 100 %.
---
>     ! Decomposable Plant Material burns between 80 to 100 %
160c161
<     ! Resistant Plant Material burns between 0 to 20 %.
---
>     ! Resistant Plant Material burns between 0 to 20 %
162c163
<     ! and emitted_carbon_RPM, and are also set in soilcarb.
---
>     ! and emitted_carbon_RPM, and are also set in soilcarb
210a212,224
> ! l_trif_fire calculations for proportion of cs burnt
> REAL(KIND=real_jlslsm) ::                                                      &
>   z2,                                                                          &
>    ! depth of bottom of soil layer for soil C burnt calculation
>   z1,                                                                          &
>    ! depth of top of soil layer for soil C burnt calculation
>   prop_cs_burnt,                                                               &
>    ! proportion of soil carbon burnt
>   burnt_carbon_layer_dpm(land_pts, dim_cslayer),                               &
>    ! DPM burnt carbon in each soil layer due to fire (kg m-2 per 360days)
>   burnt_carbon_layer_rpm(land_pts, dim_cslayer)
>    ! RPM burnt carbon in each soil layer due to fire (kg m-2 per 360days)
> 
230a245,246
> burnt_carbon_layer_dpm(:,:) = 0.0
> burnt_carbon_layer_rpm(:,:) = 0.0
258c274
<     cn(l,n,2) = cs(l,n,2) / ns_pool_gb(l,n,2) ! C:N ratio of DPM - Prognostic
---
>     cn(l,n,2) = cs(l,n,2) / ns_pool_gb(l,n,2) ! C:N ratio of RPM - Prognostic
491c507
< ! Remove burnt litter from top soil layer only
---
> ! Remove burnt litter down to z_burn_max
496,509c512,540
<     burnt_carbon_dpm(l) = g_burn_gb(l) *                                       &
<                           (cs(l,1,1) * (ccdpm_min + (ccdpm_max - ccdpm_min)    &
<                           * (1.0 - (sthu_soilt(l,1,1)))))
<     burnt_carbon_rpm(l) = (g_burn_gb(l) *                                      &
<                           (cs(l,1,2) * (ccrpm_min + (ccrpm_max - ccrpm_min)    &
<                           * (1.0 - (sthu_soilt(l,1,1))))))
<     ! Need to introduce a check because it is updated before updating soil C
<     burnt_carbon_dpm(l) = MAX(MIN(burnt_carbon_dpm(l), cs(l,1,1) +             &
<                           pc(l,1,1) / r_gamma - cs_min), 0.0)
<     burnt_carbon_rpm(l) = MAX(MIN(burnt_carbon_rpm(l), cs(l,1,1) +             &
<                           pc(l,1,1) / r_gamma - cs_min), 0.0)
<     pc(l,1,1)     = pc(l,1,1) - burnt_carbon_dpm(l)
<     pc(l,1,2)     = pc(l,1,2) - burnt_carbon_rpm(l)
<     burnt_soil(l) = burnt_carbon_dpm(l) + burnt_carbon_rpm(l)
---
>     z2 = 0.0
>     DO n=1,dim_cslayer
>       z1 = z2
>       z2 = z2 + dzsoil(n)
>       prop_cs_burnt = 0.0
>       IF ( z2 <  z_burn_max ) THEN
>         prop_cs_burnt = 1.0  ! combustibility of 1
>       ELSE IF ( z2 >= z_burn_max .AND. z1 <  z_burn_max ) THEN
>         prop_cs_burnt = (z_burn_max - z1) / (z2 - z1)
>       END IF
> 
>       burnt_carbon_layer_dpm(l,n) = prop_cs_burnt * g_burn_gb(l) *             &
>                           (cs(l,n,1) * (ccdpm_min + (ccdpm_max - ccdpm_min)    &
>                           * (1.0 - (sthu_soilt(l,1,n)))))
>       burnt_carbon_layer_rpm(l,n) = prop_cs_burnt * g_burn_gb(l) *             &
>                           (cs(l,n,2) * (ccrpm_min + (ccrpm_max - ccrpm_min)    &
>                           * (1.0 - (sthu_soilt(l,1,n)))))
>       ! Need to introduce a check because it is updated before updating soil C
>       burnt_carbon_layer_dpm(l,n) = MAX(MIN(burnt_carbon_layer_dpm(l,n),       &
>                           cs(l,n,1) +  pc(l,n,1) / r_gamma - cs_min), 0.0)
>       burnt_carbon_layer_rpm(l,n) = MAX(MIN(burnt_carbon_layer_rpm(l,n),       &
>                           cs(l,n,2) + pc(l,n,2) / r_gamma - cs_min), 0.0)
>       pc(l,n,1)     = pc(l,n,1) - burnt_carbon_layer_dpm(l,n)
>       pc(l,n,2)     = pc(l,n,2) - burnt_carbon_layer_rpm(l,n)
>     END DO
>     burnt_soil(l) = SUM(burnt_carbon_layer_dpm(l,:)) +                         &
>                     SUM(burnt_carbon_layer_rpm(l,:))
>     burnt_carbon_dpm(l) = SUM(burnt_carbon_layer_dpm(l,:))
>     burnt_carbon_rpm(l) = SUM(burnt_carbon_layer_rpm(l,:))
diff -r vn7.0copy1_c4/src/./science/vegetation/soilcarb_tracer_jls_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/vegetation/soilcarb_tracer_jls_mod.F90
47c47
<     ! if this is true then use this code to calcualte soil age
---
>     ! if this is true then use this code to calculate soil age
diff -r vn7.0copy1_c4/src/./science/vegetation/triffid_jls.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/vegetation/triffid_jls.F90
137c137
<   soil_model_rothc,                                                            &
---
>   soil_model_4pool,                                                            &
692,694c692,694
< ! If not using RothC, set variables related to the soil to zero. In that case
< ! these are not used further below.
< IF ( soil_bgc_model /= soil_model_rothc ) THEN
---
> ! If not using 4-pool soil C, set variables related to the soil to zero.
> ! In that case these are not used further below.
> IF ( soil_bgc_model /= soil_model_4pool ) THEN
721c721
<   IF ( soil_bgc_model == soil_model_rothc ) THEN
---
>   IF ( soil_bgc_model == soil_model_4pool ) THEN
734c734
<   END IF  !  RothC
---
>   END IF  !  4-pool soil C
1308c1308
< IF ( soil_bgc_model == soil_model_rothc ) THEN
---
> IF ( soil_bgc_model == soil_model_4pool ) THEN
1407c1407
< END IF  !  soil_model_rothc
---
> END IF  !  soil_model_4pool
1541c1541
<   IF ( soil_bgc_model == soil_model_rothc ) THEN
---
>   IF ( soil_bgc_model == soil_model_4pool ) THEN
1595c1595
<   END IF  !  soil_bgc_model == soil_model_rothc
---
>   END IF  !  soil_bgc_model == soil_model_4pool
1609c1609
< IF ( (soil_bgc_model == soil_model_rothc) .AND. .NOT. l_layeredC) THEN
---
> IF ( (soil_bgc_model == soil_model_4pool) .AND. .NOT. l_layeredC) THEN
1611a1612,1617
> !IF ( (soil_bgc_model == soil_model_4pool) .AND. l_layeredC) THEN
> !  DO t = 1,trif_pts
> !    l = trif_index(t)
> !    n_inorg_gb(l) = SUM(n_inorg_soilt_lyrs(l,1,:))
> !  END DO
> !END IF
1624a1631,1638
> !
> ! Include veg_c_fire_emissions_gb and burnt_soil in the calculation of
> ! triffid_co2_gb, the loss of carbon as CO2 from all land sources. This
> ! assumes that all carbon lost from land due to fire is lost as CO2, in
> ! the absence of any explicit stores of burnt carbon. Failing to add it
> ! results in loss of conservation of carbon in CO2 emissions-driven
> ! configuration. Both variables have the same units (kg/m2/360 days) as
> ! exudates_gb, etc, as seen in src/io/model_interface/variable_metadata.F90.
1632c1646,1648
<                       wp_slow_out_gb(l)
---
>                       wp_slow_out_gb(l) +                                      &
>                       veg_c_fire_emission_gb(l) +                              &
>                       burnt_soil(l)
diff -r vn7.0copy1_c4/src/./science/vegetation/veg-veg1a_jls_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/vegetation/veg-veg1a_jls_mod.F90
21c21
<                z0_t, z0h_t, l_lice_point, ztm_gb                               &
---
>                z0_t, z0h_t, l_lice_point, l_lice_surft, ztm_gb                 &
128a129
> LOGICAL, INTENT(IN OUT) :: l_lice_surft(ntype)
191c192
< CALL tilepts(land_pts, frac, surft_pts, surft_index, l_lice_point)
---
> CALL tilepts(land_pts, frac, surft_pts, surft_index, l_lice_point, l_lice_surft)
diff -r vn7.0copy1_c4/src/./science/vegetation/veg-veg2a_jls_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/vegetation/veg-veg2a_jls_mod.F90
19c19
<                fraca, fracp, fracb, frac_vs,                                   &
---
>                fracaero, fracp, fracb, frac_vs,                                &
45c45
<                l_lice_point,                                                   &
---
>                l_lice_point, l_lice_surft,                                     &
59,62c59
< 
< #if !defined(UM_JULES)
< USE soilcarb_mix_mod, ONLY: soilcarb_mix
< #endif
---
> USE soilcarb_mix_mod,         ONLY: soilcarb_mix
75,79c72
< USE veg_param, ONLY:                                                           &
< #if !defined(UM_JULES)
<   litc_norm,                                                                   &
< #endif
<   agric
---
> USE veg_param, ONLY: litc_norm, agric
85c78
<   soil_model_rothc,                                                            &
---
>   soil_model_4pool,                                                            &
89,93c82
< USE jules_soil_mod, ONLY:                                                      &
< #if !defined(UM_JULES)
<   dzsoil,                                                                      &
< #endif
<   sm_levels
---
> USE jules_soil_mod, ONLY: dzsoil, sm_levels
147c136
<   fraca(land_pts),                                                             &
---
>   fracaero(land_pts),                                                          &
277a267
> LOGICAL, INTENT(IN OUT) :: l_lice_surft(ntype)
329c319
<   lit_resp
---
>   lit_resp,                                                                    &
330a321,322
>   eps_real
>     ! Small value to avoid fp issues
335,336c327
< #if !defined(UM_JULES)
<   dcs_rothc(land_pts,dim_cslayer,5),                                           &
---
>   dcs_4pool(land_pts,dim_cslayer,4),                                           &
338d328
< #endif
381d370
< #if !defined(UM_JULES)
386d374
< #endif
403a392,393
> eps_real = EPSILON(1.0_real_jlslsm)
> 
442c432
< IF ( soil_bgc_model == soil_model_rothc ) THEN
---
> IF ( soil_bgc_model == soil_model_4pool ) THEN
460c450
<      ( soil_bgc_model == soil_model_rothc ) ) THEN
---
>      ( soil_bgc_model == soil_model_4pool ) ) THEN
497c487
< END IF  !  TRIFFID step and RothC
---
> END IF  !  TRIFFID step and 4-pool soil C
502c492
< CALL tilepts(land_pts, frac, surft_pts, surft_index, l_lice_point)
---
> CALL tilepts(land_pts, frac, surft_pts, surft_index, l_lice_point, l_lice_surft)
562c552
<   IF ( soil_bgc_model == soil_model_rothc ) THEN
---
>   IF ( soil_bgc_model == soil_model_4pool ) THEN
612c602
<       frac_agric(l) = MIN(fraca(l),frac_vs(l) - (REAL(nnpft+1) * frac_min))
---
>       frac_agric(l) = MIN(fracaero(l),frac_vs(l) - (REAL(nnpft+1) * frac_min))
642c632
<   IF ( soil_bgc_model == soil_model_rothc ) THEN
---
>   IF ( soil_bgc_model == soil_model_4pool ) THEN
654,661c644
< 
< #if !defined(UM_JULES)
<         dcs_rothc(l,nn,1) = cs(l,nn,1)
<         dcs_rothc(l,nn,2) = cs(l,nn,2)
<         dcs_rothc(l,nn,3) = cs(l,nn,3)
<         dcs_rothc(l,nn,4) = cs(l,nn,4)
< #endif
< 
---
>         dcs_4pool(l,nn,1:4) = cs(l,nn,1:4)
668c651
<   END IF  !  soil_model_rothc
---
>   END IF  !  soil_model_4pool
780c763
<   IF ( soil_bgc_model == soil_model_rothc ) THEN
---
>   IF ( soil_bgc_model == soil_model_4pool ) THEN
791c774,775
<   CALL tilepts(land_pts, frac, surft_pts, surft_index, l_lice_point)
---
>   CALL tilepts(land_pts, frac, surft_pts, surft_index, l_lice_point,           &
>                l_lice_surft)
798c782
<     IF ( soil_bgc_model == soil_model_rothc ) THEN
---
>     IF ( soil_bgc_model == soil_model_4pool ) THEN
829c813
<     IF ( soil_bgc_model == soil_model_rothc ) THEN
---
>     IF ( soil_bgc_model == soil_model_4pool ) THEN
834d817
< #if !defined(UM_JULES)
845c828
<         CALL soilcarb_mix(land_pts, trif_pts, trif_index, dcs_rothc(:,:,1:4),  &
---
>         CALL soilcarb_mix(land_pts, trif_pts, trif_index, dcs_4pool,           &
848d830
< #endif
873c855
<     END IF  !  soil_model_rothc
---
>     END IF  !  soil_model_4pool
878,879c860,862
<         ratio          = frac_old(l,n) / frac(l,n)
<         npp_ac(l,n)    = ratio * (npp_dr(l,n) - npp_dr_out(l,n) +              &
---
>         IF ((frac_old(l,n) > eps_real) .AND. (frac(l,n) > eps_real)) THEN
>           ratio          = frac_old(l,n) / frac(l,n)
>           npp_ac(l,n)    = ratio * (npp_dr(l,n) - npp_dr_out(l,n) +            &
881c864
<         resp_w_ac(l,n) = ratio * (resp_w_dr(l,n) - resp_w_dr_out(l,n))         &
---
>           resp_w_ac(l,n) = ratio * (resp_w_dr(l,n) - resp_w_dr_out(l,n))       &
882a866,869
>         ELSE
>           npp_ac(l,n) = 0.0
>           resp_w_ac(l,n) = 0.0
>         END IF
941c928
<      ( soil_bgc_model == soil_model_rothc ) ) THEN
---
>      ( soil_bgc_model == soil_model_4pool ) ) THEN
958c945
< END IF  !  TRIFFID step and RothC
---
> END IF  !  TRIFFID step and 4-pool soil C
diff -r vn7.0copy1_c4/src/./science/water_resources/irrigation_water_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./science/water_resources/irrigation_water_mod.F90
197c197
< USE timestep_mod, ONLY: timestep_len=>timestep
---
> USE timestep_mod, ONLY: timestep
316,317c316
<                           / ( land_area(l)                                     &
<                               * timestep_len * REAL(nstep_water_res) )
---
>                           / ( land_area(l) * timestep * REAL(nstep_water_res) )
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/.: science_cable
Only in vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./util: cable
diff -r vn7.0copy1_c4/src/./util/datetime_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./util/datetime_mod.F90
55c55
<   l_leap = .TRUE.
---
>   l_leap = .TRUE.,                                                             &
58a59,63
>   l_local_solar_time = .FALSE.
>                      ! Assume time throughout the model and in the
>                      ! driving data is actually local solar time,
>                      ! disregarding any attributes of the driving data
> 
503c508
< USE precision_mod, ONLY: INT64
---
> USE precision_mod, ONLY: int_64
525c530
< INTEGER(KIND=INT64) :: diff
---
> INTEGER(KIND=int_64) :: diff
diff -r vn7.0copy1_c4/src/./util/logging_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./util/logging_mod.F90
11c11
< USE mpi, ONLY: mpi_comm_world
---
> USE jules_vars_mod, ONLY: mpi_local_comm
100,102d99
< ! Combine the name of the originating procedure with the message
< full_message = TRIM(proc_name) // ': ' // message
< 
106c103
<   full_message = "[INFO] " // full_message
---
>   full_message = "[INFO]"
109c106
<   full_message = "[DEBUG] " // full_message
---
>   full_message = "[DEBUG]"
112c109
<   full_message = "[WARNING] " // full_message
---
>   full_message = "[WARNING]"
115c112
<   full_message = "[ERROR] " // full_message
---
>   full_message = "[ERROR]"
118c115
<   full_message = "[FATAL ERROR] " // full_message
---
>   full_message = "[FATAL ERROR]"
125a123,125
> ! Combine the name of the originating procedure with the message
> full_message = TRIM(full_message) // " " // TRIM(proc_name) // ': ' // message
> 
128,129c128,129
<   CALL mpi_comm_size(mpi_comm_world, ntasks, ERROR)
<   CALL mpi_comm_rank(mpi_comm_world, task_id, ERROR)
---
>   CALL mpi_comm_size(mpi_local_comm, ntasks, ERROR)
>   CALL mpi_comm_rank(mpi_local_comm, task_id, ERROR)
173c173
<   CALL mpi_abort(mpi_comm_world, 1, ERROR)
---
>   CALL mpi_abort(mpi_local_comm, 1, ERROR)
diff -r vn7.0copy1_c4/src/./util/shared/gridbox_mean_mod.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./util/shared/gridbox_mean_mod.F90
17,18c17
< USE ancil_info, ONLY: land_pts, nsurft, surft_pts,                             &
<                       ainfo_type
---
> USE ancil_info, ONLY: land_pts, nsurft, ainfo_type
71c70
<       DO i = 1,surft_pts(t)
---
>       DO i = 1,ainfo%surft_pts(t)
87,88c86
< USE ancil_info, ONLY: land_pts, nsoilt, soilt_pts,                             &
<                       ainfo_type
---
> USE ancil_info, ONLY: land_pts, nsoilt, ainfo_type
138c136
<       DO i = 1,soilt_pts(t)
---
>       DO i = 1,ainfo%soilt_pts(t)
153c151
< USE ancil_info, ONLY: land_pts, surft_pts, ainfo_type
---
> USE ancil_info, ONLY: land_pts, ainfo_type
215c213
<       DO i = 1,surft_pts(t)
---
>       DO i = 1,ainfo%surft_pts(t)
232c230
< USE ancil_info,              ONLY: land_pts, nmasst, surft_pts, ainfo_type
---
> USE ancil_info,              ONLY: land_pts, nmasst, ainfo_type
286c284
<       DO l = 1, surft_pts(n)
---
>       DO l = 1, ainfo%surft_pts(n)
diff -r vn7.0copy1_c4/src/./util/shared/metstats/metstats_timestep.F90 vn7.6_vcmax-jmax-diurnal_knr_24Nov/src/./util/shared/metstats/metstats_timestep.F90
9c9
<                              current_time, timestep_len,land_pts)
---
>                              current_time, timestep, land_pts)
17c17
<                               secs_in_day => isec_per_day,                     &
---
>                               secs_in_day => rsec_per_day,                     &
20c20
< USE jules_vegetation_mod, ONLY: alpha_acclim
---
> USE jules_vegetation_mod, ONLY: n_day_photo_acclim
62c62
< REAL, INTENT(IN)    :: timestep_len
---
> REAL, INTENT(IN)    :: timestep
99a100,102
> ! Smoothing factor of exponential filter used with temp_ave_nday.
> REAL :: alpha_acclim
> 
109c112
< n_daily_ave = secs_in_day / timestep_len
---
> n_daily_ave = secs_in_day / timestep
125c128
<   precip_ext(:) = timestep_len * (ls_rain_gb(:) + con_rain_gb(:) +             &
---
>   precip_ext(:) = timestep * (ls_rain_gb(:) + con_rain_gb(:) +                 &
164c167
< WHERE (local_time >= midnight .AND. local_time < (midnight + timestep_len))
---
> WHERE (local_time >= midnight .AND. local_time < (midnight + timestep))
169c172
< WHERE (local_time >= noon     .AND. local_time < (noon + timestep_len))
---
> WHERE (local_time >= noon     .AND. local_time < (noon + timestep))
199a203,204
>   alpha_acclim = 1.0 - EXP( -1.0 * timestep                                    &
>                           / ( n_day_photo_acclim * secs_in_day ) )
